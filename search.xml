<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2022-2023 Winter Petrozavodsk Camp D2 赛后总结</title>
    <url>/2025/02/04/2022-2023-Winter-Petrozavodsk-Camp-D2-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/gym/104427">https://codeforces.com/gym/104427</a></p>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>不是很难，显然的事情，如果终止状态两个相邻的块颜色相同，那么开始的时候他们也是这个颜色。</p>
<p>而其余块的颜色显然是随意的，因为联通块的边界都已经被定死了，中间的不一样大不了操作一下就行了。</p>
<p>时间复杂度：$O(nm)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fep(i,x,y) for(int i=x;i&lt;=y;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> feq(i,x,y) for(int i=x;i&gt;=y;i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">char</span> st[N][N];<span class="type">bool</span> v[N][N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st[i]+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">fep</span>(j,<span class="number">1</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i][j]!=st[i][j+<span class="number">1</span>])v[i][j]=v[i][j+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="built_in">fep</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i][j]!=st[i<span class="number">-1</span>][j])v[i][j]=v[i<span class="number">-1</span>][j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">fep</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!v[i][j])ans=ans*<span class="number">2</span>%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>我们不妨考虑没有双向边的图 G , 和只有双向边的图 G’ 。</p>
<p>显然如果 G’ 为空，那么所有点入度都不为 $0$ 为充要条件。</p>
<p>否则考虑 G’ 中的一个联通块，如果联通块中有一个点在 $G$ 中入度不为 $0$ ，或者是这个联通块的边数≥点数那么这个联通块显然有解，否则无解，然后实现一下即可。</p>
<p>时间复杂度：$O((n+m)\log n)$ 。</p>
<p>最优复杂度：$O(n+m)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 210000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fep(i,x,y) for(int i=x;i&lt;=y;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> feq(i,x,y) for(int i=x;i&gt;=y;i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">set&lt;PII&gt; fuck;</span><br><span class="line"><span class="type">int</span> fa[N],s1[N],s2[N],in[N];</span><br><span class="line">PII a[N];<span class="type">int</span> n,m,nn;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fa[x]=<span class="built_in">findfa</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mer</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">findfa</span>(x);y=<span class="built_in">findfa</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> ;</span><br><span class="line">    fa[x]=y;s1[y]+=s1[x];s2[y]+=s2[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        fuck.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(x,y));in[y]++;</span><br><span class="line">        <span class="keyword">if</span>(fuck.<span class="built_in">find</span>(<span class="built_in">make_pair</span>(y,x))!=fuck.<span class="built_in">end</span>())&#123;</span><br><span class="line">            a[++nn]=<span class="built_in">make_pair</span>(x,y);in[x]--;in[y]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,n)fa[i]=i,s1[i]=<span class="number">1</span>,s2[i]=in[i];</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,nn)&#123;</span><br><span class="line">        <span class="type">int</span> x=a[i].first,y=a[i].second;</span><br><span class="line">        <span class="built_in">mer</span>(x,y);s2[<span class="built_in">findfa</span>(x)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[i]==i &amp;&amp; s2[i]&lt;s1[i])&#123;<span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>不会</p>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>一个很显然的事情，最终的图一定是一堆非叶节点挂着叶子节点的森林。</p>
<p>因为有一个非常显然的事情：</p>
<p><img src="1.png" alt=""></p>
<p>右边的方案肯定比左边的方案要优秀。</p>
<p>那么做法就很简单了，其实就是每个子树在处理完自己之后，需要挑选一个叶子节点送上去。</p>
<p>然后对于一个子树的根节点 $x$ ，其的所有儿子送上权值后，除了被挑选的权值，其余权值都需要乘以自己。</p>
<p>显然，对于一个子树的一个叶子节点，我们需要维护两个信息：这个叶子节点的权值，和这个子树除了这个叶子节点外的最小权值，分别记为 $A,B$ ，不难发现，当根节点面对儿子子树送上来的 $(A,B)$ 时，如果不打算送上去，其产生的贡献为：$A*val_x+B$ ，不难发现，对于儿子子树而言，其需要存储叶子节点个数的 $(A,B)$ ，同时父节点的 $val$ 对于其而言可以说是未知的，而这个统计贡献的方式又是一次函数，所以又是喜闻乐见的维护凸包时间。</p>
<p>那么这个时候每个节点需要干的事情就一个：维护出我自己的凸包。</p>
<p>对于非叶子节点，其每个儿子的凸包的 $B$ 都需要加上其他儿子的贡献，即凸包的上下移动。</p>
<p>而合并凸包可以正常的按秩合并，也可以直接李超线段树合并，时间复杂度都是 $log^2$ 的。</p>
<p>李超线段树的优势是好写，劣势也是有的，因为其的空间比较大，而且是值域线段树，一个 $log$ 是值域的，而且只能处理凸包上下移动，如果是左右移动就寄了，而且如果习惯了写凸包合并实际上也不会比李超线段树难写很多。</p>
<p>时间复杂度：$O(n\log^2{n})$</p>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>队友做的题目，赛后我自己来看一眼。</p>
<p>感觉确实还行，但是情况讨论比较逆天。</p>
<p>简单来说，这道题目有一个性质：</p>
<p>就是我们假设我们需要的修改的最左边的位置为 $l$ ，那么显然需要修改的最右边的位置为 $r$ 。</p>
<p>那么对于任意一个最优解，我们用一个最小的区间 $[a,b]$ 包住我们所有修改过的位置，则 $a=l$ 和 $b=r$ 至少有其一可以成立。</p>
<p>因此。我们先忽略走路的代价，然后预处理出 $[l,i]$ 和 $[i,r]$ 的最小修改代价。</p>
<p>然后就是处理每个区间对于 $i$ 的贡献了，这就非常的简单了。</p>
<p>例如 $[l,i]$ 对于 $j(j\ge l)$  的贡献分为两种，先走到 $l$ ，再走到 $i$ ，这可以在从小到大遍历时处理，也可以先走 $i$ 再走 $l$ ，这可以从大到小遍历时枚举。</p>
<p>然后只要能够讨论出所有情况，这道题目就做完了。</p>
<p>时间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//#define DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fep(i,x,y) for(int i=x;i&lt;=y;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> feq(i,x,y) for(int i=x;i&gt;=y;i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL inf=(LL)<span class="number">1e15</span>;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line">LL C,a[N],f1[N],f2[N];</span><br><span class="line">LL ans[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(LL *f,<span class="type">int</span> l,<span class="type">int</span> r,LL sum)</span></span>&#123;f[l]+=sum;f[r+<span class="number">1</span>]-=sum;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;n,&amp;C);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,mid=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">            f1[i]=f2[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fep</span>(i,<span class="number">1</span>,n/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i]!=st[n-i+<span class="number">1</span>])&#123;l=i;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">feq</span>(i,n/<span class="number">2</span>,<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i]!=st[n-i+<span class="number">1</span>])&#123;mid=i;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!l)&#123;</span><br><span class="line">            <span class="built_in">fep</span>(i,<span class="number">1</span>,n)<span class="built_in">printf</span>(<span class="string">&quot;0 &quot;</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l);</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">change</span>(f1,<span class="number">1</span>,mid<span class="number">-1</span>,inf);<span class="built_in">change</span>(f2,n-mid+<span class="number">2</span>,n,inf);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=l;i+i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i]==st[n-i+<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;=a[n-i+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="built_in">change</span>(f1,i,n,a[i]);</span><br><span class="line">                <span class="built_in">change</span>(f2,i+<span class="number">1</span>,n-i+<span class="number">1</span>,a[n-i+<span class="number">1</span>]);</span><br><span class="line">                <span class="built_in">change</span>(f2,<span class="number">1</span>,i,a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">change</span>(f2,<span class="number">1</span>,n-i+<span class="number">1</span>,a[n-i+<span class="number">1</span>]);</span><br><span class="line">                <span class="built_in">change</span>(f1,i,n-i,a[i]);</span><br><span class="line">                <span class="built_in">change</span>(f1,n-i+<span class="number">1</span>,n,a[n-i+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fep</span>(i,<span class="number">1</span>,n)f1[i]+=f1[i<span class="number">-1</span>],f2[i]+=f2[i<span class="number">-1</span>];</span><br><span class="line">        <span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">        <span class="built_in">fep</span>(i,<span class="number">1</span>,n)<span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>,f1[i],f2[i]);</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="type">int</span> r=n-l+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// fep(i,l,n-l+1)f1[i]+=(i-l)*C,f2[i]=(r-i)*C;</span></span><br><span class="line">        LL now1=inf,now2=inf,now3=inf;</span><br><span class="line">        <span class="built_in">fep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            now1=<span class="built_in">min</span>(now1,<span class="built_in">min</span>(f1[i]-C*l,f2[i]+C*(r-i)-C*i));</span><br><span class="line">            now2=<span class="built_in">min</span>(now2,f2[i]+C*(r-i)+C*r);</span><br><span class="line">            now3=<span class="built_in">min</span>(now3,f2[i]-i*C);</span><br><span class="line">            <span class="keyword">if</span>(i&gt;r)now2=inf;</span><br><span class="line">            ans[i]=<span class="built_in">min</span>(now1+C*i,now2-C*i);</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=r)ans[i]=<span class="built_in">min</span>(ans[i],now3+i*C);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">        <span class="built_in">fep</span>(i,<span class="number">1</span>,n)<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,ans[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        now1=inf;now2=inf;now3=inf;</span><br><span class="line">        <span class="built_in">feq</span>(i,n,<span class="number">1</span>)&#123;</span><br><span class="line">            now1=<span class="built_in">min</span>(now1,f1[i]+(i-l)*C-l*C);</span><br><span class="line">            now2=<span class="built_in">min</span>(now2,<span class="built_in">min</span>(f2[i]+r*C,f1[i]+C*(i-l)+C*i));</span><br><span class="line">            now3=<span class="built_in">min</span>(now3,f1[i]+i*C);</span><br><span class="line">            <span class="keyword">if</span>(i&lt;l)now1=inf;</span><br><span class="line">            ans[i]=<span class="built_in">min</span>(ans[i],<span class="built_in">min</span>(now1+i*C,now2-i*C));</span><br><span class="line">            <span class="keyword">if</span>(i&lt;=l)ans[i]=<span class="built_in">min</span>(ans[i],now3-i*C);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fep</span>(i,<span class="number">1</span>,n)<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,ans[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p>本场最逆天的大贪心题，但实际上只要你建了个好模，能够从一个合适的角度思考，这道题目其实也不是很难。</p>
<p>当然，这道题目其实也有一个方法可以快速的做出来，就是你先想一个最简单的贪心，然后尝试构造数据卡掉这个贪心，然后研究一下错误的原因，想办法解决，大概率就能在较短的时间做出来这道题目。</p>
<p>例如：</p>
<p>一个比较简单的贪心，我们认为肯定是存在一个分界线，这个分界线往上都是漂亮的，往下都是不漂亮的。</p>
<p>这样存在数据：</p>
<p>1 1 1 2 3 3 3 4 4 4</p>
<p>这个数据应该选择 $1,2$ 作为每一段的分界点。</p>
<p>分析一下选两个 $1$ 和 $1,2$ 的区别在于段数的变化，</p>
<p>一个有四段，一个只有三段，因此，这也就引出了另外一个队伍的做法：</p>
<p>从小到大，根据当前已经选择的分界点和段数，判断是否还需要新增分界点，如果需要，就从最短的段中扔出一个数字作为分界点，显然的事情是这样一定存在一个方案使得我们选择的数字都是漂亮的，而且这也一定是最优方案，因为每次选择分界点都是迫不得已且已经尽可能的让段数减少了。</p>
<details class="toggle" ><summary class="toggle-button" style="">不过这是别的队的做法，我的做法是反过来的。</summary><div class="toggle-content"><p>我的做法是从大到小，根据现在的分界点和段数，适当的让段数延长或者新增一个段，是反过来的。</p>
<p>至于上面两个做法的严谨证明，可以自行证明。</p>
<p>不过对于我的做法，我可以简单的阐释一下证明过程：</p>
<p>首先发现一个检验模型，即一个段视为 $1$ ，一个分界点视为 $-1$ ，从大到小求和，且每当和 $&lt;1$ 时就重置为 $1$ ，这样只要求完后和为 $1$ ，那么就至少存在一个方案使得漂亮数的数量大于等于目前我们所选的漂亮数。</p>
<p>然后根据这个模型，我们可以证明一定存在一个最优方案使得 $sum$ 只能在最后一步才能出现重置的情况，所以我们不妨加上这个限制求最优方案。</p>
<p>因此，做法便为每次发现可能需要重置时，调整方案使得其不会重置，且这个过程采用贪心使其最优化。</p>
<p>用到的思想为：如果对于一个方案集：$S$ ，其中 $S’\subseteq S$ ，且存在最优方案使得 $x\in S’$ ，则可以把在 $S$ 上求最优方案改成在 $S’$ 上求最优方案。</p>
<p>贪心的证明还是那个老方法：</p>
<p>在算法进行的过程中，当需要我们新增段数时，我们新增了段数，显然会导致方案无效，当需要我们新增或者延长时，触发连招：</p>
<p>假如存在一个满足之前条件的最优方案不放在这里，那么一定存在一个满足之前条件的最优方案放在这里。显然，因为我们加入了满足之前条件这个限制，所以不会导致循环论证。</p>
<p>准确来说，只要你找到一个最优方案满足当前的限制条件又不会破坏之前的限制条件，就不会循环论证，而上面的调整显然调整的是一个新的漂亮数的位置，并不会影响到之前已经固定下来的漂亮数的位置，所以自然也就不会循环论证了。</p>
<p>说起循环论证，我一开始在做这道题目的时候方向错了，就出现了一个非常有意思的事情：</p>
<p>我发现了三个性质，用调整都可以证明存在一个最优方案满足这个条件，但是最尴尬的事情是我无法证明他们可以被同时满足。</p>
<p>即可能存在以下情况：一个最优方案，我调整了一下，满足性质 $1$ ，又调整了一下，满足了性质 $2$ ，结果不满足性质 $1$ 了，循环往复，这样就陷入了循环论证当中。</p>
<p>不过还好后来转换了想题思路，没过多久就想出来了，也算没坑队友太久。</p>
</div></details>
<p>时间复杂度：$O(n\log{n})$</p>
<p>这道题目非常有意思，刚拿起此题，都会凭借直觉想出一个简单的贪心，然后发现WA了，但是能说直觉做题法错了吗？其实也没错，因为只要你做了足够多的贪心题，你就会在想出这个贪心做法的时候感觉这个做法总会有一点点问题，问题应该是出在数字允许相同这个条件上，然后自己尝试卡一下，就会发现一个 hack 数据，在发现错误原因后，就能慢慢想出正确做法了，所以虽然一开始是错的，但是直觉做题法还是能帮助我们逐步想出正解的。</p>
<p><del>也不排除有逆天直接就想到了正确的做法，如果你直接想出了做法，请忽略上面的话。</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 310000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fep(i,x,y) for(int i=x;i&lt;=y;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> feq(i,x,y) for(int i=x;i&gt;=y;i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; fuck;</span><br><span class="line"><span class="type">int</span> n,a[N],ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&gt;y;&#125;</span><br><span class="line"><span class="type">int</span> now;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!fuck.<span class="built_in">empty</span>())fuck.<span class="built_in">pop</span>();</span><br><span class="line">        ans=now=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="built_in">fep</span>(i,<span class="number">1</span>,n)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp);</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]!=a[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> x=i;<span class="keyword">while</span>(x&lt;n &amp;&amp; a[x+<span class="number">1</span>]==a[x])x++;</span><br><span class="line">                fuck.<span class="built_in">push</span>(x-i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res--;</span><br><span class="line">            <span class="keyword">if</span>(!now)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res&lt;<span class="number">0</span> || (!res &amp;&amp; i!=n))&#123;</span><br><span class="line">                    now=fuck.<span class="built_in">top</span>();fuck.<span class="built_in">pop</span>();res+=<span class="number">2</span>;</span><br><span class="line">                    ans++;now--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(now &amp;&amp; !res)now--,res++,ans++;</span><br><span class="line">            <span class="comment">// printf(&quot;%d %d %d\n&quot;,now,res,ans);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p>非常的简单，首先让全局都变成 $2$ ，这样就变成了单点修改，然后根据需要放 $3$ 就行了。</p>
<p>时间复杂度：$O(nm)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fep(i,x,y) for(int i=x;i&lt;=y;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> feq(i,x,y) for(int i=x;i&gt;=y;i--)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> st[N][N],ans[N][N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st[i]+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">fep</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            ans[i][j]=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            <span class="type">int</span> nex=<span class="number">4</span>-(i==<span class="number">1</span>)-(j==<span class="number">1</span>)-(i==n)-(j==m);</span><br><span class="line">            <span class="keyword">if</span>((nex&amp;<span class="number">1</span>)^(st[i][j]==<span class="string">&#x27;B&#x27;</span>))ans[i][j]=<span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,ans[i]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><p>不会</p>
<h1 id="I"><a href="#I" class="headerlink" title="I"></a>I</h1><p>显然，割点就走不过去了。</p>
<p>然后我们写了一棵圆方树，然后调了一万年，艹！</p>
<p>当然，实际上这道题目存在更加优秀的做法，就是直接在 $DFS$ 树上跑。</p>
<p>我们实际上想要知道一个点在圆方树上是在这个割点的哪个子树里面，更准确的说，是想要知道原图上某个点不经过某个割点不能走到的区域的大小。</p>
<p>不难发现，例如当 $x$ 是割点时，此时有三种情况。（$siz[x]$ 表示 $x$ 的子树大小，$siz’[x]$ 表示 $x$ 子树中满足 $y$ 是 $x$ 儿子且 $low[y]\geq dfn[x]$ 的 $y$ 的子树大小之和）</p>
<ol>
<li>$y$ 的祖先是 $x$ ，那么此时 $siz’[x]$ 就是不能走到的区域大小。</li>
<li>设 $z$ 为 $y$ 的祖先且为 $x$ 的儿子。<ol>
<li>假设 $low[z]\ge dfn[x]$ ，则 $n-siz[z]-1$ 就是无法走到的区域大小。</li>
<li>假设 $low[z]&lt;dfn[x]$ ，则 $siz’[x]$ 就是无法走到的区域大小。</li>
</ol>
</li>
</ol>
<p>然后就可以不用建出圆方树了，也就可以不用调一万年了，悲。</p>
<p>不过非圆方树的做法是口胡的，还没验证，有时间验证一下。</p>
<p>时空复杂度：$O(m+(n+q)\log{n})$。</p>
<p>事实上预处理一下，可以在 $O(n+m+q)$ 的时空内解决这道题目。</p>
<h1 id="J"><a href="#J" class="headerlink" title="J"></a>J</h1><p>队友做的，但是我也参与讨论了。</p>
<ol>
<li>某个颜色的被删除点对肯定是包含和被包含关系的，且如果剩下来一个数字，那一定是中间那个。<br>即如果某个颜色存在点对 $(a_1,b_1),(a_2,b_2)$ ，那么一定存在关系：$a_1&gt;a_2,b_1&lt;b_2$ 或者反过来。<br>证明方式就是如果存在违规点对，把早出现的点对变成大区间，晚出现的变成小区间，可以证明一定不劣。<br>可以发现，经过这样的调整，区间长度的平方和一定减小，所以这样的调整一定会结束。<br>至于只会剩下中间那个，类似证明即可。</li>
<li>一定存在一个最优方案使得删除顺序为长度长的优先。<br>类似上面的，每次交换相邻两个点对然后证明不劣就行了。</li>
</ol>
<p>排个序然后用树状数组维护一下就行了。</p>
<p>时间复杂度：$O(n\log{n})$ 。</p>
<p>同时也可以发现，这个做法很符合正常人的直觉：删大区间对剩下区间的影响最小，所以优先删最大的区间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 310000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fep(i,x,y) for(int i=x;i&lt;=y;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> feq(i,x,y) for(int i=x;i&gt;=y;i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> bst[N],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&amp;-x;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)bst[x]+=k,x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findans</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)ans+=bst[x],x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a[N];</span><br><span class="line">PII b[N];<span class="type">int</span> top;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(PII x,PII y)</span></span>&#123;<span class="keyword">return</span> (x.second-x.first)&gt;(y.second-y.first);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        top=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="built_in">fep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            a[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="type">int</span> siz=a[i].<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j+j&lt;=siz;j++)b[++top]=<span class="built_in">make_pair</span>(a[i][j<span class="number">-1</span>],a[i][siz-j]);</span><br><span class="line">            a[i].<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(b+<span class="number">1</span>,b+top+<span class="number">1</span>,cmp);</span><br><span class="line">        LL ans=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fep</span>(i,<span class="number">1</span>,top)&#123;</span><br><span class="line">            ans+=b[i].second-b[i].first-<span class="built_in">findans</span>(b[i].second)+<span class="built_in">findans</span>(b[i].first);</span><br><span class="line">            <span class="built_in">change</span>(b[i].first,<span class="number">1</span>);<span class="built_in">change</span>(b[i].second,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">        <span class="built_in">memset</span>(bst+<span class="number">1</span>,<span class="number">0</span>,(n&lt;&lt;<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="K"><a href="#K" class="headerlink" title="K"></a>K</h1><p>感觉其实还没 $F$ 难。</p>
<p>重点是要发现一个性质，当我连接 $i,j$ 且 $|j-i|=2$ 时，相当于直接删除了中间的数字，然后根据这个构造上界即可。</p>
<p>考虑从小到大遍历一个最优方案。</p>
<p>首先，对于 $|j-i|=1$ 的边，能连就连。(后面默认这一部分边都已经连上了)</p>
<p>对于 $|j-i|&gt;1$ 的边，显然我们每次连都会导致中间的点不能再用了（因为我们从小到大遍历边的），保持遍历边的顺序不变，假如我们直接把中间点给删了，就会发现对于任意时刻的序列，对于能连的 $|j-i|=1$ 的边也都是连上的，也就是在新序列中，下一条边的 $|j-i|$ 仍然 $&gt;1$ 。</p>
<p>所以我们就不难发现一个上界：$(n-1)+(n-2)=2n-3$ 。</p>
<p>现在我们先把 $|j-i|=1$ 的点连了，同时需要注意：序列最左边和最右边是一直不会被删除的，他们之间的连边对全局不会有影响，能连就连，不能连就算了（和 $|j-i|=1$ 的边是一个性质的）。</p>
<p>所以，如果序列左右两边的颜色如果相同，那么至少剩下 $3$ 个数字，不同 ，至少剩下两个数字。</p>
<p>然后就是讨论：</p>
<ol>
<li>$m≥3$ ，考虑每次连边删去中间的点。<ol>
<li>那么无论任何时候，都存在一个点可以被删除（即连接其相邻的两个点）。</li>
<li>如果有一个颜色被删除到只剩一个，那么显然其可以向剩余所有点连边，最后会剩下三个数字。</li>
<li>如果序列两边两个数字不同，连边。</li>
</ol>
</li>
<li>$m=2$ ，不妨变成 $01$ 序列，定义联通块为相同颜色的区间，最大联通块是以某个位置能延申出去的最长连通块，连通块个数是最大连通块个数。<ol>
<li>如果我们只删除一个数字，那么连通块个数不变。</li>
<li>连边只会导致：连通块长度减小，连通块个数减少，不会导致连通块长度增加。</li>
<li>因此，只删一个数字的操作次数上限为：连通块长度-1 的和。</li>
<li>显然，接下来只进行删除两个数字的操作是最优秀的，也显然可以办到，最终结果为 $010/101/01/10$ ，都是最优的终止状态，因此这样子操作下来就是边数的上限。</li>
</ol>
</li>
</ol>
<p>然后照着做就完了，时间复杂度：$O(n)$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">上面的是别的队的做法，我原来答辩到爆炸的做法在这</summary><div class="toggle-content"><p>$m\ge 3$ 的情况，我是这么做的：</p>
<ol>
<li>首先把每个连通块消到只剩 $1$ 个数字。</li>
<li>然后乱删，直到只剩下三个颜色且其中一个颜色只剩下一个数字。</li>
<li>然后尝试删除出现次数最多的颜色，失败，且如果出现次数第二多的颜色出现了至少两次，则删除且一定能成功，反之退出，或者直到只剩两个颜色时退出。</li>
</ol>
<p>显然，此时终止状态不多，以 $0,1,2$ 表示（$0$ 出现次数最多，$1$ 次多，$2$ 最少，只出现了一次）：</p>
<p>长度为 $4$ 的：$0120$</p>
<p>长度为 $3$ 的：$012,021,020$</p>
<p>长度为 $2$ 的：$12$ </p>
<p>然后再特判一下，就做完了。</p>
<p>MD，这个做法本来就答辩，打代码加思考细节就只有半个小时时间，笑死，根本写不完，然后这道题目赛时就没做出来了，不过也是我的问题，毕竟这个做法本来也是我想的，要是我能想出别的队的那个做法，估计是有可能能写出来的，毕竟他们那个做法比我的做法好写太多了。</p>
<p>而且我这个做法的细节处理也是有点冗杂的，实际上第 $3$ 步能改成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">然后尝试删除出现次数最多的颜色，失败，则删除出现次数第二多的颜色，再失败，则删除出现次数第三多的，直到只剩两个颜色时退出。</span><br></pre></td></tr></table></figure>
<p>这个修改只不过是把处理终止状态的步骤和第 $3$ 步尝试删除的部分融合了，观察一下上面所剩下的终止状态就可以发现这个修改是显然正确的。</p>
</div></details>
<p>由于是赛后补的题目，所以采用的是别的队伍的做法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 210000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NN 410000</span></span><br><span class="line"><span class="comment">// #define DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fep(i,x,y) for(int i=x;i&lt;=y;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> feq(i,x,y) for(int i=x;i&gt;=y;i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line">PII sta[NN];<span class="type">int</span> top;</span><br><span class="line"><span class="type">int</span> n,col[N],cc[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">&#125;li[N];<span class="type">bool</span> v[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del_f</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;li[li[x].r].l=li[x].l;li[li[x].l].r=li[x].r;&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; fuck;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> !v[x] &amp;&amp; li[x].l &amp;&amp; li[x].r&lt;=n &amp;&amp; col[li[x].l]!=col[li[x].r];&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> lef=li[x].l,rig=li[x].r;</span><br><span class="line">    v[x]=<span class="number">1</span>;<span class="built_in">del_f</span>(x);sta[++top]=<span class="built_in">make_pair</span>(lef,rig);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(lef))fuck.<span class="built_in">push_back</span>(lef);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(rig))fuck.<span class="built_in">push_back</span>(rig);</span><br><span class="line">    cc[col[x]]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,n)li[i].l=i<span class="number">-1</span>,li[i].r=i+<span class="number">1</span>;</span><br><span class="line">    li[n+<span class="number">1</span>].l=n;li[<span class="number">0</span>].r=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">        <span class="built_in">freopen</span>(<span class="string">&quot;std.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">init</span>();top=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;col[i]);cc[col[i]]++;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">1</span> &amp;&amp; col[i]!=col[i<span class="number">-1</span>])sta[++top]=<span class="built_in">make_pair</span>(i<span class="number">-1</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(i))fuck.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> pre=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(col[i]!=col[i<span class="number">-1</span>])!pre?pre=i<span class="number">-1</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pre)<span class="built_in">del</span>(i<span class="number">-1</span>);            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// #ifdef DEBUG</span></span><br><span class="line">        <span class="comment">// printf(&quot;%d\n&quot;,top);</span></span><br><span class="line">        <span class="comment">// fflush(stdout);</span></span><br><span class="line">        <span class="comment">// #endif</span></span><br><span class="line">        <span class="built_in">feq</span>(i,pre,<span class="number">2</span>)<span class="built_in">del</span>(i);</span><br><span class="line">        <span class="comment">// #ifdef DEBUG</span></span><br><span class="line">        <span class="comment">// printf(&quot;%d\n&quot;,top);</span></span><br><span class="line">        <span class="comment">// fflush(stdout);</span></span><br><span class="line">        <span class="comment">// #endif</span></span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x=li[<span class="number">0</span>].r,type=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(x!=n+<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(li[x].l!=li[<span class="number">0</span>].r &amp;&amp; !type)sta[++top]=<span class="built_in">make_pair</span>(li[<span class="number">0</span>].r,x);</span><br><span class="line">                x=li[x].r;type^=<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// printf(&quot;%d\n&quot;,x);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                x=fuck[fuck.<span class="built_in">size</span>()<span class="number">-1</span>];fuck.<span class="built_in">pop_back</span>();</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">check</span>(x))<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(cc[col[x]]==<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">                <span class="built_in">del</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// printf(&quot;OK\n&quot;);</span></span><br><span class="line">            <span class="type">int</span> now=li[<span class="number">0</span>].r;</span><br><span class="line">            <span class="keyword">while</span>(now!=n+<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(now!=x &amp;&amp; li[now].l!=x &amp;&amp; li[now].r!=x)sta[++top]=<span class="built_in">make_pair</span>(now,x);</span><br><span class="line">                now=li[now].r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(col[<span class="number">1</span>]!=col[n])sta[++top]=<span class="built_in">make_pair</span>(<span class="number">1</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,top);</span><br><span class="line">        <span class="built_in">fep</span>(i,<span class="number">1</span>,top)<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,sta[i].first,sta[i].second);</span><br><span class="line">        <span class="built_in">memset</span>(cc+<span class="number">1</span>,<span class="number">0</span>,m&lt;&lt;<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// memset(col,0,sizeof(col));</span></span><br><span class="line">        <span class="comment">// memset(li,0,sizeof(li));</span></span><br><span class="line">        <span class="built_in">memset</span>(v+<span class="number">1</span>,<span class="number">0</span>,n);</span><br><span class="line">        <span class="comment">// memset(v,0,sizeof(v));</span></span><br><span class="line">        <span class="comment">// memset(sta,0,sizeof(sta));</span></span><br><span class="line">        fuck.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><ol>
<li>亲手写一些代码，例如：口胡或者知道做法但是没有写的题目。</li>
<li>把没有做的题目自己做一遍。</li>
<li>自己去看一遍官方题解并且补充一下官方题解的做法。</li>
<li>去把合并凸包的两种方式都写一遍并且写一篇博客。</li>
<li>补充一下线段树合并时间复杂度的证明：常规证明，和从按秩合并的角度理解的证明（刘家宁提供的角度）。</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>2023-2024 ICPC Asia Jakarta Regional Contest K. Deck-Building Game</title>
    <url>/2024/03/21/2023-2024-ICPC-Asia-Jakarta-Regional-Contest-K-Deck-Building-Game/</url>
    <content><![CDATA[<p>题目链接：<a href="https://codeforces.com/contest/1906/problem/K">https://codeforces.com/contest/1906/problem/K</a></p>
<p>题目大意：在原数组找出两堆异或值相同的数值，问有多少种找法，可以为空，每个数字可以不在任何一堆，两堆有标号。</p>
<details class="toggle" ><summary class="toggle-button" style="">所有做法的基础</summary><div class="toggle-content"><p>一个显然的事情，这道题目相当于求 $\prod\limits_{i=1}^n(1+2x^{a_i})$ ，这里的乘法是异或卷积。</p>
<p>为了快速计算这个乘积，有了很多种搞法。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">题解做法</summary><div class="toggle-content"><p>题解做法的优点就是比较自然。</p>
<p>显然这个可以分治 FWT ，但是 FWT 不同于 FFT ，分治了值域不变，不改变复杂度。</p>
<p>咋整，观察到如果分治区间是 $[l,r)$ ，那么实际上这个区间乘出来的非 $0$ 项只能落在 $[0,r-l),[l,r)$ ，直接拿出左区间的两个非 $0$ 区间和右区间的两个非 $0$ 区间互相乘一下就行了，这样能做到时间复杂度：$O(V\log^2 V)$ 。</p>
<p>代码：<a href="https://codeforces.com/contest/1906/submission/235539466">https://codeforces.com/contest/1906/submission/235539466</a></p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>我的做法和题解想法基本一致，唯一一点不同的是，对于 $(r-l)=2^l$ ，那么二进制下 $l$ 位都是一样的，因此对于二进制位剩下的位置，要么和 $[l,r)$ 里面的每个数字一样，代表异或了奇数次，要么全是 $0$ ，代表异或了偶数次。</p>
<p>所以我们不妨给每个数字的最高位填个 $1$ ，代表了这个数字异或次数的奇偶性即可。</p>
<p>时间复杂度仍然是：$O(V\log^2 V)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L=<span class="number">17</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SN=(<span class="number">1</span>&lt;&lt;L);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;f,<span class="type">const</span> <span class="type">int</span> C[<span class="number">2</span>][<span class="number">2</span>],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(f.<span class="built_in">size</span>()==len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;len;t&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;len;l+=t+t)&#123;</span><br><span class="line">            <span class="type">int</span> r=l+t;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t;i++)&#123;</span><br><span class="line">                <span class="type">int</span> x=f[l+i],y=f[r+i];</span><br><span class="line">                f[l+i]=(<span class="number">1ll</span>*C[<span class="number">0</span>][<span class="number">0</span>]*x+<span class="number">1ll</span>*C[<span class="number">0</span>][<span class="number">1</span>]*y)%mod;</span><br><span class="line">                f[r+i]=(<span class="number">1ll</span>*C[<span class="number">1</span>][<span class="number">0</span>]*x+<span class="number">1ll</span>*C[<span class="number">1</span>][<span class="number">1</span>]*y)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Cxor[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,mod<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Ixor[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;(mod+<span class="number">1</span>)/<span class="number">2</span>,(mod+<span class="number">1</span>)/<span class="number">2</span>&#125;,&#123;(mod+<span class="number">1</span>)/<span class="number">2</span>,mod-(mod+<span class="number">1</span>)/<span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> n,a[N*<span class="number">2</span>];</span><br><span class="line">LL fc[N],nfc[N],f2[N];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line">vector&lt;array&lt;<span class="type">int</span>,2&gt;&gt; <span class="built_in">solve</span>(<span class="type">int</span> dep,<span class="type">int</span> l,<span class="type">int</span> r)&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        vector&lt;array&lt;<span class="type">int</span>,2&gt; &gt; ans;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=a[l];i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span>)ans[<span class="number">0</span>][<span class="number">0</span>]=(ans[<span class="number">0</span>][<span class="number">0</span>]+<span class="built_in">C</span>(a[l],i)*f2[i])%mod;</span><br><span class="line">            <span class="keyword">else</span> ans[<span class="number">0</span>][<span class="number">1</span>]=(ans[<span class="number">0</span>][<span class="number">1</span>]+<span class="built_in">C</span>(a[l],i)*f2[i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> lans=<span class="built_in">solve</span>(dep<span class="number">-1</span>,l,mid);</span><br><span class="line">    <span class="keyword">auto</span> rans=<span class="built_in">solve</span>(dep<span class="number">-1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; lf;lf.<span class="built_in">resize</span>(<span class="number">1</span>&lt;&lt;(dep+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;(dep<span class="number">-1</span>));i++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> [f0,f1]=lans[i];</span><br><span class="line">        lf[i]=f0;</span><br><span class="line">        lf[i+(<span class="number">1</span>&lt;&lt;dep)]=f1;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; rf;rf.<span class="built_in">resize</span>(<span class="number">1</span>&lt;&lt;(dep+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;(dep<span class="number">-1</span>));i++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> [f0,f1]=rans[i];</span><br><span class="line">        rf[i]=f0;</span><br><span class="line">        rf[i+(<span class="number">1</span>&lt;&lt;(dep<span class="number">-1</span>))+(<span class="number">1</span>&lt;&lt;dep)]=f1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FWT</span>(lf,Cxor,(<span class="number">1</span>&lt;&lt;(dep+<span class="number">1</span>)));</span><br><span class="line">    <span class="built_in">FWT</span>(rf,Cxor,(<span class="number">1</span>&lt;&lt;(dep+<span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;(dep+<span class="number">1</span>));i++)lf[i]=<span class="number">1ll</span>*lf[i]*rf[i]%mod;</span><br><span class="line">    <span class="built_in">FWT</span>(lf,Ixor,(<span class="number">1</span>&lt;&lt;(dep+<span class="number">1</span>)));</span><br><span class="line">    vector&lt;array&lt;<span class="type">int</span>,2&gt; &gt; ans;ans.<span class="built_in">resize</span>(<span class="number">1</span>&lt;&lt;dep);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;dep);i++)&#123;</span><br><span class="line">        ans[i]=&#123;lf[i],lf[i+(<span class="number">1</span>&lt;&lt;dep)]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=f2[<span class="number">0</span>]=<span class="number">1</span>;f2[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod,f2[i]=f2[i<span class="number">-1</span>]*<span class="number">2</span>%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        a[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> ans=<span class="built_in">solve</span>(L,<span class="number">0</span>,(<span class="number">1</span>&lt;&lt;L)<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ans[<span class="number">0</span>][<span class="number">0</span>]+ans[<span class="number">0</span>][<span class="number">1</span>])%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">我的做法改进</summary><div class="toggle-content"><p>发现一个事情，矩阵为 $\begin{bmatrix} 1 &amp; 1\ 1 &amp; -1 \end{bmatrix}$ 的 FWT （即异或的 FWT）最终的结果其实可以写成这样：</p>
<script type="math/tex; mode=display">f[i]=\sum\limits_{i=0}^{L}(-1)^{popcount(i\And j)}a[j]</script><p>利用这个式子，可以改进分治 FWT 。</p>
<p>不妨假设：$(r-l)=2^l$ ，显然左区间的值域在 $[0,2^l)$ （高位补了 $1$ 判断奇偶性），现在要扩充到 $[0,2^{l+1})$ ，扩充规则为给原来的每个下表在最高位（算前导 $0$ ）下面塞个 $0$ （右区间塞 $1$） ，然后在剩下的位置补 $0$ 。</p>
<p>然后根据上面的式子可以利用变化前的点值，在线性时间得到变化后的点值。（具体见代码）</p>
<p>然后直接乘就行了，时间复杂度：$O(V\log{V})$ 。</p>
<p>这个做法相比较于下面的做法，或许不是最妙的，但是是最适用的，因为不依赖于系数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L=<span class="number">17</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SN=(<span class="number">1</span>&lt;&lt;L);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT</span><span class="params">(LL *f,<span class="type">const</span> LL C[<span class="number">2</span>][<span class="number">2</span>],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;len;t&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;len;l+=t+t)&#123;</span><br><span class="line">            <span class="type">int</span> r=l+t;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t;i++)&#123;</span><br><span class="line">                LL x=f[l+i],y=f[r+i];</span><br><span class="line">                f[l+i]=(C[<span class="number">0</span>][<span class="number">0</span>]*x+C[<span class="number">0</span>][<span class="number">1</span>]*y)%mod;</span><br><span class="line">                f[r+i]=(C[<span class="number">1</span>][<span class="number">0</span>]*x+C[<span class="number">1</span>][<span class="number">1</span>]*y)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> LL Cxor[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,mod<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="type">const</span> LL Ixor[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;(mod+<span class="number">1</span>)/<span class="number">2</span>,(mod+<span class="number">1</span>)/<span class="number">2</span>&#125;,&#123;(mod+<span class="number">1</span>)/<span class="number">2</span>,mod-(mod+<span class="number">1</span>)/<span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> n,a[N*<span class="number">2</span>];</span><br><span class="line">LL fc[N],nfc[N],f2[N];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line">LL f[<span class="number">2</span>][N*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;L);i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=a[i];j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&amp;<span class="number">1</span>)f[<span class="number">1</span>][i]=(f[<span class="number">1</span>][i]+<span class="built_in">C</span>(a[i],j)*f2[j])%mod;</span><br><span class="line">            <span class="keyword">else</span> f[<span class="number">0</span>][i]=(f[<span class="number">0</span>][i]+<span class="built_in">C</span>(a[i],j)*f2[j])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        LL lf=f[<span class="number">0</span>][i],rf=f[<span class="number">1</span>][i];</span><br><span class="line">        f[<span class="number">0</span>][i]=(lf+rf)%mod;</span><br><span class="line">        f[<span class="number">1</span>][i]=(lf+mod-rf)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=L;t++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;L);i+=(<span class="number">1</span>&lt;&lt;t))&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=i;l&lt;i+(<span class="number">1</span>&lt;&lt;(t<span class="number">-1</span>));l++)&#123;</span><br><span class="line">                <span class="type">int</span> r=l+(<span class="number">1</span>&lt;&lt;(t<span class="number">-1</span>));</span><br><span class="line">                LL l0=f[<span class="number">0</span>][l],l1=f[<span class="number">1</span>][l];</span><br><span class="line">                LL l00=l0,l01=l0;</span><br><span class="line">                LL l10=l1,l11=l1;</span><br><span class="line">                </span><br><span class="line">                LL r0=f[<span class="number">0</span>][r],r1=f[<span class="number">1</span>][r];</span><br><span class="line">                LL r00=r0,r01=r1;</span><br><span class="line">                LL r10=r1,r11=r0;</span><br><span class="line"></span><br><span class="line">                f[<span class="number">0</span>][l]=l00*r00%mod;</span><br><span class="line">                f[<span class="number">0</span>][r]=l01*r01%mod;</span><br><span class="line">                f[<span class="number">1</span>][l]=l10*r10%mod;</span><br><span class="line">                f[<span class="number">1</span>][r]=l11*r11%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FWT</span>(f[<span class="number">0</span>],Ixor,(<span class="number">1</span>&lt;&lt;L));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=f2[<span class="number">0</span>]=<span class="number">1</span>;f2[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod,f2[i]=f2[i<span class="number">-1</span>]*<span class="number">2</span>%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        a[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,f[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">深刻观察法</summary><div class="toggle-content"><p>来自比赛 Announcement 评论区。</p>
<p>发现一个事情，矩阵为 $\begin{bmatrix} 1 &amp; 1\ 1 &amp; -1 \end{bmatrix}$ 的 FWT （即异或的 FWT）最终的结果其实可以写成这样：</p>
<script type="math/tex; mode=display">f[i]=\sum\limits_{i=0}^{L}(-1)^{popcount(i\And j)}a[j]</script><p>同时又观察到，结果只能是 $-1$ 或者 $3$ ，那么这有什么用呢？</p>
<p>思考一下，FWT 和 FFT 有一个很重要的不同，就是 FWT 不需要扩展数组，因为下标值域不会扩展，所以 FWT 实际上能算出所有多项式的点值表达式直接乘起来然后再逆回去，而 FFT 是不行的（除非一开始就把所有的多项式算出充足的点值）。</p>
<p>但是算出所有多项式的点值表达式的时间开销仍然很大，第一种做法采用了分治 FWT 来加速这个过程，但是这里，我们直接观察出了 FWT 后的结果长啥样，那我们是不是可以不用 FWT ，直接算出结果呢？</p>
<p>显然，求 $\prod f_k[i]$ 只需要算出有多少个 $-1$ 或者有多少个 $3$ 就行了。</p>
<p>有了这个思路，就有很多种搞法了。</p>
<p>我使用的做法是：$n=even+odd$ ，那么只需要令 $a[x]=x的出现次数$ ，然后直接跑 FWT ，就可以知道每个位置的 $even-odd$ ，然后就可以直接算出来 $-1$ 和 $3$ 的个数了。</p>
<p>还有别的搞法，例如：SOS dp，但是因为感觉这个的转移式子和 FWT 没什么本质区别，就不再赘述了，放个这个做法的代码： <a href="https://codeforces.com/contest/1906/submission/235477273">https://codeforces.com/contest/1906/submission/235477273</a> 。</p>
<p>时间复杂度：$O(V\log{V})$ 的，空间复杂度：$O(V)$，$V$ 是值域。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L=(<span class="number">1</span>&lt;&lt;<span class="number">17</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FWT</span><span class="params">(LL *f,<span class="type">const</span> LL C[<span class="number">2</span>][<span class="number">2</span>],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;len;t&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;len;l+=t+t)&#123;</span><br><span class="line">            <span class="type">int</span> r=l+t;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t;i++)&#123;</span><br><span class="line">                LL x=f[l+i],y=f[r+i];</span><br><span class="line">                f[l+i]=(C[<span class="number">0</span>][<span class="number">0</span>]*x+C[<span class="number">0</span>][<span class="number">1</span>]*y)%mod;</span><br><span class="line">                f[r+i]=(C[<span class="number">1</span>][<span class="number">0</span>]*x+C[<span class="number">1</span>][<span class="number">1</span>]*y)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">LL f3[N],a[NN];</span><br><span class="line">LL Cxor[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,mod<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">LL Ixor[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;(mod+<span class="number">1</span>)/<span class="number">2</span>,(mod+<span class="number">1</span>)/<span class="number">2</span>&#125;,&#123;(mod+<span class="number">1</span>)/<span class="number">2</span>,mod-(mod+<span class="number">1</span>)/<span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    f3[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        a[x]++;</span><br><span class="line">        f3[i]=f3[i<span class="number">-1</span>]*<span class="number">3</span>%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FWT</span>(a,Cxor,L);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L;i++)&#123;</span><br><span class="line">        <span class="type">int</span> num=a[i];</span><br><span class="line">        <span class="keyword">if</span>(num&gt;n)num-=mod;</span><br><span class="line">        <span class="comment">//n=f+z,num=z-f;</span></span><br><span class="line">        <span class="type">int</span> z=(n+num)/<span class="number">2</span>,f=(n-num)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(f&amp;<span class="number">1</span>)a[i]=(mod-f3[z])%mod;</span><br><span class="line">        <span class="keyword">else</span> a[i]=f3[z];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FWT</span>(a,Ixor,L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,a[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>FWT</tag>
        <tag>计数</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-2021 ICPC Asia Seoul Regional Contest 赛后总结</title>
    <url>/2025/02/04/2020-2021-ICPC-Asia-Seoul-Regional-Contest-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/gym/102920">https://codeforces.com/gym/102920</a></p>
<p>C**，打的是真尼玛的屎啊！</p>
<p>大败而归了，哭。</p>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>纯纯暴力题，队友写的。</p>
<p>不过还是要注意实现细节，以后还是要自己多做一下这种题，不能天天交给队友。</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>签到题，交给队友了。</p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>题意：给你一棵树，有一些点是公寓，现在一个点 $x$ 是好点，当且仅当：$\forall y,\exists z$ 使得 $z$ 是公寓且 $dis(x,z)&lt;dis(y,z)$ 。</p>
<p>做法也是非常简单，显然公寓一定是好点。</p>
<p>其余点是好点的充要条件是以这个点为根时，必须要有两棵子树里面有公寓。</p>
<p>时空复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 110000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NN 210000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fep(i,x,y) for(int i=x;i&lt;=y;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> feq(i,x,y) for(int i=x;i&gt;=y;i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">  <span class="type">int</span> y,next;</span><br><span class="line">&#125;a[NN];<span class="type">int</span> len,last[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;len++;a[len].y=y;a[len].next=last[x];last[x]=len;&#125;</span><br><span class="line"><span class="type">int</span> siz[N],n,m,sum[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k=last[x];k;k=a[k].next)&#123;</span><br><span class="line">    <span class="type">int</span> y=a[k].y;<span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(y,x);siz[x]+=siz[y];</span><br><span class="line">    <span class="keyword">if</span>(siz[y])sum[x]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(m-siz[x])sum[x]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">  <span class="built_in">fep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">    <span class="type">int</span> x,y,c;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;c);</span><br><span class="line">    <span class="built_in">ins</span>(x,y);<span class="built_in">ins</span>(y,x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">fep</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">    <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    siz[x]=<span class="number">1</span>;sum[x]=<span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">fep</span>(i,<span class="number">1</span>,n)ans+=(sum[i]&gt;=<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>非常巧妙的一道 DP 题，但是不可否认的是 n^3 过 1000 真的非常的屎。</p>
<p>题意是这样的：你有一辆车，有个油量 $W$ ，有 $n$ 个加油站，从一个城市到另外一个城市消耗的油量是曼哈顿距离，每个加油站加油有费用，然后问你从起点到终点的最小费用，同时还有限制，加油次数不能超过一个值。</p>
<p>这道题目用到了一个很有意思的点，一定存在一个最优方案，使得：当一辆车在连续两个加油站都加了油时，一定会有一个加油站加满了油或者到达时没有了油。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>第一个加油站的费用设为 $w1$ ，第二个设为 $w2$。</p>
<p>当 $w1\le w2$ 时，我们显然可以在第一次把一些第二次加的油提前加了。</p>
<p>反之，则可以在第二次加上第一次的油使得第一次不加油或者到达第二个加油站时恰好没有油。</p>
</div></details>
<p>利用这个性质，我们可以设计出 DP 状态。</p>
<p>$f_i$ 表示从一个加油站出发且加满油时的代价，$g_i$ 表示到达一个加油站且没有油时的代价。</p>
<p>然后转移有两种，一种是只走一条边的，一种是走两条边的，处理两条边转移的复杂度是 $n^3$ 的，所以是 $n^3$ 的。</p>
<p>至于 $\Delta$ 的话，可以先处理出 $n^2$ 的转移矩阵，然后就可以 $n^2\Delta$ 做完了。</p>
<p>时间复杂度：$O(n^2(n+\Delta))$ 。</p>
<p>至于转移，有四种：$f,g-&gt;f,g$ ，但是实际上需要 $n^3$ 处理的只有一种。</p>
<p>思考一下，加入司机没油出发，那么显然需要加油再走，这时途径一个加油站并且加了油，设出发加油站加油费用 $w1$ ，中间站 $w2$ 。</p>
<p>当 $w1\leq w2$ 时，显然我们要么加满出发，或者不用去中间站加油，反之我们到达中间站的时候油量为 $0$ 更加优秀。</p>
<p>而当我们到达终点站时加满油，同样可以与中间进行比较，发现中间可以存在中继状态。所以我们其实只需要在转移 $g-&gt;g$ 时转移一下就行了。</p>
<p>状态转移方程：</p>
<p>对于点 $x,y$ ，且 $dis(x,y)\le W$ 。</p>
<p>四种转移都是比较显然的。</p>
<p>然后枚举 $x,y,z$ ，转移一下即可。</p>
<h2 id="扩展：关于循环论证"><a href="#扩展：关于循环论证" class="headerlink" title="扩展：关于循环论证"></a>扩展：关于循环论证</h2><p>刚刚在证明转移的时候突然发现的一个事情：</p>
<p>一个很简单的例子，现在有一个圆盘，上面有 $n$ 个格子，其中一个格子放了小球，这个时候你放了一个球进去，然后证明：圆盘中任意的相邻个位置有一个小球，逻辑是这样的：</p>
<p>现在小球在 $1$ 号位置，你观测 1,2 ，发现的确，然后推球进了 $2$ 号位置，观测 $2,3$ ，也发现的确。</p>
<p>这样子的证明问题在于方案不一定是同一个了，同理，当我们在证明一个事情的时候，总是会说，显然存在一个最优方案满足一个局部条件，但是不一定存在一个最优方案满足所有的局部条件。</p>
<p>这个时候有两种解决方法：</p>
<ol>
<li>人为的给最优方案之间加上另外一个限制条件，使得最优方案中也有优劣之分，类似相等时加上浮动使其存在偏序关系，本质为人为构造了偏序关系。</li>
<li>证明确实就是存在最优方案满足所有的局部条件，证明方法很多，例如可以证明最优方案经过调整某个值只减不增等等。</li>
</ol>
<p>为什么突然提到这一个问题呢？</p>
<p>因为上面在证明的时候我突然意识到一个问题，我上面有句话：总是存在一种最优方案使得 $x-&gt;y-&gt;z$ 的转移只用转移 $g-&gt;g$ 。</p>
<p>其中的证明逻辑为：其余的情况我总是可以通过其余的转移完成，这在这道题目是对的，但是有时候其又有可能是错的，因为可能会循环论证，虽然这种情况一般不会发生，但是我毕竟是遇到过的，还是要引以为戒。</p>
<p>至于这题，为什么这样的证明是正确呢？</p>
<p>原因很简单：举个例子，当我需要从 $f-&gt;g$ 时，如果需要经过 $x-&gt;y-&gt;z$ 转移，我也一定可以通过 $f_x-&gt;g_x-&gt;g_z$ 或者是 $f_x-&gt;f_y-&gt;g_z$ 进行转移，我证明的，只是某种转移总是可以被另外一些转移覆盖，你可以理解为优化后的转移方式 $S$ 是原来转移方式 $G$ 的子集，但是 $S$ 可以实现 $G$ 的所有功能，我们仅仅证明了这个，而这种优化的证明，显然不会出现循环论证的情况，因为这种证明既不会影响前面的决策，也不会影响后面的决策，仅仅是改变了中间转移时的决策，证明了有些决策是冗杂的，可以去掉的而已，所以不会出现循环论证的情况（相对应的，所有类似的证明方式都不会出现这种情况）。</p>
<p>当然，也需要注意，如果你证明优化转移的方式并不常规，也就是和我们上面讲的证明并不类似，有一些本质的区别，那就需要注意会不会循环论证了，毕竟我们上面只是针对某种证明方式去论述其不会出现循环论证，如果你的证明方法并不是这一种，那还是多加小心为好。</p>
<p>毕竟，我之前是真的有过因为这种事情而假过做法的QAQ，如果这种事情出现在了重大的赛事上，那真的就是永生难忘了QAQ。</p>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>也是非常简单的题目。</p>
<p>做法为，出现奇数次的 $1$ 和后面出现偶数次的 $1$ 配对，$2$ 只能出现在配对的 $1$ 中间。</p>
<p>时空复杂度：$O(n)$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>证明奇偶性的简单方法：去掉绝对值，给一些数字标上 $-$ ，那么权值和应该为 $0$ ，所以加上绝对值后 $D$ 序列的总和应该为偶数。</p>
<p>考虑本质，显然我们只需要考虑相邻两个数字的比较关系，我们可以在相邻两个数字间画上箭头，一个数字被箭头所指向的次数，我们可以认为就是这个位置的有效权值，显然，非相邻数字的比较关系不可能贡献给 $D$ 序列的。</p>
<p>而我们现在就是要改变箭头的方向从而得到一个位置有效权值的改变量。</p>
<p>显然，对于任意一种我们认为的合法 $D$ 序列，我们总是可以构造出来一种箭头和改变箭头的方案使得其满足 $D$ 序列。</p>
<p>而只有连续改变箭头，才会在端点处出现 $1$ ，否则都为偶数，所以 $2$ 只能被成对的 $1$ 包含在里面，证毕。</p>
</div></details>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fep(i,x,y) for(int i=x;i&lt;=y;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> feq(i,x,y) for(int i=x;i&gt;=y;i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,a[N],bk;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="built_in">fep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">    <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">2</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">1</span>)bk^=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">2</span> &amp;&amp; !bk)&#123;<span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(bk)&#123;<span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反思：找不到错误的时候。"><a href="#反思：找不到错误的时候。" class="headerlink" title="反思：找不到错误的时候。"></a>反思：找不到错误的时候。</h2><p>当你实在找不到代码和做法的问题的时候，不妨考虑一下是不是题意读错了，赶紧去重新读一遍题意或者叫队友读一遍题意。</p>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p>题意：有 $n$ 个颜料桶，有 $m$ 个初始有不同的颜色，同时还有一些有向管子，表示颜料从第 $x$ 个颜料流到第 $y$ 个颜料桶。</p>
<p>然后颜料混合会产生新的颜色，注意：因为管子流速不同，所以即使是同两种颜色，只要是在不同的桶中，就会配出不同的颜色。</p>
<p>最后问你稳定状态有多少种颜色。</p>
<p>至于颜料会不会流完等等问题，不太确定，反正也不会做，先鸽着。</p>
<h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p>纯纯傻鸟题，二分卡我时间。</p>
<p>但是存在 $O(n)$ 做法，简单来说就是终止状态有两种，递增，递减，直接针对两种情况判一下就行了，判断过程不难，自己想。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fep(i,x,y) for(int i=x;i&lt;=y;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> feq(i,x,y) for(int i=x;i&gt;=y;i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,LL&gt; PII;</span><br><span class="line"><span class="type">int</span> f;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getz</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">  x=<span class="number">0</span>;f=<span class="number">1</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(c&gt;<span class="string">&#x27;9&#x27;</span> || c&lt;<span class="string">&#x27;0&#x27;</span>)c==<span class="string">&#x27;-&#x27;</span>?f=<span class="number">-1</span>:<span class="number">1</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(c&lt;=<span class="string">&#x27;9&#x27;</span> &amp;&amp; c&gt;=<span class="string">&#x27;0&#x27;</span>)x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c-<span class="string">&#x27;0&#x27;</span>),c=<span class="built_in">getchar</span>();</span><br><span class="line">  f==<span class="number">-1</span>?x=-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;LL dd,a[N],b[N],c[N];</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(LL *d)</span></span>&#123;</span><br><span class="line">  LL minval=d[<span class="number">1</span>],maxval=d[<span class="number">1</span>];</span><br><span class="line">  <span class="built_in">fep</span>(i,<span class="number">2</span>,n)minval=<span class="built_in">min</span>(d[i],minval),maxval=<span class="built_in">max</span>(d[i],maxval);</span><br><span class="line">  <span class="keyword">return</span> (maxval-minval)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">getz</span>(n);<span class="built_in">getz</span>(dd);dd*=<span class="number">2</span>;</span><br><span class="line">  <span class="built_in">fep</span>(i,<span class="number">1</span>,n)&#123;<span class="built_in">getz</span>(a[i]);a[i]*=<span class="number">2</span>;b[i]=a[i]-dd*(i<span class="number">-1</span>);c[i]=a[i]+dd*(i<span class="number">-1</span>);&#125;</span><br><span class="line">  <span class="comment">// fep(i,1,n)printf(&quot;%lld %lld\n&quot;,b[i],c[i]);</span></span><br><span class="line">  LL ans=<span class="built_in">min</span>(<span class="built_in">solve</span>(b),<span class="built_in">solve</span>(c));</span><br><span class="line">  <span class="keyword">if</span>(ans&amp;<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">&quot;%lld.5\n&quot;</span>,ans&gt;&gt;<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld.0\n&quot;</span>,ans&gt;&gt;<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><p>没看题，神仙队友AC了。</p>
<h1 id="I"><a href="#I" class="headerlink" title="I"></a>I</h1><p>啊，我心中的痛啊！！！</p>
<p>显然，$n^2$ 个区间跑出来，就可以三位偏序了，按权值排序，然后用树状数组套数组爽过。</p>
<p>时间复杂度：$O((n^2+q)\log^2{n})$</p>
<details class="toggle" ><summary class="toggle-button" style="">根号做法</summary><div class="toggle-content"><p>这里先讲讲：$O(n^2\sqrt{n}+nm)$ 的根号做法，但是这种做法大概率不如树状数组优秀，因为这边有一个组只维护了两个分块数组（指的是每次更新要根号的数组）用了 1500ms 。</p>
<p>考虑按照权值从小到大加入区间，维护以下几个数组：</p>
<p>$bel[i]$ 表示 $i$ 在第 $bel[i]$ 个块。</p>
<p>$f1[i]$ 表示块内答案。</p>
<p>$f2[i]<a href="j&lt;bel[i]">j</a>$ 表示右端点为 $i$ ，左端点在 $j$ ~ $bel[i]-1$ 的块内的最大答案。</p>
<p>$f3[i]<a href="bel[j]&lt;bel[i]">j</a>$ 表示左端点在 $j$ ~ $bel[j]$ 块的右端，右端点为 $i$ 的最大答案。</p>
<p>不难发现，插入一个区间可以 $O(sqrt{n})$ 更新。</p>
<p>然后每次修改暴力枚举 $i$ $O(n)$ 查询完就行了，块的两端随便处理一下就行了。</p>
<p>接着讲一下我自己的同复杂度做法，但是多维护了一个分块数组，大概率是过不了的。</p>
<p>$f1[l][r]$ 表示块 $l$ ~ $r$ 的最优答案。</p>
<p>$f2[i][j]$ 同上。</p>
<p>$f3[i][j]$ 类似 $f2$ ，只不过 $j&gt;bel[i]$ 。</p>
<p>怎么更新 $f1$ 呢？其实只需要转换一下更新模式就行了。</p>
<p>我们每过 $\sqrt{n}$ 个区间更新一下 $f1$ ，单次更新 $O(n)$ ，这样时间复杂度就是 $O(n^2\sqrt{n})$ 了，毕竟更新 $f1$ 最麻烦的就是枚举 $l,r$ ，我们把多次更新并到一起岂不美哉。</p>
<p>这里就要说一下为什么他是三个数组我是两个数组了，实际上就是我没有灵活应用好这个 $nq$ 了，因为询问的时间复杂度实在是太松了，所以实际上很多操作可以等到询问再处理，例如他的做法之所以比我的做法少了一个分块数组，实际上就是他多了枚举区间所有位置统计答案的步骤，而我只用枚举区间两端的散块，也就是我牺牲了修改的常数换取了询问的尝试。</p>
<p>实际上如果我也进行遍历区间的操作，我也能省掉 $f1$ ，只维护两个分块数组。</p>
<p>UPD：其实写到这里我突然又觉得我的不一定会比上面的做法慢，因为虽然我比他多了一个分块数组，$n^2\sqrt{n}$ 常数多了 $1$ ，但是询问少了一次遍历整个区间，所以 $nm$ 少了一个 $1$ ，而 $n^2\sqrt{n}&lt;nm$ ，说不定还能跑的比上面的做法快，所以说到底没有 AC 纯粹就是懒得写。</p>
<p>重回正题，不难发现，这两个做法合一起就能 $O((n^2+m)\sqrt{n})$ 了。</p>
<p>整块对整块的方法用我的方法处理，整块对散块就必须两个方向都处理一遍了，即我的做法的 $f2,f3$ ，区间两端的散块对散块，采用上面做法的 $f3$ 处理，至于散块内部（散块内部用于询问在块内和区间两端的散块内部），也很简单，定义类似 $f1$ ，但是更新却很简单。</p>
<p>即：$ff[l][r]$ 表示一个块内 $[l,r]$ 的最小值，每次出现这个块内的答案就更新一下，单次更新 $O(n)$ ，但是一个块最多更新 $\sqrt{n}*\sqrt{n}=n$ 次，只有 $\sqrt{n}$ 个块，所以至多更新 $O(n^2\sqrt{n})$ 次，这样就完成了对 $ff$ 的更新，人话讲就是：暴力更新，复杂度是对的。</p>
<p>当然，你也可以采用和 $ff$ 类似的技巧，将其的更新复杂度降到：$O(n^2)$ ，但是没有这个必要，因为这道题目的时间复杂度瓶颈多了去了，你去掉一个瓶颈时间复杂度照样下不来，还更难写了，没有这个必要，直接暴力更新就是最好的选择。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">队友做法</summary><div class="toggle-content"><p>队友赛时想的 $O(nm\alpha(n))$ 做法。（但是赛时被心态已经爆炸的我认为很难写且会超时，给直接给否决掉，导致我们最后都没有 AC 这道题目。）&lt;/summary&gt;</p>
<p>简单来说，前缀和，然后排好序（从小到大），然后每次查询就按排好序的方式拿出序列。</p>
<p>假设 $A$ 是我们询问的区间 ，$A’$ 是 $A$ 排序好的区间。</p>
<p>使用双指针，找每个位置 $i$ 最靠左的 $j$ 满足 $A_i-A_j\le U_i$ ，显然，如果 $j\le i$ ，这就是当 $i$ 为右端点的最优方案。</p>
<p>但是不一定，因此我们考虑从右到左删除数字，到 $x$ ，先看其的贡献，然后删除，那指向他的那些 $i$ 怎么办呢？答案是指向 $x$ 右边那个数字。</p>
<p>那么我们就需要一个支持单点删除，并且快速查询一个位置右边第一个没有被删除的位置是哪个的数据结构，显然就是并查集了。</p>
<p>然后就做完了。</p>
</div></details>
<h1 id="J"><a href="#J" class="headerlink" title="J"></a>J</h1><p>纯纯傻鸟题，线性基就做完了。</p>
<p>显然如果你能构造出来每一种方案，那么你原来的方程组一定是满秩的。（线性变换前后秩不变，而最终方案的秩为 $n$ ）</p>
<p>那么线性基的时候用 bitset 记录一下方案，不就做完了吗。</p>
<p>时间复杂度：$O(\frac{n^3}{w})$</p>
<h1 id="K"><a href="#K" class="headerlink" title="K"></a>K</h1><p>当时做这道题目犯了一个致命的失误，我以为可能会无解，然后觉得太难了，就没想这道题目，但实际上我当时想的误解情况是非法的。</p>
<p>当时觉得一个“工”字不存在方案，现在突然发现工字不满足题目的限制，做这种构造题就特别容易出现构造一个在自己认为无解的反例，然后觉得题目太难不可做，扔了，但实际上反例是非法的情况。</p>
<p>先说一点，题目应该是一定有解的，这是做这道题目一开始就应该要有的直觉，不然出题人给这么多限制条件干嘛，又是洞又是周围必须要有两个 $1$ 啥的。</p>
<p>关于洞的描述，其实有个很规范且简单的说法，假设地图无限大，那么 $0$ 的连通块应该只有一个。</p>
<p>然后就是怎么做的问题了，显然，对于一个长度 $\ge 2$ 的横条，一定存在解。</p>
<p>因此我们考虑将这个连通块不断竖切，得到一堆长条，然后就差不多做完了。</p>
<p>但是有一个例外：如果一个格子上下没有连接 $1$ 而左右连接了 $1$ 咋整，形成了一个类 “工” 字，因此我们考虑对于一个连通图的某些部分横切，某些部分纵切，显然，对于刚刚的情况，我们就希望两边连接的部分有一个部分是横切的。</p>
<p>这个时候，联系一下为什么题目要限制洞？不难发现，整个图形成了一个类似树的形状，再想想一棵树除根节点外的每个点都能独立对应一条边，再结合我们希望一个特殊格子其连接的两端有一端能对他负责，就不难想到最终的做法。</p>
<p>我们将只有上下联通 $1$ 或者左右联通 $1$ 的格子抽象为边，将不是这种的 $1$ 形成的连通块抽象成点，然后从一个点出发，每个点和其边绑定，方向由边决定，然后这样切一下就解决了。</p>
<p>注意，一条边其实不一定由一个格子构成，可能是由一条特殊的 $1$ 构成的链组成。</p>
<p>这个做法最大的误区是以为一个阶梯状的链上面全是特殊点，实际上这个阶梯状的链上一个特殊点都没有，因为其不符合之前说的要么上下，要么左右。</p>
<p><img src="1.png" alt=""></p>
<p>感觉这道题目虽然难写，但是思维难度也是不低的，非常的有意思。</p>
<p>可惜不是我想出来的QAQ，是别的队伍在赛时做出来了，赛后跟我们讲的QAQ。</p>
<h1 id="L"><a href="#L" class="headerlink" title="L"></a>L</h1><p>这道题目没做出来，可是真的就差点了QAQ。</p>
<p>之前做过一道类似的题目，这道题目也是很快就想到了应该有决策单调性，但是一直搁那列式，就是找不到单调性（机房中还是有人是列式找到单调性的，比较NB），最后画了个图找出来了。</p>
<p>显然，题目可以转化为求梯形面积（经典数形结合），需要考虑的点构成一个八字，且只需要考虑八字的左边与八字的右边匹配的情况。</p>
<p><img src="2.png" alt=""></p>
<p>假如 $1$ 在 $4$ 的决策比在 $3$ 好，那么 $2$ 的在 $4$ 的决策也比 $3$ 好。</p>
<p>从图中就可以看出来：蓝&lt;红 ，绿&lt;蓝，紫&gt;红，显然紫&gt;绿。</p>
<p>然后分治一下就做完了，时间复杂度：$O(n\log{n})$</p>
<details class="toggle" ><summary class="toggle-button" style="">另外引用一下同机房另外一个人的直觉流做题法</summary><div class="toggle-content"><p>在八字上，$(h_i+h_j)*(j-i)$ 。</p>
<p>$i$ 往右移动，$(j-i)$ 下降，$(h_i+h_j)$ 上升。</p>
<p>$j$ 往右移动，$(j-i)$ 下降，$(h_i+h_j)$ 上升。</p>
<p>$j$ 往左移动，$(j-i)$ 上升，$(h_i+h_j)$ 下降。</p>
<p>那么根据和固定，两数越接近乘积越大的均衡思想（这里不是说和是固定的，是从这个定理中可以看出应该数字越接近，乘积越大的均衡思想），我们应该用让 $j$ 往左移动，所以这道题目应该存在决策单调性，且方向是 $i,j$ 同向的。（不过他们赛时脑子有点晕，没有很肯定方向，求稳把两个方向都做了一遍。）</p>
<p>当然这种直觉流做题不能太过依赖啊，只有刷题量大的选手才能用的好，因为大量的题目能让他们做出正确的判断，比如这个大佬可能就是以前做过类似的乘积存在单调性的题目才能这么快察觉应该有决策单调的（毕竟感觉这个题目比较经典，他应该是做过的），上面这一套说法应该是其在察觉到决策单调后所想的一个比较简单的方法用于去阐释决策单调的，也就是先射箭后画靶。（也有可能没有做过，的确是通过这么一个想法想到的决策单调，但是不可否认的是这个大佬的刷题量确实很大）</p>
<p>毕竟，同样的说法，我换个说法，就又是另外一个方向，假如 $(h_i+h_j)$ 很大，那我为什么不能 $i,j$ 全部往外走，减少 $(h_i+h_j)$ ，增大 $(j-i)$ 呢？</p>
<p>所以，如果对直觉做题法不够放心的话，还是老老实实确定了正确性再写吧，不过感觉最正确的姿势应该是：先用直觉找到大致方向，再确定正确性，然后开写。当然，如果感觉很难证，结论又感觉很正确，又不难写，队伍里面有没有要写的题目，也可以不妨写一下尝试一下，说不定就过了，过的了血赚，过不了就换个方向，以写代证伪，节省了证伪的时间。</p>
</div></details>
<h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><ol>
<li>亲手写一些代码。</li>
<li>补充一个关于状态转移和状态转移优化的理解。</li>
<li>把没有做的题目自己做一遍。</li>
<li>自己去看一遍官方题解并且补充一下官方题解的做法。</li>
<li>补充 $L$ 题的推式子证明方法。</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>ABC142 赛后总结</title>
    <url>/2025/02/04/ABC142-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>我怕不是傻子吧！！！</p>
<p>没有AK啊啊啊。</p>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>这道题目的大意就是求$1-n$里面奇数的个数占$1-n$个数的多少</p>
<p>真SB的题目</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="type">int</span>  n;</span><br><span class="line"><span class="type">double</span>  a;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">if</span>(n&amp;<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>,(n/<span class="number">2</span>+<span class="number">1</span>)*<span class="number">1.0</span>/n);</span><br><span class="line">	<span class="keyword">else</span>  <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>,(n/<span class="number">2</span>)*<span class="number">1.0</span>/n);</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>类似于淘淘摘苹果，给你个高度，问你有多少个数字大于等于他。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="type">int</span>  n,m,ans;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span>  x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">		<span class="keyword">if</span>(x&gt;=m)ans++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>题目大意就是给你第$i$个同学之前有$ai-1$个同学进入，然后问你进来先后的同学编号。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  N  110000</span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="type">int</span>  n,a[N],what[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">bool</span>  <span class="title">cmp</span><span class="params">(<span class="type">int</span>  x,<span class="type">int</span>  y)</span></span>&#123;<span class="keyword">return</span>  a[x]&lt;a[y];&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);what[i]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(what+<span class="number">1</span>,what+n+<span class="number">1</span>,cmp);<span class="comment">//这个很类似我打的离散化呀</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,what[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,what[n]);</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>题目大意就是给你$A,B$，然后你需要求出$A,B$的公共约数，同时在约数中找到最多的约数个数，使得约数之间互质。</p>
<p>其实最优的方案就是找到最多的两个数字最多的公共质因数个数。</p>
<p>但是需要注意一点<del>估计也就我脑抽了</del>：</p>
<p>$x\%i==0$但是$y\%i!=0$，但是此时有可能$y\%(x/i)==0$，结果我当时就写挂了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">long</span>  <span class="type">long</span>  LL;</span><br><span class="line">LL  top;</span><br><span class="line"><span class="function"><span class="type">bool</span>  <span class="title">pd1</span><span class="params">(LL  x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">1</span>)<span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(LL  i=<span class="built_in">sqrt</span>(x);i&gt;=<span class="number">2</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(x%i==<span class="number">0</span>)<span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">pd2</span><span class="params">(LL  x,LL  y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x&gt;y?x^=y^=x^=y:<span class="number">0</span>;</span><br><span class="line">	LL  ed=<span class="built_in">sqrt</span>(x);</span><br><span class="line">	<span class="keyword">for</span>(LL  i=<span class="number">1</span>;i&lt;=ed;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(y%i==<span class="number">0</span>  &amp;&amp;  <span class="built_in">pd1</span>(i)==<span class="number">1</span>)top++;</span><br><span class="line">			<span class="keyword">if</span>(y%(x/i)==<span class="number">0</span>  &amp;&amp;  i*i!=x  &amp;&amp;  <span class="built_in">pd1</span>(x/i)==<span class="number">1</span>)top++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">LL  n,m;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="built_in">pd2</span>(n,m);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,top);</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>也就是告诉你一些上锁的箱子，然后给你一些钥匙，每个钥匙可重复使用，要多少钱，能开什么箱子。</p>
<p>一个状压DP即可，连我这个DP傻子都会写的状压，肯定是道SB题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  N  20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  M  1100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  ALL  71000</span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="type">int</span>  n,m,f[ALL],b[M],c[M],lim;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">int</span>  <span class="title">mymin</span><span class="params">(<span class="type">int</span>  x,<span class="type">int</span>  y)</span></span>&#123;<span class="keyword">return</span>  x&lt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)lim=(lim&lt;&lt;<span class="number">1</span>)^<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=lim;i++)f[i]=<span class="number">999999999</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span>  k;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;b[i],&amp;k);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span>  y;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;y);</span><br><span class="line">			c[i]^=(<span class="number">1</span>&lt;&lt;(y<span class="number">-1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">0</span>;i&lt;lim;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  j=<span class="number">1</span>;j&lt;=m;j++)f[i|c[j]]=<span class="built_in">mymin</span>(f[i|c[j]],f[i]+b[j]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(f[lim]==<span class="number">999999999</span>)f[lim]=<span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[lim]);</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p>全场唯一一个比较有难度的题目。可惜我图论自从不写网络流的题目后，整个人就变SB了。</p>
<p>所以我就只有D、F没做，差点AK了QAQ。</p>
<p>大概就是这样子的：</p>
<p>你对原图跑一遍强联通，然后对于一个强联通，必然有一个诱导子图，然后你先DFS找到一个环，然后在回溯的过程中如果发现环中有两个不相邻的点可以直接相通的话，那么就可以直接把原本两个点之间的路径截去了。</p>
<p>大概就是这样：</p>
<p><img src="https://i.loli.net/2019/09/29/ndYgzDUMROCFv9t.png" alt="25.png"></p>
<p>DFS加上删边使得这个图的入度出度都是1。</p>
<p>你也可以理解为你现在找到一个很大的核桃，然后你一直盘他盘他，把他盘到你想要的的样子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  N  1100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  M  2100</span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>  y,next;</span><br><span class="line">&#125;a[M];<span class="type">int</span>  len,last[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">ins</span><span class="params">(<span class="type">int</span>  x,<span class="type">int</span>  y)</span></span>&#123;a[++len].y=y;a[len].next=last[x];last[x]=len;&#125;</span><br><span class="line"><span class="type">int</span>  dfn[N],low[N],now,sta[N],top,bel[N],cnt[N],blen;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">int</span>  <span class="title">mymin</span><span class="params">(<span class="type">int</span>  x,<span class="type">int</span>  y)</span></span>&#123;<span class="keyword">return</span>  x&lt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">dfs</span><span class="params">(<span class="type">int</span>  x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dfn[x]=low[x]=++now;sta[++top]=x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  k=last[x];k;k=a[k].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span>  y=a[k].y;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[y])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(y);</span><br><span class="line">			low[x]=<span class="built_in">mymin</span>(low[x],low[y]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>  <span class="keyword">if</span>(!bel[y])low[x]=<span class="built_in">mymin</span>(low[x],dfn[y]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(low[x]==dfn[x])</span><br><span class="line">	&#123;</span><br><span class="line">		++blen;</span><br><span class="line">		<span class="keyword">while</span>(sta[top]!=x)</span><br><span class="line">		&#123;</span><br><span class="line">			bel[sta[top]]=blen;</span><br><span class="line">			top--;cnt[blen]++;</span><br><span class="line">		&#125;</span><br><span class="line">		top--;bel[x]=blen;cnt[blen]++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>  list[N],head,st;</span><br><span class="line"><span class="type">bool</span>  v[N]<span class="comment">/*表示这些点是否选为了答案*/</span>;</span><br><span class="line"><span class="type">int</span>  be[N];<span class="comment">//表示目前为这个图的第几个被找到的 </span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">dfs2</span><span class="params">(<span class="type">int</span>  x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(v[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span>  i=head;</span><br><span class="line">		<span class="keyword">for</span>(;list[i]!=x;i--)be[list[i]]=i;</span><br><span class="line">		be[list[i]]=i;</span><br><span class="line">		<span class="keyword">return</span>  ;</span><br><span class="line">	&#125;</span><br><span class="line">	v[x]=<span class="literal">true</span>;</span><br><span class="line">	list[++head]=x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  k=last[x];k;k=a[k].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span>  y=a[k].y;</span><br><span class="line">		<span class="keyword">if</span>(bel[x]==bel[y])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs2</span>(y);<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//只搜索连通块的话必然可以找到一种联通块的方法</span></span><br><span class="line">	<span class="keyword">if</span>(be[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  k=last[x];k;k=a[k].next)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span>  y=a[k].y;</span><br><span class="line">			<span class="keyword">if</span>(be[y])<span class="comment">//请开始你的盘核桃行为 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(be[y]&gt;be[x]<span class="comment">/*是在后面的话*/</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span>  i=be[x]+<span class="number">1</span>;i&lt;be[y];i++)be[list[i]]=<span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span><span class="comment">//在前面 </span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;be[y];i++)be[list[i]]=<span class="number">0</span>;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span>  i=be[x]+<span class="number">1</span>;i&lt;=head;i++)be[list[i]]=<span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>  n,m;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span>  x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">		<span class="built_in">ins</span>(x,y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!bel[i])<span class="built_in">dfs</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(cnt[bel[i]]&gt;<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs2</span>(i);</span><br><span class="line">			<span class="type">int</span>  ans=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span>  j=<span class="number">1</span>;j&lt;=n;j++)<span class="keyword">if</span>(be[j])ans++;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span>  j=<span class="number">1</span>;j&lt;=n;j++)<span class="keyword">if</span>(be[j])<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,j);</span><br><span class="line">			<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>我是SB，下次一定要争取AK，踏向更强的征程！</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AGC035 赛后总结</title>
    <url>/2024/05/25/AGC035-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://atcoder.jp/contests/agc035/tasks">https://atcoder.jp/contests/agc035/tasks</a></p>
<h1 id="A-XOR-Circle"><a href="#A-XOR-Circle" class="headerlink" title="A. XOR Circle"></a>A. XOR Circle</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc035/tasks/agc035_a">https://atcoder.jp/contests/agc035/tasks/agc035_a</a></p>
<p>题目大意：把 $n$ 个数字放在一个环上，满足任意相邻的三个数字 $A,B,C$ 都满足： $A\otimes C = B$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>不妨假设前三个数字为 $A,B,A\otimes B$ ，那么我们可以得到后面的数字为：$A,B,A\otimes B…$ ，可以看到 $3$ 是这个圆的周期。</p>
<p>因此，如果 $n$ 是 $3$ 的倍数，就是有三组 $n$ 个数字且异或和为 $0$ 。</p>
<p>否则就是所有数字都是 $0$ 。</p>
<p>时间复杂度：$O(n\log{n})$ ，而且不难做到 $O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, a[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[l] == a[r];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">3</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">pd</span>(<span class="number">1</span>, n) &amp;&amp; !a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pd</span>(<span class="number">1</span>, n / <span class="number">3</span>) &amp;&amp; <span class="built_in">pd</span>(n / <span class="number">3</span> + <span class="number">1</span>, n / <span class="number">3</span> * <span class="number">2</span>) &amp;&amp; <span class="built_in">pd</span>(n / <span class="number">3</span> * <span class="number">2</span> + <span class="number">1</span>, n) &amp;&amp; (a[n / <span class="number">3</span>] ^ a[n / <span class="number">3</span> * <span class="number">2</span>] ^ a[n]) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">solve</span>()) cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="B-Even-Degrees"><a href="#B-Even-Degrees" class="headerlink" title="B. Even Degrees"></a>B. Even Degrees</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc035/tasks/agc035_b">https://atcoder.jp/contests/agc035/tasks/agc035_b</a></p>
<p>题目大意：给每条边定个向，满足每个点的出度为偶数。</p>
<details class="toggle" ><summary class="toggle-button" style="">题解</summary><div class="toggle-content"><p>这个问题可以等价的转化为一个经典问题：能不能进行边匹配，满足匹配边之间有一个公共点。（无重边）</p>
<p>这个问题有解的条件是：连通且边数为偶数。</p>
<p>做法是：把 $DFS$ 树建出来，然后把所有返祖边存在子树内，然后从下到上，依次把每个点的非父亲边两两匹配，如果剩下一条就和父亲边匹配，如果没有，就把父亲边像返祖边一样丢给父亲，显然在边数为偶数的情况下，这样一定能匹配完所有的边。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y, next;</span><br><span class="line">&#125;a[N * <span class="number">2</span>]; <span class="type">int</span> len, las[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    a[++len] = &#123;y, las[x]&#125;;</span><br><span class="line">    las[x] = len;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; gfa[N];</span><br><span class="line"><span class="type">int</span> fa[N], dfn[N], ti;</span><br><span class="line"><span class="type">int</span> n, m, sta[N], top;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    dfn[x] = ++ti;</span><br><span class="line">    sta[++top] = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = las[x]; k; k = a[k].next)&#123;</span><br><span class="line">        <span class="type">int</span> y = a[k].y;</span><br><span class="line">        <span class="keyword">if</span>(y == fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(dfn[y] &amp;&amp; dfn[y] &lt; dfn[x]) gfa[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">            fa[y] = x;</span><br><span class="line">            <span class="built_in">dfs</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">if</span>(m &amp; <span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="built_in">ins</span>(x, y);</span><br><span class="line">        <span class="built_in">ins</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(gfa[i].<span class="built_in">size</span>() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x = gfa[i].<span class="built_in">back</span>();</span><br><span class="line">            gfa[i].<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="type">int</span> y = gfa[i].<span class="built_in">back</span>();</span><br><span class="line">            gfa[i].<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="built_in">print</span>(i, x);</span><br><span class="line">            <span class="built_in">print</span>(i, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        <span class="type">int</span> now = sta[i];</span><br><span class="line">        <span class="keyword">while</span>(gfa[now].<span class="built_in">size</span>() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x = gfa[now].<span class="built_in">back</span>();</span><br><span class="line">            gfa[now].<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="type">int</span> y = gfa[now].<span class="built_in">back</span>();</span><br><span class="line">            gfa[now].<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="built_in">print</span>(now, x);</span><br><span class="line">            <span class="built_in">print</span>(now, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!gfa[now].<span class="built_in">size</span>()) gfa[fa[now]].<span class="built_in">push_back</span>(now);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">print</span>(now, gfa[now][<span class="number">0</span>]), <span class="built_in">print</span>(now, fa[now]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>update ：</p>
<p>在看完题解后，感觉自己像个小丑，我这个做法完全可以这么翻译：</p>
<p>我在 $DFS$ 树上给非树边定向后，从下到上，对于每个点，如果出边为奇数，那么就把父亲边调转，何必多次一举去做匹配的过程。</p>
<p>或者说可以这么考虑，发现匹配过程得到的匹配对是完全没有用的，我们完全可以假装我们匹配过了，然后直接把点的所有非父亲边弹出，并根据数量决定需不需要父亲边。</p>
<p>还是写复杂了。</p>
</div></details>
<h1 id="C-Skolem-XOR-Tree"><a href="#C-Skolem-XOR-Tree" class="headerlink" title="C. Skolem XOR Tree"></a>C. Skolem XOR Tree</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc035/tasks/agc035_c">https://atcoder.jp/contests/agc035/tasks/agc035_c</a></p>
<p>题目大意：给你 $2n$ 个点，$i,i+n$ 的权值都是 $n$ ，要求你构造一棵树，满足 $i,i+n$ 路径（包括端点）的异或和为 $i$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>不懂，感觉现在不会构造题啊，比赛时被这道题卡了一路。</p>
<p>首先注意到一个事情：$n=2^n$ 无解。</p>
<p>剩下的情况，如果 $n$ 是奇数的话，我们注意到可以：</p>
<p>$1$ 放中间，然后 $2k,2k+1$ 这样子放：$2k, 2k+1, 1, 2k, 2k+1$ 。</p>
<p>而 $1$ 的匹配可以随便找一个 $2k,2k+1$ 放在其屁股后面。</p>
<p>如果 $n$ 是偶数，那么假设 $n = k + t$ ，其中 $k,t$ 的或为 $0$ ，那么可以通过走 $k,k+1$ 和 $t,t+1$ 的路来跑出 $n$ 的路。</p>
<p><img src="1.png" alt=""></p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">lowbit</span>(n) == n)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i += <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">print</span>(i - <span class="number">1</span>, i);</span><br><span class="line">        <span class="built_in">print</span>(i, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">1</span>, i - <span class="number">1</span> + n);</span><br><span class="line">        <span class="built_in">print</span>(i - <span class="number">1</span> + n, i + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(n + <span class="number">1</span>, n + <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">lowbit</span>(n);</span><br><span class="line">        <span class="type">int</span> y = n ^ x;</span><br><span class="line">        <span class="built_in">print</span>(n, x + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">print</span>(n + n, y + n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="D-Add-and-Remove"><a href="#D-Add-and-Remove" class="headerlink" title="D. Add and Remove"></a>D. Add and Remove</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc035/tasks/agc035_d">https://atcoder.jp/contests/agc035/tasks/agc035_d</a></p>
<p>题目大意：给你 $n$ 个数字，每次可以选择相邻的三个数字，把中间的数字删掉并且加到旁边两个数字，问最后剩下的两个数字之和的最小值。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>一种很新的状压 $dp$ 。</p>
<p>首先不大可能同时考虑整个序列，毕竟被删的位置没法决定当前的状态，和删除的顺序也有关，因此逐个位置考虑。</p>
<p>发现一个事情，一个数字删除后在的位置一定是相邻的两个格子，而其对最终答案的贡献取决于其这两个格子左右删除的顺序。</p>
<p>因此我们可以设一个 $dp[state]$ ，$state$ 表示当前这个数字对应的删除顺序。</p>
<p>然后直接转移就行了。</p>
<p>时间复杂度：$O(n2^n)$ 。</p>
<p>感觉这个状压 $dp$ 非常的有意思。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B = <span class="number">16</span>;</span><br><span class="line">LL dp[<span class="number">2</span>][(<span class="number">1</span> &lt;&lt; B)];</span><br><span class="line">LL cnt[(<span class="number">1</span> &lt;&lt; B)], a[B + <span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gethighbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> <span class="number">31</span> - __builtin_clz(x);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getbit</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> (x &gt;&gt; y) &amp; <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">changebit</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> k)</span></span>&#123;<span class="keyword">return</span> x ^ ((<span class="built_in">getbit</span>(x, y) ^ k) &lt;&lt; y);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt[<span class="number">1</span>] = <span class="number">2ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt; (<span class="number">1</span> &lt;&lt; i); x++)&#123;</span><br><span class="line">            <span class="type">int</span> tmp = x;</span><br><span class="line">            LL lc = <span class="number">1ll</span>, rc = <span class="number">1ll</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="type">int</span> now = tmp &amp; <span class="number">1</span>;</span><br><span class="line">                tmp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(!now) rc = rc + lc;</span><br><span class="line">                <span class="keyword">else</span> lc = lc + rc;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[<span class="built_in">changebit</span>(x, i, <span class="number">1</span>)] = lc + rc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    n -= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; a[<span class="number">0</span>] + a[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>, pre = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp[now], <span class="number">20</span>, <span class="built_in">sizeof</span>(dp[now]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dp[now][(<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span>] = a[<span class="number">0</span>] + a[n + <span class="number">1</span>] + cnt[(<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span>] * a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        now ^= <span class="number">1</span>; pre ^= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(dp[now], <span class="number">20</span>, <span class="built_in">sizeof</span>(dp[now]));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> state = <span class="number">1</span>; state &lt; (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>)); state++)&#123;</span><br><span class="line">            <span class="type">int</span> nexstate = state &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            dp[now][nexstate] = <span class="built_in">min</span>(dp[now][nexstate], dp[pre][state]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> state = <span class="number">1</span>; state &lt; (<span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>)); state++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(__builtin_popcount(state) &gt; (n - i)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> nexstate = (state &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>;</span><br><span class="line">            dp[now][nexstate] = <span class="built_in">min</span>(dp[now][nexstate], dp[now][state]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> state = <span class="number">1</span>; state &lt; (<span class="number">1</span> &lt;&lt; n); state++)&#123;</span><br><span class="line">            <span class="type">int</span> next1 = <span class="built_in">lowbit</span>(state);</span><br><span class="line">            <span class="keyword">if</span>(next1 != state)&#123;</span><br><span class="line">                next1 = __lg(next1);</span><br><span class="line">                <span class="type">int</span> nexstate = (state &gt;&gt; (next1 + <span class="number">1</span>));</span><br><span class="line">                dp[now][nexstate] = <span class="built_in">min</span>(dp[now][nexstate], dp[pre][state]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> state = <span class="number">1</span>; state &lt; (<span class="number">1</span> &lt;&lt; n); state++)&#123;</span><br><span class="line">            dp[now][state] += a[i] * cnt[state];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = dp[now][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(__builtin_popcount(i) == <span class="number">1</span>) ans = <span class="built_in">min</span>(ans, dp[now][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这个做法又可以优化的空间吗？</p>
<p>我们来精细计算一下：</p>
<p>对于一个 $k$ 位的状态，其有效的区间是 $n-k$ 。</p>
<p>因此实际上有效的状态为：$\sum\limits_{i=0}^n 2^{i}(n-i)=\sum\limits_{i=0}^{n-1}\sum\limits_{j=0}^i2^{j}=\sum\limits_{i=0}^{n-1}2^{i+1}-1=2^{n+1}-(n+2)$ 。</p>
<p>所以如果在 $dp$ 的时候只考虑有效状态的话，实际上是 $O(2^n)$ 的。</p>
<p>能够实现出来吗？$cnt$ 的计算使用位运算技巧可以做到 $2^n$ ，而 $dp$ 如果使用 vector 提前把所有可行状态存下来，也同样可以做到 $O(状态数)$，也就是 $O(2^n)$ 。</p>
<p>因此，上述 $dp$ 完全可以做到 $O(2^n)$ 的空间和时间，但是会比较难写。</p>
<p>对此我的评价是，完全不如正解。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">正解</summary><div class="toggle-content"><p>有一种形式的 $dp$ 非常的好写，相较于其余的 $dp$ 。</p>
<p>就是记忆化形式的 $dp$ ，甚至有的时候可以去掉记忆化，那样就更好写了。</p>
<p>首先把 $a_1,a_n$ 给删掉，然后在数组两边放上两个变量 $L,R$ ，这样就变成了每次删除一个数字，然后把这个数字给放到两边，这样删完这个数组后得到的答案就是 $L+R$ 。</p>
<p>因此，倒着考虑每个区间最后被删除的数字是啥，我们就可以得到如下的 dp ：</p>
<p>$dp[l][r][cl][cr]$ 表示 $[l,r]$ 区间中的数字删完后，贡献为 $L<em>cl+R</em>cr$ 后的贡献最小值。</p>
<p>然后 $dp[l][r][cl][cr]=\min\limits_{l\le i\le r}(dp[l][i-1][cl][cl+cr]+dp[i+1][r][cl+cr][cr]+(cl+cr)*a[i])$ 。</p>
<p>然后用这个式子 $dp$ 就行了。</p>
<p>最后答案就是 $dp[1][n][1][1]+a[1]+a[n]$ 。</p>
<p>那么状态是多少呢？注意到这个的状态数计算和我的做法一样，都是 $\sum\limits_{i=0}^{n}2^{i}(n-i)$ ，也就是 $O(2^n)$ 。</p>
<p>而合法的转移数是 $\sum\limits_{i=0}^{n}2^{i}(n-i)^2$ ，也是 $O(2^n)$ 的.</p>
<p>注：$\sum\limits_{i=0}^{n}2^{i}(n-i)^k$ 都是 $O(2^n)$ 的。</p>
<p>因此如果使用记忆化的话时间复杂度为：$O(2^n*T)$ ，$T$ 为使用的数据结构的储存时间。</p>
<p>但是使用数据结构储存还是麻烦了，如果使用 map 还得自己写个四元组作为键。（貌似也可以使用 array<int,4>）</p>
<p>因此不妨考虑不记忆化，那么不记忆化的复杂度是多少呢？</p>
<p>设 $T(n)$ 表示一个长度为 $r-l+1=n$ 的递归复杂度，那么 $T(n)$ 满足：</p>
<p>$T(n)=\sum\limits_{i=0}^{n-1}2T(i)$</p>
<p>那么可以得到 $T(n)=3T(n-1)$ ，从而知道复杂度就是 $O(3^n)$ 。</p>
<p>这样代码就好写很多了。</p>
<p>这里粘一份别人的代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[<span class="number">25</span>];</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> xl,<span class="type">int</span> xr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(r-l&lt;=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="type">long</span> <span class="type">long</span> ans=<span class="number">1e18</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=l+<span class="number">1</span>;i&lt;=r<span class="number">-1</span>;i++)</span><br><span class="line">  ans=<span class="built_in">min</span>(ans,<span class="built_in">dfs</span>(l,i,xl,xl+xr)+<span class="built_in">dfs</span>(i,r,xl+xr,xr)+a[i]*(xl+xr));</span><br><span class="line"> <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> n;</span><br><span class="line"> cin&gt;&gt;n;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  cin&gt;&gt;a[i];</span><br><span class="line"> cout&lt;&lt;a[<span class="number">1</span>]+a[n]+<span class="built_in">dfs</span>(<span class="number">1</span>,n,<span class="number">1</span>,<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代码来源：https://www.luogu.com.cn/article/nuav36aw</span></span><br><span class="line"><span class="comment">//代码作者：StudyingFather</span></span><br></pre></td></tr></table></figure>
<p>怎么能想出这么好写的做法？</p>
<p>我不知道，我没想出来。</p>
<p>不过我觉得答案应该是：积累。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>ACM备忘录</title>
    <url>/2025/02/04/ACM%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    <content><![CDATA[<h1 id="NTT-模数表"><a href="#NTT-模数表" class="headerlink" title="NTT 模数表"></a>NTT 模数表</h1><p>$g$ 是 $\mod{r<em>2^k+1}$ 的原根 ，$p=r</em>2^k+1.$</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th>$r$</th>
<th>$k$</th>
<th>$g$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$3$</td>
<td>$1$</td>
<td>$1$</td>
<td>$2$</td>
</tr>
<tr>
<td style="text-align:center">$5$</td>
<td>$1$</td>
<td>$2$</td>
<td>$2$</td>
</tr>
<tr>
<td style="text-align:center">$17$</td>
<td>$1$</td>
<td>$4$</td>
<td>$3$</td>
</tr>
<tr>
<td style="text-align:center">$97$</td>
<td>$3$</td>
<td>$5$</td>
<td>$5$</td>
</tr>
<tr>
<td style="text-align:center">$193$</td>
<td>$3$</td>
<td>$6$</td>
<td>$5$</td>
</tr>
<tr>
<td style="text-align:center">$257$</td>
<td>$1$</td>
<td>$8$</td>
<td>$3$</td>
</tr>
<tr>
<td style="text-align:center">$7681$</td>
<td>$15$</td>
<td>$9$</td>
<td>$17$</td>
</tr>
<tr>
<td style="text-align:center">$12289$</td>
<td>$3$</td>
<td>$12$</td>
<td>$11$</td>
</tr>
<tr>
<td style="text-align:center">$40961$</td>
<td>$5$</td>
<td>$13$</td>
<td>$3$</td>
</tr>
<tr>
<td style="text-align:center">$65537$</td>
<td>$1$</td>
<td>$16$</td>
<td>$3$</td>
</tr>
<tr>
<td style="text-align:center">$786433$</td>
<td>$3$</td>
<td>$18$</td>
<td>$10$</td>
</tr>
<tr>
<td style="text-align:center">$5767169$</td>
<td>$11$</td>
<td>$19$</td>
<td>$3$</td>
</tr>
<tr>
<td style="text-align:center">$7340033$</td>
<td>$7$</td>
<td>$20$</td>
<td>$3$</td>
</tr>
<tr>
<td style="text-align:center">$23068673$</td>
<td>$11$</td>
<td>$21$</td>
<td>$3$</td>
</tr>
<tr>
<td style="text-align:center">$104857601$</td>
<td>$25$</td>
<td>$22$</td>
<td>$3$</td>
</tr>
<tr>
<td style="text-align:center">$167772161$</td>
<td>$5$</td>
<td>$25$</td>
<td>$3$</td>
</tr>
<tr>
<td style="text-align:center">$469762049$</td>
<td>$7$</td>
<td>$26$</td>
<td>$3$</td>
</tr>
<tr>
<td style="text-align:center">$998244353$</td>
<td>$119$</td>
<td>$23$</td>
<td>$3$</td>
</tr>
<tr>
<td style="text-align:center">$1004535809$</td>
<td>$479$</td>
<td>$21$</td>
<td>$3$</td>
</tr>
<tr>
<td style="text-align:center">$2013265921$</td>
<td>$15$</td>
<td>$27$</td>
<td>$31$</td>
</tr>
<tr>
<td style="text-align:center">$2281701377$</td>
<td>$17$</td>
<td>$27$</td>
<td>$3$</td>
</tr>
<tr>
<td style="text-align:center">$3221225473$</td>
<td>$3$</td>
<td>$30$</td>
<td>$5$</td>
</tr>
<tr>
<td style="text-align:center">$75161927681$</td>
<td>$35$</td>
<td>$31$</td>
<td>$3$</td>
</tr>
<tr>
<td style="text-align:center">$77309411329$</td>
<td>$9$</td>
<td>$33$</td>
<td>$7$</td>
</tr>
<tr>
<td style="text-align:center">$206158430209$</td>
<td>$3$</td>
<td>$36$</td>
<td>$22$</td>
</tr>
<tr>
<td style="text-align:center">$2061584302081$</td>
<td>$15$</td>
<td>$37$</td>
<td>$7$</td>
</tr>
<tr>
<td style="text-align:center">$2748779069441$</td>
<td>$5$</td>
<td>$39$</td>
<td>$3$</td>
</tr>
<tr>
<td style="text-align:center">$6597069766657$</td>
<td>$3$</td>
<td>$41$</td>
<td>$5$</td>
</tr>
<tr>
<td style="text-align:center">$39582418599937$</td>
<td>$9$</td>
<td>$42$</td>
<td>$5$</td>
</tr>
<tr>
<td style="text-align:center">$79164837199873$</td>
<td>$9$</td>
<td>$43$</td>
<td>$5$</td>
</tr>
<tr>
<td style="text-align:center">$263882790666241$</td>
<td>$15$</td>
<td>$44$</td>
<td>$7$</td>
</tr>
<tr>
<td style="text-align:center">$1231453023109121$</td>
<td>$35$</td>
<td>$45$</td>
<td>$3$</td>
</tr>
<tr>
<td style="text-align:center">$1337006139375617$</td>
<td>$19$</td>
<td>$46$</td>
<td>$3$</td>
</tr>
<tr>
<td style="text-align:center">$3799912185593857$</td>
<td>$27$</td>
<td>$47$</td>
<td>$5$</td>
</tr>
<tr>
<td style="text-align:center">$4222124650659841$</td>
<td>$15$</td>
<td>$48$</td>
<td>$19$</td>
</tr>
<tr>
<td style="text-align:center">$7881299347898369$</td>
<td>$7$</td>
<td>$50$</td>
<td>$6$</td>
</tr>
<tr>
<td style="text-align:center">$31525197391593473$</td>
<td>$7$</td>
<td>$52$</td>
<td>$3$</td>
</tr>
<tr>
<td style="text-align:center">$180143985094819841$</td>
<td>$5$</td>
<td>$55$</td>
<td>$6$</td>
</tr>
<tr>
<td style="text-align:center">$1945555039024054273$</td>
<td>$27$</td>
<td>$56$</td>
<td>$5$</td>
</tr>
<tr>
<td style="text-align:center">$4179340454199820289$</td>
<td>$29$</td>
<td>$57$</td>
<td>$3$</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AGC039 赛后总结</title>
    <url>/2024/05/28/AGC039-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="A-Connection-and-Disconnection"><a href="#A-Connection-and-Disconnection" class="headerlink" title="A. Connection and Disconnection"></a>A. Connection and Disconnection</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc039/tasks/agc039_a">https://atcoder.jp/contests/agc039/tasks/agc039_a</a></p>
<p>题目大意：字符串 $S$ 放置 $K$ 次，对字符串修改最少的字符满足使相邻字符不同。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>我的做法是找到所有相同的字符构成的连续段，然后统计答案，开头和结尾特判一下就行了。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(ss) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">LL K;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st);</span><br><span class="line">    n = <span class="built_in">strlen</span>(st + <span class="number">1</span>);</span><br><span class="line">    cin &gt;&gt; K;</span><br><span class="line">    <span class="type">int</span> len0 = <span class="number">0</span>;</span><br><span class="line">    LL ans = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)&#123;</span><br><span class="line">        <span class="type">int</span> r = l;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; n &amp;&amp; st[r + <span class="number">1</span>] == st[l]) r++;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; <span class="number">1</span> &amp;&amp; r &lt; n) ans += (r - l  + <span class="number">1</span>) / <span class="number">2</span> * K;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l == <span class="number">1</span> &amp;&amp; r &lt; n)&#123;</span><br><span class="line">            len0 = r - l + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(st[<span class="number">1</span>] != st[n]) ans += (r - l + <span class="number">1</span>) / <span class="number">2</span> * K;</span><br><span class="line">            <span class="keyword">else</span> ans += (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l &gt; <span class="number">1</span> &amp;&amp; r == n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[<span class="number">1</span>] != st[n]) ans += (r - l + <span class="number">1</span>) / <span class="number">2</span> * K;</span><br><span class="line">            <span class="keyword">else</span> ans += (r - l + <span class="number">1</span>) / <span class="number">2</span> + (r - l + <span class="number">1</span> + len0) / <span class="number">2</span> * (K - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ans += n * K / <span class="number">2</span>;</span><br><span class="line">        l = r;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">其余做法</summary><div class="toggle-content"><p>看到一个很有意思的搞法：先统计 $S$ 的答案，再统计 $SS$ 的答案，两者相减得到在已经有字符串的情况下再添加字符串的贡献。</p>
<p>需要特判所有字符相同的情况。</p>
<p>这个做法感觉很牛啊。</p>
</div></details>
<h1 id="B-Graph-Partition"><a href="#B-Graph-Partition" class="headerlink" title="B. Graph Partition"></a>B. Graph Partition</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc039/tasks/agc039_b">https://atcoder.jp/contests/agc039/tasks/agc039_b</a></p>
<p>题目大意：给你一张无向图，将点分成尽可能多的部分满足任何一条边只会出现在相邻两个部分之间。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>首先注意到一个事情，这个图没有奇环是这个图有解的充要条件。（证明方法就是沿着奇数走一圈）</p>
<p>换个角度来看：题目的要求等价于相邻两个点的部分编号奇偶性不同，由这一点可以很自然的联想到二分图染色，从而知道如果二分图染色失败则无解，从而自然的想到有解的充要条件。</p>
<p>然后发现，$x\to y$ 的任何一条路径的边数都一定 $\ge |id_x-id_y|$ 。</p>
<p>我们不妨考虑从部分 $1$ 的角度来看，由于这个图是联通的，设 $h_x$ 表示 $1$ 中的点到 $x$ 的最短路，那么 $id_x\le h_x+1$ 。</p>
<p>我们不妨直接拉满，就设置一个中心 $st$ ，$id_x=h_x+1$，可以发现，在二分图上，这样子划分是一定合法的。</p>
<p>而且不难证明最优解一定长这样。</p>
<p>直接枚举 $st$ 就行了。</p>
<p>时间复杂度：$O(n^3)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(ss) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> st[N][N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y, next;</span><br><span class="line">&#125;a[N * N]; <span class="type">int</span> len, las[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;a[++len] = &#123;y, las[x]&#125;; las[x] = len;&#125;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> spos)</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(spos);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0</span>, <span class="built_in">sizeof</span>(h));</span><br><span class="line">    h[spos] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> laspos = spos;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        laspos = x;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = las[x]; k; k = a[k].next)&#123;</span><br><span class="line">            <span class="type">int</span> y = a[k].y;</span><br><span class="line">            <span class="keyword">if</span>(!h[y])&#123;</span><br><span class="line">                h[y] = h[x] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((h[y] &amp; <span class="number">1</span>) == (h[x] &amp; <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h[laspos];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">get_char_array</span>(st[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i][j] == <span class="string">&#x27;1&#x27;</span>) <span class="built_in">ins</span>(i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = <span class="built_in">max</span>(ans, <span class="built_in">bfs</span>(i));</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="C-Division-by-Two-with-Something"><a href="#C-Division-by-Two-with-Something" class="headerlink" title="C. Division by Two with Something"></a>C. Division by Two with Something</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc039/tasks/agc039_c">https://atcoder.jp/contests/agc039/tasks/agc039_c</a></p>
<p>题目大意：给 $n,X(X&lt;2^{n})$ ，求 $[0,X]$ 的权值和，权值定义为一个数字 $x$ 经过下述操作最少花几次回到自己。</p>
<p>操作：$x$ 是奇数就除二向下取整，偶数就除二后，加上 $2^{n-1}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>注意到一个事情，上面这个操作等价于把一个 $n$ 位二进制的最低位翻转放到最高位。</p>
<p>于是，所有数字都一定会在 $2n$ 次操作后回到自己。</p>
<p>注意到，如果存在 $x,y(x&lt;y)$ 都能让 $x$ 回到自己，那么 $y-x$ 也可以，因此存在一个最小的次数 $ans$ 整除所有可行的次数，且 $ans$ 的所有倍数都可行。</p>
<p>也就是答案一定是 $2n$ 的因子。</p>
<p>又注意到 $n$ 次后一定回不到自己，因此 $ans$ 是 $2n$ 的因子而不是 $n$ 的因子。</p>
<p>注意到 $\frac{ans}{2}$ 整除于 $n$ ，我们不妨以 $\frac{ans}{2}$ 审视 $S$ ，可以发现 $S$ 可以写成 $010101010…0$ 。</p>
<p>即在 $len|n$ 的条件下，$S$ 可以以 $len$ 为单位写成 $010101…0$ 等价于 $S$ 在 $2len$ 后会回到自己。</p>
<p>综上可以得到以 $len$ 为单位的 $0101…0$ 的字符串数量等于 $ans|2len$ 的字符串数量。</p>
<p>容斥一下就可以得到每个 $ans$ 对应的字符串数量了。</p>
<p>时间复杂度：$O(n\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(ss) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> st[N], t[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">(<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    LL now = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) now = (now * <span class="number">2</span> + st[i] - <span class="string">&#x27;0&#x27;</span>) % mod;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">1</span>, type = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        t[i] = ((st[pos] - <span class="string">&#x27;0&#x27;</span>) ^ type) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos == len) pos = <span class="number">1</span>, type ^= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> pos++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t[i] &lt; st[i]) <span class="keyword">return</span> (now + <span class="number">1</span>) % mod;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t[i] &gt; st[i]) <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (now + <span class="number">1</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line">LL cnt[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st);</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span> &amp;&amp; n % (i * <span class="number">2</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">            cnt[i] = (cnt[i] + <span class="built_in">solve</span>(i)) % mod;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">2</span>; k &lt;= n / i; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(n / i % k == <span class="number">0</span>) cnt[i * k] = (cnt[i * k] - cnt[i] + mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += cnt[i] * i * <span class="number">2</span>;</span><br><span class="line">            ans %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AGC036 赛后总结</title>
    <url>/2024/05/27/AGC036-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://atcoder.jp/contests/agc036/tasks">https://atcoder.jp/contests/agc036/tasks</a></p>
<h1 id="A-Triangle"><a href="#A-Triangle" class="headerlink" title="A. Triangle"></a>A. Triangle</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc036/tasks/agc036_a">https://atcoder.jp/contests/agc036/tasks/agc036_a</a></p>
<p>题目大意：要求构造一个整点三角形满足面积是 $\frac{S}{2}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>首先注意到有一边平行于坐标轴就肯定构造不出 $S$ 是素数解的情况。</p>
<p>因此考虑这么一张图：</p>
<p><img src="1.png" alt=""></p>
<p>注意到上面的三角形在面积乘 $2$ 后相比正方形会删去浅蓝色区域，于是考虑以此为基础给一组构造。</p>
<p>于是就得到下面这么一个构造：</p>
<p>给一个 $h$ ，得到宽度：$w=\left \lceil \frac{S}{h} \right \rceil$ 。</p>
<p>设 $\epsilon = hw-S$ 。</p>
<p>那么其中一个点在 $(0,\epsilon)$ ，一个点在 $(w-1,h)$ ，一个点在 $(w,0)$ 。</p>
<p>由于长宽还有范围要求，所以建议直接把 $h$ 拉到能拉到的最大，但是在比赛时我的选择是 $\left\lceil\sqrt{n}\right\rceil$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    LL l = <span class="number">1</span>, r = <span class="number">1e9</span>, mid, ans;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid * mid &gt;= n)&#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL wide = (n + ans - <span class="number">1</span>) / ans;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0ll</span>, ans * wide - n);</span><br><span class="line">    <span class="built_in">print</span>(wide - <span class="number">1</span>, ans);</span><br><span class="line">    <span class="built_in">print</span>(wide, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是麻烦了，可以不用写这个二分的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    LL ans = <span class="built_in">min</span>((LL)<span class="number">1e9</span>, n);</span><br><span class="line">    LL wide = (n + ans - <span class="number">1</span>) / ans;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">0ll</span>, ans * wide - n);</span><br><span class="line">    <span class="built_in">print</span>(wide - <span class="number">1</span>, ans);</span><br><span class="line">    <span class="built_in">print</span>(wide, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">其余做法</summary><div class="toggle-content"><p>每日一个求三角形面积小技巧。</p>
<p>对于三点 $(x_1,y_1),(x_2,y_2),(x_3,y_3)$ ，其的面积就是 $|\frac12\begin{vmatrix}x_1&amp;y_1&amp;1\\x_2&amp;y_2&amp;1\\x_3&amp;y_3&amp;1\end{vmatrix}|$ 。</p>
<p>原理就是添加一个高度 $1$ ，然后在三维用行列式算其体积。</p>
<p>当然，如果 $x_1=y_1=0$ ，可以直接在二维中利用叉积计算面积，就是：$\frac{1}{2}|x_2y_3-x_3y_2|$ 。</p>
<p>因此，在本题中，我们不妨假设 $x_2=10^9,y_2=1$ 。</p>
<p>这样就可以得到 ：$y_3=\left\lceil\frac{S}{10^9}\right\rceil$ ，然后 $y_2=x_2y_3-S$ 。</p>
<p>显然不需要担心共线问题，因此共线的话上面算出来会是 $0$ ，不是 $0$ 就说明 $(x_2,y_2),(x_3,y_3)$。 不是共线的。</p>
</div></details>
<h1 id="B-Do-Not-Duplicate"><a href="#B-Do-Not-Duplicate" class="headerlink" title="B. Do Not Duplicate"></a>B. Do Not Duplicate</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc036/tasks/agc036_b">https://atcoder.jp/contests/agc036/tasks/agc036_b</a></p>
<p>题目大意：给你一个长度为 $n$ 的数组和一个空栈，然后你可以对栈执行一个操作：</p>
<p>如果 $x$ 在栈，弹出到 $x$ 不在栈中，否则加入栈。</p>
<p>依次对数组从左到右每个元素执行此操作，重复这个过程 $K$ 次，问最后栈是啥。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>注意到一个事情，一个栈会从非空到空当且仅当栈底元素进行了操作。</p>
<p>因此当栈为空加入 $x$ 时，下一次栈为空就是 $x$ 下一次入栈的时候，因此可以在数组上维护每个位置下一个出现相同数字的位置，实现出现空栈的位置的快速转移，而这个过程对于数组中每个位置，下一次出现空栈的位置是固定的。</p>
<p>所以会有循环，直接快速计算就行了。</p>
<p>等到最后不会出现空栈时，肯定只会剩下不超过 $n$ 个元素，直接模拟就行了。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> nex[N], n, las[N], m = <span class="number">2e5</span>;</span><br><span class="line"><span class="type">int</span> a[N * <span class="number">2</span>];</span><br><span class="line">LL pre[N], K;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getpos</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> (x - <span class="number">1</span>) % n + <span class="number">1</span>;&#125;</span><br><span class="line"><span class="type">int</span> sta[N], top;</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!v[a[i]])&#123;</span><br><span class="line">            v[a[i]] = <span class="number">1</span>;</span><br><span class="line">            sta[++top] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(a[sta[top]] != a[i]) v[a[sta[top--]]] = <span class="number">0</span>;</span><br><span class="line">            v[a[sta[top--]]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= top; i++) cout &lt;&lt; a[sta[i]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        a[i + n] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x = a[i];</span><br><span class="line">        <span class="keyword">if</span>(las[x] &amp;&amp; las[x] &lt;= n) nex[las[x]] = i - las[x] + <span class="number">1</span>;</span><br><span class="line">        las[x] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fill</span>(pre + <span class="number">1</span>, pre + n + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> pos;</span><br><span class="line">    LL limit = (K - <span class="number">1</span>) * n + <span class="number">1</span>, now = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">while</span>(now &lt; limit &amp;&amp; pre[pos = <span class="built_in">getpos</span>(now)] == <span class="number">-1</span>)&#123;</span><br><span class="line">        pre[pos] = now;</span><br><span class="line">        now += nex[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(now &lt; limit)&#123; <span class="comment">//circle</span></span><br><span class="line">        LL T = now - pre[pos];</span><br><span class="line">        now += (limit - now) / T * T;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(now &lt; limit)&#123;</span><br><span class="line">        pos = <span class="built_in">getpos</span>(now);</span><br><span class="line">        now += nex[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="built_in">getpos</span>(now));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>update：注意到这个有向图不只是每个点出度为 $1$ ，入度也为 $1$ ，因此每个点都在一个环上，所以代码可以更短更好写。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> nex[N], n, las[N], m = <span class="number">2e5</span>;</span><br><span class="line"><span class="type">int</span> a[N * <span class="number">2</span>];</span><br><span class="line">LL K;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getpos</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> (x - <span class="number">1</span>) % n + <span class="number">1</span>;&#125;</span><br><span class="line"><span class="type">int</span> sta[N], top;</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!v[a[i]])&#123;</span><br><span class="line">            v[a[i]] = <span class="number">1</span>;</span><br><span class="line">            sta[++top] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(a[sta[top]] != a[i]) v[a[sta[top--]]] = <span class="number">0</span>;</span><br><span class="line">            v[a[sta[top--]]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= top; i++) cout &lt;&lt; a[sta[i]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        a[i + n] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x = a[i];</span><br><span class="line">        <span class="keyword">if</span>(las[x] &amp;&amp; las[x] &lt;= n) nex[las[x]] = i - las[x] + <span class="number">1</span>;</span><br><span class="line">        las[x] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ti = <span class="number">1ll</span>;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ti += nex[pos];</span><br><span class="line">    &#125; <span class="keyword">while</span>((pos = <span class="built_in">getpos</span>(ti)) != <span class="number">1</span>);</span><br><span class="line">    K %= (ti - <span class="number">1</span>) / n;</span><br><span class="line">    <span class="keyword">if</span>(!K) K += (ti - <span class="number">1</span>) / n;</span><br><span class="line">    ti = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">while</span>(K * n - ti &gt;= n)&#123;</span><br><span class="line">        pos = <span class="built_in">getpos</span>(ti);</span><br><span class="line">        ti += nex[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="built_in">getpos</span>(ti));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="C-GP-2"><a href="#C-GP-2" class="headerlink" title="C. GP 2"></a>C. GP 2</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc036/tasks/agc036_c">https://atcoder.jp/contests/agc036/tasks/agc036_c</a></p>
<p>题目大意：每次你可以选择两个数字进行操作，一个 $+1$ ，一个 $+2$ ，问进行 $M$ 次后有多少种不同的结果。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>很有感觉的一道题目，难在既要找条件又要计数。</p>
<p>首先注意到一个事情：最大值必须 $\le 2M$ ，但是这显然不是充要的，注意到如果有超过 $M$ 个 $1$ ，那么肯定不是可行解。</p>
<p>由此又注意到只会有和 $M$ 奇偶性相同且 $\le M$ 个数字是奇数（事实上在和为 $3M$ 时这句话可以直接换成：$\le M$ 个数字是奇数）</p>
<p>那么这是充要的吗？是的，用归纳法证明一下就行了。</p>
<p>接下来就是计数，注意到我们可以枚举奇数的个数，然后把剩下的数字两个两个分，但是这样最大值可能爆 $2M$ ，但是注意到如果最大值 $&gt;2M$ ，那么奇数个数一定 $\le M$ ，所以所有最大值 $&gt;2M$ 的分配都会被恰好记一次，直接删去即可。</p>
<p>所以答案就是：$\sum\limits_{i=0}^{min(n,M)}\binom{n}{i}\binom{\frac{3M-i}{2}+n-1}{n-1}-\sum\limits_{i=2M+1}^{3M}\binom{n}{1}\binom{3M-i+n-2}{n-2}$ 。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line">LL fc[N], nfc[N];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x] * nfc[y] % mod * nfc[x - y] % mod;&#125;</span><br><span class="line"><span class="function">LL <span class="title">xuan</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!y) <span class="keyword">return</span> <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">C</span>(x + y - <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> lim)</span></span>&#123;</span><br><span class="line">    fc[<span class="number">0</span>] = fc[<span class="number">1</span>] = nfc[<span class="number">0</span>] = nfc[<span class="number">1</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= lim; i++) nfc[i] = (mod - mod / i) * nfc[mod % i] % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= lim; i++) nfc[i] = nfc[i - <span class="number">1</span>] * nfc[i] % mod, fc[i] = fc[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">init</span>(n + m + m);</span><br><span class="line">    LL ans = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m &amp;&amp; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((i &amp; <span class="number">1</span>) != (m &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        ans += <span class="built_in">xuan</span>((m * <span class="number">3</span> - i) / <span class="number">2</span>, n) * <span class="built_in">C</span>(n, i);</span><br><span class="line">        ans %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        ans = (ans - n * <span class="built_in">xuan</span>(i, n - <span class="number">1</span>));</span><br><span class="line">        ans = (ans % mod + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>update：最后容斥那个部分，还有一个组合意义，就是如果我直接把最大值减去 $2m+1$ ，那么就变成 $m-1$ 个数字分配，因此又可以写成：$n\binom{M+n-2}{n-1}$ 。</p>
<p>再看前面容斥的那个式子，可以写成：$n\sum\limits_{i=0}^{M-1}\binom{i+n-2}{n-2}$ ，在杨辉三角形上，其对应的一条斜线，所以可以写成：$n\binom{M+n-2}{n-1}$ 。</p>
<p>注意到上面的等式为：$\frac{1}{(n-2)!}\sum\limits_{i=0}^{M-1}\frac{(i+n-2)!}{i!}=\binom{M+n-2}{n-1}$ 。</p>
<p>这启示我们连续 $n$ 个数字相乘的和可以用组合数进行快速计算。</p>
</div></details>
<h1 id="D-Negative-Cycle"><a href="#D-Negative-Cycle" class="headerlink" title="D. Negative Cycle"></a>D. Negative Cycle</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc036/tasks/agc036_d">https://atcoder.jp/contests/agc036/tasks/agc036_d</a></p>
<p>题目大意：现在有 $n-1$ 条不能删的边 ：$(i,i+1,0)$ ，同时又有 $n(n-1)$ 条边，对于 $i\to j$ ，如果 $i&lt;j$ ，边权就是 $-1$ ，反之为 $1$ ，问需要花多少代价删边后图中没有负环。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>非常有意思的一道题目，需要注意到负环和最短路之间密切的关系。</p>
<p>我们令 $d$ 数组为从 $1$ 开始跑最短路得到的数组，由于不能删的边的存在，$d$ 是非升的，显然，任何一个不存在负环的图都对应这么一个 $d$ ，我们希望在知道 $d$ 的情况下保留尽可能多的边。</p>
<p>注意到只能保留非同段的 $-1$ 和同段或者相邻段的 $1$ 。</p>
<p>因此直接设 $dp[i][j]$ 表示最后一段为 $[j+1][i]$ 的最小代价就行了。</p>
<p>时间复杂度：$O(n^3)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e2</span> + <span class="number">5</span>;</span><br><span class="line">LL dp[N][N], a[N][N], f[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function">LL <span class="title">findans</span><span class="params">(<span class="type">int</span> l1, <span class="type">int</span> r1, <span class="type">int</span> l2, <span class="type">int</span> r2)</span></span>&#123;<span class="keyword">return</span> a[r1][r2] - a[l1 - <span class="number">1</span>][r2] - a[r1][l2 - <span class="number">1</span>] + a[l1 - <span class="number">1</span>][l2 - <span class="number">1</span>];&#125;</span><br><span class="line"><span class="function">LL <span class="title">queryf</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;<span class="keyword">return</span> f[r] - f[l - <span class="number">1</span>];&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j) f[j] += a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i] += f[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) a[i][j] += a[i - <span class="number">1</span>][j] + a[i][j - <span class="number">1</span>] - a[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">30</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)&#123;<span class="comment">//j + 1 ~ i</span></span><br><span class="line">            <span class="comment">// if(i &amp;&amp; i == j) continue;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = i + <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">                dp[k][i] = <span class="built_in">min</span>(dp[k][i], </span><br><span class="line">                        dp[i][j] + (<span class="built_in">queryf</span>(i + <span class="number">1</span>, k) - <span class="built_in">findans</span>(<span class="number">1</span>, i, i + <span class="number">1</span>, k)) + <span class="built_in">findans</span>(i + <span class="number">1</span>, k, <span class="number">1</span>, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = dp[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) ans = <span class="built_in">min</span>(ans, dp[n][i]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="E-ABC-String"><a href="#E-ABC-String" class="headerlink" title="E. ABC String"></a>E. ABC String</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc036/tasks/agc036_e">https://atcoder.jp/contests/agc036/tasks/agc036_e</a></p>
<p>题目大意：给你一个只有 $A,B,C$ 的字符串，要求找到最长的一个子序列，满足相邻字符不同，而且每个字符出现次数相同。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>又是屎中屎讨论，吐了。</p>
<p>注意到可以先把原串变成相邻字符不同，毕竟相邻的相同字符无论如果只会出现一次，因此这样子变换不会影响最终答案。</p>
<p>换一下字符，满足 $A\ge B\ge C$ （出现次数）。</p>
<p>然后注意到在不管 $A$ 的情况下，剩下的 $BC$ 可以分成若干段 $BCBCB…$ ，相邻段满足首位字母相同，例如：$BCB,BC,CB$ 。</p>
<p>注意到每一段中间的 $A$ 都可以删完，所以 $A$ 个数此时的下界为段数 $-1$ ，而且显然当前 $A$ 的个数和下界中间任何一个数字都能取到。</p>
<p>我们考虑先让 $B=C$ ，为了降低 $A$ 的下界（后面会看到，$A$ 的下界比较高的话，可能会在后面产生浪费），我们希望能最小化段数，因此明智的删法就是删每一段开头结尾的 $C$ ，然后缝合两段，由于 $C&gt;B$ ，总是存在这样的 $C$ 直到只剩下一段，这个时候就只能删开头了。</p>
<p>注意到这个过程中，每次删一个 $C$ ，也可能会删一个 $A$ ，但不会影响 $A\ge B\ge C$ 的偏序关系。</p>
<p>在 $B=C$ 后，如果下界 $\le C$ ，那么我们就可以得到一个取到上界的解，就是 $3C$ ，但是如果不是，注意到此时一定会有孤立的 $B,C$ ，删一个 $B,C$ （其实只要删 $B,C$ 的时候能让段数减少就行，但是直接删孤立的 $B,C$ 是最方便的），直到下界等于 $C$ 即可。</p>
<p>但是这为什么是对的呢？ $ans=3C$ 的情况可以理解，但是 $ans&lt;3C$ 的呢？注意到另外一个限制条件：段数，显然最终答案的段数 $-1$ 必须 $\le C$ ，而删一个 $B$ 或 $C$ 只能使段数 $-1$ ，由此可以证明这种情况已经取得了最优解。</p>
<p>理论上这就做完了，但是确实不好写。</p>
<p>我的实现思路是：</p>
<p>如果我们一直在字符串上操作，那不太好操作，因此我希望直接在段信息上操作，忽略所有的 $A$ ，然后在最后再通过匹配等方式补上一个合法的填 $A$ 的方案。</p>
<p>同时注意到上面那个做法删除的 $B,C$ 位置都是非常有讲究的。</p>
<p>不妨给去掉 $A$ 后的字符串每个 $B,C$ 贴上个原来的位置标签，然后在每次要删除 $B$ 或者 $C$ 时，找到最后面的同字符，满足这两个位置间的字符都是相同的，将操作变成删除这个字符，例如：$BBBBC$ ，本来要删除第一个 $B$ ，现在变成删除第四个 $B$ 。</p>
<p>这样子操作后，我们对剩下的字符串在原串中做能匹就匹的匹配，则每个字符的匹配位置和其位置标签一致。</p>
<p>不妨设匹配完后的位置为 $x_1,x_2,x_3…$ ，那么 $(x_1,x_2)$ 区间内，肯定只由 $B$ 或者 $C$ 和 $A$ 构成，具体是 $B$ 还是 $C$ 取决于 $x_1$ 是啥，其余区间同理。</p>
<p>例如：<strong>B</strong>ABABABA<strong>C</strong> ，加粗表示匹配上的位置。</p>
<p>那么在 $ans=3C$ 的时候，每个区间里面只有 $C$ ，因此我们删除 $C$ 后导致 $A$ 碰撞而必须删除的 $A$ 的数量 $\le C$ ，因此在 $x1,x2,…$ 之间可以塞的 $A$ 的数量 $\ge C$ 。</p>
<p>同理，如果 $ans&lt;3C$ ，那么下界也就是 $A$ 的数量和 $C$ 相等，此时不需要多塞，直接将 $A$ 塞入原来的 $BC$ 串直接做匹配就可以得到结果。</p>
<p>因此这样就得到了一种相对好写的复原方案的方法。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="built_in">strlen</span>(ss));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> n, a[N], cnt[<span class="number">4</span>], id[<span class="number">4</span>], be[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> lt, rt, len;&#125; sta[N]; <span class="type">int</span> top;</span><br><span class="line">string ans, zans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// assert(false);</span></span><br><span class="line">    <span class="built_in">get_char_array</span>(st);</span><br><span class="line">    n = <span class="built_in">strlen</span>(st + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++) id[i] = i;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pre = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> now = st[i] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(now != pre) a[++tmp] = now, cnt[now]++;</span><br><span class="line">            pre = now;</span><br><span class="line">        &#125;</span><br><span class="line">        n = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(id, id + <span class="number">3</span>, [](<span class="type">int</span> x, <span class="type">int</span> y)&#123;<span class="keyword">return</span> cnt[x] &gt; cnt[y];&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++) be[id[i]] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = be[a[i]];</span><br><span class="line">    <span class="built_in">sort</span>(cnt, cnt + <span class="number">3</span>, [](<span class="type">int</span> x, <span class="type">int</span> y)&#123;<span class="keyword">return</span> x &gt; y;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= n &amp;&amp; !a[l]) l++;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">int</span> cnt0 = <span class="number">0</span>, now = a[l], r = l;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; n &amp;&amp; a[r + <span class="number">1</span>] != now)&#123;</span><br><span class="line">            r++;</span><br><span class="line">            <span class="keyword">if</span>(a[r]) now = a[r];</span><br><span class="line">            <span class="keyword">else</span> cnt0++;</span><br><span class="line">        &#125;</span><br><span class="line">        sta[++top] = &#123;a[l], now, r - l + <span class="number">1</span> - cnt0&#125;;</span><br><span class="line">        l = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= top; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!tmp || cnt[<span class="number">1</span>] == cnt[<span class="number">2</span>] || sta[i].lt == <span class="number">2</span>) sta[++tmp] = sta[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sta[tmp].rt = sta[i].rt;</span><br><span class="line">                sta[tmp].len += sta[i].len - <span class="number">1</span>;</span><br><span class="line">                cnt[<span class="number">1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt[<span class="number">1</span>] == cnt[<span class="number">2</span>] + <span class="number">1</span> &amp;&amp; sta[<span class="number">1</span>].lt == <span class="number">1</span>)&#123;</span><br><span class="line">            cnt[<span class="number">1</span>]--;</span><br><span class="line">            sta[<span class="number">1</span>].lt = <span class="number">2</span>;</span><br><span class="line">            sta[<span class="number">1</span>].len--;</span><br><span class="line">            <span class="keyword">if</span>(!sta[<span class="number">1</span>].len)&#123;</span><br><span class="line">                <span class="built_in">assert</span>(tmp == <span class="number">1</span>);</span><br><span class="line">                tmp--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(cnt[<span class="number">1</span>] == cnt[<span class="number">2</span>]);</span><br><span class="line">        top = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!top)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(top - <span class="number">1</span> &gt; cnt[<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> goal = cnt[<span class="number">1</span>] - ((top - <span class="number">1</span>) - cnt[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">assert</span>(goal &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= top; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sta[i].len == <span class="number">1</span> &amp;&amp; cnt[sta[i].lt] &gt; goal) cnt[sta[i].lt]--;</span><br><span class="line">            <span class="keyword">else</span> sta[++tmp] = sta[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(cnt[<span class="number">1</span>] == goal &amp;&amp; cnt[<span class="number">2</span>] == goal &amp;&amp; cnt[<span class="number">1</span>] == tmp - <span class="number">1</span>);</span><br><span class="line">        top = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= top; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>, now = sta[i].lt; j &lt;= sta[i].len; j++, now = <span class="number">3</span> - now) ans += now + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(i != top) ans += <span class="string">&quot;A&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[<span class="number">0</span>] = cnt[<span class="number">1</span>] - (top - <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(now &lt; ans.<span class="built_in">length</span>() &amp;&amp; a[i] == ans[now] - <span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            zans += ans[now++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!a[i] &amp;&amp; cnt[<span class="number">0</span>] &amp;&amp; (zans.<span class="built_in">empty</span>() || zans.<span class="built_in">back</span>() != <span class="string">&#x27;A&#x27;</span>) &amp;&amp; (now == ans.<span class="built_in">length</span>() || ans[now] != <span class="string">&#x27;A&#x27;</span>))&#123;</span><br><span class="line">            zans += <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            cnt[<span class="number">0</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(!cnt[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c : zans) c = id[c - <span class="string">&#x27;A&#x27;</span>] + <span class="string">&#x27;A&#x27;</span>, cnt[c - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">    <span class="built_in">assert</span>(cnt[<span class="number">0</span>] == cnt[<span class="number">1</span>] &amp;&amp; cnt[<span class="number">1</span>] == cnt[<span class="number">2</span>]);</span><br><span class="line">    cout &lt;&lt; zans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是即使相对好写，还是很难写，考场上我是肯定写不出来的。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">正解</summary><div class="toggle-content"><p>上面的做法虽然说比较自然，但是正确性和实现都不好想。</p>
<p>不妨换个角度看待问题。</p>
<p>第一部分使 $C=B$ ，等价于如果有 $CAC$ 就删除到只剩下 $C$ 。</p>
<p>如果没有 $CAC$ ，但是 $B&gt;C$ ，那么就说明原串变成：$CBCBCB….C$ ，把开头或者结尾的 $C$ 删了就行。</p>
<p>然后对于第二部分，显然我们可以提前计算出我们需要删多少的 $B,C$ ，然后进行等量的 $BAB\to B,CAC\to C$ 的操作。</p>
<p>然后就是删 $A$ ，开头的 $A$ ，结尾的 $A$ ，以及 $BAC,CAB$ 中的 $A$ 删一下，删到 $A=C$ 为止，这样再看这个过程，是不是就清晰很多了呢？</p>
<p>虽然看起来还是很大便，但是实现上的细节少了很多，而且正确性更加容易理解了。</p>
<p>要是我在考场写这个做法，写出来的概率要比我原来的做法高得多。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AGC037 赛后总结</title>
    <url>/2024/05/28/AGC037-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://atcoder.jp/contests/agc037">https://atcoder.jp/contests/agc037</a></p>
<h1 id="A-Dividing-a-String"><a href="#A-Dividing-a-String" class="headerlink" title="A. Dividing a String"></a>A. Dividing a String</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc037/tasks/agc037_a">https://atcoder.jp/contests/agc037/tasks/agc037_a</a></p>
<p>题目大意：将字符串分成若干个部分，满足相邻两个部分不相同。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>我一开始的想法是基于贪心，有相同的字符就让后一个变成长度为 $2$ 的字符串。</p>
<p>然后如果在 $n-1$ 就直接把 $n-1,n$ 合并了。</p>
<p>但是在写博客的时候发现我当时漏考虑了一种情况：$aaaaa$ ，这种情况我的想法会分出：$a|aa|aa$ 。</p>
<p>但最终结果还是一样的，为啥？因为对于最后以个串，假设分成了：$a|aa|a|aa…|aa|aa$ ，那么一定能变成：$aa|a|aa|a…|a|aa$ 。</p>
<p>但是为什么这是最优解呢？</p>
<p>我们不妨先想一个弱化版问题，如果 $abcd$ 中 $b=c$ ，那么必须有 $ab,bc,cd$ 中的其中一个满足（$ab$ 指 $ab$ 在一个部分，其余同理）</p>
<p>这样，我们可以把原问题看成 $n-1$ 个数字，然后有一堆要求 $[l,r]$ 中必须删除一个数字的要求，而这个问题的答案显然是删除剩下区间中 $r$ 最小的区间的 $r$ 位置。</p>
<p>显然任何一个合法解都满足上述要求，而上面求出了在这个要求下需要的最小合并数，如果这个能够是解，则就是最优解。</p>
<p>然后讨论易证上面的这个最小合并数能够构造出一个合法解，然后就做完了。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="built_in">strlen</span>(ss));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st);</span><br><span class="line">    n = <span class="built_in">strlen</span>(st + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i != n &amp;&amp; st[i] == st[i + <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == n - <span class="number">1</span>)&#123;</span><br><span class="line">                cnt += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cnt += <span class="number">2</span>;</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="B-RGB-Balls"><a href="#B-RGB-Balls" class="headerlink" title="B. RGB Balls"></a>B. RGB Balls</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc037/tasks/agc037_b">https://atcoder.jp/contests/agc037/tasks/agc037_b</a></p>
<p>题目大意：给 $3N$ 个球， 红蓝黄个数相同，要求你给 $N$ 个人分球，满足每个人每个颜色各一个球，最小化每个人拿到的球的下标最大值减最小值之和。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>我们可以这么想这个过程（用 $A,B,C$ 代表三个颜色）。</p>
<p>我们现在有一堆 $AB,A,AC…$ 然后进来一个新的颜色，我们希望去拿它匹配。</p>
<p>就比如说进来一个 $A$ 吧，那么，如果有现成的 $BC/CB$ 一定会去匹配，因为答案可以写成：$\sum\limits_{e_i-s_i}$ （$e_i$ 表示结束时间，$s_i$ 表示开始时间）。</p>
<p>证明就是交换，无论这个 $A$ 去和其他什么乱七八糟的东西匹配，最后和 $BC/CB$ 匹配的 $A’$ 交换，都会使答案下降。</p>
<p>同理，如果没有 $BC/CB$ ，但是有 $B/C$ ，也会去匹配，而不是单开一个，证明也是交换。</p>
<p>因此做法就出来了，当前剩下的对是固定的，而且和前缀每个颜色的个数有关，例如 $A&gt;B&gt;C$ ，那么就有 $A-B$ 个 $A$ ，$B-C$ 个 $AB/BA$ 。</p>
<p>根据这个 $dp$ 计数就行了。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N * <span class="number">3</span>];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="built_in">strlen</span>(ss));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, now;</span><br><span class="line"><span class="type">char</span> st[N * <span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> cnt[B], id[B], be[B];</span><br><span class="line"><span class="type">char</span> num[<span class="number">300</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    num[<span class="string">&#x27;R&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line">    num[<span class="string">&#x27;G&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">    num[<span class="string">&#x27;B&#x27;</span>] = <span class="number">2</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st);</span><br><span class="line">    LL ans = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++) id[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">3</span>; i++)&#123;</span><br><span class="line">        now = num[st[i]];</span><br><span class="line">        <span class="built_in">sort</span>(id, id + <span class="number">3</span>, [](<span class="type">int</span> x, <span class="type">int</span> y)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[x] == cnt[y]) <span class="built_in">return</span> (x == now) &gt; (y == now);</span><br><span class="line">            <span class="keyword">return</span> cnt[x] &gt; cnt[y];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; j++) be[id[j]] = j;</span><br><span class="line">        <span class="keyword">if</span>(be[now] == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> ans = ans * (cnt[id[be[now] - <span class="number">1</span>]] - cnt[now]) % mod;</span><br><span class="line">        cnt[now]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = ans * i % mod;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过这个做法在 $4$ 个及以上的颜色就爆了，只能 $3$ 个。</p>
<p>原因是：$ABACC$ ，在有了 $AB,A$ 后，由于 $ABC$ 不是成品，所以 $CC$ 可以以任意顺序匹配现有的串，导致性质失效，所以无法再用上述的方法计数。</p>
</div></details>
<h1 id="C-Numbers-on-a-Circle"><a href="#C-Numbers-on-a-Circle" class="headerlink" title="C. Numbers on a Circle"></a>C. Numbers on a Circle</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc037/tasks/agc037_c">https://atcoder.jp/contests/agc037/tasks/agc037_c</a></p>
<p>题目大意：所有数字在环上，可以进行一个操作，选择一个数字，令其加上相邻两个数字之和，所有数字为正数，问能不能使所有数字由 $a\to b$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>注意到一个事情，由于所有数字都是正数，那么 $b$ 中的局部极大值都一定是这个局部最后操作的，或者说以他为中心的相邻三个数字中最后一个操作的，因此我们可以直接尝试从 $b$ 还原到 $a$ 。</p>
<p>注意到等价于用局部最大值去模相邻两个数字之和，每次取模一定会少一半，因此次数上界为 $O(n\log{V})$ 。</p>
<p>注意到最大值一定是局部极大值，直接用堆就行了。</p>
<p>时间复杂度：$O(n\log{V}\log{n})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PLI;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">priority_queue&lt;PLI&gt; p;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">preid</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x == <span class="number">1</span> ? n : x - <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">nexid</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x == n ? <span class="number">1</span> : x + <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function">LL <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">        p.<span class="built_in">push</span>(&#123;b[i], i&#125;);</span><br><span class="line">        <span class="keyword">if</span>(b[i] &lt; a[i]) <span class="keyword">return</span> <span class="number">-1ll</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL cnt = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">while</span>(!p.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> [d, id] = p.<span class="built_in">top</span>();</span><br><span class="line">        p.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> pid = <span class="built_in">preid</span>(id);</span><br><span class="line">        <span class="type">int</span> nid = <span class="built_in">nexid</span>(id);</span><br><span class="line">        LL val = b[pid] + b[nid];</span><br><span class="line">        LL T = <span class="built_in">min</span>( (b[id] - a[id]) / val, (b[id] - <span class="built_in">max</span>(b[pid], b[nid])) / val + <span class="number">1</span>);</span><br><span class="line">        cnt += T;</span><br><span class="line">        b[id] -= T * val;</span><br><span class="line">        <span class="keyword">if</span>(b[id] &gt; a[id] &amp;&amp; b[id] &gt;= <span class="built_in">max</span>(b[pid], b[nid])) <span class="keyword">return</span> <span class="number">-1ll</span>;</span><br><span class="line">        <span class="keyword">if</span>(b[id] &gt; a[id]) p.<span class="built_in">push</span>(&#123;b[id], id&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">solve</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="D-Sorting-a-Grid"><a href="#D-Sorting-a-Grid" class="headerlink" title="D. Sorting a Grid"></a>D. Sorting a Grid</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc037/tasks/agc037_d">https://atcoder.jp/contests/agc037/tasks/agc037_d</a></p>
<p>题目大意：给一个矩形，矩形中的数字都是 $[1,nm]$ 且不同，然后有三次操作，第一次对所有行重排，第二次对所有列重排，第三次对所有行重排，给一种方案使得最后矩形变成 $1,2,3,….$ 的矩形。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>很有意思的一道题目，注意到问题可以等价于在第一步行排列的时候，让每一行的数字在每一列都有一个，即把最终矩阵中每一行的数字给同一个颜色，不同行不同颜色，然后希望在行排列后，每一列中的颜色都是不一样的。</p>
<p>这个时候有一个二分图匹配的感觉，很可惜的是，建不出能过的图。</p>
<p>那么怎么做呢？注意到在列数只有两个的时候，等价于将每一行的两个颜色连边然后找环，这启示我们是与图相关的算法。<del>那还能不是二分图匹配？</del></p>
<p>又注意到，如果一定有解的话，我们可以归纳，即先摆出一列，剩下的部分就是一个子问题，因此问题是怎么摆出一列。</p>
<p>注意到这个时候用二分图匹配就可以，至于为什么二分图匹配一定有解，可以使用 Hall 定理证明。</p>
<p>时间复杂度：$O(n^4)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; cnt[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getid</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x - <span class="number">1</span>) / m + <span class="number">1</span>;&#125;</span><br><span class="line"><span class="keyword">namespace</span> Graph&#123;</span><br><span class="line">    <span class="type">int</span> mat[N];</span><br><span class="line">    <span class="type">bool</span> e[N][N], v[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;e[x][y] = <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">findmatch</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        v[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!e[x][i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!mat[i] || (!v[mat[i]] &amp;&amp; <span class="built_in">findmatch</span>(mat[i])))&#123;</span><br><span class="line">                mat[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">            <span class="built_in">assert</span>(<span class="built_in">findmatch</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(e, <span class="number">0</span>, <span class="built_in">sizeof</span>(e));</span><br><span class="line">        <span class="built_in">memset</span>(mat, <span class="number">0</span>, <span class="built_in">sizeof</span>(mat));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Graph::ins;</span><br><span class="line"><span class="keyword">using</span> Graph::init;</span><br><span class="line"><span class="keyword">using</span> Graph::solve;</span><br><span class="line"><span class="keyword">using</span> Graph::mat;</span><br><span class="line"><span class="type">int</span> ans1[N][N], ans2[N][N];</span><br><span class="line"><span class="type">int</span> id[N];</span><br><span class="line"><span class="type">int</span> tmp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            cnt[i][<span class="built_in">getid</span>(x)].<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">1</span>; t &lt;= m; t++)&#123;</span><br><span class="line">        Graph::<span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!cnt[i][j].<span class="built_in">empty</span>()) <span class="built_in">ins</span>(j, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Graph::<span class="built_in">solve</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> col = mat[i];</span><br><span class="line">            ans1[i][t] = cnt[i][col].<span class="built_in">back</span>();</span><br><span class="line">            cnt[i][col].<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) id[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">        tmp = j;</span><br><span class="line">        <span class="built_in">sort</span>(id + <span class="number">1</span>, id + n + <span class="number">1</span>, [](<span class="type">int</span> x, <span class="type">int</span> y)&#123;<span class="keyword">return</span> <span class="built_in">getid</span>(ans1[x][tmp]) &lt; <span class="built_in">getid</span>(ans1[y][tmp]);&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans2[i][j] = ans1[id[i]][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) cout &lt;&lt; ans1[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) cout &lt;&lt; ans2[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就算用网络流时间复杂度也是：$O(n^3\sqrt{n})$ 的，但是如果用 Vizing 定理可以做到 $O(n^3)$ ，做法写在了 Vizing 定理学习笔记中了。</p>
</div></details>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc037/tasks/agc037_e">https://atcoder.jp/contests/agc037/tasks/agc037_e</a></p>
<p>题目大意：你可以对字符串进行以下操作 $K$ 次：</p>
<p>$S$ 翻转得到 $S’$ ，在 $SS’$ 中找到长度为 $n$ 的字符串替代 $S$ 。</p>
<p>问最后得到的最小字典序的字符串。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>这是题？</p>
<p>显然一个事情，设 $maxlen=SS’$ 中最长的连续最小字符。</p>
<p>那么显然最后得到的字符串的前缀一定 $\le maxlen*2^{K-1}$ ，而且等号成立当且仅当每一步中都选择最长的连续最小字符段为后缀（最后一次为前缀）.</p>
<p>可以注意到，除了第一次有多种选择，后面都只有唯一选择。</p>
<p>因此直接暴力就行了，时间复杂度：$O(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="built_in">strlen</span>(ss));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> ans[N], now[N], tmp[N];</span><br><span class="line"><span class="type">int</span> n, K;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">query</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pos &gt; n ? st[n + n - pos + <span class="number">1</span>] : st[pos];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rev</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + i &lt;= n; i++) <span class="built_in">swap</span>(s[i], s[n - i + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">char</span> *s1, <span class="type">char</span> *s2)</span></span>&#123; <span class="comment">// s1 &lt; s2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1[i] != s2[i]) <span class="keyword">return</span> s1[i] &lt; s2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(now, ans)) <span class="built_in">swap</span>(ans, now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st);</span><br><span class="line">    <span class="type">char</span> minchar = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) minchar = <span class="built_in">min</span>(minchar, st[i]);</span><br><span class="line">    <span class="type">int</span> maxlen = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[l] != minchar) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> r = l;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; n &amp;&amp; st[r + <span class="number">1</span>] == minchar) r++;</span><br><span class="line">        <span class="keyword">if</span>(r == n) maxlen = <span class="built_in">max</span>((r - l + <span class="number">1</span>) * <span class="number">2</span>, maxlen);</span><br><span class="line">        <span class="keyword">else</span> maxlen = <span class="built_in">max</span>(maxlen, r - l + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans[i] = st[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[l] != minchar) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> r = l;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; n &amp;&amp; st[r + <span class="number">1</span>] == minchar) r++;</span><br><span class="line">        <span class="keyword">if</span>((r != n &amp;&amp; (r - l + <span class="number">1</span>) == maxlen) || (r == n &amp;&amp; (r - l + <span class="number">1</span>) * <span class="number">2</span> == maxlen))&#123;</span><br><span class="line">            <span class="type">int</span> endpos = n + (n - l + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt; n; t++) tmp[n - t] = <span class="built_in">query</span>(endpos - t);</span><br><span class="line">            <span class="type">int</span> startpos = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(K &gt;= <span class="number">14</span> || maxlen * (<span class="number">1</span> &lt;&lt; (K - <span class="number">1</span>)) &gt;= n) startpos = n + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> startpos += maxlen * (<span class="number">1</span> &lt;&lt; (K - <span class="number">1</span>)) - maxlen;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt; n; t++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(t + startpos &lt;= n) now[t + <span class="number">1</span>] = tmp[t + startpos];</span><br><span class="line">                <span class="keyword">else</span> now[t + <span class="number">1</span>] = minchar;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">rev</span>(now);</span><br><span class="line">            <span class="built_in">updata</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans + <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>幽默题目。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>dp</tag>
        <tag>Hall定理</tag>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC041 赛后总结</title>
    <url>/2024/05/28/AGC041-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://atcoder.jp/contests/agc041">https://atcoder.jp/contests/agc041</a></p>
<h1 id="A-Table-Tennis-Training"><a href="#A-Table-Tennis-Training" class="headerlink" title="A. Table Tennis Training"></a>A. Table Tennis Training</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc041/tasks/agc041_a">https://atcoder.jp/contests/agc041/tasks/agc041_a</a></p>
<p>题目大意：有 $n$ 场比赛，每次比完，$i$ 的胜者去 $i-1$ ，败者去 $i+1$ ，$1$ 的胜者和 $n$ 的败者不动，问 $A$ 和 $B$ 赛场的两个人相遇需要至少多少次比赛。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>注意到，能改变奇偶性的只有 $1,n$ 赛场。</p>
<p>所以讨论一下就行了。</p>
<p>如果奇偶性相同就直接相遇，否则去一次 $1$ 或者 $n$ 改一下就行了。</p>
<p>时间复杂度：$O(1)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">LL n, A, B;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; A &gt;&gt; B;</span><br><span class="line">    <span class="keyword">if</span>((A &amp; <span class="number">1</span>) == (B &amp; <span class="number">1</span>)) cout &lt;&lt; <span class="built_in">abs</span>(A - B) / <span class="number">2</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">min</span>((A + B - <span class="number">1</span>) / <span class="number">2</span> , (n + n - A - B + <span class="number">1</span>) / <span class="number">2</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="B-Voting-Judges"><a href="#B-Voting-Judges" class="headerlink" title="B. Voting Judges"></a>B. Voting Judges</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc041/tasks/agc041_b">https://atcoder.jp/contests/agc041/tasks/agc041_b</a></p>
<p>题目大意：有 $n$ 道题目，有 $m$ 个裁判选择恰好 $V$ 个题目投票，然后每道题目基础有 $a_i$ 票，得票数最高的 $P$ 道题目会入选比赛，问每道题目有没有机会入选。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>先从大到小排序。</p>
<p>如果我们想要让 $a_{i}$ 有可能能成为前 $P$ 个，贪心来看，投给 $a_{i}$ 优先级最高，其次是前 $P-1$ 个和 $\le a_i$ 的题目，最后才是介于 $P$ 名和 $&gt;a_i$ 的题目。</p>
<p>别人加等于我减，所以可以看成对这些题目的减法，因此问题能够转换成问 $[P,i-1]$ 区间中的数字，有 $m$ 次操作能够选择若干数字 $-1$ ，问能不能全部 $\le a_i$ 。（不难证明这是充要条件）</p>
<p>然后就做完了。</p>
<p>时间复杂度：$O(n\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, a[N], P, V;</span><br><span class="line">LL sum[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; V &gt;&gt; P;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    V = n - V;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, [](<span class="type">int</span> x, <span class="type">int</span> y)&#123;<span class="keyword">return</span> x &gt; y;&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;= P) ans++;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> len = <span class="built_in">min</span>(i - P, V);</span><br><span class="line">            ans += ((sum[i - <span class="number">1</span>] - sum[P - <span class="number">1</span>] - <span class="number">1ll</span> * a[i] * (i - P)) &lt;= <span class="number">1ll</span> * len * m &amp;&amp; </span><br><span class="line">            a[P] - m &lt;= a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="C-Domino-Quality"><a href="#C-Domino-Quality" class="headerlink" title="C. Domino Quality"></a>C. Domino Quality</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc041/tasks/agc041_c">https://atcoder.jp/contests/agc041/tasks/agc041_c</a></p>
<p>题目大意：可以放一些 $1<em>2$ 的方块在矩阵里面，要求每一行每一列涉及的 $1</em>2$ 的方块数一样而且不为 $0$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>首先 $\le 2$ 是无解的。</p>
<p>$\ge 3$ 时呢？</p>
<p>一个想法是发现我们可以像矩阵那样，分成左上角和右下角，所以可以把 $n$ 写成 $n_1+n_2+…$ 的形式，只要每一部分中每行每列的涉及的方块数一样就行。</p>
<p>首先可以构造出偶数时每行每列为 $3$ 的情况：</p>
<p><img src="1.png" alt=""></p>
<p>还有 $5$ 时的情况：</p>
<p><img src="2.png" alt=""></p>
<p>$7$ 的情况：</p>
<p><img src="3.png" alt=""></p>
<p>然后就做完了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> st[N][N];</span><br><span class="line"><span class="type">char</span> ans[][<span class="number">6</span>] = &#123;<span class="string">&quot;aabbc&quot;</span> ,</span><br><span class="line">                 <span class="string">&quot;f.ggc&quot;</span> ,</span><br><span class="line">                 <span class="string">&quot;fkk.d&quot;</span> ,</span><br><span class="line">                 <span class="string">&quot;de..d&quot;</span> ,</span><br><span class="line">                 <span class="string">&quot;de.ee&quot;</span>&#125;;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">3</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;aa.\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;..b\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;..b\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">7</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a..yykk\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ayy.tt.\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;bkkp...\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;b..p..g\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;....pqg\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;....pqf\n&quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ccee..f\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) st[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n5 = n;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>) n5 -= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n5; i += <span class="number">2</span>)&#123;</span><br><span class="line">            st[i][i] = st[i + <span class="number">1</span>][i] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            st[i][i + <span class="number">1</span>] = st[i + <span class="number">1</span>][i + <span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(i != n5 - <span class="number">1</span>)&#123;</span><br><span class="line">                st[i][i + <span class="number">2</span>] = st[i][i + <span class="number">3</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">                st[i + <span class="number">1</span>][i + <span class="number">2</span>] = st[i + <span class="number">1</span>][i + <span class="number">3</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                st[i][<span class="number">1</span>] = st[i][<span class="number">2</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">                st[i + <span class="number">1</span>][<span class="number">1</span>] = st[i + <span class="number">1</span>][<span class="number">2</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) st[n5 + i + <span class="number">1</span>][n5 + j + <span class="number">1</span>] = ans[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cout &lt;&lt; st[i] + <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="D-Problem-Scores"><a href="#D-Problem-Scores" class="headerlink" title="D. Problem Scores"></a>D. Problem Scores</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc041/tasks/agc041_d">https://atcoder.jp/contests/agc041/tasks/agc041_d</a></p>
<p>题目大意：问有多少个数组满足非递降且任意 $k+1$ 个数字之和 $&gt;$ $k$ 个数字之和。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>很有感觉的一道题目，每个地方设置的刚刚好。</p>
<p>首先注意到一个事情，这个条件可以的等价的写成：$k=\left \lceil \frac{n-1}{2} \right \rceil$ ，前 $k+1$ 个数字之和要 $&gt;$ 后 $k$ 个数字之和。</p>
<p>不妨以第 $k+1$ 个数字为中心，这么写：前第 $k$ 个数字和后第 $k$ 个数字的差值 + 前第 $k-1$ 个数字和后第 $k-1$ 个数字的差值 … + 第 $k+1$ 个数字。</p>
<p>可以把整个过程想象成在 $k+1$ 这个位置左边放一个数字，右边放一个数字。</p>
<p>但是这样子想，怎么设 $dp$ 都会带上一个十分讨厌的 $\log$ ，这个 $\log$ ，于是想到一个经典问题，摆阶梯。</p>
<p>如果竖着 $dp$ ，就避不开这个 $\log$ ，但是如果横着 $dp$ ，就可以避免这个 $\log$ 。</p>
<p><img src="4.png" alt=""></p>
<p>再联系到这道题目就可以得到最终的做法：</p>
<p>dp[i][r] 表示放置了 $i$ 个数字后最右边的数字处在 $r$ 而且这 $i$ 的数字的权值和为 $0$ 。</p>
<p>然后每次会在中心的数字上面放一个左边的数字和右边的数字，然后可以把左边的数字往左边推一格，右边同理，同时，在推完后把中心位置调到使权值和恰好为 $0$ 的位置。</p>
<p>可以发现，对于任意一个个数 $\ge 3$ 的方案，只要权值和为 $0$ ，就一定不会有数字 $\le 0$ 。</p>
<p>所以不用容斥就可以计算出最终答案。</p>
<p>时间复杂度：$O(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line">LL dp[N], mod;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trans</span><span class="params">(<span class="type">int</span> cnt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + cnt &lt;= n; i++) dp[i + cnt] = (dp[i + cnt] + dp[i]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; mod;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">1</span>; t &lt;= (n - <span class="number">1</span>) / <span class="number">2</span>; t++)&#123;</span><br><span class="line">        <span class="built_in">trans</span>(t);</span><br><span class="line">        <span class="built_in">trans</span>(t + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">trans</span>(n / <span class="number">2</span>);</span><br><span class="line">    LL ans = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = (dp[i] * (n - i + <span class="number">1</span>) + ans) % mod;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="E-Balancing-Network"><a href="#E-Balancing-Network" class="headerlink" title="E. Balancing Network"></a>E. Balancing Network</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc041/tasks/agc041_e">https://atcoder.jp/contests/agc041/tasks/agc041_e</a></p>
<p>题目大意：给你 $n$ 条横着的电线，然后从左到右有若干条通道，每条通道连接两根电线，然后你需要给每条通道指定向上或者向下的方向，使其满足：</p>
<p>当 $T=1$ 时，要求任何一根电线左端出发最终能到达一根电线上。</p>
<p>当 $T=2$ 时，要求不会都到一根电线上。</p>
<p>如果不存在输出无解。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>分类讨论真的是。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">$T = 1$</summary><div class="toggle-content"><p>当你想着这个问题足够久或者手动的模拟过一会后，你会感到一种熟悉的感觉从脑袋中流淌。</p></p>
<p>没错，它就是可达性统计。</p>
<p>这个部分分神似可达性统计。</p>
<p>所以你可能会想，我能不能设 $dp[x]$ 表示前 $i$ 条边能到达 $x$ 的集合，然后当存在边 $(x,y)$ 时。</p>
<p>就更新：$dp[x]=dp[y]=dp[x]|dp[y]$ ？</p>
<p>这为什么是对的？</p>
<p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>归纳证明，我们先认为 $\exists$ 一种局面使得前 $i$ 条边过后 $dp[x]$ 中的电线都能到达 $x$ 这条电线，其中设 $E_x$ 表示与 $dp[x]$ 有关的边，即从 $dp[x]$ 回溯回去，任何和产生 $dp[x]$ 有关的边。</p></p>
<p>而 $dp[x],E_x$ 显然可以通过从 $x$ 的当前位置倒着 BFS 回去得到。</p>
<p>从而可以得到这么一个结论：无论任何局面，$dp[x]$ 外的点都不会经过 $E_x$ 中的边，也不会到达 $x$ 。</p>
<p>而在 $E_x$ 固定正确的方向后， $E_x$ 外的边满足更改方向不会影响 $dp[x]$ 中的点到达 $x$ ，换句话说，$E_x$ 外的边不会影响最终到达电线 $x$ 的集合，且该集合就等于 $dp[x]$ 。</p>
<p>然后当出现边 $(x,y)$ 时，显然 $x,y$ 外的点不受影响，关键是 $x,y$ 。</p>
<p>不妨只证明新的 $dp[x]$ 仍然满足要求。</p>
<p>构造一种新的局面：$E_x$ 的边方向照旧，$E_y\setminus E_x$ 的边方向同样照旧，其余随意。</p>
<p>首先知道 $dp[x]$ 一定能到达 $x$ ，然后是 $dp[y]\setminus dp[x]$ ，对于 $z\in dp[y]\setminus dp[x]$ ，$z$ 到 $y$ 的路径只会在 $E_y\setminus E_x$ 中，而不会有 $E_x$ ，否则 $z\in dp[x]$ ，所以 $z$ 能到达 $y$ ，然后走到 $x$ 。对于 $dp[x],dp[y]$ 之外的点，根据上面的性质，在去掉 $(x,y)$ 时，其永远到不了 $x,y$ ，加上显然也到不了，因此这种局面下到达 $x$ 的集合就是 $dp[x]\cup dp[y]$ 。</p>
<p>证毕。</p>
<p>那么为什么是最优解呢？</p>
<p>可以注意到 $dp[x]$ 可以由 $x$ 倒着 BFS 得到，因此如果 $y$ 存在一种局面可以到达 $x$ ，根据路径可逆，$x$ 一定能倒着 BFS 到 $y$ ，因此所有局面中到达 $x$ 的集合一定是 $dp[x]$ 的子集。</p>
<p>从而得到 $dp[x]$ 就是最优集合，证毕。</p>
<p>综上，该 $dp$ 正确，证毕。</p>
</div></details>
<p>然后在跑完 $dp$ 后得到谁可以是那个汇聚万物的电线，最后直接倒着 $BFS$ 回去还原一下方案就行了，时间复杂度：$O(\frac{nm}{w})$ 。</p></div></details>
<details class="toggle" ><summary class="toggle-button" style="">$T = 2$</summary><div class="toggle-content"><p>首先 $n\le 2$ 的时候一定无解。</p>
<p>当 $n&gt;2$ 时，我们考虑为什么 $n=2$ 时无解，是不是我们能够知道一开始 $(1,2)$ 是两个合法终点，但是如果存在一条边给他们两个连起来，就寄了。</p>
<p>但是如果我们能够存储两对不一样的合法终点呢？这样每次连至多终结其中一个，而另外一个手动模拟一下就知道，可以重新生成两对不一样的合法终点，然后就做完了。</p>
<p>时间复杂度：$O(n)$ 。</p>
</div></details>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, T;</span><br><span class="line"><span class="keyword">namespace</span> Solve1&#123;</span><br><span class="line">    PII e[M];</span><br><span class="line">    bitset&lt;N&gt; f[N];</span><br><span class="line">    <span class="type">char</span> st[M];</span><br><span class="line">    <span class="type">bool</span> v[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; [x, y] = e[i];</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            f[x] |= f[y];</span><br><span class="line">            f[y] |= f[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f[i].<span class="built_in">count</span>() == n)&#123;</span><br><span class="line">                ans = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!ans)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        v[ans] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = m; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">auto</span> [x, y] = e[i];</span><br><span class="line">            <span class="keyword">if</span>(!v[x] &amp;&amp; !v[y]) st[i] = <span class="string">&#x27;^&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!v[x] &amp;&amp; v[y])&#123;</span><br><span class="line">                st[i] = <span class="string">&#x27;v&#x27;</span>;</span><br><span class="line">                v[x] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(v[x] &amp;&amp; !v[y])&#123;</span><br><span class="line">                st[i] = <span class="string">&#x27;^&#x27;</span>;</span><br><span class="line">                v[y] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> st[i] = <span class="string">&#x27;v&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; st + <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Solve2&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        string type;</span><br><span class="line">    &#125;p1, p2;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x, <span class="type">const</span> node &amp;y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == y.x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x == y.y) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> node &amp;z)</span></span>&#123;<span class="keyword">return</span> (<span class="type">int</span>) (<span class="built_in">pd</span>(x, z) &gt; <span class="number">0</span>) + (<span class="type">int</span>) (<span class="built_in">pd</span>(y, z) &gt; <span class="number">0</span>);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cl</span><span class="params">(node &amp;x)</span></span>&#123;</span><br><span class="line">        node y = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">        <span class="built_in">swap</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">        p2 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="type">int</span> x, y;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            node now;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">getp</span>(x, y, p1) == <span class="number">1</span> || <span class="built_in">getp</span>(x, y, p2) == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">getp</span>(x, y, p1) == <span class="number">1</span>)&#123;</span><br><span class="line">                    ans += p1.type;</span><br><span class="line">                    now = &#123;p1.x, p1.y, <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    ans += p2.type;</span><br><span class="line">                    now = &#123;p2.x, p2.y, <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">cl</span>(p1); <span class="built_in">cl</span>(p2);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">pd</span>(x, now) == <span class="number">1</span>)&#123;</span><br><span class="line">                    p2 = &#123;x, now.y, <span class="string">&quot;^&quot;</span>&#125;;</span><br><span class="line">                    p1 = &#123;<span class="built_in">min</span>(now.y, y), <span class="built_in">max</span>(now.y, y), <span class="string">&quot;v&quot;</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">pd</span>(x, now) == <span class="number">2</span>)&#123;</span><br><span class="line">                    p1 = &#123;now.x, now.y, <span class="string">&quot;^&quot;</span>&#125;;</span><br><span class="line">                    p2 = &#123;now.x, y, <span class="string">&quot;v&quot;</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">pd</span>(y, now) == <span class="number">1</span>)&#123;</span><br><span class="line">                    p1 = &#123;x, now.y, <span class="string">&quot;^&quot;</span>&#125;;</span><br><span class="line">                    p2 = &#123;now.x, now.y, <span class="string">&quot;v&quot;</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">pd</span>(y, now) == <span class="number">2</span>)&#123;</span><br><span class="line">                    p1 = &#123;<span class="built_in">min</span>(now.x, x), <span class="built_in">max</span>(now.x, x), <span class="string">&quot;^&quot;</span>&#125;;</span><br><span class="line">                    p2 = &#123;now.x, now.y, <span class="string">&quot;v&quot;</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p1.type += <span class="string">&quot;^&quot;</span>;</span><br><span class="line">                p2.type += <span class="string">&quot;^&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += p1.type;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; T;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="number">1</span>) Solve1::<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">else</span> Solve2::<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好屎的分类讨论，能在考场写出来的人真是神仙吧。</p>
<p>update ：$T=1$ 的证明写了这么久，其实我都忽略了一个最关键的东西：$dp[x]$ 就是由 $x$ 倒着 BFS 得到的终点集合，我只需要构造出一种局面使得 $dp[x]$ 能全部到达 $x$ ，再说明一下最优性，就可以直接把问题转换成求 $x$ 倒着 BFS 能到达的集合，这样就可以很轻松的证明这个做法的正确性了，根本不用搞得那么繁琐。</p>
<p>而构造一种局面使得 $dp[x]$ 能全部到达 $x$ 是简单的，倒着考虑就行了。</p></div></details>
<details class="toggle" ><summary class="toggle-button" style="">其他题解</summary><div class="toggle-content"><ol>
<li>$T=1$ 的做法和我的做法一样，但证明比我的证明更加简单，已经更新到我的做法最后的 update 部分。</li>
<li><p>同样做复杂了，我们设 $ed_x$ 表示第 $x$ 条线最后到哪条线，设 $cnt_i$ 表示 $ed_x=i$ 的 $x$ 的个数，倒着跑，注意到每次添加 $(x,y)$ 后，定向只会导致两个 $cnt$ 加减一，因此在 $n&gt;2$ 的情况下，一定存在一种定向，使得不存在 $i$ 满足 $cnt_i=n$ 。</p>
<p>这种做法相较于我的做法没有繁杂的讨论，非常的好写。</p>
</li>
</ol>
<p>这种讨论题难就难在想出好写的做法，反正我没想出来，投降 ┗( T﹏T )┛ 。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC043 C. Giant Graph</title>
    <url>/2024/06/03/AGC043-C-Giant-Graph/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc043/tasks/agc043_c">https://atcoder.jp/contests/agc043/tasks/agc043_c</a></p>
<p>题目大意：给三张无向图 $X,Y,Z$，满足点数为 $n$ ，边数分别为 $M_1,M_2,M_3$ ，然后构造一个点数为 $N^3$ 的图，满足其中的节点 $(x,y,z)$ 。</p>
<p>且其中的边为：</p>
<p>若 $(x_1,x_2)\in E_X$ ，则 $\forall y,z:((x_1,y,z),(x_2,y,z))\in E$</p>
<p>对于 $E_Y,E_Z$ 同理。</p>
<p>然后点 $(x,y,z)$ 的权值为 $10^{18(x+y+z)}$ ，问最大权值和的独立集的最大权值和是多少。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>注意到 $10^{18(x+y+z)}=10^{18x}10^{18y}10^{18z}$ ，由于 $10^{18}$ 很大，所以可以注意到两个独立集权值的比较，可以看成是 $(x+y+z)$ 从大到小排序后比较数组字典序。</p>
<p>首先不难证明一个结论（由于和相同的点不会互相删除，所以直接用贪心的思路证明就行了）：</p>
<p>一个独立集是最优解，当且仅当所有点 $(x,y,z)$ 要么在独立集里，要么存在 $(x’,y’,z’)(x’+y’+z’\ge x+y+z)$ 在独立集里且与他有连边。</p>
<p>因此只要能构造出这样的独立集就行了。</p>
<p>在构造的过程中，我们可以发现图中同时有一些点总是同时存在。</p>
<p>什么意思呢？我们将每条边从大到小连边，然后每次将这个 DAG 中入度为 $0$ 的点作为一个集合，然后在 DAG 上删除这个集合，重复这个过程。可以发现，每个集合中的点总是同时存在不妨按照时间顺序给每个集合编号：$X_1,X_2,X_3…$ ，则 $\forall i&lt;j:\forall x\in X_j:\exists y\in X_i:y\to x$ 。</p>
<p>从而知道 $X$ 集合的至多 $O(\sqrt{m})$ 个，同理 $Y$ 集合和 $Z$ 集合也是。</p>
<p>现在可以将原来的 $X,Y,Z$ 图等价的同构成由 $\{X_i\},\{Y_i\},\{Z_i\}$ 构成的图，其中每个图都是 $i\to j(i<j)$ ，其中权值关系为：$X_i>X_j(i&lt;j)$ （从上面的构造不难看出）。</p>
<p>由于此时的点数只有 $m\sqrt{m}$ ，直接暴力枚举就行了，可以证明此时得到的解在原图上一定满足上面说的是最优解的条件，所以我们就得到了最优解。</p>
<p>时间复杂度：$O(m\sqrt{m})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span>  LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B = <span class="number">455</span>;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>, base = (LL)<span class="number">1e18</span> % mod;</span><br><span class="line">vector&lt;LL&gt; val[<span class="number">3</span>];</span><br><span class="line"><span class="type">bool</span> vis[B][B][B];</span><br><span class="line">LL f[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; out[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1ll</span>; <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i] = f[i - <span class="number">1</span>] * base % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        out[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; pos;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--) pos.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">while</span>(!pos.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">        LL now = <span class="number">0ll</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : pos)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!v[x])&#123;</span><br><span class="line">                now = (now + f[x]) % mod;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> y : out[x]) v[y] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> tmp.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        val[id].<span class="built_in">push_back</span>(now);</span><br><span class="line">        <span class="built_in">swap</span>(pos, tmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : pos) v[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) v[i] = <span class="number">0</span>, out[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">assert</span>(val[id].<span class="built_in">size</span>() &lt;= B);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">2</span>; t++) <span class="built_in">solve</span>(t);</span><br><span class="line">    LL ans = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> sum = <span class="number">0</span>; sum + <span class="number">3</span> &lt;= val[<span class="number">0</span>].<span class="built_in">size</span>() + val[<span class="number">1</span>].<span class="built_in">size</span>() + val[<span class="number">2</span>].<span class="built_in">size</span>(); sum++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= sum &amp;&amp; i &lt; val[<span class="number">0</span>].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; i + j &lt;= sum &amp;&amp; j &lt; val[<span class="number">1</span>].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="type">int</span> k = sum - i - j;</span><br><span class="line">                <span class="keyword">if</span>(k &gt;= val[<span class="number">2</span>].<span class="built_in">size</span>() || vis[i][j][k]) <span class="keyword">continue</span>;</span><br><span class="line">                ans = (ans + val[<span class="number">0</span>][i] * val[<span class="number">1</span>][j] % mod * val[<span class="number">2</span>][k]) % mod;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t = i + <span class="number">1</span>; t &lt; val[<span class="number">0</span>].<span class="built_in">size</span>(); t++) vis[t][j][k] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t = j + <span class="number">1</span>; t &lt; val[<span class="number">1</span>].<span class="built_in">size</span>(); t++) vis[i][t][k] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t = k + <span class="number">1</span>; t &lt; val[<span class="number">2</span>].<span class="built_in">size</span>(); t++) vis[i][j][t] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方做法</summary><div class="toggle-content"><p>吐槽：不是哥们，我怎么又嗯做做出来一道题目啊。</p>
<p>这道题目的正经做法是这样子的：</p>
<p>注意到最优方案一定是每次选可选的 $i+j+k$ 中最大的，我们可以对边定向，由小指向大，那么可以注意到我们能选到的点当且仅当，将这个图当成一个博弈状态图，这个点是一个必败态。</p>
<p>然后又注意到这其实是三个图的的组合游戏，所以就是异或。</p>
<p>直接求一下 SG 函数，然后不难发现，一个图中的 SG 的上限是根号的，所以直接 $O(m)$ 求一下就行了。</p>
<p>总时间复杂度：$O(n+m)$ 。</p>
<p>反思：</p>
<p>回到我的做法中，我把每个小图中的某些点归为一类，那么这个分类代表什么呢？我当时觉得这玩意可能有实际意义，但是当时我没有看出来。</p>
<p>没看出来的一个很重要的原因：我只对小图求了等价类，但是没有对大图做等价类，因此没有注意到大图的等价类就是小图等价类的组合这个性质。</p>
<p>还有一个很重要的原因：我的建图是从大指向小的。</p>
<p>只能说做题确实需要建模，这题目基本只要想出和 SG 的联系基本就做完了。但是我觉得这并不是我的问题，因为我确实想不到其和 SG 的联系。不能说没有建，只能说建不出来，不是方法问题，是实力问题。</p>
<p>就这样吧，我觉得目前来看，在我的思考过程中，方法没有问题，要真要说优化的话，只能说希望下次做类似的题能做的快一点吧，其余没啥了。</p>
<p>收获：</p>
<p>已知现在有几个有向图游戏，那么这多个游戏同时进行，既可以表示成每个游戏上你都在一个点上，然后每次移动一个点，其意义就是多个游戏同时进行，例子：多个石堆，每次只能在一个石堆上移除石子；也可以像这道题目一样，用 $(x_1,x_2,…,x_n)$ 来表示，边也像这道题目一样标，其意义为直接将这多个游戏同时进行的这场游戏视为一个整体，一个有向图游戏。</p>
<p>这道题目给我的收获就是：发现多个同时进行的有向图游戏还可以用后面那种表示，同时也加深了一下我对有向图游戏的理解。</p>
<p>我认为这是一道好题。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>SG</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-2022 ICPC Asia Pacific - Yokohama Regional 赛后小结</title>
    <url>/2024/08/08/2021-2022-ICPC-Asia-Pacific-Yokohama-Regional-%E8%B5%9B%E5%90%8E%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://qoj.ac/contest/912">https://qoj.ac/contest/912</a></p>
<p>乐了，贵队被同机房两个人差点打爆了。</p>
<p>A 听队长说公式就在题面上，他直接写了过了。</p>
<p>我看了 B ，但是当时一直在想贪心，然后没有秒掉，后面队长来了似乎秒了，和队长交流听不懂他在说啥，相信。</p>
<p>后面队长没过样例，一看，他看错题了，但是他说的很对，直接暴力就是对的，所以我直接上机过了。</p>
<p>J Imakf 会了，上机写过了。此时一个小时 18 min 。</p>
<p>然后我过了 B 后在想 G ，发现无法直接维护树的状态进行 dp ，原因是很难保证一个点不会既成为一个点的父亲，也成为这个点的儿子，在思考良久后，不得已启用了 Purfer 序列来做这个题目（不是我自大，我个人认为训了也有一些场了，什么时候的签至多用到什么样的算法我还是有点数的，一个前期计数用到 Purfer 序列推式子是我没想到的，当然，也有可能是我太菜了）</p>
<p>结果在用了 Purfer 序列十几分钟后，发现式子非常好看，然后最后发现可以额外添加一个 $0$ 号点来解决根的问题后，直接上了，一个半小时过了。</p>
<p>C 队长秒了，两个小时的时候过了。</p>
<p>D 和 Imakf 讨论，Imakf 声称和 CF 之前某个题很像，那个题我赛时过了，赛后补了，所以他直接丢给我了，我在思考到后面，发现如果用 CF 那个题目的思考过程来想会非常别扭，涉及讨论，于是尝试用区间来想，发现这样想非常简单，2 个小时 14 min AC 。</p>
<p>然后开始坐牢，Imakf 会 I，三个半小时过了这题。</p>
<p>期间和队友讨论 F 和 H ，H 我其实有想过只关心某几个串，然后随一下，但是我没有想到对的道理，也没有成形做法，所以跳过这个做法，但是其实应该和队长说一下的，说不定队长就编出正解了。</p>
<p>然后和 Imaka 讨论 F，会了一维是 $&lt;p$ 的做法，现在不会两个 $&lt;p$ 的那一段，当时我们陷入了几个问题：</p>
<ol>
<li>我们两个人都以为这一段可以是长方形，导致没有启发性的想到对称。</li>
<li>我期间独立尝试过 $(a+bi)(b+ai)$ 的对称，可惜最终算出：$2ab+(a^2+b^2)i$ 导致最后都没有做出来，直到赛后和别人讨论，恍然大悟，痛心不已，但是就算搞出来了，我能想到 FFT 求系数吗，打个大大的问号。</li>
<li>我们两个人都没想过几何意义，想想，这玩意不就是因为互为补角，所以乘出来大部分是纯虚数。</li>
</ol>
<p>所以 F 最后都没干出来，但是队长 H $O(2^{30})$ 过了，此时四个小时。</p>
<p>此时队长让我上 F 的 MTT + 多点求值 + 分治 NTT ，我拒绝了，我觉得我绝对写不出来。赛后来看，我们当时并没有好的决策，但其实 F 是有机会能想出来的，只是这个机会不属于我，自从我写出 $2ab+(a^2+b^2)i$ 开始。我只能说，如果我同意上机，只是因为我不想背锅，但其实我个人认为，这完全没有上机的道理，我完全写不出来，而且我也不会，我并不知道这玩意能不能算虚树。</p>
<p>最后遗憾离场。</p>
<p>部分题解：</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>枚举一下一等奖和二等奖，剩下的部分排个序取三等奖。</p>
<p>时间复杂度：$O(100^3*\log{100})$</p>
<h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p>首先由 Purfer 序列有公式：$\frac{(n-2)!}{(d_{1}-1)!(d_{2}-1)!…(d_{n}-1)!}$ 。</p>
<p>如果忽略掉根，那么可以得到每个节点的 $(d-1)$ 就是儿子数量。</p>
<p>但现在有个问题，这样无法保证一定有一个儿子 $&gt;$ 自己，所以考虑容斥，枚举有多少个点不满足这个要求。</p>
<p>假设枚举了一个点是不满足要求的，那考虑给这个点钦定儿子，这是可以在 dp 过程中完成的。</p>
<p>考虑钦定完后统计方案，我们会得到一个个连通块。</p>
<p>考虑某个连通块的所有叶子分别要求有 $c_1,…,c_{k}$ 个儿子，那么把这个连通块缩成一个点，然后考虑其的度数，则为 $1+\sum c_{i}$ 。</p>
<p>故缩成一个点后的 Purfer 计数贡献为 $\frac{1}{(\sum c_{i})!}$ ，但是显然给了这个连通块边还不够，还需要给每个叶子分派边，这个系数为 $\binom{\sum c_{i}}{c_{1},…,c_{k}}$ ，两者乘一下，正好是 $\frac{1}{c_{1}!…c_{k}!}$ 。</p>
<p>所以我们得到了一个方案的计数贡献就是：$\frac{(\mathrm{连通块个数-2})!}{c1!…ck!}$ 。</p>
<p>可以注意到，这个时候贡献就和连通块的具体形态没有关系了，只和叶子的度数有关，因此我们只要知道每个点是不是叶子就行了。</p>
<p>当然，还有儿子的次序问题，这个简单，枚举的过程中如果发现某个点有儿子给系数 $*2$ 就行了。</p>
<p>不过还有个问题，上面的讨论都没有讨论根节点，所有的一切在根节点的时候都会变，原因是根节点没有父节点，尤其是连通块的部分，我们需要知道父节点的连通块有多大，爆了。</p>
<p>但其实很好解决，就是来一个 $0$ 节点作为整棵树的根，和原来的根连一下就行了，而这个 $0$ 号节点不会参与任何的连通块，所以就不会出现这个问题了。</p>
<p>时间复杂度：$O(n^3)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN = <span class="number">6e2</span> + <span class="number">5</span>;</span><br><span class="line">LL nfc[N], fc[N];</span><br><span class="line">LL dp[<span class="number">2</span>][N][N];</span><br><span class="line"><span class="type">int</span> n, ll[N], rr[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(LL &amp;x, LL y)</span></span>&#123;x = (x + y % mod + mod) % mod;&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r)</span></span>&#123;<span class="keyword">return</span> l &lt;= mid &amp;&amp; mid &lt;= r;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	nfc[<span class="number">0</span>] = nfc[<span class="number">1</span>] = fc[<span class="number">0</span>] = fc[<span class="number">1</span>] = <span class="number">1ll</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) nfc[i] = (mod - mod / i) * nfc[mod % i] % mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) nfc[i] = nfc[i - <span class="number">1</span>] * nfc[i] % mod, fc[i] = fc[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		cin &gt;&gt; ll[i] &gt;&gt; rr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> now = <span class="number">1</span>, pre = <span class="number">0</span>;</span><br><span class="line">	dp[now][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1ll</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="built_in">swap</span>(now, pre);</span><br><span class="line">		<span class="built_in">memset</span>(dp[now], <span class="number">0</span>, <span class="built_in">sizeof</span>(dp[now]));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i + i &amp;&amp; j &lt;= n - <span class="number">1</span>; j++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; i; k++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(!dp[pre][j][k]) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">pd</span>(ll[i], <span class="number">0</span>, rr[i])) <span class="built_in">upd</span>(dp[now][j][k], dp[pre][j][k]);</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">pd</span>(ll[i], <span class="number">1</span>, rr[i]))&#123;</span><br><span class="line">					<span class="built_in">upd</span>(dp[now][j + <span class="number">1</span>][k], dp[pre][j][k] * <span class="number">2</span>);</span><br><span class="line">					<span class="type">int</span> res = i - <span class="number">1</span> - k;</span><br><span class="line">					<span class="built_in">upd</span>(dp[now][j + <span class="number">1</span>][k + <span class="number">1</span>], - dp[pre][j][k] * <span class="number">2</span> * res);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">pd</span>(ll[i], <span class="number">2</span>, rr[i]))&#123;</span><br><span class="line">					<span class="built_in">upd</span>(dp[now][j + <span class="number">2</span>][k], dp[pre][j][k]);</span><br><span class="line">					<span class="type">int</span> res = i - <span class="number">1</span> - k;</span><br><span class="line">					<span class="built_in">upd</span>(dp[now][j + <span class="number">2</span>][k + <span class="number">2</span>], - dp[pre][j][k] * res * (res - <span class="number">1</span>));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	LL ans = <span class="number">0ll</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) ans = (ans + dp[now][n - <span class="number">1</span>][i] * fc[n - <span class="number">1</span> - i]) % mod;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好，看完别人做法，唐完了。</p>
<p>怎么想了半个小时没想出来怎么解决既是父亲又是儿子的问题的。</p>
<p>不妨先把第二个限制丢了，考虑最传统的状态设计：$f_{i,j,k}$ ，需要 $j$ 个儿子，有 $k$ 个节点需要父亲。</p>
<p>只需要先决定当前的点是谁的儿子，那么此时合法的父亲只有 $k-1$ 个，原因是这个连通块的根不能作为其父亲。</p>
<p>而第二个限制只需要从大到小做就可以解决了。</p>
<p>做完了，时间复杂度：$O(n^3)$ 。</p>
<p>唐完了，怎么不会直接做的做法啊，唐完了。</p>
<p>不过我的做法还是有点可取之处的，他们这个做法是关于儿子平方的，而我的做法是关于儿子线性的，不过也就优这一点了，乐麻了。</p>
<p>代码：咕咕咕。</p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>注意到输出串你其实是知道的，所以可以设 $dp[i][j]$ 表示需要至多多少条指令，使得从前往后恰好输出长度为 $i$ 的前缀，从后往前，在输出这些指令之前，恰好输出了长度为 $j$ 的前缀。</p>
<p>然后转移就行了。</p>
<p>我一开始以为，这个做法依赖一串指令从前往后和从后往前所添加的字符个数都是唯一的，原因是这样对于一串指令而言，$i,j$ 是固定的。</p>
<p>但我后面发现这并不重要，如果对于一个指令串有多个合法的 $i,j$ ，那只需要保证每一对合法的 $i,j$ 都能考虑到这个指令串就行了。</p>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>D 首先有几个观察：</p>
<ol>
<li>一个区间中的一个点是这个树的根当且仅当其是这个点的最大值点。</li>
<li>一个点能为根的区间当且仅当这个区间经过他且是他在笛卡尔树上子树的子集。（证明可以考虑在笛卡尔树上从上往下归纳）</li>
<li>两个点能连边则这两个点在笛卡尔树上是父子关系。（反证法，在两个点连边的瞬间，考虑两点 LCA ，则一个在左子树内，一个在右子树内，则根据第二条，两者区间不相邻，矛盾）</li>
</ol>
<p>所以考虑在笛卡尔树上考虑这个问题，每个点会向祖先连边，限制有点奇怪，如果直接在树上考虑直径所有可能的形态，像 ，感觉会有点麻烦，而且不够直观。</p>
<p>首先如果这个直径是从祖先向儿子的，没有转折，则显然是根节点的子树（也就是整棵树）的最大深度。</p>
<p>现在考虑这个直径会折一下，LCA 即最浅深度的点在 $x$ ，考虑两条路径在连向 $x$ 的那个瞬间，是不是可以看成是 $x$ 子树内的两个区间向他连边，这两个区间不能相交，然后两条路径长度就是这两个区间所能构造的最大深度。</p>
<p>可以注意到，这两个区间只要不交且不包含 $x$ ，其可以在子树内任意位置，这说明我们考虑的非常的对，任意性拉满了。</p>
<p><img src="1.png" alt=""></p>
<p>但是考虑，如果有空隙，我们尝试把区间和这个空隙合并，如果更新了根，则路径变长不亏，否则就算没更新根，也是不亏（事实上整棵树在保留原有结构的情况下扩展，最大深度只会变大，不会变小，显然是不劣的，无论怎么扩展）。</p>
<p>所有可以证明，这两个区间要么是两个儿子，要么占满了其中的一个儿子。</p>
<p>所以考虑 $dp[i][0/1]$ 表示 $i$ 子树内有 $1/2$ 个区间的最大长度和，或者换句话说，将 $i$ 的子树分成 $1/2$ 个树的最大深度和。</p>
<p>然后转移一下就行了，时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> dp[N][<span class="number">2</span>], n;</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> sta[N], top;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> lc = son[x][<span class="number">0</span>], rc = son[x][<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span>(lc)&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(lc);</span><br><span class="line">		dp[x][<span class="number">0</span>] = <span class="built_in">max</span>(dp[x][<span class="number">0</span>], dp[lc][<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line">		dp[x][<span class="number">1</span>] = <span class="built_in">max</span>(dp[x][<span class="number">1</span>], dp[lc][<span class="number">0</span>]);</span><br><span class="line">		dp[x][<span class="number">1</span>] = <span class="built_in">max</span>(dp[x][<span class="number">1</span>], dp[lc][<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">		ans = <span class="built_in">max</span>(ans, dp[lc][<span class="number">1</span>] + <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(rc)&#123;</span><br><span class="line">		<span class="built_in">dfs</span>(rc);</span><br><span class="line">		dp[x][<span class="number">0</span>] = <span class="built_in">max</span>(dp[x][<span class="number">0</span>], dp[rc][<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line">		dp[x][<span class="number">1</span>] = <span class="built_in">max</span>(dp[x][<span class="number">1</span>], dp[rc][<span class="number">0</span>]);</span><br><span class="line">		dp[x][<span class="number">1</span>] = <span class="built_in">max</span>(dp[x][<span class="number">1</span>], dp[rc][<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">		ans = <span class="built_in">max</span>(ans, dp[rc][<span class="number">1</span>] + <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(lc &amp;&amp; rc)&#123;</span><br><span class="line">		dp[x][<span class="number">1</span>] = <span class="built_in">max</span>(dp[x][<span class="number">1</span>], dp[lc][<span class="number">0</span>] + dp[rc][<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line">		ans = <span class="built_in">max</span>(ans, dp[lc][<span class="number">0</span>] + dp[rc][<span class="number">0</span>] + <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(top &amp;&amp; a[i] &gt; a[sta[top]])&#123;</span><br><span class="line">			<span class="keyword">if</span>(pre) son[sta[top]][<span class="number">1</span>] = pre;</span><br><span class="line">			pre = sta[top--];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(pre) son[i][<span class="number">0</span>] = pre;</span><br><span class="line">		sta[++top] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = top - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) son[sta[i]][<span class="number">1</span>] = sta[i + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dp[i][<span class="number">1</span>] = -INF;</span><br><span class="line">	<span class="built_in">dfs</span>(sta[<span class="number">1</span>]);</span><br><span class="line">	cout &lt;&lt; <span class="built_in">max</span>(ans, dp[sta[<span class="number">1</span>]][<span class="number">0</span>]) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><p>非常牛，赛时 $2^30$ 干过去了，$2^30$ 就不介绍了，压位 + 优秀的搜，队长伟大，无需多言。</p>
<p>这里说一下正解。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>2021 Summer Petrozavodsk Camp D3 赛后总结</title>
    <url>/2025/02/04/2021-Summer-Petrozavodsk-Camp-D3-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/gym/103469">https://codeforces.com/gym/103469</a></p>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>没看，队友切了。</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>一道答辩的数据结构题。</p>
<p>核心思路是维护每次修改所可能造成的影响。</p>
<p>显然，除 $w$ 向下取整这个部分显然是通过取模然后减去余数再除的方式搞定。</p>
<p>那么就是怎么维护这个乘法的问题了。</p>
<p>每次改变一个数字，会使得一些数字的排名减一或者加一，然后就是计算 $b_i * (i^k-(i-1)^k)$ ，然后就是拆组合数，即只要我们维护了：</p>
<p>$b_i*i^j(j\le k)$ ，然后用组合数维护一下转移不就做完了吗？</p>
<p>类似求 $\sum i^k$ 的思路转移就行了。</p>
<p>时空复杂度都懒得算了，没写。</p>
<p>当然，题解写的 $w^2$ 我觉得可以 $w$ ，即他认为 $b_i$ 和 $i$ 都需要维护模 $w$ 的结果，构成一个二维数组，但是我觉得 $b_i$ 那维没有必要。</p>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>答辩题，$\frac{n^3}{w}$ 的题目 $n=4000$ ，乐。</p>
<p>不太难想，就是每次区间只可能更新一次，然后用 bitset 维护一下合并区间对其余区间的贡献就行了。</p>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>非常的 interesting ，就是每次将图分成两个部分，然后两个部分之间的边数必须是偶数条。</p>
<p>当时搞错了一个事情，以为只要是两个部分的边加起来是偶数也可以。</p>
<p>但是实际上不对，一个很简单的道理：欧拉回路的边数有可能是奇数的，减一减就知道这个说法不对了。</p>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p>非常的有意思，两次操作和固定，所以实际上我们只需要关心一个变量。</p>
<p>两次操作分别为：$2x,2x-sum$ ，这个时候题目给的总和不能被 $p$ 整除就有用了，如果我们将目标和 $x$ 都除 $sum$ ，那么就可以变成枚举 $x*2^k$ ，然后减去一些 $2$ 的次幂，直接判断 $x-goal$ 能不能被拼出来就行了。</p>
<p>时间复杂度：$q\log{p}$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fep(i,x,y) for(int i=x;i&lt;=y;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> feq(i,x,y) for(int i=x;i&gt;=y;i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">LL mod;<span class="type">int</span> n;</span><br><span class="line"><span class="function">LL <span class="title">ksm</span><span class="params">(LL x,LL y)</span></span>&#123;</span><br><span class="line">    LL ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x%mod;</span><br><span class="line">        x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> val,LL x1,LL x2)</span></span>&#123;</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,val)x1=x1*<span class="number">2</span>%mod;</span><br><span class="line">    LL fuck=(x1-x2+mod)%mod;</span><br><span class="line">    <span class="keyword">while</span>(val &amp;&amp; fuck)fuck&gt;&gt;=<span class="number">1</span>,val--;</span><br><span class="line">    <span class="keyword">return</span> !fuck;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;std.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%d&quot;</span>,&amp;mod,&amp;n);</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        LL x1,y1,x2,y2;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">        LL sum=(x1+y1)%mod;</span><br><span class="line">        <span class="keyword">if</span>((x1+y1)%mod!=(x2+y2)%mod)&#123;<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x1!=x2);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="number">0</span>;LL ni=<span class="built_in">ksm</span>(sum,mod<span class="number">-2</span>);x1=x1*ni%mod;x2=x2*ni%mod;</span><br><span class="line">            <span class="comment">// printf(&quot;%lld %lld\n&quot;,x1,x2);</span></span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">check</span>(x,x1,x2))x++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p>非常神奇的计数题。</p>
<p>实际上队友1说的话非常的正确，你的每种计数都能得到一个方程，现在就是用方程去拼出想要的方程。</p>
<p>这道题目的技巧在于灵活的应用正图和反图进行容斥，比如有些只用正图得不到的方程是可以通过在反图中的计数得到结果的。</p>
<p>计数过程需要用到 bitset 。</p>
<p>时间复杂度：$O(\frac{n^3}{w})$ 。</p>
<p><img src="1.png" alt=""></p>
<p>结果就为：$\frac{2+3}{2}-1-4$ 。</p>
<h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><p>大分类讨论题，不知道队友怎么过的。</p>
<h1 id="I"><a href="#I" class="headerlink" title="I"></a>I</h1><p>不会。</p>
<h1 id="J"><a href="#J" class="headerlink" title="J"></a>J</h1><p>简单来说，假设 $p,q$ 序列已知，那么我们能构造一种映射使得 $s$ 和矩阵一一对应。</p>
<p>对应方法如下：</p>
<p>特殊的，我们可以认为：$p_i=n-i+1$ ，那么从大到小依次放下 2n~1 ，假设我们 $p$ 放了 $x$ 个，$q$ 放了 $y$ 个，$s_{x+1}=1$ ，显然直接放在 $p$ ，否则只有当 $q_{x+1}$ 被放了数字才能且必须立即在 $p_{x+1}$ 的位置放下数字。</p>
<p>然后就做完了。</p>
<p>现在考虑怎么维护 $0$ ，多加一维不就行了？</p>
<p>显然，我们只要知道 $q$ 序列中 $0$ 的对应位置有多少个位置矩阵上下都放了数字，我们就能推出所有的情况。</p>
<p>即：$00,01,10,11$ ，知其一即可知所有。</p>
<p>然后按照对应方法转移即可。</p>
<p>时间复杂度：$O(n^3)$ 。</p>
<p>当然，实际转移是 $4$ 维的，需要维护一维 $0/1$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">官方题解</summary><div class="toggle-content"><p>我们不妨认为 $p_i=i$ ，那么一个合法的 $01$ 序列有多少呢？</p>
<p>答案是 $q$ 的上升子序列个数。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>定义一个序列的标志子序列为从第一个位置开始，每次往后跳到第一个大于自己的位置所构成的子序列，叫做标志子序列。</p></p>
<p><p>把 $1$ 对应位置的 $q$ 抽出来构成一个子序列，那么任意两个子序列中的的标志子序列不会相同。</p></p>
<p><p>简单来说，我们考虑一个标志子序列可以找到多少个序列。</p></p>
<p><p>可以发现如果 $i<j,q_i>q_j$ ，那么 $s_i=1,s_j=0$ 不能同时成立。</p></p>
<p><p>所以当我们把标志子序列的对应位置标为 $1$ 时，就会有很多位置也对应的标记为 $1$ ，而不是 $1$ 的位置观察一下可以发现，如果将其标为 $1$ ，就会改变标志子序列，所以一个标志子序列只能找到一个序列，同理，一个序列只能找到一个标志子序列。</p></p>
<p><p>但是标志子序列这样找到的 $s$ 序列一定合法吗？手操一下就发现一定可以构造出对应的矩阵，所以一定合法。</p><br>&lt;/div&gt;&lt;/details&gt;</p>
<p><p>然后做法也是类似的，从小到大考虑 $q$ 。</p></p>
<p><p>$f[i][j][k][0/1]$ 表示前 $i$ 个数字，目前进行到了 $j$ ，前面有 $k$ 个空，$0/1$ 表示强不强制让 $j$ 成为上升子序列的一部分的方案数。</p></p>
<p><p>基本 DP 都差不多。</p></p>
<p><p>那么这个做法有什么优势呢？</p></p>
<ol>
<li>更加本质，这个定理的判定脱离了矩阵的影响。</li>
<li>更加易懂。（其实更加本质的做法一般都是更加易懂的）</li>
</ol>
<p>但是我的做法可以算序列中 $1$ 的数量，他的算不了，只能说，只能判定是否合法的定理是这样子的。</p>
<p>会导致这两个做法区别的原因是方向不同：</p>
<ol>
<li>在处理如何找到一个合法的 $s$ 序列时，官方是直接去找判定 $s$ 的合法条件，从而摆脱了矩阵的影响。</li>
<li>而我则是借助矩阵，只要矩阵的填数过程是合法的（即上下离散化是 $p,q$ ），那么跑出来的 $s$ 序列也一定是合法，这样我就不需要处理合法性的问题了，但是我需要解决判重的问题，所以我构建了一个一一映射，并且在这个映射的基础上进行 DP 。</li>
</ol>
<p>但是你要说这两个做法完全没有一点联系吗？那还是有的，就是：</p>
<ol>
<li>官方做法中判断标志子序列找到的序列是否一定合法时可以用我的做法构造矩阵。</li>
<li><p>我的做法其实也可以推出更加本质的官方做法。<br>对于 $i$ 如果 $j&gt;i$ 的位置填了一个 $0$ ，且 $q_j<q_i$ ，那么 $i$ 就不能放 $0$ 了。
更加形式化的表述是：在我的做法中，$s_i=0$ 是随意的， $s_i=1$ 仅当对于 $\forall j,s_j=0$ ，满足 $q_j>q_i$。</p>
<p>那么显然，只要我放下了一个 $0$ ，前面的所有 $q$ 大于我的都必须标 $0$ ，有没有发现和前面的官方做法莫名类似？</p>
<p>所以，这个时候就可以这样干：从后往前跑一个递减序列，类似的定义，递减序列的位置必须为 $0$ ，同时其余必须标为 $0$ 的位置也标为 $0$ ，这个时候没有被标为 $0$ 的位置也不能标为   $0$ ，否则会破坏递减序列。正过来看发现也是找递增子序列，这样就得到了官方做法。</p>
<p> 但是可以发现这两个做法有点冲突，怎么一个放 $0$ ，一个放 $1$ 呢？但其实也不难理解，不过是一个从 $0$ 的角度考虑计数，一个从 $1$ 的角度考虑计数罢了，没有什么冲突的点。</p>
<p> 但是我们不妨还是来找一点事情来做，对于一个 $s$ 序列，我们找到其的标志递增序列和标志递减序列，现在证明一下一个数字不可能既强制标记为 $0$，又强制标记为 $1$ 。（其实这个事情是完全没必要的，因为对于一个合法序列，其一定存在两种标志序列，而又是因为合法，所以两种强制标记不可能同时作用在一个位置，否则与合法这个前提相矛盾。但是从序列的角度研究一下其为什么不会标记在同一个位置说不定可以发现一些新的东西。）</p>
<p> 其实也很简单：在一个合法序列中，假设 $i$ 标志递增序列 ，而 $j$ 是 标志递减序列，且 $i<j$ ，那么显然，$q_j>q_i$ （其实这里还是用到了合法序列的合法性的），则当一个数字在 $(i,j)$ 中，$<q_i$ 和 $>q_j$ 显然是不能同时满足的，然后就结束了。</p>
</li>
</ol></div></details>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 110</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fep(i,x,y) for(int i=x;i&lt;=y;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> feq(i,x,y) for(int i=x;i&gt;=y;i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line">LL dp[N][N][N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> a[N],ba[N],b[N],bb[N],f1[N],f2[N],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,n)&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);ba[a[i]]=i;&#125;</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">        <span class="keyword">if</span>(!b[i])f1[a[i]]++;</span><br><span class="line">        <span class="keyword">else</span> f2[b[i]]++;</span><br><span class="line">        bb[b[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    bb[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">feq</span>(i,n,<span class="number">1</span>)f1[i]+=f1[i+<span class="number">1</span>],f2[i]+=f2[i+<span class="number">1</span>];</span><br><span class="line">    dp[n][n][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">feq</span>(i,n,<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">feq</span>(j,n,<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">feq</span>(k,f1[i+<span class="number">1</span>],<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">feq</span>(t,<span class="number">1</span>,<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> v10=f1[i+<span class="number">1</span>]-k,v01=(n-j)-f2[j+<span class="number">1</span>]-k,v00=(n-f2[<span class="number">1</span>])-v01-v10-k;</span><br><span class="line">                    <span class="keyword">if</span>(i)&#123;</span><br><span class="line">                        <span class="type">int</span> x=ba[i];</span><br><span class="line">                        <span class="comment">// if(i==n &amp;&amp; j==n &amp;&amp; !k &amp;&amp; !t)&#123;</span></span><br><span class="line">                        <span class="comment">//     printf(&quot;%d %d\n&quot;,x,b[x]);</span></span><br><span class="line">                        <span class="comment">// &#125;</span></span><br><span class="line">                        <span class="keyword">if</span>(!b[x])&#123;</span><br><span class="line">                            <span class="comment">/*OK*/</span></span><br><span class="line">                            <span class="keyword">if</span>(v00 &amp;&amp; t==<span class="number">0</span>)dp[i<span class="number">-1</span>][j][k][<span class="number">0</span>]=(dp[i<span class="number">-1</span>][j][k][<span class="number">0</span>]+dp[i][j][k][t])%mod;</span><br><span class="line">                            <span class="keyword">if</span>(v01 &amp;&amp; t==<span class="number">0</span>)dp[i<span class="number">-1</span>][j][k+<span class="number">1</span>][<span class="number">0</span>]=(dp[i<span class="number">-1</span>][j][k+<span class="number">1</span>][<span class="number">0</span>]+dp[i][j][k][t]*v01)%mod;</span><br><span class="line">                            <span class="keyword">if</span>(j &amp;&amp; !bb[j])dp[i<span class="number">-1</span>][j<span class="number">-1</span>][k+<span class="number">1</span>][<span class="number">0</span>]=(dp[i<span class="number">-1</span>][j<span class="number">-1</span>][k+<span class="number">1</span>][<span class="number">0</span>]+dp[i][j][k][t])%mod;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="comment">/*OK*/</span></span><br><span class="line">                            <span class="keyword">if</span>(b[x]&gt;j)&#123;dp[i<span class="number">-1</span>][j][k][<span class="number">0</span>]=(dp[i<span class="number">-1</span>][j][k][<span class="number">0</span>]+dp[i][j][k][t])%mod;<span class="keyword">continue</span>;&#125;</span><br><span class="line">                            <span class="keyword">if</span>(j&gt;=b[x] &amp;&amp; t==<span class="number">0</span>)dp[i<span class="number">-1</span>][j][k][<span class="number">0</span>]=(dp[i<span class="number">-1</span>][j][k][<span class="number">0</span>]+dp[i][j][k][t])%mod;</span><br><span class="line">                            <span class="comment">// d2[i-1][j][k]=(d2[i-1][j][k]+d2[i][j][k])%mod;</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(j)&#123;</span><br><span class="line">                        <span class="comment">// if(i==n &amp;&amp; j==n &amp;&amp; !k &amp;&amp; !t)&#123;printf(&quot;%d %lld\n&quot;,bb[j],dp[i][j][k][t]);&#125;</span></span><br><span class="line">                        <span class="keyword">if</span>(!bb[j])&#123;</span><br><span class="line">                            <span class="keyword">if</span>(v00)dp[i][j<span class="number">-1</span>][k][<span class="number">1</span>]=(dp[i][j<span class="number">-1</span>][k][<span class="number">1</span>]+dp[i][j][k][t])%mod;</span><br><span class="line">                            <span class="keyword">if</span>(v10)dp[i][j<span class="number">-1</span>][k+<span class="number">1</span>][<span class="number">1</span>]=(dp[i][j<span class="number">-1</span>][k+<span class="number">1</span>][<span class="number">1</span>]+dp[i][j][k][t]*v10)%mod;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> dp[i][j<span class="number">-1</span>][k][<span class="number">1</span>]=(dp[i][j<span class="number">-1</span>][k][<span class="number">1</span>]+dp[i][j][k][t])%mod;<span class="comment">//OK</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(dp[<span class="number">0</span>][<span class="number">0</span>][n-f2[<span class="number">1</span>]][<span class="number">0</span>]+dp[<span class="number">0</span>][<span class="number">0</span>][n-f2[<span class="number">1</span>]][<span class="number">1</span>])%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>即使是调试，也是讲究技巧的，能否在最短的时间找到输出调试中的异常数据，以及查明异常数据产生的来龙去脉，以及明白出错原因，以及找到最优秀的更正方法，以及在最短的时候改掉错误，都是十分讲究方法的。</p>
<p>很多在调试的时候，往往需要去认为哪个地方是绝对正确的，防止无效查错，同时缩小查错范围，但是又要避免错误的认为绝对正确，否则就可能一万年都发现不了眼皮子底下的错误了，这就很考验一个选手的调试功力了。</p>
<p>当然，提醒一点，当你认为整个代码都是绝对正确且做法绝对正确时，那大概率就是题读错了，我已经犯过至少两次这样的错误了，刻骨铭心啊。</p>
<h1 id="K"><a href="#K" class="headerlink" title="K"></a>K</h1><p>不会，人类智慧。</p>
<h1 id="L"><a href="#L" class="headerlink" title="L"></a>L</h1><p>大性质题，悲。</p>
<p>其中的某几个性质是特别关键的，找不到这题就寄了，然后我就寄了。</p>
<p>简单来说，对于序列 $A,B$ 和相邻的两个位置，一定存在一个一对相同的字母，因为其是好的字符串。</p>
<p>这样可以发现，任意两个长度为 $2n+1$ 的字符串最长公共长度至少是 $n$ ，所以我们不能让其退化到 $n+1$ 。（实际上你继续看下面的做法就会发现，这两个结论的限制能力是多么的恐怖，可以说这道题目没发现这两个性质就是几乎做不了的。）</p>
<p>然后，接下来就需要你打表或者手模找规律了。</p>
<p>因为其实可行的串的模式就两种（这里的 $A,B,C$ 可以轮换）：</p>
<ol>
<li><p>?A?A?A?A?…</p>
<p>?A?A?A?A?…</p>
<p>模式为在第一个串中，选一个分界点，左边填 $B/C$ 的其中一个，另外一边填另一个，同时第二个字符串的 $?$ 填第一个字符串相同位置的相反字符。（如果是 $B$ 就填 $C$ ，反之亦然）</p>
</li>
<li><p>ABABABABABAB…</p>
<p>C?C?C?C?C?C?…</p>
<p>? 里面随便填 $A,B$ 。</p>
</li>
</ol>
<p>至于证明，没有详细证过，但是感觉就是归纳证明。</p>
<p>首先证明只要符合这种模式就一定可行（好证），然后证明不符合这种模式就不可行。</p>
<p>证明不可行我感觉就是归纳，反正我是手模了前 $5$ 个位置发现确实只有这两种模式符合，然后往后归纳的部分没怎么想，感觉基本就是讨论一下就证完了，但是是讨论，所以我就没细想了。</p>
<p>但是感觉是不是从前 $1$ 个位置开始直接归纳是不是也可以啊，到时候再看看吧，现在先鸽了。</p>
<p>反正做法就是这么一个做法，直接扫描一下所有的情况差不多就做完了，时空复杂度应该是 $O(n)$ 的，就是可能要扫很多情况，2333。</p>
<p>到时候看看有没有更加容易实现的方法吧，现在先鸽了，2333。</p>
<h1 id="M"><a href="#M" class="headerlink" title="M"></a>M</h1><p>啊？根号过 1e6 ？</p>
<p>逆天。</p>
<p>暴力跑，$O(n+m\sqrt{m})$ 。</p>
<p>相信奇迹。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fep(i,x,y) for(int i=x;i&lt;=y;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> feq(i,x,y) for(int i=x;i&gt;=y;i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">int</span> a[N],n,m=<span class="number">1e6</span>;</span><br><span class="line">LL ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        a[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!a[i])<span class="keyword">continue</span>;</span><br><span class="line">        LL x=i,y=x+<span class="number">1</span>,z;</span><br><span class="line">        <span class="keyword">while</span>((z=y*y-x*x)&lt;=m)ans+=(LL)a[i]*a[z],y++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><ol>
<li>亲手写一些代码。</li>
<li>补充一个关于状态转移和状态转移优化的理解。</li>
<li>把没有做的题目自己做一遍。</li>
<li>自己去看一遍官方题解并且补充一下官方题解的做法。</li>
<li>补充一下 L 题的详细证明。</li>
<li>仔细思考一下 G 题的本质，好像说是给了正图跟反图，是可以通过容斥把同色四元环给消掉，所以这道题目才做的了的，不太清楚，到时候再看看。（同机房的同学说的，但是我没有细想。）</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AGC044 C. Strange Dance</title>
    <url>/2024/04/22/AGC044-C-Strange-Dance/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc044/tasks/agc044_c">https://atcoder.jp/contests/agc044/tasks/agc044_c</a></p>
<p>题目大意：给一个大小为 $3^{n}$ 的数组，下标为 $0,1,2,…,3^n -1$ ，一开始 $a_{i}=i$，然后有两个操作：</p>
<ol>
<li>令 $a’_{j}=a_{i}$ ，其中 $j$ 是 $i$ 三进制中如果是 $2$ 变成 $1$ ，是 $1$ 变成 $2$ 后的结果。</li>
<li>令 $a$ 数组循环右移一格。</li>
</ol>
<p>问给定操作序列后的数组的逆是啥。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>不妨分层考虑：</p>
<p>对于一个 $3^{k}$ 的元件，假如我们已经知道其在操作后进来了多少个数字，出去了什么数字，以及剩下的数字的排布，显然能够类似归并一样的处理出 $3^{k+1}$ 。</p>
<p>然后就做完了。</p>
<p>时间复杂度：$O(n*|S|+3^{n})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SN = <span class="number">6e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L = <span class="number">21</span>;</span><br><span class="line"><span class="type">int</span> n, l, f3[L];</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> len;</span><br><span class="line">    len = <span class="built_in">strlen</span>(ss);</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> nex[][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> ord[][<span class="number">3</span>]= &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> be[SN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; l;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st);</span><br><span class="line">    n = <span class="built_in">strlen</span>(st + <span class="number">1</span>);</span><br><span class="line">    f3[<span class="number">0</span>] = <span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= l; i++) f3[i] = f3[i - <span class="number">1</span>] * <span class="number">3</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; in, out, res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; mov;</span><br><span class="line">    <span class="type">int</span> final_type;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> type = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i] == <span class="string">&#x27;S&#x27;</span>) type ^= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                out.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                tmp++;</span><br><span class="line">                mov.<span class="built_in">push_back</span>(type);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        final_type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= l; i++)&#123;<span class="comment">//merge</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp_out = out, tmp_res = res;</span><br><span class="line">        out.<span class="built_in">clear</span>();</span><br><span class="line">        res.<span class="built_in">clear</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; now[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; mov.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            <span class="type">int</span> type = mov[j];</span><br><span class="line">            <span class="type">int</span> o = tmp_out[j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">2</span>; t++)&#123;</span><br><span class="line">                <span class="type">int</span> ne = nex[type][t], x;</span><br><span class="line">                <span class="keyword">if</span>(o &lt; f3[i - <span class="number">1</span>]) x = t * f3[i - <span class="number">1</span>] + o;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(!t) x = o - f3[i - <span class="number">1</span>] + f3[i];</span><br><span class="line">                <span class="keyword">else</span> x = now[t][o - f3[i - <span class="number">1</span>]];</span><br><span class="line">                <span class="keyword">if</span>(ne == <span class="number">-1</span>) out.<span class="built_in">push_back</span>(x);</span><br><span class="line">                <span class="keyword">else</span> now[ne].<span class="built_in">push_back</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">2</span>; t++)&#123;</span><br><span class="line">            <span class="type">int</span> tt = ord[final_type][t];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x : tmp_res)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x &lt; f3[i - <span class="number">1</span>]) res.<span class="built_in">push_back</span>(tt * f3[i - <span class="number">1</span>] + x);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(!tt) res.<span class="built_in">push_back</span>(x - f3[i - <span class="number">1</span>] + f3[i]);</span><br><span class="line">                <span class="keyword">else</span> res.<span class="built_in">push_back</span>(now[tt][x - f3[i - <span class="number">1</span>]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : res)&#123;</span><br><span class="line">            <span class="keyword">while</span>(x &gt;= f3[l]) x = out[x - f3[l]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; f3[l]; i++) be[res[i]] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; f3[l]; i++) cout &lt;&lt; be[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">Trie 做法</summary><div class="toggle-content"><p>这都能字典树，厉害。</p>
<p>考虑将原来的数组用字典树表示。</p>
<p>首先注意到一个事情，第一个操作是全局下标变换，这在外边打个标记就行了。</p>
<p>而第二个操作全局下标 $+1$ 在传统字典树上很难实现，但是如果字典树是从低到高建的呢？那就非常简单了，处理进位的那棵子树就行了，时间复杂度：$O(n)$ 。</p>
<p>综上，时间复杂度为：$O(n*|S|+3^n)$ 。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC043 赛后总结</title>
    <url>/2024/05/30/AGC043-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://atcoder.jp/contests/agc043">https://atcoder.jp/contests/agc043</a></p>
<h1 id="A-Range-Flip-Find-Route"><a href="#A-Range-Flip-Find-Route" class="headerlink" title="A. Range Flip Find Route"></a>A. Range Flip Find Route</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc043/tasks/agc043_a">https://atcoder.jp/contests/agc043/tasks/agc043_a</a></p>
<p>题目大意：一个 01 矩阵，每次可以选择一个子矩阵翻转，问最少需要多少次操作能够存在一条 $(1,1)$ 到 $(n,m)$ 的全 $1$ 路径。（只能向右向下走）</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>对于一条固定的路径，可以变成一个序列考虑，发现每次操作最多少一段 $0$ ，因此就是找到一条路径最小化 $0$ 的段数。</p>
<p>时间复杂度：$O(nm)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *ss)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> s[N];</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="built_in">memcpy</span>(ss + <span class="number">1</span>, s, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(s) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> st[N][N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dp[N][N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">char</span> x, <span class="type">char</span> y)</span></span>&#123;<span class="keyword">return</span> x == <span class="string">&#x27;#&#x27;</span> &amp;&amp; y == <span class="string">&#x27;.&#x27;</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">get_char_array</span>(st[i]);</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = st[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> now = <span class="number">1e9</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">1</span>) now = <span class="built_in">min</span>(now, dp[i - <span class="number">1</span>][j] + <span class="built_in">pd</span>(st[i][j], st[i - <span class="number">1</span>][j]));</span><br><span class="line">            <span class="keyword">if</span>(j &gt; <span class="number">1</span>) now = <span class="built_in">min</span>(now, dp[i][j - <span class="number">1</span>] + <span class="built_in">pd</span>(st[i][j], st[i][j - <span class="number">1</span>]));</span><br><span class="line">            dp[i][j] = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][m] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和官方题解一样。</p>
</div></details>
<h1 id="B-123-Triangle"><a href="#B-123-Triangle" class="headerlink" title="B. 123 Triangle"></a>B. 123 Triangle</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc043/tasks/agc043_b">https://atcoder.jp/contests/agc043/tasks/agc043_b</a></p>
<p>题目大意：给你一个只包含 $1,2,3$ 的序列，每次操作会将这个序列相邻两个数字相减并取绝对值，得到一个长度 $-1$ 的序列，操作到只剩下一个值，问这个值是多少。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>首先答案只能是 $0,1,2$ 。</p>
<p>所以先把初始序列减 $1$ ，这样全局过程中我们都只需要考虑 $0,1,2$ 。</p>
<p>注意到 $\mod 2$ 意义下可以把 $|x-y|$ 变成 $x+y$ ，从而可以直接用组合数算出最终数字的奇偶性。</p>
<p>现在问题是怎么区分 $0/2$ ？</p>
<p>可以归纳证明，只要初始序列中有 $1$ ，最终答案就一定不可能是 $2$ 。</p>
<p>在序列有 $0/2$ 的情况下，显然后面都只有 $0/2$ ，因此在模 $4$ 意义下 $|x-y|=x+y$ ，所以类似上面组合数直接算答案就行了。</p>
<p>当然也可以把所有数字除 $2$ 然后在 $\mod 2$ 的意义下计算，没区别。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *ss)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> s[N];</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="built_in">memcpy</span>(ss + <span class="number">1</span>, s, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(s) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> n, a[N];</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;<span class="keyword">return</span> cnt[r] - cnt[l - <span class="number">1</span>];&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> (<span class="built_in">query</span>(<span class="number">1</span>, x) - <span class="built_in">query</span>(<span class="number">1</span>, y) - <span class="built_in">query</span>(<span class="number">1</span>, x - y)) ? <span class="number">0</span> : <span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cnt[i] = cnt[i - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> tmp = i;</span><br><span class="line">        <span class="keyword">while</span>(tmp % <span class="number">2</span> == <span class="number">0</span>) tmp /= <span class="number">2</span>, cnt[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        a[i] = st[i] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        ans = (a[i] * <span class="built_in">calc</span>(n - <span class="number">1</span>, i - <span class="number">1</span>) + ans) % <span class="number">2</span>;</span><br><span class="line">        cnt1 += (a[i] == <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans == <span class="number">1</span>) cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cnt1) cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            a[i] = a[i] / <span class="number">2</span>;</span><br><span class="line">            ans = (a[i] * <span class="built_in">calc</span>(n - <span class="number">1</span>, i - <span class="number">1</span>) + ans) % <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">1</span>) cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和官方题解一样，我麻烦的地方在于判断组合数的奇偶性：</p>
<p>$\binom{n}{m}\equiv [n \&amp; m = m]\mod2$</p>
<p>但比赛时不知道就没办法了，不可能花时间去想这个东西的，直接数 $2$ 的个数花不了什么时间，在比赛中肯定是选择时间更短的方案。</p>
<p>至于这是为什么，我记得组合数取模有一个专门的定理，到时候会专门出一篇博客讲解，这里不再赘述。</p>
</div></details>
<h1 id="C-Giant-Graph"><a href="#C-Giant-Graph" class="headerlink" title="C. Giant Graph"></a>C. Giant Graph</h1><p>单独开了一篇题解。</p>
<h1 id="D-Merge-Triplets"><a href="#D-Merge-Triplets" class="headerlink" title="D. Merge Triplets"></a>D. Merge Triplets</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc043/tasks/agc043_d">https://atcoder.jp/contests/agc043/tasks/agc043_d</a></p>
<p>题目大意：问有多少个 $3N$ 的合法排列，合法排列的定义是：</p>
<p>给 $N$ 个长度为 $3$ 的序列，序列中的数互不相同且都在 $[1,3N]$ 。</p>
<p> $P$ 初始为空，然后每次选择所有序列开头最小的数字，删掉，加入 $P$ 中，最后得到的 $P$ 称为合法排列。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>合法的 $P$ 有什么要求呢？</p>
<p>如果出现 $P_{i} &gt; P_{i+1}$ ，说明肯定是某个序列中连续弹出了两个数字，这启示我们可以把排列分成若干段：$[l_1,r_1],[l_2,r_2],…,[l_m,r_m]$ 。</p>
<p>满足：</p>
<ol>
<li>$\forall l_i\le j\le r_i:P_{j}\le P_{l_i}$</li>
<li>$P_{l_i} &lt; P_{l_{i+1}}$</li>
</ol>
<p>可以注意到对于每个排列 $P$ ，分法是唯一的。</p>
<p>那么可以注意到 $P$ 合法当且仅当每段长度 $\le 3$ ，而且长度 $\ge 2$ 的段数 $\le n$ 。</p>
<p>然后直接 dp 就行了。</p>
<p>时间复杂度：$O(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line">LL mod, f[N * <span class="number">3</span>][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; mod;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n * <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">1</span> &lt;= n * <span class="number">3</span>) f[i + <span class="number">1</span>][j] = (f[i + <span class="number">1</span>][j] + f[i][j]) % mod;</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">2</span> &lt;= n * <span class="number">3</span> &amp;&amp; j + <span class="number">1</span> &lt;= n) f[i + <span class="number">2</span>][j + <span class="number">1</span>] = (f[i + <span class="number">2</span>][j + <span class="number">1</span>] + f[i][j] * (i + <span class="number">1</span>)) % mod;</span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">3</span> &lt;= n * <span class="number">3</span> &amp;&amp; j + <span class="number">1</span> &lt;= n) f[i + <span class="number">3</span>][j + <span class="number">1</span>] = (f[i + <span class="number">3</span>][j + <span class="number">1</span>] + f[i][j] * (i + <span class="number">1</span>) % mod * (i + <span class="number">2</span>)) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) ans = (ans + f[n * <span class="number">3</span>][i]) % mod;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和官方题解基本一致。</p>
<p>学到一个新词汇，上面的划分方法可以用一个更加专业的说法说：按照前缀 $max$ 分段。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>SG</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC061 C. First Come First Serve</title>
    <url>/2023/08/25/AGC061-C-First-Come-First-Serve/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc061/tasks/agc061_c">https://atcoder.jp/contests/agc061/tasks/agc061_c</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然的方向：我们可以让一些选择非法，使得每个答案对应一个合法的选择。</p>
<p>准确来说，我们定义 $ff[i]$ 表示最大的 $j$ 使得 $i&lt;k\le j$ 满足 $l_k&lt;r_i$ 。</p>
<p>我们考虑每个顾客，填 $1$ 表示选择离开时候记录，$0$ 表示选择进入时记录。</p>
<p>那么一个位置填 $0$ 的条件为 $(i,ff[i]]$ 中有一个位置填 $0$ 或者存在一个位置 $k$ 填 $1$ 且 $i\in (k,ff[k]]$ 。</p>
<p>然后用 DP 维护合法方案即可。</p>
<p>一个显然的傻瓜式 DP 是：</p>
<p>$f_1[i]$ 表示 $i$ 填 $1$ 的目前合法序列个数。</p>
<p>$f_2[i]$ 表示 $i$ 填 $0$ 的可能合法序列个数。</p>
<p>$f_3[i]$ 表示 $i$ 填 $0$ ，$i-1$ 填 $1$ 的合法序列个数。</p>
<p>转移即可。</p>
<p>但是这里要讲一个优化，把 $f_3$ 优化掉，就是有一个转移是：</p>
<p>$f_2-&gt;f_3$ ，内容为往后放若干 $1$ 后放一个 $0$ ,那我们不妨先转移到 $f_1$ ，再减去没有放 $0$ 的序列（即减去不合法的序列）</p>
<p>于是：</p>
<p>$f_1[j]+=f2<a href="j\in (i,ff[i]">i</a>),f_1[j]-=(j\in (i+1,ff[i]])$</p>
<p>但是这时又产生了一个疑惑，在化简了式子后可以缩减为：</p>
<p>$f_1[i+1]+=f_2[i],f_1[ff[i]]-=f_2[i]$ 。</p>
<p>其实不难发现，所有的不合法方案在 DP 过程中都一定会经过 $f_1[ff[i]]$ 且贡献为 $1$ ，减掉即可。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 510000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">&#125;a[N];<span class="type">int</span> ff[N],n;</span><br><span class="line">LL f1[N],f2[N],f3[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i].l,&amp;a[i].r);</span><br><span class="line">    <span class="type">int</span> now=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(now&lt;n &amp;&amp; a[now+<span class="number">1</span>].l&lt;=a[i].r)now++;</span><br><span class="line">        ff[i]=now;</span><br><span class="line">    &#125;</span><br><span class="line">    LL fnow=<span class="number">0</span>;f1[<span class="number">1</span>]=f2[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        (f1[i]+=fnow)%=mod;(f2[ff[i]+<span class="number">1</span>]+=f1[i])%=mod;</span><br><span class="line">        <span class="keyword">if</span>(ff[i]&gt;i)(f2[i+<span class="number">1</span>]+=f2[i])%=mod,(f1[i+<span class="number">1</span>]+=f2[i])%=mod,(f1[ff[i]]+=mod-f2[i])%=mod;</span><br><span class="line">        (fnow+=f1[i])%=mod;(f3[ff[i]+<span class="number">1</span>]+=f1[i])%=mod;</span><br><span class="line">        (fnow+=mod-f3[i])%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=n;i++)printf(&quot;%d:%d %lld %lld\n&quot;,i,ff[i],f1[i],f2[i]);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,fnow);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC046 赛后总结</title>
    <url>/2024/06/26/AGC046-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://atcoder.jp/contests/agc046">https://atcoder.jp/contests/agc046</a></p>
<h1 id="A-Takahashikun-The-Strider"><a href="#A-Takahashikun-The-Strider" class="headerlink" title="A. Takahashikun, The Strider"></a>A. Takahashikun, The Strider</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc046/tasks/agc046_a">https://atcoder.jp/contests/agc046/tasks/agc046_a</a></p>
<p>题目大意：二维平面在原点，初始在原点，朝向南方，每次往面朝方向走一格，然后逆时针转 $X$ 度角，问经过几次后回到原点。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>为啥能这么快就做出来了？猜结论吗？</p>
<p>手动模拟一下，好像是最小的 $n$ 满足：$nX\equiv 0\mod 360$ 。</p>
<p>也就是：</p>
<script type="math/tex; mode=display">\begin{align*}
t=&\frac{2X\pi}{360}\\
&\sum\limits_{i=0}^{n-1}sin(it)\\
=&\frac{cos\frac{2n-1}{2}t-cos\frac{t}{2}}{2sin\frac{t}{2}}\\
=&0\\
\end{align*}</script><p>等价于：$(n-1)t=2k\pi$ 或者 $nt=2k\pi$ 。</p>
<p>即：$\frac{2X(n-1)\pi}{360}=2k\pi\to (n-1)X=360k$ ，或者 $\frac{2Xn\pi}{360}=2k\pi\to nX=360k$ 。</p>
<p>同理：</p>
<script type="math/tex; mode=display">\begin{align*}
&\sum\limits_{i=0}^{n-1}cos(it)\\
=&\frac{sin\frac{2n-1}{2}t+sin\frac{t}{2}}{2sin\frac{t}{2}}\\
=&0\\
\end{align*}</script><p>等价于：$nt=2k\pi\to nX=360k$ 。</p>
<p>综上，$nX=360k$ 是回到原点的充要条件，显然就是上面说的那个东西。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> !x ? y : <span class="built_in">gcd</span>(y % x, x);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="number">360</span> / <span class="built_in">gcd</span>(n, <span class="number">360</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="B-Extension"><a href="#B-Extension" class="headerlink" title="B. Extension"></a>B. Extension</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc046/tasks/agc046_b">https://atcoder.jp/contests/agc046/tasks/agc046_b</a></p>
<p>题目大意：给定一个初始为白 $A<em>B$ 的矩形，要求执行下列操作到 $C</em>D$ 的矩形，问有多少种不同的染色。</p>
<ol>
<li>在上面添加一行白色，并将这一行白色中添加任意一格黑色。</li>
<li>在右边添加一列白色，并将这一列白色中添加任意一格黑色。</li>
</ol>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>这种东西很典，就是给每种染色规定一个唯一的添加行列的顺序，然后直接 $dp$ 就行了。</p>
<p>首先肯定想着行列交换，显然在一种方案中行列能交换当且仅当后者不会在交点处涂黑，我们尽可能的让列靠前，对于所有 “ 行列 ” 无法交换的方案称为驻点。</p>
<p>问题来了，会有两个驻点方案吗？</p>
<p>不会，因为可以证明，以下构造出来的方案是驻点方案，且不是这个的方案都不是驻点方案：</p>
<p>对于任意一个染色方案，显然每一行或者每一列在生成的时候都会生成所在行或者列的第一个黑色。</p>
<p>知道每一行每一列生成的黑色是啥后，我们看当前的行数是否能生成下一列的黑色，能就生成，不能就先生成行的。</p>
<p>显然只要染色合法，就一定能生成一个方案，而且极其显然的是，一个方案能对应一个染色。</p>
<p>然后直接 $dp$ 计数就行了，时间复杂度：$O(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line">LL dp[N][N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> A, B, C, D;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; A &gt;&gt; B &gt;&gt; C &gt;&gt; D;</span><br><span class="line">    dp[A][B][<span class="number">0</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = A; i &lt;= C; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = B; j &lt;= D; j++)&#123;</span><br><span class="line">            dp[i + <span class="number">1</span>][j][<span class="number">1</span>] = (dp[i + <span class="number">1</span>][j][<span class="number">1</span>] + (dp[i][j][<span class="number">0</span>] + dp[i][j][<span class="number">1</span>]) * j) % mod;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; A) dp[i][j + <span class="number">1</span>][<span class="number">0</span>] = (dp[i][j + <span class="number">1</span>][<span class="number">0</span>] + dp[i][j][<span class="number">1</span>]) % mod;</span><br><span class="line">            dp[i][j + <span class="number">1</span>][<span class="number">0</span>] = (dp[i][j + <span class="number">1</span>][<span class="number">0</span>] + dp[i][j][<span class="number">0</span>] * i) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (dp[C][D][<span class="number">0</span>] + dp[C][D][<span class="number">1</span>]) % mod &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">一个有意思的容斥做法</summary><div class="toggle-content"><p><a href="https://www.luogu.com.cn/article/pgbld0pu">https://www.luogu.com.cn/article/pgbld0pu</a></p>
<p>先不管记重，$f_{i,j}=f_{i-1,j}<em>j+f_{i,j-1}</em>i$ ，假设前面是正确的，这里开始容斥，发现当 $(i,j)$ 不是黑色的时候会计两次。（这可以从转移分析得到）</p>
<p>所以正确的转移为 $f_{i,j}=f_{i-1,j}<em>j+f_{i,j-1}</em>i-f_{i-1,j-1}<em>(i-1)</em>(j-1)$ 。</p>
</div></details>
<h1 id="C-Shift"><a href="#C-Shift" class="headerlink" title="C. Shift"></a>C. Shift</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc046/tasks/agc046_c">https://atcoder.jp/contests/agc046/tasks/agc046_c</a></p>
<p>题目大意：每次选择字符串中的 $i&lt;j$ 满足 $s[i]=0,s[j]=1$ ，然后把 $1$ 放到 $0$ 左边，问经过至多 $K$ 次操作后能产生多少不同的字符串。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>注意到可以用 $0$ 给 $1$ 分段，用 $1$ 的数量变成数组 $A$，然后状态 $A$ 能到状态 $B$ 当且仅当：</p>
<ol>
<li>$\sum\limits_{i=1}^{len}|A_{i}-B_{i}|\le K$</li>
<li>$\sum\limits_{i=1}^{j}B_{i}-A_{i}\ge 0$</li>
</ol>
<p>直接 $dp[i][j][k]$ 计数就行了。</p>
<p>但是需要加个类似前缀和优化的东西保证时间复杂度是 $O(n^3)$ 的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(ss) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> n, m, a[N], b[N], K;</span><br><span class="line">LL dp[N][N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st); n = <span class="built_in">strlen</span>(st + <span class="number">1</span>);</span><br><span class="line">    cin &gt;&gt; K;</span><br><span class="line">    &#123;</span><br><span class="line">        st[++n] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)&#123;</span><br><span class="line">            <span class="type">int</span> r = l;</span><br><span class="line">            <span class="keyword">while</span>(st[r] == <span class="string">&#x27;1&#x27;</span>) r++;</span><br><span class="line">            a[++m] = r - l;</span><br><span class="line">            l = r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) b[i] = b[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    K = <span class="built_in">min</span>(K, b[m]);</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= K; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = j; k &lt;= K; k++)&#123;</span><br><span class="line">                dp[i][j][k] = (dp[i][j][k] + dp[i - <span class="number">1</span>][j][k]) % mod;</span><br><span class="line">                <span class="keyword">if</span>(j) dp[i][j][k] = (dp[i][j][k] + dp[i][j - <span class="number">1</span>][k - <span class="number">1</span>]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= K; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = j; k &lt;= K; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dp[i - <span class="number">1</span>][j][k]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">1</span>; t &lt;= j &amp;&amp; t &lt;= a[i]; t++) dp[i][j - t][k] = (dp[i][j - t][k] + dp[i - <span class="number">1</span>][j][k]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= K; i++) ans = (ans + dp[m][<span class="number">0</span>][i]) % mod;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和官方做法基本一致。</p>
</div></details>
<h1 id="D-Secret-Passage"><a href="#D-Secret-Passage" class="headerlink" title="D. Secret Passage"></a>D. Secret Passage</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc046/tasks/agc046_d">https://atcoder.jp/contests/agc046/tasks/agc046_d</a></p>
<p>题目大意：你可以对 $01$ 字符串做以下操作若干次，问有多少个本质不同字符串：</p>
<p>若字符串长度 $\ge 2$ ，删除前面两个字符中的一个，并且将另外一个插入到字符串中的任意位置。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>首先一个典中典的事情，我们可以先不把没删除的字符插入，而是等到需要用时再插入，因此我们只关心在删除了一个前缀的情况下，我们手里能有多少个 $0$ ，多少个 $1$ 。</p>
<p>由于时间十分充裕，我们可以在 $O(n^3)$ 的时间处理出来。</p>
<p>现在的问题是，我们怎么在 $O(n^3)$ 的时间内，处理出所有可能的串？</p>
<p>首先先给所有的可能串分个类，根据其拥有的 $0$ 的个数和 $1$ 的个数，可以发现，在这两个确定后，我们其实只关心一个事情，能删的前缀的最大值是多少？</p>
<p>或者具体来说，在前面那个 $dp$ 做完后，我们实际上有一堆三元数：有多少个可以自由支配的 $0/1$ ，以及多长的后缀是固定的，可以看到在 $0/1$ 总数固定的情况下，后缀越短越好，因此总共有 $n^2$ 种不同的后缀。</p>
<p>这启示我们需要在 $O(n)$ 的时间针对一个种类求出答案，但是如果单独 $dp$ 这个复杂度寄中寄，注意到后缀长度是共同变量，启示我们一起处理一个大的 $dp$ ，然后每种是其中的部分和。</p>
<p>得到以下的 $dp$ ：</p>
<p>$f[i][j][k]$ 表示后缀匹配长度为 $i$ ，有 $j$ 个 $0$ ，$k$ 个 $1$ 的不同字符串数，匹配指最长的后缀满足是子序列，即能匹配就匹配。</p>
<p>对于三元数 $(j,k,len)$ ，显然其答案就是：$\sum\limits_{i=1}^{n-len+1}f[i][j][k]$ 。</p>
<p>总时间复杂度：$O(n^3)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(ss) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> dp[N][N][N];</span><br><span class="line">LL sum[N][N][N];</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> n, cnt0[N], cnt1[N], las[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st); n = <span class="built_in">strlen</span>(st + <span class="number">1</span>);</span><br><span class="line">    sum[n + <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n + <span class="number">1</span>; i &gt;= <span class="number">2</span>; i--)&#123;<span class="comment">//i = 1 no operator</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; j + k &lt;= n; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(st[i - <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                    sum[i - <span class="number">1</span>][j + <span class="number">1</span>][k] = (sum[i - <span class="number">1</span>][j + <span class="number">1</span>][k] + sum[i][j][k]) % mod;</span><br><span class="line">                    sum[i][j][k + <span class="number">1</span>] = (sum[i][j][k + <span class="number">1</span>] + sum[i][j][k]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    sum[i - <span class="number">1</span>][j][k + <span class="number">1</span>] = (sum[i - <span class="number">1</span>][j][k + <span class="number">1</span>] + sum[i][j][k]) % mod;</span><br><span class="line">                    sum[i][j + <span class="number">1</span>][k] = (sum[i][j + <span class="number">1</span>][k] + sum[i][j][k]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        cnt0[i] += cnt0[i + <span class="number">1</span>] + (st[i] == <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        cnt1[i] += cnt1[i + <span class="number">1</span>] + (st[i] == <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        las[cnt0[i]][cnt1[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i / <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = i / <span class="number">2</span> - j; k &gt;= <span class="number">0</span>; k--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dp[i][j][k]) <span class="keyword">continue</span>;</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> c0 = cnt0[i + <span class="number">1</span>] + j, c1 = cnt1[i + <span class="number">1</span>] + k;</span><br><span class="line">                    <span class="keyword">if</span>(c0 + c1) las[c0][c1] = <span class="built_in">max</span>(las[c0][c1], i + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(i + <span class="number">2</span> &lt;= n)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(st[i + <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span> || st[i + <span class="number">2</span>] == <span class="string">&#x27;0&#x27;</span>) dp[i + <span class="number">2</span>][j + <span class="number">1</span>][k] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(st[i + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> || st[i + <span class="number">2</span>] == <span class="string">&#x27;1&#x27;</span>) dp[i + <span class="number">2</span>][j][k + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= <span class="number">1</span> &amp;&amp; j + k &gt;= <span class="number">2</span>) dp[i][j - <span class="number">1</span>][k] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(k &gt;= <span class="number">1</span> &amp;&amp; j + k &gt;= <span class="number">2</span>) dp[i][j][k - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i + <span class="number">1</span> &lt;= n)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j || k) dp[i + <span class="number">1</span>][j][k] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(st[i + <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; k) dp[i + <span class="number">1</span>][j + <span class="number">1</span>][k - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(st[i + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; j) dp[i + <span class="number">1</span>][j - <span class="number">1</span>][k + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; i + j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!i &amp;&amp; !j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = las[i][j]; k &gt;= <span class="number">1</span>; k--)&#123;</span><br><span class="line">                ans = (ans + sum[k][i][j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            ans--;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但感觉这种做法尽显暴力，等会看看正解是怎么优雅的做出这道题目的。</p>
<p>在此之前，我来证明一个在赛时没时间证明的想法：</p>
<p>删除任何一个前缀，假设可支配 $x$ 个 $0$ 和 $y$ 个 $1$ ，并且 $x+y$ 确定，那么 $x$ 的范围是个区间。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>我们可以考虑这么一个事情，给定一个前缀，给其标 $0/1$ ，$0$ 表示保留，$1$ 表示删掉，然后问这是否是一种合法的方案。</p></p>
<p>注：由于博主疏忽大意，后面记得根据语境区分 $0/1$ 指的是删除标记还是字符串的 $0/1$ 。</p>
<p>这个问题存在一种简单的判法，从左到右，如果接下来有两个字符，而且有至少一个 $1$ ，那么就直接对这两个字符操作，如果有两个 $0$ 或者只剩下一个字符，就搭一个 $1$ 进去操作（手中没有 $0$ 就不合法），等到没有剩余字符在前缀的时候，就拿手中的 $0$ 去消除手中的 $1$ 就行了（手中有 $1$ 但没 $0$ 就不合法），这样就能判断是否合法。</p>
<p>这个判法的证明也不难：</p>
<p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>对于 $2$ 个以上连续的 $0$ ，我们不妨设为 $L00R$ ，一定可以把这个过程分为 $L0,0R$ ，即一定是先做完 $L0$ ，再做 $0R$ （手中 $0,1$ 数量不会消失），注意到不合法当且仅当 $1$ 的数量不够了，因此我们希望在 $L0$ 处获得尽可能多的 $1$ ，对应的，上面的过程中遇到 $00$ ，我们都能进行这样子的划分，对于每一段，证明就变得十分的简单了，一定是：</p></p>
<p>$AB$ ，其中 $A$ 是长度为 $2len$ 的字符串，满足 $2i-1,2i$ 中至少有一个 $1$ ，$B$ 全是 $0$ ，这种段的最优策略是显然的，而显然，将这些最优策略拼起来就是整体最优的，而拼起来的策略就是上面的策略，所以就证明了上面的策略就是整体最优的。</p>
<p>证毕。</p>
</div></details>
<p>根据这个判法，我们可以将任意一种方案在每次只移动一个 $1$ 的情况下，变成下面这种方案：</p>
<p>假设总共有 $t$ 个 $1$ ，现在所有奇数位置放个 $1$ ，剩下的 $1$ 从左往右依次放在空着的偶数里。</p>
<p>鉴于这种移动可逆，所以所有的方案都可以通过这种方式互达，同时这种移动只会造成 $1$ 的变化，从而证明是个区间。</p>
<p>事实上，我们也可以加上加一个 $1$ 减一个 $1$ 的操作，从而得到在不固定 $x+y$ 的情况下 $(x+y,x)$ 的所在范围。</p>
<p>但是这个范围并没有很好，举个例子：</p>
<p>$111100110011001100$</p>
<p>至少需要 $4$ 步才能变成 $-1$ 的局面，而显然，利用这个例子，我们可以轻松的构造一个字符串使得 $x+y$ 相差为 $1$ 的 $x$ 的范围差别很大（指上下界差别很大）。</p>
<p>那难道是在 $x+y=\left\lceil\frac{n}{2}\right\rceil$ 时才会发生这种情况吗？</p>
<p>不对，可以通过类似的方法，构造出 $x+y-\left\lceil\frac{n}{2}\right\rceil$ 任意大的错误例子：</p>
<p>核心思路是：开头若干个 $11$ 提供多出来的 $1$ ，然后一个单独的 $0$ 消耗 $1$ ，然后若干个 $0110$ 加大相邻两个单独的 $1$ 之间的距离，然后再放一个单独的 $0$ 循环往复。</p>
<p>上面例子拆分就是：$11/11/0/0110/0110/0110/0$ ，为什么这个需要花多步呢？</p>
<p>因为每次尝试把 $1$ 放到 $0$ 上面时，会发现影响只是整体右移，不会导致最后手里有多余的 $1$ （因为注意到如果最后手中有多余的 $1$ ，就可以删除这个 $1$ 证明在 $x+y$ 插值绝对值不超过 $1$ 的情况下， $x$ 的上下界差值的绝对值也不超过 $1$）。</p>
<p>这里实操一下就知道了：</p>
<p>$11/11/0/0110/0110/0110/0\to 10/11/1/0110/0110/0110/0\to 10/11/1011/0/0110/0110/0$</p>
<p>而最后能多出 $1$ 一定是通过移动把两个单独的 $0$ 放到了一起，然后再放一个 $1$ 同时把两个单独的 $0$ 用一个 $1$ 解决了，从而节省一个 $1$ 。但是这个移动的过程所花费的大量的移动就已经足够把相邻 $x+y$ 的 $x$ 的上下界拉得足够大了。</p>
<p>所以不固定 $x+y$ 的情况下 $(x+y,x)$ 的范围不一定是好的。</p>
<p>虽然但是，上面的反例似乎只是说明这种方法无法证明范围是好的，也许范围就是好的，或者部分好的，只是方法问题？不知道，感觉这个的证明或者证伪已经超出了博主目前的实力范围了。</p>
<p>但是还是用代码验证一下刚才的那个说法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(ss) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> dp[N][N][N];</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> n, cnt0[N], cnt1[N], las[N][N];</span><br><span class="line"><span class="type">int</span> ll[N], rr[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st); n = <span class="built_in">strlen</span>(st + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        cnt0[i] += cnt0[i + <span class="number">1</span>] + (st[i] == <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        cnt1[i] += cnt1[i + <span class="number">1</span>] + (st[i] == <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        las[cnt0[i]][cnt1[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i / <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = i / <span class="number">2</span> - j; k &gt;= <span class="number">0</span>; k--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dp[i][j][k]) <span class="keyword">continue</span>;</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> c0 = cnt0[i + <span class="number">1</span>] + j, c1 = cnt1[i + <span class="number">1</span>] + k;</span><br><span class="line">                    <span class="keyword">if</span>(c0 + c1) las[c0][c1] = <span class="built_in">max</span>(las[c0][c1], i + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(i + <span class="number">2</span> &lt;= n)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(st[i + <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span> || st[i + <span class="number">2</span>] == <span class="string">&#x27;0&#x27;</span>) dp[i + <span class="number">2</span>][j + <span class="number">1</span>][k] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(st[i + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> || st[i + <span class="number">2</span>] == <span class="string">&#x27;1&#x27;</span>) dp[i + <span class="number">2</span>][j][k + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= <span class="number">1</span> &amp;&amp; j + k &gt;= <span class="number">2</span>) dp[i][j - <span class="number">1</span>][k] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(k &gt;= <span class="number">1</span> &amp;&amp; j + k &gt;= <span class="number">2</span>) dp[i][j][k - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(i + <span class="number">1</span> &lt;= n)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j || k) dp[i + <span class="number">1</span>][j][k] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(st[i + <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; k) dp[i + <span class="number">1</span>][j + <span class="number">1</span>][k - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(st[i + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; j) dp[i + <span class="number">1</span>][j - <span class="number">1</span>][k + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; i++) ll[i] = n + <span class="number">1</span>, rr[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">0</span>; l &lt;= n / <span class="number">2</span>; l++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> r = <span class="number">0</span>; l + r &lt;= n / <span class="number">2</span>; r++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[n][l][r]) ll[l + r] = <span class="built_in">min</span>(ll[l + r], l), rr[l + r] = <span class="built_in">max</span>(rr[l + r], l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; i++)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;x + y = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; : [&quot;</span> &lt;&lt; ll[i] &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; rr[i] &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input:</span><br><span class="line"></span><br><span class="line">111111110011001100110011001100110001100110011001100110011000110011001100110011001100011001100110011001100110</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">x + y = 1 : [0 , 1]</span><br><span class="line">x + y = 2 : [0 , 2]</span><br><span class="line">x + y = 3 : [0 , 3]</span><br><span class="line">x + y = 4 : [0 , 4]</span><br><span class="line">x + y = 5 : [0 , 5]</span><br><span class="line">x + y = 6 : [0 , 6]</span><br><span class="line">x + y = 7 : [0 , 7]</span><br><span class="line">x + y = 8 : [0 , 8]</span><br><span class="line">x + y = 9 : [0 , 9]</span><br><span class="line">x + y = 10 : [0 , 10]</span><br><span class="line">x + y = 11 : [0 , 11]</span><br><span class="line">x + y = 12 : [0 , 12]</span><br><span class="line">x + y = 13 : [0 , 13]</span><br><span class="line">x + y = 14 : [0 , 14]</span><br><span class="line">x + y = 15 : [0 , 15]</span><br><span class="line">x + y = 16 : [0 , 16]</span><br><span class="line">x + y = 17 : [0 , 17]</span><br><span class="line">x + y = 18 : [0 , 18]</span><br><span class="line">x + y = 19 : [0 , 19]</span><br><span class="line">x + y = 20 : [0 , 20]</span><br><span class="line">x + y = 21 : [0 , 21]</span><br><span class="line">x + y = 22 : [0 , 22]</span><br><span class="line">x + y = 23 : [0 , 23]</span><br><span class="line">x + y = 24 : [0 , 24]</span><br><span class="line">x + y = 25 : [0 , 25]</span><br><span class="line">x + y = 26 : [0 , 26]</span><br><span class="line">x + y = 27 : [0 , 27]</span><br><span class="line">x + y = 28 : [0 , 28]</span><br><span class="line">x + y = 29 : [0 , 29]</span><br><span class="line">x + y = 30 : [0 , 30]</span><br><span class="line">x + y = 31 : [0 , 31]</span><br><span class="line">x + y = 32 : [0 , 32]</span><br><span class="line">x + y = 33 : [0 , 33]</span><br><span class="line">x + y = 34 : [0 , 34]</span><br><span class="line">x + y = 35 : [0 , 35]</span><br><span class="line">x + y = 36 : [0 , 36]</span><br><span class="line">x + y = 37 : [0 , 37]</span><br><span class="line">x + y = 38 : [0 , 38]</span><br><span class="line">x + y = 39 : [0 , 39]</span><br><span class="line">x + y = 40 : [0 , 40]</span><br><span class="line">x + y = 41 : [0 , 41]</span><br><span class="line">x + y = 42 : [0 , 42]</span><br><span class="line">x + y = 43 : [0 , 43]</span><br><span class="line">x + y = 44 : [0 , 44]</span><br><span class="line">x + y = 45 : [0 , 45]</span><br><span class="line">x + y = 46 : [0 , 46]</span><br><span class="line">x + y = 47 : [0 , 47]</span><br><span class="line">x + y = 48 : [0 , 48]</span><br><span class="line">x + y = 49 : [0 , 49]</span><br><span class="line">x + y = 50 : [0 , 50]</span><br><span class="line">x + y = 51 : [0 , 51]</span><br><span class="line">x + y = 52 : [0 , 52]</span><br><span class="line">x + y = 53 : [7 , 45]</span><br><span class="line">x + y = 54 : [14 , 38]</span><br></pre></td></tr></table></figure>
<p>至少从例子上来看，范围不是绝对好的，至于是不是部分好的，这就不在我能力范围之内了。</p></div></details>
<p>证完了，看看题解。</p>
<p>看完了，基本一致。</p>
<p>但是看到一份很短的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> v)</span></span>&#123;((x+=v)&gt;=MOD)&amp;&amp;(x-=MOD);&#125;</span><br><span class="line"><span class="type">int</span> n,ok[<span class="number">305</span>][<span class="number">305</span>][<span class="number">305</span>],dp[<span class="number">305</span>][<span class="number">305</span>][<span class="number">305</span>],res;</span><br><span class="line"><span class="type">char</span> s[<span class="number">305</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);n=<span class="built_in">strlen</span>(s+<span class="number">1</span>);ok[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="keyword">for</span>(<span class="type">int</span> j=n;~j;j--)<span class="keyword">for</span>(<span class="type">int</span> k=n;~k;k--)&#123;</span><br><span class="line">		ok[i][j][k]|=ok[i<span class="number">-1</span>][j][k];</span><br><span class="line">		ok[i][j][k]|=ok[i][j+<span class="number">1</span>][k];</span><br><span class="line">		ok[i][j][k]|=ok[i][j][k+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(j&amp;&amp;i&gt;=<span class="number">2</span>&amp;&amp;(s[i]==<span class="string">&#x27;0&#x27;</span>||s[i<span class="number">-1</span>]==<span class="string">&#x27;0&#x27;</span>))ok[i][j][k]|=ok[i<span class="number">-2</span>][j<span class="number">-1</span>][k];</span><br><span class="line">		<span class="keyword">if</span>(k&amp;&amp;i&gt;=<span class="number">2</span>&amp;&amp;(s[i]==<span class="string">&#x27;1&#x27;</span>||s[i<span class="number">-1</span>]==<span class="string">&#x27;1&#x27;</span>))ok[i][j][k]|=ok[i<span class="number">-2</span>][j][k<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">if</span>(j&amp;&amp;s[i]==<span class="string">&#x27;0&#x27;</span>)ok[i][j][k]|=ok[i<span class="number">-1</span>][j<span class="number">-1</span>][k+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(k&amp;&amp;s[i]==<span class="string">&#x27;1&#x27;</span>)ok[i][j][k]|=ok[i<span class="number">-1</span>][j+<span class="number">1</span>][k<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	dp[n][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=n;k++)&#123;</span><br><span class="line">		<span class="built_in">add</span>(dp[i<span class="number">-1</span>][j][k],dp[i][j][k]);</span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>)<span class="built_in">add</span>(dp[i][j][k+<span class="number">1</span>],dp[i][j][k]);</span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="string">&#x27;1&#x27;</span>)<span class="built_in">add</span>(dp[i][j+<span class="number">1</span>][k],dp[i][j][k]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=n;k++)</span><br><span class="line">		<span class="keyword">if</span>(ok[i][j][k])<span class="built_in">add</span>(res,dp[i][j][k]);</span><br><span class="line">	<span class="built_in">add</span>(res,MOD<span class="number">-1</span>);<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//https://www.luogu.com.cn/article/vjo8hwnx</span></span><br></pre></td></tr></table></figure>
<p>很厉害啊，就算不压行也比我的短。</p>
<p>可以从我的做法导出这个写法是对的。但考场上我是不会这么写的，主要是不稳，本来做法就需要证明，现在还要写一份需要证明的代码，这在考场上性价比是不高的，万一代码实际上计多了或少了，就又得花时间，所以我不会在考场上写这种代码。</p>
<p>但是在考场外用来观赏或者炫技的话，美观度确实是拉满了，可以学习一下。</p>
<p>至于为什么这样写是对的，不难证明，在此就不再赘述了。</p></div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AGC063 A. Mex Game</title>
    <url>/2023/08/25/AGC063-A-Mex-Game/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc063/tasks/agc063_a">https://atcoder.jp/contests/agc063/tasks/agc063_a</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然，如果我是 $A$ ，我一定会把数字放在最小的没被堵上的 $B$ 。</p>
<p> $B$ 同理，最终结果为最小的没有被堵上的位置上面的字符。</p>
<p>时间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 210000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> st[N];<span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> now1,now2,now3;</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(now1&lt;n &amp;&amp; st[now1]!=<span class="string">&#x27;B&#x27;</span>)now1++;</span><br><span class="line">            <span class="keyword">if</span>(now1&lt;=n)v[now1++]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(now2&lt;n &amp;&amp; st[now2]!=<span class="string">&#x27;A&#x27;</span>)now2++;</span><br><span class="line">            <span class="keyword">if</span>(now2&lt;=n)v[now2++]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(now3&lt;=n &amp;&amp; v[now3])now3++;</span><br><span class="line">        <span class="keyword">if</span>(!v[now3])&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[now3]==<span class="string">&#x27;A&#x27;</span>)<span class="built_in">printf</span>(<span class="string">&quot;Alice\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Bob\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC063 B. Insert 1, 2, 3, ...</title>
    <url>/2023/08/25/AGC063-B-Insert-1-2-3/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc063/tasks/agc063_b">https://atcoder.jp/contests/agc063/tasks/agc063_b</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>对于一个序列的检验，我们可以认为是每次选择一个递增序列，删掉，看最后能不能删完，能删完就是合法序列。</p>
<p>证明两个定理：</p>
<ol>
<li>假如我在后面某步删除了某个序列，且这个序列在现在就存在且能删除，那么现在直接删除不会影响最终判断。<br>例如：1231234，我先删了 123 再删除 1234，但是其实一开始就能删除 1234，那么我一开始就删除 1234 不会影响最终判断。</li>
<li>加入我在某一步删除了一个序列，那么如果我在之前的某一步的瞬间突然删除掉了这个序列某一个后缀，不会导致将原本合法的序列判断为不合法。<br>例如：1231212456 ，显然删除顺序是：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>2022-2023 ICPC Asia Pacific - Seoul Regional 赛后小结</title>
    <url>/2024/07/20/2022-2023-ICPC-Asia-Pacific-Seoul-Regional-%E8%B5%9B%E5%90%8E%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://qoj.ac/contest/1045">https://qoj.ac/contest/1045</a></p>
<p>全给队友秒完了。</p>
<p>感觉前期节奏还行。</p>
<p> J imakf 秒了。 I 弱智 dp ，我上去写了， F 队长给我做法，我上去写。</p>
<p> F 做法大概是只要一个区间被完整覆盖，那么在这个区间移动不会付出代价，正确性显然，那么维护一下答案就行了。</p>
<p>然后 K,D,E ，K 队友声称 SB 题，DE 我看了，感觉是 SB 题。</p>
<p>然后队友发力过了 A,C,L ，我上机写 H ，TLE 了，后面发现是某个地方重复了若干次，但是有一次没有写判断，以后这种地方直接写成函数式，不然某次写漏了很难看得出来的。</p>
<p>后面开始卡题，由于我负责字符串，所以我去想 H 了，然后我就开始牛马了，我 SAM 做少了，声称不可能有对数做法，开始想根号分治。</p>
<p>最后写了个 $O(n\alpha({n})\sqrt{n})$ 的做法，还因为很唐的原因 T 到比赛结束，赛后过了。</p>
<p> T 的原因，某一个因为在 $size\le B$ 才应该运行的部分被我放在判断外面了，时间复杂度退化成平方。</p>
<p>总之，最后没过的原因：</p>
<ol>
<li>高估了代码复杂度，我声称我写不出来，要一个小时，而且觉得 150+ ，但是最后只有 120+ ，而且 45 min 写出来了。</li>
<li>没有写对拍。</li>
<li>菜。</li>
</ol>
<p>整场我的问题：</p>
<ol>
<li>没有函数式编程，没有正确的代码习惯。</li>
<li>没有正确的估计代码复杂度。</li>
<li>菜。</li>
</ol>
<p>这个 H 的具体做法和与题目相关的具体的反思单独开一篇博客写，因为感觉和小结关系不大，<del>而且写小结的时候还不会正解</del>。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AGC045 赛后总结</title>
    <url>/2024/07/12/AGC045-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>打得一坨屎。</p>
<p>比赛链接：<a href="https://atcoder.jp/contests/agc045">https://atcoder.jp/contests/agc045</a></p>
<h1 id="A-Xor-Battle"><a href="#A-Xor-Battle" class="headerlink" title="A. Xor Battle"></a>A. Xor Battle</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc045/tasks/agc045_a">https://atcoder.jp/contests/agc045/tasks/agc045_a</a></p>
<p>题目大意：第 $i$ 轮第 $S_{i}$ 个人行动 ：将 $x$ 异或 $A_{i}$ 或者不操作，$x$ 初始为 $0$ ，如果最后 $x=0$ 则 $0$ 赢，否则 $1$ 赢，问最后谁必赢。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然，先手必胜的条件是从后往前，每个 $1$ 的 $A_{i}$ 可以被其后面 $0$ 的 $A_{i}$ 表示。</p>
<p>写个线性基就行了。</p>
<p>时间复杂度：$O(n\log{V})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L = <span class="number">60</span>;</span><br><span class="line">LL mi[L + <span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">add</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = L - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>((x &gt;&gt; i) &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!mi[i])&#123;</span><br><span class="line">                mi[i] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> x ^= mi[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">LL a[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(mi, <span class="number">0</span>, <span class="built_in">sizeof</span>(mi));</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    string st;</span><br><span class="line">    cin &gt;&gt; st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i - <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="built_in">add</span>(a[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">add</span>(a[i])) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">pd</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没开 long long WA 了一发，真唐氏儿吧。</p>
<p>和题解一致。</p>
</div></details>
<h1 id="B-01-Unbalanced"><a href="#B-01-Unbalanced" class="headerlink" title="B. 01 Unbalanced"></a>B. 01 Unbalanced</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc045/tasks/agc045_b">https://atcoder.jp/contests/agc045/tasks/agc045_b</a></p>
<p>题目大意：给 $?$ 填 $01$ ，使得任意区间中 $01$ 个数差值绝对值的最大值最小。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然，可以把 $0$ 看成 $-1$ ，$1$ 看成 $1$ ，然后就是求前缀和最大值减最小值的最小可能值。</p>
<p>做法很简单，就是对于当前字符串，维护未来可能成为答案的值域范围，即指在所有可能的值域范围中，不存在一个范围是这个范围的真子集的范围。</p>
<p>注意到 $0$ 的转移就是所有区域向下移动，同时如果上界 $&lt;0$ 就补成 $0$ ，显然已经丢掉的区间不需要考虑，只考虑现在有的区间，其余转移类似，于是这样能发现结果只有两种情况：</p>
<ol>
<li>相同长度的区间，可以右移有限步，例如：$[-2,0],[-1,1],[0,2]$ 这样的。</li>
<li><p>相同长度的区间，可以右移有限的两步，即每次移动都是移动两步，同时左边和右边可能还有长度 $+1$ 的区间，但是相对位置是固定的，设基准区间为 $[l,r]$：</p>
<p>$([l-2,r-1],)[l,r],[l+2,r+2],…,<a href=",[l+2k+1,r+2k+2]">l+2k,r+2k</a>$</p>
</li>
</ol>
<p>理论上这个时候只需要讨论就行了。</p>
<p>但是我觉得讨论太麻烦了，发现你只关心左右两个区间，至多四个区间，就可以维护当前的状态。</p>
<p>但是需要注意，转移的时候如果总区间数 $&gt;4$ ，那么需要往内补至多两个区间（左右各一个），防止左右端点失效个数减少。</p>
<p>转移的时候就拿不超过 $6$ 个区间转移出他们的后继区间，然后去重，保留没有真子集的区间，按左端点为第一关键字，右端点为第二关键字排序，然后选最小的两个和最大的两个就行了，可以发现仍然是上面两种情况的合法维护，然后就行了。</p>
<p>证明正确也不难，可以发现只拿左右 $6$ 个区间转移，显然下一步的 $4$ 个区间是能转移出来的，其次的区间如果是下一步的其余合法区间，不会干扰最后选择，如果不是，又没被 $4$ 个区间去掉，说明被中间区间去掉了，研究此时这个区间的位置，左端点大于第二个区间，右端点小于第三个区间，所以也不会干扰最后选择，综上，这个转移是正确的，上面的表述可能不够严谨，但反正按照这个思路我觉得能证，应该大差不差了，懒得细想了。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line">PII <span class="keyword">operator</span> + (PII x, <span class="type">int</span> y)&#123;<span class="keyword">return</span> &#123;<span class="built_in">min</span>(x.first + y, <span class="number">0</span>), <span class="built_in">max</span>(x.second + y, <span class="number">0</span>)&#125;;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string ss;</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    vector&lt;PII&gt; f;</span><br><span class="line">    f.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c : ss)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f.<span class="built_in">size</span>() == <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f[<span class="number">1</span>].first == f[<span class="number">0</span>].first + <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(f[<span class="number">1</span>].second + <span class="number">2</span> &lt; f[<span class="number">2</span>].second) f.<span class="built_in">push_back</span>(f[<span class="number">1</span>] + <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">if</span>(f[<span class="number">1</span>].second + <span class="number">4</span> &lt; f[<span class="number">2</span>].second) f.<span class="built_in">push_back</span>(f[<span class="number">2</span>] + (<span class="number">-2</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(f[<span class="number">1</span>].first == f[<span class="number">0</span>].first + <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(f[<span class="number">1</span>].second + <span class="number">1</span> &lt; f[<span class="number">2</span>].second) f.<span class="built_in">push_back</span>(f[<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(f[<span class="number">1</span>].second + <span class="number">2</span> &lt; f[<span class="number">2</span>].second) f.<span class="built_in">push_back</span>(f[<span class="number">2</span>] + (<span class="number">-1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;PII&gt; g;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;0&#x27;</span> || c == <span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x : f) g.<span class="built_in">push_back</span>(x + (<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;1&#x27;</span> || c == <span class="string">&#x27;?&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x : f) g.<span class="built_in">push_back</span>(x + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>(), [](PII x, PII y)&#123;<span class="keyword">return</span> x.first == y.first ? x.second &lt; y.second : x.second &lt; y.second;&#125;);</span><br><span class="line">        g.<span class="built_in">erase</span>(<span class="built_in">unique</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>()), g.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;PII&gt; tmp;</span><br><span class="line">        <span class="built_in">swap</span>(g, tmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : tmp)&#123;</span><br><span class="line">            <span class="type">bool</span> bk = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> y : tmp)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x != y &amp;&amp; y.first &gt;= x.first &amp;&amp; y.second &lt;= x.second)&#123;bk = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(bk) g.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(g.<span class="built_in">size</span>() &lt;= <span class="number">4</span>) <span class="built_in">swap</span>(f, g);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            f.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i++) f.<span class="built_in">push_back</span>(g[i]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = g.<span class="built_in">size</span>() - <span class="number">2</span>; i &lt; g.<span class="built_in">size</span>(); i++) f.<span class="built_in">push_back</span>(g[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = ss.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : f) ans = <span class="built_in">min</span>(ans, x.second - x.first);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><details class="toggle" ><summary class="toggle-button" style="">犯罪记录</summary><div class="toggle-content"><p>很早的意识到这道题目前缀和的性质。</p></p>
<p>在最开始的时候，考虑每一段不是 $?$ 的区间，发现研究值域很有效，感觉需要讨论。</p>
<p>再后来，发现可能需要维护一系列可能的值域区间，而且这些区间的长度还不一定相等，猜想所需要维护的区间一定满足某种性质。</p>
<p>但是因为是一段一段字符考虑，不是一个个字符考虑，猜到了结论，但是不会证明，更不会讨论和转移，卡了一个小时。</p>
<p>最后意识到可以是一个个字符转移，遂会做，想到维护四个区间的做法，很快 AC 。（可能也不快）</p>
<p>首先，深刻反思：</p>
<ol>
<li>赛时不能颓废，颓废是犯大罪。</li>
<li>其次，$?$ 也是一种字符，当时应该尝试把 $?01$ 一起考虑，虽然这并不普遍，但是在卡题的时候思考一下是合理的。</li>
<li><p>再其次，应该意识到，如果考虑区间不行，就考虑单个字符，这是有理有据的，虽然确实也有很多题目是应该考虑区间的，但是卡题的时候，换个思路思考是十分合理的，重点不是可能不可能成为答案，而是我没有尝试过这么思考，这很危险（虽然最后还是想到了，但是卡了一个小时基本完蛋了）。</p>
<p>而且本身也有很多题目，是从考虑区间变成考虑单个数字的时候，就豁然开朗了，所以这是一个合理的方向。</p>
<p>再其次，这道题目考虑单个字符是有迹可循的，区间本质上是一堆字符中间加了 $0$ 个操作，而一堆 $?$ 是中间有 $0$ 长度的区间，而一般的算法，尤其是 $dp$ ，一般能处理 $&gt;0$ 的情况就能处理 $=0$ 的情况，所以就应该把区间拆成单个字符，一堆问号拆成单个问号想想的。</p>
</li>
</ol>
<p>总之，赛时因为没想到考虑单个字符，一直卡在考虑区间，我认为是犯大罪，是不应该犯的错误，警钟敲烂。</p>
</div></details>
<p>看了题解，越来越感觉自己很唐了。</p></div></details>
<details class="toggle" ><summary class="toggle-button" style="">别的做法 1</summary><div class="toggle-content"><p>我们考虑固定一个上界，求最大的下界，注意到肯定是把所有的 $?$ 填成 $0$ ，然后从左到右，维护后缀最小值，能填 $1$ 填 $1$ 。</p>
<p>正确的道理就是：修改相当于后缀 $+2$ ，考虑原来的每个后缀最大值，实际上限制了前面至多有多少个修改，显然在不超过限制的情况下，修改越往前，全局最小值越小。</p>
<p>考虑把上界 $+2$ ，显然至多导致多修改一个 $1$ ，所以答案不优，所以求最小的上界和最小的上界 $+1$ 就行了，最小上界就是全填 $0$ 的最大值。</p>
<p>时间复杂度：$O(n)$ 。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">反思</summary><div class="toggle-content"><p>首先，我有想过这个固定上界的思路，但是为什么没想出来怎么求出最大下界了？</p></p>
<p>因为有个唐氏儿一开始没有把所有的问号写成 $0$ ，首先，问一个位置变成 $±1$ 还是原本是 $0$ ，是否修改成 $1$ ，虽然都是两个选择，但是在贪心和 dp 中，后者的思考难度和维护难度一般都远小于前者，因为将两个操作变成不操作和操作两个选择是一个很优秀的变化，做多了就知道了。</p>
<p>但是某个唐氏儿都大一了，打了八年以上，还能忘记这一点，全程带着 $0$ 来想，好想中途有想过先全部填成 $0$ 或者 $1$ ，但是当时还在想维护区间那个思路，发现这个思路没用，想了一会就没想了，结果痛失良机，真是唐吧。想怎么求最大下界想了不下几十分钟，怎么就是没想到先把 $?$ 填成 $0$ 或者 $1$ 呢？</p>
<p>当然，后面那个上界那一步我不一定能想出来，但我恨就恨在我怎么菜到第一步都没想出来，而且还不是方向错了那种，是方向对了，但就是没想出来。</p>
<p>真是菜啊。</p>
<p>一开始全填 $1$ 也能做，就是每个后缀必须要变多少个 $0$ ，差分一下看是否能满足要求就行，在此基础上，$0$ 越靠后，全局最小值越大。</p>
</div></details>
<p>这好像就是官方做法。</p>
<p>我真是菜啊，我真是废物啊。</p></div></details>
<details class="toggle" ><summary class="toggle-button" style="">别的做法 2</summary><div class="toggle-content"><p><a href="https://www.luogu.com.cn/article/na9yv0ep">https://www.luogu.com.cn/article/na9yv0ep</a></p>
<p>一个很有意思的做法，赏心悦目。</p>
<p>二分值域范围，这样就只需要 check ，但是一开始不知道区间落在哪里，一个很有意思的搞法是一开始就把起点尝试放在区间中的每个位置（我记得我以前好想也见过这个 trick ，但是现在已经忘了），即同时维护长度个路径，然后每次转移的时候，注意到可以到达的范围是个区间，然后就做完了，时间复杂度：$O(n\log{n})$ 。</p>
<p>这里放一张图，来自上面那篇博客的。</p>
<p><img src="1.png" alt=""></p>
<p>很有意思的做法，看这种做法真是让人感到愉悦啊。<del>虽然时间复杂度劣于正解就是了</del></p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AGC064 D. Red and Blue Chips</title>
    <url>/2023/09/07/AGC064-D-Red-and-Blue-Chips/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc064/tasks/agc064_d">https://atcoder.jp/contests/agc064/tasks/agc064_d</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>Mad，做这道题目的时候把某个定理想错了，想的既错误又复杂，笑死，根本不会做，后面发现想错了，就简单很多了，不久就知道怎么做了。</p>
<p>定理1：假如给每个 B 标号，那么最终的芯片排列中 B 的不同排列有 $(n-1)!$ 种，因为最底下的 B 是固定的，而且每个排列对应一种操作方式（指的是 B 的操作方式）。（这个定理解决了 B 的位置）</p>
<p>定理2：我们定义最终排列中 B 下面的 R 的数量为其的权值，那么前 $i$ 个 B 的权值不超过第 $i$ 个 B 前面的 R 的数量，且只要满足这个要求，就一定能够构造出来。（这个定理解决了 R 的位置）</p>
<p>定理2的构造方法是在放第 $i$ 个 B 之前提前把芯片放到他即将覆盖的 B 的上面就行了，不难发现，在第 $i$ 个 B 放之前一定能放，不管即将被覆盖的 B 怎么移动，同时覆盖了之后一定不能再放。</p>
<p>那么接下来就是怎么做的问题了，显然求出每个 $B$ 的权值然后排列就行了，不难发现，我们可以人为的规定权值非严格单调递增。</p>
<p>接下来我的 DP 是：$dp[i][j][k]$ 表示前 $i$ 个 B 被考虑过了，前面还有 $j$ 个 R ，同时第 $i$ 个芯片的权值为 $k$ 。</p>
<p>不难发现 $k-&gt;k+1$ 的更新最多跑 $\frac{n}{k+1}$ 步，然后就会触发无法放置然后终止后续的更新。</p>
<p>所以这里有个调和级数，时间复杂度： $O(n^3\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 310</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line">LL nfc[N],fc[N];</span><br><span class="line">LL dp[N][N][N];</span><br><span class="line"><span class="type">int</span> n,m,a[N];</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>,&amp;n,st+<span class="number">1</span>);</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=nfc[mod%i]*(mod-mod/i)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i]==<span class="string">&#x27;B&#x27;</span>)m++;</span><br><span class="line">        <span class="keyword">else</span> a[m+<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        dp[i][a[i]][<span class="number">0</span>]=<span class="built_in">C</span>(m<span class="number">-1</span>,i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=a[i];j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=a[m<span class="number">-1</span>];k++)dp[i][j][k]=(dp[i][j][k]+dp[i][j][k<span class="number">-1</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=a[i];j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=a[m<span class="number">-1</span>];k&gt;=<span class="number">1</span>;k--)&#123;</span><br><span class="line">                <span class="type">int</span> t=k<span class="number">-1</span>,now=j;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> q=i+<span class="number">1</span>;q&lt;m;q++)&#123;</span><br><span class="line">                    now+=a[q]-a[q<span class="number">-1</span>]-k;<span class="keyword">if</span>(now&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">                    dp[q][now][k]=(dp[q][now][k]+dp[i][j][t]*<span class="built_in">C</span>(m<span class="number">-1</span>-i,q-i))%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=a[m<span class="number">-1</span>];i++)ans=(ans+dp[m<span class="number">-1</span>][i][a[m<span class="number">-1</span>]])%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而一翻题解，发现题解的复杂度没有 $\log$ ，于是我又去优化。</p>
<p>然后就改了一个地方，就是对于 $i$ ，实际上能够更新到答案的有效的 $i$ 只会到 $n-\frac{n}{k}$ 左右。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 310</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line">LL nfc[N],fc[N];</span><br><span class="line">LL dp[N][N][N];</span><br><span class="line"><span class="type">int</span> n,m,a[N];</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>,&amp;n,st+<span class="number">1</span>);</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=nfc[mod%i]*(mod-mod/i)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i]==<span class="string">&#x27;B&#x27;</span>)m++;</span><br><span class="line">        <span class="keyword">else</span> a[m+<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        dp[i][a[i]][<span class="number">0</span>]=<span class="built_in">C</span>(m<span class="number">-1</span>,i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=a[i];j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=a[m<span class="number">-1</span>];k++)dp[i][j][k]=(dp[i][j][k]+dp[i][j][k<span class="number">-1</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=m<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=a[i];j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=(a[m<span class="number">-1</span>]-a[i]+j)/(m<span class="number">-1</span>-i);k&gt;=<span class="number">1</span>;k--)&#123;</span><br><span class="line">                    <span class="type">int</span> t=k<span class="number">-1</span>,now=j;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> q=i+<span class="number">1</span>;q&lt;m;q++)&#123;</span><br><span class="line">                        now+=a[q]-a[q<span class="number">-1</span>]-k;<span class="keyword">if</span>(now&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">                        dp[q][now][k]=(dp[q][now][k]+dp[i][j][t]*<span class="built_in">C</span>(m<span class="number">-1</span>-i,q-i))%mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=a[m<span class="number">-1</span>];i++)ans=(ans+dp[m<span class="number">-1</span>][i][a[m<span class="number">-1</span>]])%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这个复杂度是多少呢？答案是 $O(n^3)$ 。</p>
<p>因为我们不妨考虑枚举 $k$ ，那么有效的 $i$ 有 $O(\frac{n}{k})$ 个，向后转移就平方 $O(n*(\sum\limits_{k=1}^n\frac{n^2}{k^2}))=O(n^3\sum\limits_{i=1}^n\frac{1}{i^2})=O(n^3)$ 。</p>
<p>奇妙吧，这就是时间复杂度分析的美妙之处，一个看似只改变常数的优化竟然能优化掉复杂度中的一个 $\log$ ，实在是奇妙无比。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>dp</tag>
        <tag>经典trick</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC062 B. Split and Insert</title>
    <url>/2023/09/01/AGC062-B-Split-and-Insert/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc062/tasks/agc062_b">https://atcoder.jp/contests/agc062/tasks/agc062_b</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>非常有意思的一道题目。</p>
<p>我们考虑一个序列被切割以后进入一种如放的状态，简单来说就是我手里现在有两个序列可以拼起来。</p>
<p>当操作一次后会发现手里的两个序列变成了四个序列，而代价实际上就是原来两个序列裂成两个序列的代价之和（因为代价的计算公式是一次式）。</p>
<p>因此，显然，我们要把原串切成一堆上升序列，而代价都是可以自己独立统计后再加起来的，直接上区间 DP ，时间复杂度：$O(Kn^3)$ 。</p>
<p>无解的充分必要条件：最少的上升序列个数 $&gt;2^K$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 110</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">LL dp[N][N][N],C[N];</span><br><span class="line"><span class="type">int</span> n,K,a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;K);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;C[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        a[x]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,a[i]);</span></span><br><span class="line">    <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">20</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;a[i+<span class="number">1</span>])cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)cnt&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(cnt)&#123;<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dp[K+<span class="number">1</span>][i][i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[j<span class="number">-1</span>])<span class="keyword">break</span>;</span><br><span class="line">            dp[K+<span class="number">1</span>][i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=K;t&gt;=<span class="number">1</span>;t--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">                dp[t][i][j]=dp[t+<span class="number">1</span>][i][j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;j;k++)dp[t][i][j]=<span class="built_in">min</span>(dp[t+<span class="number">1</span>][i][k]+dp[t+<span class="number">1</span>][k+<span class="number">1</span>][j]+(j-k)*C[t],dp[t][i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=K+1;i++)&#123;</span></span><br><span class="line">    <span class="comment">//     for(int j=1;j&lt;=n;j++)&#123;</span></span><br><span class="line">    <span class="comment">//         for(int k=j;k&lt;=n;k++)printf(&quot;%d %d %d:%lld\n&quot;,i,j,k,dp[i][j][k]);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dp[<span class="number">1</span>][<span class="number">1</span>][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AGC061 B. Summation By Construction</title>
    <url>/2023/09/06/AGC061-B-Summation-By-Construction/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc061/tasks/agc061_b">https://atcoder.jp/contests/agc061/tasks/agc061_b</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>Mad，纯纯折磨题。</p>
<p>首先，$n=2$ 的时候是无解的，因为连出 $i=2$ 的路径后剩下的两条边无法连到一起。</p>
<p>做法的核心思想是，将两条路径拼到一起，考虑找出一个更长的路径，然后再拆开。</p>
<p>例如奇数的情况，是把路径拼成 $\frac{n+1}{2}$ 条长度为 $2n$ 的路径，然后拆出结果。</p>
<p>做法就是，下面分别从 $1,3,5..$ 开时重复连 M 型。（下面默认二分图上面部分有 $n$ 个点，下面部分有 $n+1$ 个点）</p>
<p>$n=5$ 的情况如下：</p>
<p><img src="1.png" alt=""></p>
<p>然后当时因为 $2$ 无解，而且偶数的情况我想不出来，感觉应该是无解，然后还证明了，然后就写了交上去，WA飞了，百思不得其解，下了数据才发现除了 $2$ 都有解，但是由于已经忘了怎么证了，也就不知道证明哪里假了。</p>
<p>所以，在做这种题目的时候，不能因为没想出来就主观认为无解（不然你猜猜这道题目的评级为什么 3000+ ），还是应该写个暴力或者手动再验证几组数据再下结论。</p>
<p>那么偶数怎么做呢？</p>
<p>同样的思路，我们发现 $i=n$ 一定会在下面产生两个奇数点，需要一条路径消掉，所以不妨考虑处理 $\frac{n}{2}+2$ 条路经，其中 $\frac{n}{2}-1$ 条处理上面为起终点的长度为 $2(n-1)$ 的路径，然后剩下三条路径一条以上面剩下两个奇数点为起终点，两条在下面。</p>
<p>首先是 $\frac{n}{2}-1$ 的路径，在上面分别以 $3,5,7…$ 为起点，以下面的 $n-1$ 个点为中转点抛出类似 M 的路径，被去掉的 $2$ 个点也是有规律的，按照 $(n-2,n-1),(n-4,n-3)…$ 这样下去。</p>
<p>剩下的边可以凑数长度为 $4,2n,2(n-3)$ 的路径，至于怎么凑，看代码吧。</p>
<p>时间复杂度：$O(Tn^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 110</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NN 210</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> v[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+i&lt;=n;i++)&#123;</span><br><span class="line">                <span class="type">int</span> cnt=<span class="number">0</span>;<span class="type">int</span> y=x;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    <span class="keyword">if</span>(cnt&lt;=i+i)v[j][y]=i;</span><br><span class="line">                    <span class="keyword">else</span> v[j][y]=n-i;</span><br><span class="line">                    cnt++;y++;<span class="keyword">if</span>(y==n+<span class="number">2</span>)y=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(cnt&lt;=i+i)v[j][y]=i;</span><br><span class="line">                    <span class="keyword">else</span> v[j][y]=n-i;</span><br><span class="line">                &#125;</span><br><span class="line">                x+=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> pre=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n/<span class="number">2</span>;i++)&#123;</span><br><span class="line">                <span class="type">int</span> x=i*<span class="number">2</span>+<span class="number">1</span>,t=n-i*<span class="number">2</span>,y=<span class="number">1</span>,cnt=pre+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(cnt==<span class="number">2</span> || cnt==n<span class="number">-3</span>)cnt++;</span><br><span class="line">                pre=cnt;</span><br><span class="line">                <span class="type">int</span> type=cnt;</span><br><span class="line">                <span class="comment">// printf(&quot;%d %d %d\n&quot;,x,y,t);</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;cnt)type=n<span class="number">-1</span>-cnt;</span><br><span class="line">                    v[x][y]=type;</span><br><span class="line">                    x++;<span class="keyword">if</span>(x==n+<span class="number">1</span>)x=<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// printf(&quot;%d %d %d\n&quot;,x,y,t);</span></span><br><span class="line">                    v[x][y]=type;</span><br><span class="line">                    y++;<span class="keyword">if</span>(y==n+<span class="number">2</span>)y=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span>(y==t || y==t+<span class="number">1</span>)&#123;y++;<span class="keyword">if</span>(y==n+<span class="number">2</span>)y=<span class="number">1</span>;&#125;</span><br><span class="line">                    <span class="comment">// printf(&quot;%d %d %d\n&quot;,x,y,t);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            v[<span class="number">1</span>][<span class="number">1</span>]=v[<span class="number">1</span>][<span class="number">2</span>]=v[n][<span class="number">2</span>]=v[n][n+<span class="number">1</span>]=n;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-2</span>;i++)v[n-i][n+<span class="number">2</span>-i]=v[n-i][n+<span class="number">1</span>-i]=n;</span><br><span class="line">            v[<span class="number">2</span>][<span class="number">1</span>]=v[<span class="number">2</span>][<span class="number">2</span>]=v[<span class="number">3</span>][<span class="number">2</span>]=v[<span class="number">3</span>][<span class="number">3</span>]=<span class="number">2</span>;</span><br><span class="line">            v[<span class="number">1</span>][<span class="number">3</span>]=v[<span class="number">4</span>][<span class="number">3</span>]=n<span class="number">-3</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">4</span>;i&lt;n;i++)v[i][i]=v[i+<span class="number">1</span>][i]=n<span class="number">-3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n+<span class="number">1</span>;j++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,v[i][j]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回顾：</p>
<p>这道题目其实还是挺有难度的，回顾一下做题过程纪念纪念自己花了这么久时间做出来的一道题目。</p>
<p>而且这道题目的做题过程其实也可以推广到很多存在性构造题上。</p>
<p>首先看到一个构造题，尤其是比较难的构造题，如果直接从其的题目条件出发很多时候不一定能做，因为情况太多，太过复杂和没有规律，这个时候就需要把问题缩小到一个有规律的题目上面，只不过这种缩小有时候可能会无解。</p>
<p>例如奇数的情况我就认为一定存在一种方案使得路径能够连接成 $\frac{n+1}{2}$ 条长度为 $2n$ 的路径，从而把题目变成了一个有规律更好想的题目，但是这种缩小有时候不一定正确，思考缩小的过程也是凭直觉，比较感性，灵感往往来源于自己手动模拟多次后作出的猜想。</p>
<p>再例如，我认为偶数也可以拼成 $\frac{n}{2}$ 条长度为 $2(n-1)$ 的路径，但是却发现剩下的边构成了一个环（事实上想想也知道肯定不是路径，因为此时图中不存在奇数度的点），那么就把一条路径放回去，尝试人为的构造出三条路径。</p>
<p>而且这一步从度数的角度考虑也非常的正确，因为 $i=n$ 的路径一定会在下面创造一对奇数度点，所以我们必须把上面一条由两条路径拼成的路径拆回两条，一条占住他们本来的奇数度点，一条下来消掉 $i=n$ 创造的奇数度点。</p>
<p>然后通过这个操作，问题规模就缩小很多了，接下来就可以自己不断手模求一个通用解了，这样偶数的情况也就搞定了。</p>
<p>所以构造题，往往就是你自己再给题目加上一些约束条件，看看能否找到一个解，找不到就不断调整约束条件，直到找到为止。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC063 C. Add Mod Operations</title>
    <url>/2023/09/01/AGC063-C-Add-Mod-Operations/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc063/tasks/agc063_c">https://atcoder.jp/contests/agc063/tasks/agc063_c</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>无解的充分必要条件：</p>
<p>存在 $i,j(i≠j)$ ，使得 $a_i=a_j,b_i≠b_j$ 。</p>
<p>有解时的构造方法：</p>
<p>设 $c_i$ 表示 $a_i$ 在 $a$ 序列里面从大到小排序的位置。</p>
<p>考虑构造一个这样的序列：$b_i+c_i*K$ ，$K$ 表示一个大于所有 $a$ 的数字。</p>
<p>然后最后全部模 $K$ 就行了。</p>
<p>怎么构造这个序列呢？考虑不算次数的情况，那么先把所有数字加个 INF ，然后每次让当前最大的数字变成 $0$，并且再变成 $0$ 之前加上这个数字与前一个变成 $0$ 的数字之间的间隔，然后就做完了。</p>
<p>然后只要精细化的处理一下这个过程，就可以办到恰好 $n$ 次做完这个过程。</p>
<p>时间复杂度：$O(n\log{n})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,LL&gt; PLL;</span><br><span class="line"><span class="type">const</span> LL inf=<span class="number">1e16</span>;</span><br><span class="line">LL a[N],b[N];<span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> top,sta[N];LL now,d[N];</span><br><span class="line">PLL c[N];LL maxcost=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> a[x]&gt;a[y];&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;b[i]);maxcost=<span class="built_in">max</span>(maxcost,b[i]+<span class="number">1</span>);&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">bool</span> bk=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((a[j]==a[i]) &amp;&amp; (b[j]!=b[i]))&#123;<span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;i &amp;&amp; a[j]==a[i])bk=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!bk)sta[++top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(sta+<span class="number">1</span>,sta+top+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;top;i++)d[i]=(top-i<span class="number">-1</span>)*maxcost+b[sta[i]];</span><br><span class="line">    now=inf;LL nowx=now%maxcost;now+=(b[sta[top]]-nowx+maxcost)%maxcost;now-=a[sta[top]];</span><br><span class="line">    c[top].second=maxcost;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Yes\n%d\n&quot;</span>,top);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=top;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=top)c[i].second=now+a[sta[i]];</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">1</span>)c[i].first=d[i<span class="number">-1</span>]-d[i],now-=c[i].first;</span><br><span class="line">    &#125;</span><br><span class="line">    c[<span class="number">1</span>].first=now;</span><br><span class="line">    <span class="keyword">if</span>(top==<span class="number">1</span>)c[<span class="number">1</span>].first%=c[<span class="number">1</span>].second;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;i++)<span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>,c[i].first,c[i].second);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>AGC065 D. Not Intersect</title>
    <url>/2024/02/11/AGC065-D-Not-Intersect/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc065/tasks/agc065_d">https://atcoder.jp/contests/agc065/tasks/agc065_d</a></p>
<p>题目大意：圆上有 $n$ 个点，问有多少种连法，使得有 $m$ 条边且边不交叉（可以在端点处相交）</p>
<p>$n,m\le 10^7$ </p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>神仙组合意义，投降。</p>
<p>当 $m=0$ 或者 $m&gt;2n-3$ 时可以直接输出答案，下面默认 $n\ge 2,0&lt;m\le 2n-3$</p>
<p>设 $f_i$ 表示 $n$ 个点 $i$ 条边的答案，$g_i$ 表示 $n$ 个点 $i$ 条边且允许重边的答案。</p>
<p>显然有：$f_n=\sum\limits_{i=1}^n\binom{n-1}{i-1}g_i$</p>
<p>则由二项式反演有：$g_n=\sum\limits_{i=1}^{n}(-1)^{n-i}\binom{n-1}{i-1}f_i$ 。</p>
<p>现在考虑怎么计算 $g_i$ ，考虑边不能交叉这个条件，如果你足够智慧，你就会发现有一个结构很符合这个要求：栈。</p>
<p>现在我们用这么一个过程去描述连边的过程：</p>
<p>从 $1$ 到 $n$ ，到达 $i$ 的时候，先弹出栈内的若干元素，再往栈内加入若干个 $i$ ，到最后栈为空，如果 $i$ 在 $j$ 的时候弹出就代表了一条 $(i,j)$ 的边。</p>
<p>显然，这个过程一一对应，现在就是计数了。</p>
<p>可以发现，$1$ 只能入栈，$n$ 只能出栈，所以我们不妨改为 $n-1$ 次入栈和出栈。（接下来假设要求 $g_k$ 的值）</p>
<p>现在就是 $a_i$ 表示入栈的次数，$b_i$ 表示出栈的次数，满足：</p>
<script type="math/tex; mode=display">1\le i\le n-1,a_i\ge b_i,0\le a_i,b_i \le k,a_i\le a_{i+1},b_i\le b_{i+1},a_{n-1}=b_{n-1}=k</script><p>显然，一个合法的 $a$ 序列代表了一条从 $(0,0)$ 到 $(n-2,k)$ 只能向右或者向上的的路径，$b$ 同理。</p>
<p>则一个合法的 $a,b$ 序列对应了两条合法的路径，且满足一条路径始终在另外一条路径下端。</p>
<p>可以发现，我们设 $0$ 为向右，$1$ 为向上，假设我们能计算有 $a$ 个 $0$ ，$b$ 个 $1$ 时有多少对路径满足第二条路径在第一条路径下方，称作函数 $calc(a,b)$ ，那么我们所求的就是 $calc(n-2,k)$ 。</p>
<p>研究第 $i$ 步，可以发现就四种情况：$(0,0),(0,1),(1,0),(1,1)$ ，可以发现，就是要让每个时刻 $(1,0)$ 的数量不少于 $(0,1)$ 的数量，如果用折线法描述就是上面是：$0,-1,0,1$ ，然后不要让折线低过 $x$ 轴，显然，$-1,1$ 的数量是一样的，枚举 $1$ 的数量就可以知道四种情况的数量了：</p>
<script type="math/tex; mode=display">
\begin{align*} 
calc(a,b)&=\sum\limits_{i=0}^{min(a,b)}\frac{(2i)!}{i!(i+1)!}*\binom{a+b-2i}{a-i}*\binom{(a+b-2i)+(2i+1)-1}{(2i+1)-1}\\
&=\sum\limits_{i=0}^{min(a,b)}\frac{(2i)!}{i!(i+1)!}*\binom{a+b-2i}{a-i}*\binom{a+b}{2i}\\ 
&=\sum\limits_{i=0}^{min(a,b)}\frac{(2i)!}{i!(i+1)!}*\frac{(a+b-2i)!}{(a-i)!(b-i)!}*\frac{(a+b)!}{(2i)!(a+b-2i)!}\\ 
&=\sum\limits_{i=0}^{min(a,b)}\frac{(a+b)!}{i!(i+1)!(a-i)!(b-i)!}\\
&=\frac{(a+b)!}{a!(b+1)!}\sum\limits_{i=0}^{min(a,b)}\frac{a!}{i!(a-i)!}\frac{(b+1)!}{(i+1)!(b-i)!}\\
&=\frac{(a+b)!}{a!(b+1)!}\sum\binom{a}{i}\binom{b+1}{b-i}\\
&=\frac{(a+b)!}{a!(b+1)!}\binom{a+b+1}{b}\\
&=\frac{(a+b)!(a+b+1)!}{a!b!(a+1)!(b+1)!}
\end{align*}</script><p>然后直接算就行了。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e7</span>+<span class="number">105</span>;</span><br><span class="line">LL fc[N],nfc[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> L=<span class="number">3e7</span>+<span class="number">3</span>;</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=L;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=L;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;LL m;</span><br><span class="line">LL g[N];</span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fc[a+b+<span class="number">1</span>]*fc[a+b]%mod*nfc[a]%mod*nfc[b]%mod*nfc[a+<span class="number">1</span>]%mod*nfc[b+<span class="number">1</span>]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">if</span>(!m)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;n+n<span class="number">-3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//n&gt;=2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)g[i]=<span class="built_in">calc</span>(n<span class="number">-2</span>,i);</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((m-i)&amp;<span class="number">1</span>)ans=(ans-g[i]*<span class="built_in">C</span>(m<span class="number">-1</span>,i<span class="number">-1</span>)%mod+mod)%mod;</span><br><span class="line">        <span class="keyword">else</span> ans=(ans+g[i]*<span class="built_in">C</span>(m<span class="number">-1</span>,i<span class="number">-1</span>))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h6 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h6><p>没有生成函数做法。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC135 赛后总结</title>
    <url>/2024/06/25/ARC135-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://atcoder.jp/contests/arc135/tasks/arc135_a">https://atcoder.jp/contests/arc135/tasks/arc135_a</a></p>
<h1 id="A-Floor-Ceil-Decomposition"><a href="#A-Floor-Ceil-Decomposition" class="headerlink" title="A. Floor, Ceil - Decomposition"></a>A. Floor, Ceil - Decomposition</h1><p>题目链接：<a href="https://atcoder.jp/contests/arc135/tasks/arc135_a">https://atcoder.jp/contests/arc135/tasks/arc135_a</a></p>
<p>题目大意：每次你可以选择一个数字，分为 $\left\lfloor \frac{x}{2} \right\rfloor, \left\lceil \frac{x}{2} \right\rceil$ ，一开始只有一个数字 $X$ ，问你最终可能的乘积最大值是多少。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>很弱智，显然 $\ge 4$ 直接分就行了。</p>
<p>最后只会剩下 $2,3$ 。</p>
<p>但是我的写法比较 SB 。</p>
<p>我写了个堆 + map，每次把最大数字弹出并且记录个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function">LL <span class="title">ksm</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">    x %= mod;</span><br><span class="line">    LL ans = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ans = ans * x % mod;</span><br><span class="line">        x = x * x % mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">map&lt;LL, LL&gt; m;</span><br><span class="line">priority_queue&lt;LL&gt; p;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m.<span class="built_in">find</span>(x) == m.<span class="built_in">end</span>()) p.<span class="built_in">push</span>(x);</span><br><span class="line">    m[x] += y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    m[x] = <span class="number">1ll</span>;</span><br><span class="line">    p.<span class="built_in">push</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(p.<span class="built_in">top</span>() &gt;= <span class="number">4</span>)&#123;</span><br><span class="line">        LL x = p.<span class="built_in">top</span>();</span><br><span class="line">        p.<span class="built_in">pop</span>();</span><br><span class="line">        LL cnt = m[x];</span><br><span class="line">        LL a = x / <span class="number">2</span>, b = x - a;</span><br><span class="line">        <span class="built_in">add</span>(a, cnt);</span><br><span class="line">        <span class="built_in">add</span>(b, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">while</span>(!p.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        LL x = p.<span class="built_in">top</span>();</span><br><span class="line">        p.<span class="built_in">pop</span>();</span><br><span class="line">        ans = ans * <span class="built_in">ksm</span>(x, m[x]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有没有更加好写的写法？</p>
<p>有，记忆化搜索。</p>
<p>也是我认为最好写的写法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line">map&lt;LL, LL&gt; dp;</span><br><span class="line"><span class="function">LL <span class="title">dfs</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp.<span class="built_in">find</span>(x) != dp.<span class="built_in">end</span>()) <span class="keyword">return</span> dp[x];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> dp[x] = <span class="built_in">dfs</span>(x / <span class="number">2</span>) * <span class="built_in">dfs</span>(x - x / <span class="number">2</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    dp[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    LL n; cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dfs</span>(n) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一种写法是直接记录 $\left\lfloor \frac{x}{2^k} \right\rfloor, \left\lceil \frac{x}{2^k} \right\rceil$ 以及其个数，直到组合为 $\{2,3\},\{3,4\}$ 时结束。</p>
<p>但我个人感觉这种写法就算比第一种写法好写，也容易写错，所以赛时没有使用。</p>
<p>具体代码没写。</p>
</div></details>
<h1 id="B-Sum-of-Three-Terms"><a href="#B-Sum-of-Three-Terms" class="headerlink" title="B. Sum of Three Terms"></a>B. Sum of Three Terms</h1><p>题目链接：<a href="https://atcoder.jp/contests/arc135/tasks/arc135_b">https://atcoder.jp/contests/arc135/tasks/arc135_b</a></p>
<p>题目大意：给你一个数组 $S$ ，要求找到一个长度为 $n+2$ 的数组 $A$ 满足：</p>
<ol>
<li>非负。</li>
<li>$S[i]=A[i]+A[i+1]+A[i+2]$</li>
</ol>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>注意到 $S[i+1]-S[i]=A[i+3]-A[i]$ 。</p>
<p>所以条件可以等价成：$A[1]+A[2]+A[3]=S[1]$ ，以及 $A[i]-A[i-3]=k$ ，以及要求非负。</p>
<p>那么直接求出在非负条件下 $A[1],A[2],A[3]$ 的下界，然后直接随便定个初值就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> LL inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">LL S[N], sum[N];</span><br><span class="line">LL l[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        cin &gt;&gt; S[i];</span><br><span class="line">    &#125;</span><br><span class="line">    l[<span class="number">0</span>] = l[<span class="number">1</span>] = l[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        sum[i] = sum[i - <span class="number">3</span>] + S[i] - S[i <span class="number">-1</span>];</span><br><span class="line">        l[i % <span class="number">3</span>] = <span class="built_in">max</span>(l[i % <span class="number">3</span>], -sum[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l[<span class="number">0</span>] + l[<span class="number">1</span>] + l[<span class="number">2</span>] &gt; S[<span class="number">2</span>])&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">    l[<span class="number">2</span>] = S[<span class="number">2</span>] - l[<span class="number">0</span>] - l[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        l[i] = l[i % <span class="number">3</span>] + sum[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        cout &lt;&lt; l[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟官方做法本质相同，在此不再赘述。</p>
</div></details>
<h1 id="C-XOR-to-All"><a href="#C-XOR-to-All" class="headerlink" title="C. XOR to All"></a>C. XOR to All</h1><p>题目链接：<a href="https://atcoder.jp/contests/arc135/tasks/arc135_c">https://atcoder.jp/contests/arc135/tasks/arc135_c</a></p>
<p>题目大意：给你一个序列，每次可以选择其中一个数字，然后让序列中所有数字异或这个数字，问最后得到的和的最大值是多少，可以操作无数次。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>注意到一个事情，最终答案一定是所有序列异或上某个数字，而且只要操作过，就一定有数字为 $0$ ，综上，我们直到无论操作多少次，都等价于让序列异或上原来序列中的一个数字，也就是操作多次=操作一次。</p>
<p>所以直接枚举统计答案就行了。</p>
<p>时间复杂度：$O(n\log{V})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L = <span class="number">30</span>;</span><br><span class="line">LL cnt[L], n, a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; L; j++) cnt[j] += (a[i] &gt;&gt; j) &amp; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        ans += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        LL now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; L; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((a[i] &gt;&gt; j) &amp; <span class="number">1</span>) now += (<span class="number">1ll</span> &lt;&lt; j) * (n - cnt[j]);</span><br><span class="line">            <span class="keyword">else</span> now += (<span class="number">1ll</span> &lt;&lt; j) * cnt[j];</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, now);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="D-Add-to-Square"><a href="#D-Add-to-Square" class="headerlink" title="D. Add to Square"></a>D. Add to Square</h1><p>题目链接：<a href="https://atcoder.jp/contests/arc135/tasks/arc135_d">https://atcoder.jp/contests/arc135/tasks/arc135_d</a></p>
<p>题目大意：给一个表格，然后可以执行一个操作：选择一个 2*2 的子矩阵，然后让其加上同一个值（可以为负数），可以执行无数次，问最小的可能的绝对值和是多少。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>一个很典的想法是，先给这个操作找到不变量。</p>
<p>可以发现，如果将表格奇偶染色，然后将奇数格变成负的，然后将操作做对应的变换，那么整个矩阵的和就是不变量，而且不影响最终答案。（显然取负值并不改变绝对值的和）</p>
<p>所以变成这样的问题：选择一个 2*2 的矩阵，使得 $(1,1),(2,2)$ 加上 $x$ ，$(1,2),(2,1)$ 减去 $x$ 。</p>
<p>又可以发现，这里我们相当于有 $(n-1)(m-1)$ 个方程，且不线性相关，所以我们能把左上角消成 $0$ ，只保留最右边和最下边。</p>
<p>但是剩下的数字是多少，这个时候就可以发现，其实每行和每列的和也是不变量，这决定了在把左上角矩阵消成 $0$ 后的矩阵长啥样。</p>
<p>接着就可以发现：两个矩阵能互相到达当且仅当每行和每列的和是一样的。</p>
<p>然后就可以做了，不难发现答案的上界是：行的和的绝对值和，和列的和的绝对值和的最大值。</p>
<p>构造方案就是一个匹配的活。</p>
<p>时间复杂度：$O(nm+n^2+m^2)$ 。</p>
<p>做毕。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e2</span> + <span class="number">5</span>;</span><br><span class="line">LL a[N][N], b[N][N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">LL row[N], col[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="number">-1</span> : (x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">            <span class="keyword">if</span>((i + j) &amp; <span class="number">1</span>) a[i][j] = -a[i][j];</span><br><span class="line">            row[i] += a[i][j];</span><br><span class="line">            col[j] += a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="type">int</span> type = <span class="number">0</span>;</span><br><span class="line">    LL ans = <span class="number">0ll</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        LL ans1 = <span class="number">0ll</span>, ans2 = <span class="number">0ll</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans1 += <span class="built_in">abs</span>(row[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) ans2 += <span class="built_in">abs</span>(col[i]);</span><br><span class="line">        <span class="keyword">if</span>(ans1 &lt; ans2)&#123;</span><br><span class="line">            type = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">swap</span>(n, m);</span><br><span class="line">            <span class="built_in">swap</span>(row, col);</span><br><span class="line">            <span class="built_in">swap</span>(ans1, ans2);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = ans1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(col[i] != <span class="number">0</span>) &#123;x = i; <span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">int</span> y = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">sgn</span>(col[x]) == <span class="built_in">sgn</span>(row[i]))&#123;</span><br><span class="line">                y = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(y != <span class="number">-1</span>);</span><br><span class="line">        a[y][x] = <span class="built_in">sgn</span>(col[x]) * <span class="built_in">min</span>(<span class="built_in">abs</span>(col[x]), <span class="built_in">abs</span>(row[y]));</span><br><span class="line">        col[x] -= a[y][x];</span><br><span class="line">        row[y] -= a[y][x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(row[i] != <span class="number">0</span>) &#123;x = i; <span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">int</span> y = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(row[i] != <span class="number">0</span> &amp;&amp; <span class="built_in">sgn</span>(row[x]) != <span class="built_in">sgn</span>(row[i]))&#123;</span><br><span class="line">                y = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LL val = <span class="built_in">min</span>(<span class="built_in">abs</span>(row[x]), <span class="built_in">abs</span>(row[y]));</span><br><span class="line">        a[x][<span class="number">1</span>] += <span class="built_in">sgn</span>(row[x]) * val;</span><br><span class="line">        a[y][<span class="number">1</span>] += <span class="built_in">sgn</span>(row[y]) * val;</span><br><span class="line">        row[x] -= <span class="built_in">sgn</span>(row[x]) * val;</span><br><span class="line">        row[y] -= <span class="built_in">sgn</span>(row[y]) * val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(type)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) b[i][j] = a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) a[j][i] = b[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(n, m);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i + j) &amp; <span class="number">1</span>) a[i][j] = -a[i][j];</span><br><span class="line">            cout &lt;&lt; a[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="E-Sequence-of-Multiples"><a href="#E-Sequence-of-Multiples" class="headerlink" title="E. Sequence of Multiples"></a>E. Sequence of Multiples</h1><p>题目链接：<a href="https://atcoder.jp/contests/arc135/tasks/arc135_e">https://atcoder.jp/contests/arc135/tasks/arc135_e</a></p>
<p>题目大意：给定 $N,X$ ，要求构造一个和最小的长度为 $N$ 的序列 $A$ 满足：</p>
<ol>
<li>严格递增。</li>
<li>$A_1=X$</li>
<li>$A_{i}$ 被 $i$ 整除。</li>
</ol>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>注意到一个事情：$A_i=i*B_i$ 。</p>
<p>那么 $A_{i}\equiv -B_i \mod{i+1}$ 。</p>
<p>我们显然关心 $A_{i+1}-A_{i}$ ，而这个显然等于：$B_{i}\mod i+1$ （注，由于严格递增，在整除的时候为 $i+1$）</p>
<p>当 $B_{i}&lt;i+1$ 时，就为 $B_{i}$ ，而且不难发现以后也为 $B_{i}$ 。</p>
<p>即 $B_{i}$ 是非严格单调递减的，而且当 $B_{i}\le i+1$ 后，$B_{i}$ 保持恒定。</p>
<p>具体来说：$B_{i+1}=B_{i}-\left\lfloor\frac{B_{i}-1}{i+1}\right\rfloor$</p>
<p>但是我们可以发现，这个保持恒定的量级可以到 $10^9$ 。</p>
<p>$\ge$ 是显然的，$\le$ 也不难：</p>
<p>往极坏的角度想：在 $i$ 的时候就 $+i$ 。</p>
<p>那么在 $2e9$ 的时候就是：$1e18+\frac{(2e9+1)*2e9}{2}&lt;2e9^2$ 。</p>
<p>所以在 $\le 2e9$ 的时候进入恒定状态。</p>
<p>但我们显然不可能枚举这个量级，怎么办呢？</p>
<p>在苦思冥想下，我突然意识到，复杂度有没有可能是：$O(n^{\frac{1}{3}})$ 的。</p>
<p>因为可以发现在 $1e6$ 量级后，$\frac{B_i-1}{i}$ 的量级也是 $1e6$ 的。（与上面的证明方法类似）</p>
<p>而且 $\left\lfloor\frac{B_{i}-1}{i+1}\right\rfloor$ 是单调递减的，这意味着 $B_{i+1}-B_{i}$ 在 $1e6$ 之后只会有 $1e6$ 种可能的取值。（以上指的都是量级）</p>
<p>所以直接二分出每个可能取值的分界点，就可以在 $O(n^{\frac{1}{3}}\log{n})$ 的复杂度内解决了。</p>
<p>后面发现二分的判别式是一个线性函数，因此可以 $O(1)$ 找到分界点。</p>
<p>而且类似整除分块的，在 $1e6$ 之前的部分同样也可以用这个函数处理，因为也只有 $1e6$ 种取值，不过限制取值数量的条件不是值域，而是定义域，这时求出来的分界点很集中，基本就是自己。</p>
<p>然后就做完了。</p>
<p>时间复杂度：$O(Tn^{\frac{1}{3}})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function">LL <span class="title">ksm</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">    LL ans = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ans = ans * x % mod;</span><br><span class="line">        x = x * x % mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ni</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">ksm</span>(x, mod - <span class="number">2</span>);&#125;</span><br><span class="line"><span class="type">const</span> LL n2 = <span class="built_in">ni</span>(<span class="number">2</span>), n4 = <span class="built_in">ni</span>(<span class="number">4</span>), n6 = <span class="built_in">ni</span>(<span class="number">6</span>);</span><br><span class="line"><span class="function">LL <span class="title">mt</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> (x % mod + mod) % mod;&#125;</span><br><span class="line"><span class="function">LL <span class="title">q1</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">mt</span>(x) * <span class="built_in">mt</span>(x + <span class="number">1</span>) % mod * n2 % mod;&#125;</span><br><span class="line"><span class="function">LL <span class="title">q1</span><span class="params">(LL l, LL r)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">mt</span>(<span class="built_in">q1</span>(r) - <span class="built_in">q1</span>(l - <span class="number">1</span>));&#125;</span><br><span class="line"><span class="function">LL <span class="title">q2</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">mt</span>(x) * <span class="built_in">mt</span>(x + <span class="number">1</span>) % mod * <span class="built_in">mt</span>(x + x + <span class="number">1</span>) % mod * n6 % mod;&#125;</span><br><span class="line"><span class="function">LL <span class="title">q2</span><span class="params">(LL l, LL r)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">mt</span>(<span class="built_in">q2</span>(r) - <span class="built_in">q2</span>(l - <span class="number">1</span>));&#125;</span><br><span class="line"><span class="comment">// LL q3(LL x)&#123;return mt(x) * mt(x) % mod * mt(x + 1) % mod * mt(x + 1) % mod * n4 % mod;&#125;</span></span><br><span class="line"><span class="comment">// LL q3(LL l, LL r)&#123;return mt(q3(r) - q3(l - 1));&#125;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        LL n, X, ans = <span class="number">0ll</span>;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; X;</span><br><span class="line">        ans = <span class="built_in">mt</span>(n) * <span class="built_in">mt</span>(X) % mod;</span><br><span class="line">        LL val = <span class="number">2ll</span>;</span><br><span class="line">        <span class="keyword">while</span>(val &lt; X &amp;&amp; val &lt;= n)&#123;</span><br><span class="line">            LL cnt = (X - <span class="number">1</span>) / val;</span><br><span class="line">            LL l = val + <span class="number">1</span>, r = <span class="built_in">min</span>(X / cnt, n), mid, pos = val;</span><br><span class="line">            pos = <span class="built_in">min</span>((X + cnt * val - <span class="number">1</span>) / (cnt + cnt), n);</span><br><span class="line">            ans += <span class="built_in">mt</span>(X + val * cnt) * <span class="built_in">mt</span>(n + <span class="number">1</span>) % mod * <span class="built_in">mt</span>(pos - val + <span class="number">1</span>) % mod;</span><br><span class="line">            ans -= <span class="built_in">mt</span>(X + val * cnt) * <span class="built_in">q1</span>(val, pos) % mod;</span><br><span class="line">            ans -= <span class="built_in">mt</span>(cnt + cnt) * <span class="built_in">mt</span>(n + <span class="number">1</span>) % mod * <span class="built_in">q1</span>(val, pos) % mod;</span><br><span class="line">            ans += <span class="built_in">mt</span>(cnt + cnt) * <span class="built_in">q2</span>(val, pos) % mod;</span><br><span class="line"></span><br><span class="line">            ans = <span class="built_in">mt</span>(ans);</span><br><span class="line"></span><br><span class="line">            X -= cnt * (pos - val + <span class="number">1</span>);</span><br><span class="line">            val = pos + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val &lt;= n)&#123;</span><br><span class="line">            <span class="built_in">assert</span>(X &lt;= val);</span><br><span class="line">            ans += <span class="built_in">mt</span>(n - val + <span class="number">2</span>) * <span class="built_in">mt</span>(n - val + <span class="number">1</span>) % mod * n2 % mod * X;</span><br><span class="line">            ans = <span class="built_in">mt</span>(ans);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但因为没在赛时推出正确的式子，导致无法在赛时 AC 。</p>
<p>不过是 VP ，问题也不是那么大。</p>
<p>和官方做法基本一致，在此不再赘述官方做法。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">别的做法</summary><div class="toggle-content"><p><a href="https://www.luogu.com.cn/article/thzagqey">https://www.luogu.com.cn/article/thzagqey</a></p>
<p>有一种做法，是打表，发现在 $\sqrt{x}$ 后 $A$ 变成了等差数列。</p>
<p>差分一下，发现序列由 $n^{\frac{1}{3}}$ 段等差数列构成，并且总是在即将 $\le 0$ 后转换到下一个等差数列。</p>
<p>更准确的来讲，是说可以把序列分成若干段等差数列，每段都在即将 $\le 0$ 时结束，等差数列的长度可以为 $1$ 。（后面会讲为什么）</p>
<p>直接计算就行了。</p>
<p>时间复杂度：$O(Tn^{\frac{1}{3}})$ 。</p>
<p>问题来了，为什么？</p>
<p>首先等差数列不难理解，在我的做法中，$B_{i-1}-\left\lfloor\frac{B_{i-1}-1}{i}\right\rfloor<em>i=B_{i-1}-(B_{i-1}-B_{i})</em>i=B_{i}<em>i-B_{i-1}</em>(i-1)=A_{i}-A_{i-1}$ 就是 $A$ 的差分，二分中的每一段实际就是 $B$ 差分相等的部分，即我们认为：$B_{i+k}=B_{i}-kd$ 。</p>
<p>则有：</p>
<script type="math/tex; mode=display">\begin{align*}

&B_{i+k}(i+k)-B_{i+k-1}(i+k-1) \\
=&(B_{i}-kd)(i+k)-(B_{i}-(k-1)d)(i+k-1) \\
=&B_{i}-kd-d(i+k-1) \\
=&B_{i}-2dk-d(i-1) \\
=&-2dk+(B_{i}-d(i-1))

\end{align*}</script><p>即 $A$ 的一阶差分是个等差数列。</p>
<p>但为什么总是在即将 $\le 0$ 后转换到下一个等差数列呢？</p>
<p>而分界点的条件可以表示为：</p>
<p>最大的 $k$ 满足：$\left\lfloor\frac{B_{i+(k-1)}-1}{i+k}\right\rfloor \ge d,\left\lfloor\frac{B_{i+k}-1}{i+k+1}\right\rfloor &lt; d$ ，这里 $\ge$ 可以写成 $=$ 。</p>
<p>也就是：</p>
<script type="math/tex; mode=display">
\begin{align*}
\left\lfloor\frac{B_{i+k-1}-1}{i+k}\right\rfloor &\ge d \\
B_{i}-(k-1)d-1&\ge d(i+k)\\
B_{i}&\ge 2dk+d(i-1)+1\\
B_{i}-2dk-d(i-1)&\ge 1\\
A_{i+k}-A_{i+k-1}&\ge 1\\

\left\lfloor\frac{B_{i+k}-1}{i+k+1}\right\rfloor &< d\\
B_{i}-kd-1&<d(i+k+1)\\
B_{i}&<2d(k+1)+d(i-1)+1\\
B_{i}-2d(k+1)-d(i-1)&<1\\

\end{align*}</script><p>这就证明了这件事情。</p>
<p>但需要注意的是：可以发现，一段长度为 $len+1$ 的 $B$ 的等差数列，对应 $A$ 的差分序列的一段长度为 $len$ 的等差数列，因此会有很多长度为 $1$ 的等差数列。（虽然可以认为相邻两个数字是等差数列，但是这种等差数列并不满足上面的将要 $\le 0$ 就切换到另外一个等差数列的性质）</p>
<p>为此，在实现中的一个简单的解决方法是直接算出后 $10$ 项，如果满足等差数列就直接算，赌他不会这么巧恰好由 $10$ 个长度为 $1$ 的等差数列构成。</p>
<p>但是我们还是希望知道什么时候 $len$ 会稳定的 $\ge 2$ 呢？</p>
<p>我们先设 $C_{i}=B_{i}-1$ ，那么 $C_{i+1}=C_{i}-\left\lfloor\frac{C_{i}}{i+1}\right\rfloor$ 。</p>
<p>那么问题可以抽象成这样：</p>
<p>现在有 $i+1$ 个柱子，均匀放，每次将最少东西的柱子的东西删除，再添加一个柱子均匀放，问经过几轮后能够出现稳定两轮删除的东西数相同？</p>
<p>设 $D_{i}=\left\lfloor\frac{C_{i}}{i+1}\right\rfloor$ ，这里给一个必要条件，当 $D_{i-1} ≠ D_{i}$ 且 $6D_{i}+1\le i$ 时，在此之后 $len\ge 1$ 。</p>
<p>证明就是假定一个 $i*D_{i-1}$ 的长方形（这样对后面的亏损是最大化的），然后开做这个补的过程，发现可以做至少两次，同时可以证明此时 $D_{i-1}=D_{i}+1$ ，所以只能用最上面那一行来补就证明完了。</p>
<script type="math/tex; mode=display">\begin{align*}
D_{i}&\le \frac{i-1}{6}\\
C_{i}&\le (i+1)D_{i}+i\le \frac{i^2-1}{6}+i\\
B_{i}=C_{i}+1&\le \frac{i^2+6i+5}{6}\\
A_{i}&\le \frac{i^2+6i+5}{6}*i\\
\end{align*}</script><p>我们想要估计出 $i$ 的量级：</p>
<script type="math/tex; mode=display">\begin{align*}
A_1+\frac{i(i+1)}{2}&\le \frac{i^2+6i+5}{6}*i\\
10^{18}&\le \frac{i^2+6i+5}{6}*i-\frac{i(i+1)}{2}\\
\end{align*}</script><p>这条式子在 $\ge 2*10^6$ 处总是满足，而且显然是 $O(n^{\frac{1}{3}})$ 的。</p>
<p>问题就在于什么时候：$D_{i}≠D_{i+1}$ 。</p>
<p>设 $a_{i}=A_{i}-A_{i-1}$ 。</p>
<p>如果 $a_{i+1}&gt;a_{i}$ 或者 $a_{i}-a_{i-1}≠a_{i+1}-a_{i}$ ，那么显然 $D_{i}≠D_{i-1}$ 。</p>
<p>否则：$a_{i-1}\ge a_{i}\ge a_{i+1},a_{i-1}-a_{i}=a_{i}-a_{i+1}$ ，那么有如果 $D_{i-1}≠D_{i}$ ，那么从 $i$ 开始就有长度为 $2$ 的等差数列，公差为 $a_{i}-a_{i+1}$，否则 $D_{i-1}=D_{i}$ ，这个时候 $i$ 依旧是公差为 $a_{i}-a_{i+1}$ 的等差数列的一部分，直接计算就行了。</p>
<p>也就是说，在 $2e6$ 后我们可以在 $O(1)$ 的时间进入求等差数列的过程，这个过程就是：求出公差，一直算到 $\le 0$ 为止，然后接着求下一段直到 $\ge n$ 。（因为 $A$ 为等差数列的阶段等价于 $a$ 为恒为 $0$ 的等差数列的阶段，只不过这个等差数列不会结束而已）</p>
<p>这样这个做法就比较好实现了。</p>
<p>综上，时间复杂度：$O(Tn^{\frac{1}{3}})$ 。<del>但问题是如果我都会证明这个了为什么不直接用上面这个做法</del></p>
<p>其实说的道理，既然一开始就选择了打表，不妨在实现时就使用多算几项估计一下等差数列，也不会有多难写，还充分发扬了打表省时间的优势，如果尝试证明的话就会浪费不少时间了，不过赛后确实可以花时间证证。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AH2017/HNOI2017 影魔</title>
    <url>/2025/02/05/AH2017-HNOI2017-%E5%BD%B1%E9%AD%94/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>[AH2017/HNOI2017]影魔：<a href="https://www.luogu.com.cn/problem/P3722">https://www.luogu.com.cn/problem/P3722</a></p>
<h1 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h1><h2 id="做法1（口胡）"><a href="#做法1（口胡）" class="headerlink" title="做法1（口胡）"></a>做法1（口胡）</h2><p>这个做法估计会T</p>
<p>考虑每个数字连向后面第一个比他大的树，对一个区间建一颗树，对于 $i&lt;j&lt;k,a_i&lt;a_j&lt;a_k$ 的询问，即为树上每个点 $dep-2$ 之和，然后其余类似，用莫队维护，时间复杂度：$O(n\sqrt{n})$，常数和码量都巨大，于是没有打，膜了题解。</p>
<p>当然，至于为什么为 $dep-2$ 之和，因为我们默认 $i&lt;j&lt;k,a_i&lt;a_j&lt;a_k$ 是由 $(i,k)$ 区间中最大的数字来找到这个区间。</p>
<h2 id="做法2"><a href="#做法2" class="headerlink" title="做法2"></a>做法2</h2><p>以下摘自此博客：<a href="https://www.luogu.com.cn/blog/AAAALL12138/solution-p3722">https://www.luogu.com.cn/blog/AAAALL12138/solution-p3722</a></p>
<p>这个题可以采取离线处理的方式.先处理出每个点 $i$ 左边第一个比它大的点 $L[i]$，和右边第一个比它大的点 $R[i]$。</p>
<p>那么对于区间 $L[i]$ 到 $R[i]$ 有 $p1$ 的贡献。①</p>
<p>对于左端点在 $L[i]+1$ 到 $i-1$，右端点为 $R[i]$ 的区间有 $p2$ 的贡献。②</p>
<p>对于左端点为 $L[i]$，右端点为 $i+1$ 到 $R[i]-1$ 的区间也有 $p2$ 的贡献。③</p>
<p>所以我们离线排序处理好。</p>
<p>对于①情况，我们在扫到 $R[i]$ 时，更新点 $L[i]$ 的贡献。</p>
<p>对于②情况，我们在扫到 $R[i]$ 时，更新区间 $L[i]+1$ 到 $i-1$ 的贡献。</p>
<p>对于③情况，我们在扫到 $L[i]$ 时，更新区间 $i+1$ 到 $R[i]-1$ 的贡献。</p>
<p>我们对于每个询问 $[l,r]$，在扫到 $l-1$ 时，我们记录此时区间 $l$ 到 $r$ 的每个点的贡献和为 sum1，然后当我们扫到 $r$ 时，再次记录此时的区间 $l$ 到 $r$ 的每个点的贡献和为 sum2，显然答案就是 sum2 - sum1 了。</p>
<p>好，至于为什么吗，我来解释一下，为什么 $p1$ 的贡献只用 $L[i],R[i]$ 来统计呢？（当然，这也可以证明 $p1$ 区间个数实在 $O(n)$ 级别的）</p>
<ol>
<li>为什么每个区间必定会被统计且只会被统计一次：首先，考虑这个 $(l,r)$ 是个合法的 $p1$ 区间，那么对于 $(l,r)$ 范围中最大的数字 $mid$，其 $L[i]=l,R[i]=r$，且对于这个区间其他数字，绝对不可能 $L[i]=l,R[i]=r$，因为 $mid$ 比他们都打，卡在中间挡住了他们。</li>
<li>为什么 $(L[i],R[i])$ 一定构成一个合法区间：这不废话？</li>
</ol>
<p>对于 $p2$ 的 $a_i<a_j<a_k$，证明方法类似，每个区间由这个区间中最大的数字来统计，$a_{i}>a_{j}&gt;a_{k}$。</p>
<p>当然，别忘了 $(i,i+1)$ 固定有 $p1$ 的贡献。</p>
<p>时间复杂度：$O(n \log n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  N  210000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  NN  410000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  NNN  610000</span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">long</span>  <span class="type">long</span>  LL;</span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>  l,r,d;</span><br><span class="line">	LL  lazy,c;</span><br><span class="line">&#125;tr[NN];<span class="type">int</span>  len,last[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">pushlazy</span><span class="params">(<span class="type">int</span>  x,LL  k)</span></span>&#123;tr[x].lazy+=k;tr[x].c+=k*tr[x].d;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">updata</span><span class="params">(<span class="type">int</span>  x)</span></span>&#123;tr[x].c=tr[tr[x].l].c+tr[tr[x].r].c;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">downdata</span><span class="params">(<span class="type">int</span>  x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[x].lazy)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">pushlazy</span>(tr[x].l,tr[x].lazy);</span><br><span class="line">		<span class="built_in">pushlazy</span>(tr[x].r,tr[x].lazy);</span><br><span class="line">		tr[x].lazy=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">bt</span><span class="params">(<span class="type">int</span>  l,<span class="type">int</span>  r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>  now=++len;tr[now].d=(r-l+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(l&lt;r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span>  mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		tr[now].l=len+<span class="number">1</span>;<span class="built_in">bt</span>(l,mid);</span><br><span class="line">		tr[now].r=len+<span class="number">1</span>;<span class="built_in">bt</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">change</span><span class="params">(<span class="type">int</span>  now,<span class="type">int</span>  l,<span class="type">int</span>  r,<span class="type">int</span>  ll,<span class="type">int</span>  rr,LL  k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==ll  &amp;&amp;  r==rr)&#123;<span class="built_in">pushlazy</span>(now,k);<span class="keyword">return</span>  ;&#125;</span><br><span class="line">	<span class="type">int</span>  mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">downdata</span>(now);</span><br><span class="line">	<span class="keyword">if</span>(rr&lt;=mid)<span class="built_in">change</span>(tr[now].l,l,mid,ll,rr,k);</span><br><span class="line">	<span class="keyword">else</span>  <span class="keyword">if</span>(mid&lt;ll)<span class="built_in">change</span>(tr[now].r,mid+<span class="number">1</span>,r,ll,rr,k);</span><br><span class="line">	<span class="keyword">else</span>  <span class="built_in">change</span>(tr[now].l,l,mid,ll,mid,k),<span class="built_in">change</span>(tr[now].r,mid+<span class="number">1</span>,r,mid+<span class="number">1</span>,rr,k);</span><br><span class="line">	<span class="built_in">updata</span>(now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL  <span class="title">findans</span><span class="params">(<span class="type">int</span>  now,<span class="type">int</span>  l,<span class="type">int</span>  r,<span class="type">int</span>  ll,<span class="type">int</span>  rr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==ll  &amp;&amp;  r==rr)<span class="keyword">return</span>  tr[now].c;</span><br><span class="line">	<span class="type">int</span>  mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">downdata</span>(now);</span><br><span class="line">	<span class="keyword">if</span>(rr&lt;=mid)<span class="keyword">return</span>  <span class="built_in">findans</span>(tr[now].l,l,mid,ll,rr);</span><br><span class="line">	<span class="keyword">else</span>  <span class="keyword">if</span>(mid&lt;ll)<span class="keyword">return</span>  <span class="built_in">findans</span>(tr[now].r,mid+<span class="number">1</span>,r,ll,rr);</span><br><span class="line">	<span class="keyword">else</span>  <span class="keyword">return</span>  <span class="built_in">findans</span>(tr[now].l,l,mid,ll,mid)+<span class="built_in">findans</span>(tr[now].r,mid+<span class="number">1</span>,r,mid+<span class="number">1</span>,rr);	</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>  L[N],R[N],n,m,a[N];</span><br><span class="line">LL  q1,q2;</span><br><span class="line"><span class="type">int</span>  sta[N],top;</span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">Query</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>  l,r;</span><br><span class="line">	LL  *id,type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">CHANGE</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>  l,r,k,id<span class="comment">/*在访问到哪个人时会使用这个*/</span>;</span><br><span class="line">&#125;ch[NNN];<span class="type">int</span>  clen,cnow=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">bool</span>  <span class="title">cmp</span><span class="params">(CHANGE  x,CHANGE  y)</span></span>&#123;<span class="keyword">return</span>  x.id&lt;y.id;&#125;</span><br><span class="line">vector&lt;Query&gt; fuck[N];</span><br><span class="line">LL  ans[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">solve</span><span class="params">(<span class="type">int</span>  x<span class="comment">/*加入第x个位置*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(cnow&lt;=clen  &amp;&amp;  ch[cnow].id==x)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ch[cnow].l&lt;=ch[cnow].r)<span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,ch[cnow].l,ch[cnow].r,ch[cnow].k);</span><br><span class="line">		cnow++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">0</span>;i&lt;fuck[x].<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Query  y=fuck[x][i];</span><br><span class="line">		(*y.id)+=y.type*<span class="built_in">findans</span>(<span class="number">1</span>,<span class="number">1</span>,n,y.l,y.r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q1,&amp;q2);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(top  &amp;&amp;  a[sta[top]]&lt;a[i])top--;</span><br><span class="line">		L[i]=sta[top];</span><br><span class="line">		sta[++top]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	top=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(top  &amp;&amp;  a[sta[top]]&lt;a[i])top--;</span><br><span class="line">		R[i]=sta[top];</span><br><span class="line">		sta[++top]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(L[i]  &amp;&amp;  R[i])</span><br><span class="line">		&#123;</span><br><span class="line">			ch[++clen].id=R[i];ch[clen].k=q1;ch[clen].l=L[i];ch[clen].r=L[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(R[i])</span><br><span class="line">		&#123;</span><br><span class="line">			ch[++clen].id=R[i];ch[clen].k=q2;ch[clen].l=L[i]+<span class="number">1</span>;ch[clen].r=i<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(L[i])</span><br><span class="line">		&#123;</span><br><span class="line">			ch[++clen].id=L[i];ch[clen].k=q2;ch[clen].l=i+<span class="number">1</span>;ch[clen].r=!R[i]?n:R[i]<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">bt</span>(<span class="number">1</span>,n);</span><br><span class="line">	<span class="built_in">sort</span>(ch+<span class="number">1</span>,ch+clen+<span class="number">1</span>,cmp);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span>  l,r;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">		ans[i]=(r-l)*q1;</span><br><span class="line">		Query  x;x.l=l;x.r=r;x.type=<span class="number">-1</span>;x.id=&amp;ans[i];</span><br><span class="line">		fuck[l<span class="number">-1</span>].<span class="built_in">push_back</span>(x);</span><br><span class="line">		x.type=<span class="number">1</span>;x.id=&amp;ans[i];</span><br><span class="line">		fuck[r].<span class="built_in">push_back</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">solve</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AGC066 E. Sliding Puzzle On Tree</title>
    <url>/2024/05/16/AGC066-E-Sliding-Puzzle-On-Tree/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc066/tasks/agc066_e">https://atcoder.jp/contests/agc066/tasks/agc066_e</a></p>
<p>题目大意：</p>
<p>给一棵树，然后依次在编号为 $1,2,…,n$ 上面放不同的石子，每次放完石子后，问经过下面操作任意次后能得到多少种不同的局面：</p>
<p>将一个石子移到相邻没有石头的位置。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>首先做这道题目一个直观的感受是，答案的结构会不会是可以把石头分成一个个集合，集合内的石头可交换吧？</p>
<p>但是首先就有一个问题，树上没有偏序结构，什么叫可交换？没有次序怎么定义可交换？</p>
<p>注意到一个事情，假设把石头看成没区别的，那么石头可以摆成任意一个局面，我们不妨固定一个局面 $A$ ，然后对于每种其他局面 $B$，我们也固定一种从 $A$ 到 $B$ 的交换方法，而这个交换方法可以用 $\{(x,y)\}$ 来表示，逆过来同理，具体表示为将 $A$ 中的 $x$ 位置的石子放到了 $B$ 的 $y$ 位置。</p>
<p>因此对于 $A$ 的同一局面的不同标号，一定可以对应 $B$ 的不同标号，同理 $B$ 的也可以变成 $A$ 的。</p>
<p>所以最终答案一定可以表示成 $\binom{n}{k}*cnt$ ，$cnt$ 表示同一局面有多少种不同的标号。</p>
<p>因此交换就可以定义了，固定一个局面下两个点的标号是否可交换。</p>
<p>那么怎么判断可交换呢？我在思考这个问题的时候是在 $fix$ 一条直径的情况下做的，然后再推广到不 $fix$ 的情况，这里直接给出我的最终做法，对我的思考过程感兴趣的读者可以去看反思部分。</p>
<p>考虑以某个叶子为根，然后根据某种神奇的 $dfs$ 序开始放下每一个石子（多叉树的后序遍历）。（下面的讨论和证明都默认是基于这个局面，基本上换个局面下面的观察就大概率是错的了）</p>
<p>先特判 $k\ge n-1$ 的情况。</p>
<p>剩下的情况，然后我们考虑两个石子什么时候可以交换，至于不能用交换形容的情况，我们等会再说。</p>
<p>显然只要两个石子是同父亲的，就可以交换，考虑石子什么时候和自己的儿子可交换，一个充分条件是，设 $f_{x}$ 表示 $x$ 到第一个二叉父亲（不包括自己）的所需要的边数，则 $k\le n-(f_{x}+2)$。</p>
<p>这也是为什么要选个叶子当根，否则还要讨论跨过根去到根的另一个子树的情况。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">充分性证明</summary><div class="toggle-content"><p>根据我们放石子的顺序，我们一定可以摆出下面的局面：</p></p>
<p><img src="1.png" alt=""></p>
<p>手模一下就行了，证毕。</p>
</div></details>
<p>但是，这就够了吗？</p>
<p>事实上是够了。</p>
<details class="toggle" ><summary class="toggle-button" style="">必要性及只用考虑交换的证明</summary><div class="toggle-content"><p>可以发现，由于我们的放法，$x$ 这个位置的石子在放下时，其子树就满了，因此空位都在 $x$ 子树外。</p>
<p>设 $gfa_x$ 表示 $x$ 的第一个有两个以上儿子的祖先。</p>
<p>大致情况就和下面的图一样，将 $x$ 移动到 $gfa_x$ 部分，这样石子就分成了两个部分，显然这两个部分之间无法产生交换。</p>
<p><img src="2.png" alt=""></p>
<p>因此，这个节点就像是一个分界点，将子树和外面的点分开，两部分之间不会产生交换。</p>
<p>要严谨写证明过程的话，归纳证明就行了。</p>
<p>证毕。</p>
</div></details>
<p>那么上面的情况就够了吗？</p>
<p>够了，在讨论了上面的情况后，两个石子不能交换的充要条件就是中间有个第二种情况的拦路虎，而显然发生这种情况时，两个石子一定不能交换，因此这不仅是只考虑上面情况的充要，而是原问题的充要条件。</p>
<p>但是问题是，我们现在考虑完交换，那这是否就覆盖了所有的情况呢？</p>
<p>我们这么想，假设 $x,y$ 不可交换，但是存在一个变换，能使 $x$ 到达 $y$ 所在的位置，那么根据上面 $x,y$ 不可交换的条件，中间一定存在一个类似分界一样的东西，会限制 $x$ 不能到达 $y$ 能到达的一些地方，而前面说法矛盾，故不存在这种情况。因此，只考虑交换便能覆盖所有的局面。</p>
<p>做完了。</p>
<p>实现方面，注意到对于 $\forall x,y$ ，上面只给了在 $x\to y$ 这条路径上都已经按照顺序放了石头之后 $x,y$ 可交换的条件，但是如果还没放满呢？</p>
<p>显然除了 $lca$ 外，如果一个位置放了石子，且其的一个儿子也在这条路径上，则显然必须满足这个位置能和儿子交换，而且这显然是充要的，但我们注意到一个事情，如果 $x$ 在 $t$ 的时间假如，则其能与儿子交换的条件要么一直不满足，要么在 $\le t-1$ 时一定能满足。</p>
<p>因此 $x,y$ 可交换的条件在放不放满石头的时候都是一样的（除了 $lca$ 外，如果一个位置和其的一个儿子都在这条路径上，则必须满足这个位置能和儿子交换），直接实现就行了。</p>
<p>时间复杂度：$O(n\alpha(n))$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line">LL fc[N], nfc[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> L = <span class="number">2e5</span>;</span><br><span class="line">    nfc[<span class="number">0</span>] = nfc[<span class="number">1</span>] = fc[<span class="number">0</span>] = fc[<span class="number">1</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= L; i++) nfc[i] = (mod - mod / i) * nfc[mod % i] % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= L; i++) nfc[i] = nfc[i - <span class="number">1</span>] * nfc[i] % mod, fc[i] = fc[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x] * nfc[y] % mod * nfc[x - y] % mod;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y, next;</span><br><span class="line">&#125;a[N * <span class="number">2</span>]; <span class="type">int</span> len, las[N], du[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;a[++len] = &#123;y, las[x]&#125;; las[x] = len;&#125;</span><br><span class="line"><span class="type">int</span> n, rt;</span><br><span class="line"><span class="type">int</span> siz[N];</span><br><span class="line"><span class="type">int</span> dfn[N], be[N], ti;</span><br><span class="line">vector&lt;PII&gt; event[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    siz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> son = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = las[x]; k; k = a[k].next)&#123;</span><br><span class="line">        <span class="type">int</span> y = a[k].y;</span><br><span class="line">        <span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        son = y;</span><br><span class="line">        <span class="keyword">if</span>(du[x] &gt;= <span class="number">3</span>) <span class="built_in">dfs</span>(y, x, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">dfs</span>(y, x, !c ? <span class="number">0</span> : c + <span class="number">1</span>);</span><br><span class="line">        siz[x] += siz[y];</span><br><span class="line">    &#125;</span><br><span class="line">    be[ dfn[x] = ++ti ] = x;</span><br><span class="line">    <span class="keyword">if</span>(son &amp;&amp; c) event[n - c - <span class="number">2</span>].<span class="built_in">push_back</span>(&#123;x, son&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL contribution = <span class="number">1ll</span>;</span><br><span class="line"><span class="type">int</span> fa[N], cnt[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">findfa</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mer</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x = <span class="built_in">findfa</span>(x);</span><br><span class="line">    y = <span class="built_in">findfa</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x == y) <span class="keyword">return</span> ;</span><br><span class="line">    contribution = contribution * nfc[cnt[x]] % mod * nfc[cnt[y]] % mod;</span><br><span class="line">    fa[x] = y;</span><br><span class="line">    cnt[y] += cnt[x];</span><br><span class="line">    contribution = contribution * fc[cnt[y]] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    x = <span class="built_in">findfa</span>(x);</span><br><span class="line">    contribution = contribution * nfc[cnt[x]] % mod;</span><br><span class="line">    cnt[x]--;</span><br><span class="line">    contribution = contribution * fc[cnt[x]] % mod;</span><br><span class="line">&#125;</span><br><span class="line">LL ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> x, y;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            <span class="built_in">ins</span>(x, y);</span><br><span class="line">            <span class="built_in">ins</span>(y, x);</span><br><span class="line">            du[x]++;</span><br><span class="line">            du[y]++;</span><br><span class="line">        &#125;</span><br><span class="line">        rt = <span class="number">1</span>;<span class="comment">//n = 1;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(du[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                rt = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(rt, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = las[i]; k; k = a[k].next)&#123;</span><br><span class="line">                <span class="type">int</span> y = a[k].y;</span><br><span class="line">                <span class="keyword">if</span>(dfn[y] &gt; dfn[i]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(pre) event[n - <span class="number">2</span>].<span class="built_in">push_back</span>(&#123;pre, y&#125;);</span><br><span class="line">                pre = y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            fa[i] = i;</span><br><span class="line">            cnt[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[n] = <span class="number">1ll</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">            <span class="built_in">del</span>(be[i + <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> [x, y] : event[i]) <span class="built_in">mer</span>(x, y);</span><br><span class="line">            ans[i] = <span class="built_in">C</span>(n, i) * contribution % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        contribution = <span class="number">1ll</span>;</span><br><span class="line">        len = ti = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(las + <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">        <span class="built_in">memset</span>(du + <span class="number">1</span>, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n; i++) event[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真是场酣畅淋漓的做题啊。</p></div></details>
<details class="toggle" ><summary class="toggle-button" style=""></summary><div class="toggle-content"><p>破案了，我说为什么难度比 $D$ 低，原来是原题加强，但是原题做法能过。 </p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">反思</summary><div class="toggle-content"><p>想想我的想题过程：</p>
<ol>
<li><p>觉得肯定要思考哪些石头是能交换的。（卡了至少 30 分钟）</p>
<p>否决理由：“交换”的定义非常奇怪，对于两种不同的摆石子方式，怎么判断两个石头已经被交换了？（但实际在后面发现，只要解决了这个问题，就已经成功很大一步了，可惜我当时的第一想法是放弃而不是解决）</p>
</li>
<li><p>觉得可能是通过一个石子能够到达哪些位置进行解答，显然处于等价关系的点应该能到达的位置是一样的，本质是尝试在定义上面的交换关系。（卡了至少 30 分钟）</p>
<p>否决理由：能到达的点这个东西并不好量化，而且求出来也十分困难，讨论起来也很麻烦，还不一定能讨论出来，直觉上正解肯定不是这么搞的，直接放弃了。</p>
</li>
<li>发现答案一定是：同种石子的答案 * 一种摆石子方式的不同局面（同一种方式的不同局面通过同一种映射一定到达另一种方式的不同局面，是个双射），所以可以直接固定一个摆石子的方式，研究有多少种不同的局面，这个时候猜测一定是一个集合里面的点可互相交换。（其实也就是严格定义了第一点）</li>
<li><p>断定三个石头共线，则左右两个石头能交换当且仅当和中间的石头能交换。（卡了至少 30 分钟）</p>
<p>否决理由：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br><span class="line">2 5</span><br></pre></td></tr></table></figure>
<p> 其中石头在 $1,2,3$ ，$1,3$ 可交换，但 $2$ 不可交换。</p>
</li>
<li><p>接下来卡了很久，因为总觉得这个交换非常的难思考，直到我拿着 $4$ 的例子思考了一下，打算先假设只用接下来这一种方法来判断交换（即找到了一种比较好的判断交换的充分条件进行思考）：</p>
<p><img src="2.png" alt=""></p>
<p>上面黑点表示有石子，白点表示没有石子，那么上面的所有石子都是可交换的，但是如果上下再多一个石子，多出来的石子不可交换，也就是在这种三叉路口上，没有石头的路的长度决定了可交换的有石头的路的长度。</p>
</li>
<li>那么这种结构想到了啥？直径！可以发现，如果我们放石头的时候，有限把树的直径以外的部分填满，那么石头都是可交换的，用上面的结构，但是如果必须要填在直径上呢？</li>
<li><p>继续开始思考，我们发现，我们可以不断的移动直径上没有填石头的部分到某些三叉路口，来使得某些石头是可交换的，但这个时候发现了一种情况：</p>
<p><img src="3.png" alt=""></p>
<p>可以发现，无论没有石子的部分怎么移动，这个石头都不能通过 $5$ 的结构与任何石子交换，但是上面这个例子显然能够证明这个石子无法与其余石子交换，因为其在一条直道上，无法走向左右任意一个交叉口的某个子树里（即使能走到交叉口，不能走到子树里也是白搭），那么能否这样类似的证明其余无法用 $5$ 构造交换的情况其实也是不可交换的呢？（其实这个时候就和下面说的一样，本质上是找到了一个判断不能交换的必要条件，证明这个必要条件是充分的，毕竟想想，证明无法交换就必定满足这个必要条件，反过来就是不满足这个必要条件的就是可交换的，因此这个过程其实就是判断这个必要条件是充要的过程）</p>
</li>
<li><p>刚刚那个问题的答案是可以的，可以移动整段没有石子的路段（这里其实假定了整段不分裂的移动更优，但事实是在后面在这种假设下证明了必要条件是充要的后，这个假设自然也就成立了，也就是下面说的第三点），到一个个石子路口，且只假设会不断向叶子前进，不会做多余的操作，可以用上面的方法证明不能用这种方法交换的一定都是不能交换的。</p>
<p><img src="4.png" alt=""></p>
<p>注：不会多余就是一端在交叉路口，而另一端一定是指向直径方向的。</p>
<p>同时，用上面这个方法也能同时证明，只需要考虑交换就够了，不会出现 $x,y,z$ 可以三轮换但是不能交换的情况。</p>
</li>
<li><p>这个时候这道题目就已经做出来了，但是感觉这个做法有点难写（在直径上操作），而且也并不广泛。</p>
<p> 用到的直径性质也不多（只有在直径上没有石头的时候用到了直径性质），也就是说在直径上做这件事并不本质，直觉告诉我题解肯定不是这么做的。</p>
</li>
<li>这个时候尝试推广这个做法，并最终得到了我自己的最终做法。</li>
</ol>
<p>显然这个思考过程是非常长的，因此需要优化！</p>
<p>在没有看题解之前，我判断这个过程中有什么东西是可以优化的呢？</p>
<ol>
<li><p>就是我发现我在思考一些结论时，总是想着怎么证明，但正确做法应该是先想能不能构造反例，因为构造反例的难度往往比证明要低，而且构造不出来的过程可以指导证明</p>
<p>也就是我之前喜欢先从证明入手，然后因为证明不出来从而发现反例，这是很低效的，因为面对一个棘手的问题往往没有从正面切入的点。</p>
<p>但是如果从反面切入，如果发现是错的，结束了，不是错的，研究为什么对，这样又能对这个问题更加深入一步，而不至于摸不着头绪。</p>
</li>
<li><p>像这种题目，要先多去思考必要条件，也就是两个点不能交换的必要条件，在找到足够多后，再尝试证明或找到充要条件，这样会快很多。</p>
<p>显然，根据我上面的过程，我其实一种都在想两个点能交换的充要条件，但如果我先想两个点不能交换（尤其是两个相邻点）的必要条件，我想会更快想出正解。</p>
<p>虽然最后我想出来正解其实也是找了两个点能交换的充分条件进行思考得到的，因为一般情况下充要条件很难想出来，这个时候就需要找一些比较强的充分或者必要条件进行思考，而且很多情况下，其实这些就是充要条件，只是还没有证明的思路罢了。</p>
</li>
<li><p>假设法，在无法证明某些结论前先假设其是对的，然后进行进一步思考，如果找到反例再来推翻这个假设。</p>
<p>例如如果我一开始就假定两个石头能交换，则中间绝对不能隔着超过一个不能交换的石头，那么这种更加优秀的结构能够更好的引导接下来的思考（至少比原来抓瞎好），我想在这种假设下，也能更快的想出正解，而且事实是，一般想到正解后，这种假设的正确性也就迎刃而解了，尤其是在各种贪心和计数题上。</p>
</li>
</ol>
<p>在看了题解之后，我又有了什么新的感悟？</p>
<p>update：没什么感悟。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方题解</summary><div class="toggle-content"><p>幽默了。原来我想题过程中，从“一个点能到达的集合”作为出发点是真的可行的啊。</p>
<p>接下来认为 $a,b,c$ 是石子，$x,y,z$ 是位置，石子和位置并不绑定，石子是石子，位置是位置，需要的时候可以把石子摆成任意想要的局面。（这里的局面指忽略标号的局面）</p>
<p>同时规定 $dis(x,y)$ 或者 $dis(a,x)$ 表示两点或者石子所在位置到 $x$ 的距离。</p>
<p>设 $S(a)$ 表示石子 $a$ 能到达的位置的集合。（注意，这里的 $S(a)$ 定义是基于石子的）</p>
<p>对于位置 $x$ ，我们称 $a$ 能够利用 $x$ 当且仅当 $x$ 有两个相邻节点属于 $S(a)$ 。</p>
<p>那么以下这三句话等价：</p>
<ol>
<li>$S(a)=S(b)$</li>
<li>$a,b$ 能够利用同一个度数 $\ge 3$ 的节点。</li>
<li>$a,b$ 能够在不影响其他位置的情况下交换他们身上的石子。（这其实给了交换的另外一种定义，但是我认为在没有想到去标号后任何局面可达这件事时，这种定义思考和证明起来是极其麻烦的，反正我不会）</li>
</ol>
<p>$3\to 1,3\to 2, 1\to 2$ 都是显然的。</p>
<p>现在简单的证明一下 $1\to 2$ 。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>首先你需要注意到这么一个形式：$x\in S(a)$ ，如果 $x$ 有一个相邻节点 $y\notin S$ 是什么情况？</p></p>
<p>手动模拟可以发现一定是长这样：</p>
<p><img src="3.png" alt=""></p>
<p>总之就是 $x$ 和 $y$ 之间有一个分界线，两边的集合除了中间外无法互相到达。</p>
<p>从而知道 $x$ 只有一个相邻节点在 $S(a)$ 中。</p>
<p>因此我们可以知道 $S(a)$ 中的节点要么所有相邻节点都在里面，要么只有一个，我们又知道 $S(a)$ 是一个子连通块，因此这等价于这个子连通块中所有非叶子节点的所有相邻节点都在这个 $S(a)$ 中，这样有一个好处，任何一条从集合内走到集合外的简单路径都满足会经过子连通块的叶子（注：这个性质和定义其实是等价的，两者能互推）。</p>
<p>通过上面的描述，我们可以知道 $a$ 能利用 $x$ 等价于 $x\in S(a)$  且 $x$ 不是叶子。</p>
<p>同时通过上面那个例子，我们知道，对于 $S(a)$ 的叶子 $x$ ，如果 $x\in S(b)$ ，那么：</p>
<p><img src="4.png" alt=""></p>
<p>（准确来说这个图画的有点错，$a$ 不一定能到达左边的所有点）</p>
<p>要么 $b\in S(a)$ ，从而 $x$ 也是 $S(b)$ 的叶子，要么 $b\in V’$ ，则 $a,b$ 不可能利用同一个节点。</p>
<p>因此我们知道，如果 $S(a),S(b)$ 有交，且利用的节点有交集，可以通过上面的性质证明，$S(a)=S(b)$ ，同时因为他们利用同一个节点，所以一定有交，所以 $S(a)=S(b)$ ，证毕。</p>
</div></details>
<p>但是 $2\to 3,1\to 3$ 就十分麻烦了，因为在树上讨论交换是一个十分麻烦的事情，树的结构千变万化，很难用少量的讨论去说清楚这个事情。</p>
<p>因此一般情况下，给树赋予某种结构后再进行讨论会比较好，而 DFS 序就是树上一种比较一般且比较好的结构，所以很多树的证明都会涉及到 DFS 序，包括我的做法在最终证明和实现道题目的时候，也是用 DFS 序的。（虽然也可以用直径就是了）</p>
<p>在知道我的做法的正确性后，可以说明 $2\to 3,1\to 3$ 的正确性。首先可以用交换表述所有的情况，其次在 DFS 序上，两石子不能交换当且仅当路径中存在分界线那种结构，这个时候两个石子一定不能利用同一个节点。</p>
<p>因此两石子能利用一个节点则代表他们可以交换，证毕。</p>
<p>但是如果不基于我那个做法，单独给一个证明，我不会，我也没看懂题解那个证明。</p>
<p><img src="5.png" alt=""></p>
<p>我很想知道题解中这一步是怎么构造方案的，反正我感觉不基于某种结构是几乎不可能构造出来的，反正我的智商不支持我这么干，投降。</p>
<p>在假设上面都是对的后有意思的事情就来了。</p>
<p>现在可以建立一张图，其中以石子和度数 $\ge 3$ 的点为节点，其中如果石子可以利用一个位置，我们就给两点间连一条无向边，可以发现，这个图的每个连通块中的石子就是交换的。</p>
<p>以下都讨论都默认节点度数为 $3$ 。</p>
<p>但是这个图的量级是 $O(n^2)$ 的，不够得劲。注意到一个事情，如果 $a$ 能够同时利用 $x,y$ ，那么任何一个石子一定要么能同时利用 $x,y$ ，要么都不能，所以我们可以认为此时 $x,y$ 等价，可以发现这个等价也具有传递性。</p>
<p>同时又因为 $S(a)$ 也是联通块，我们可以得到，如果存在这样一条简单路径：$x\to y\to z$ ，那么 $a$ 能利用 $y$ / $x,y,z$ 等价。</p>
<p>这启示我们这么建图：$a$ 只向其各个方向上最近的 $x$ 连边，$x$ 只向其各个方向上最近的等价的 $y$ 连边，不难证明，这个图与上面那个图的连通性一样，而这个图的边数是 $O(n)$ 的。</p>
<p>开始讨论每条边在什么时候存在。</p>
<ol>
<li>$x,y$ 等价，可以发现在 $[1,n-dis(x,y)-2]$ 都存在，证明很好证明，不存在显然，存在只需要证明存在一个石头既能到 $x$ 又能到 $y$ ，这是显然的，直接先把所有石子移动到两边然后随便拿一个外面的石子就行了。</li>
<li>$a,x$ ，且 $a$ 初始时就在 $x$ 上，要么有至少两个子树（以 $x$ 为根）有空位，要么 $x$ 能等价于另外一个其他节点。</li>
<li><p>$a,x$ ，且 $a$ 初始不在 $x$ 上，条件为去掉 $a$ 所在的子树（以 $x$ 为根）和 $x$ 后的空位数量大于等于 $a$ 到 $x$ 路径上的石子数量 （包括 $a,x$）</p>
<p>首先满足肯定 $a$ 能利用 $x$ ，不满足，但 $a$ 能利用 $x$ ，那肯定是 $a$ 的儿子子树发力了，考虑 $a$ 的子树中最靠近 $a$ 的 $\ge 3$ 度点 $y$ （包括 $a$ 脚下的节点），能发生这种情况则 $a,y$ 一定能满足上面那个条件。（手模一下就知道了）</p>
<p>所以此时 $a$ 能利用 $y$ ，$x,y$ 等价，那么就算没有 $a,x$ 的边，$a$ 也能通过 $a-y-x$ 走到 $x$ ，所以不连也无所谓。</p>
</li>
</ol>
<p>然后就讨论完每条边的条件了。</p>
<p>其中第二种可以线性处理，而第三种边的条件等价于去掉 $x$ 为根时 $a$ 的子树，剩下的空位要 $\ge$ $dis(a,x)+1$ 需要用线段树合并处理出第 $k$ 个空位消失的时间。</p>
<p>这样我们就能知道每条边出现时间的右边界，而左边界显然是石子的出现时间，这个时候就已经可以用 $O(n\log^2 n)$ 的时间做完整道题目了。</p>
<p>但问题来了，一个石头真的需要放下了我们才能将其加入图中吗？</p>
<p>发现一个事情，第一种边也就是节点等价的边是不依赖于石子的，而且这个图的建立是绝对正确的，没有偷工减料，也就是只有第一种边的时候， $x,y$ 之间连通等价于他们等价。（注：有了第二、三种边也不影响这条性质成立）</p>
<p>同时可以证明：$\forall x≠y$ ，且此时满足了 $a$ 和 $x,y$ 连边的条件，那么无论此时 $a$ 放没放上去，$x,y$ 都等价。（发现第二三种边的条件不依赖于 $a$ 放没放上去，因此如果此时 $a$ 还没放上去，就先放上去，此时 $x,y$ 等价，然后再把 $a$ 拿走，空位增多，则此时 $x,y$ 还等价，证毕）</p>
<p>因此，先认为 $k$ 从大到小，则无论任何时候，与 $a$ 相关的边都只会导致一部分节点连通，而显然就算没有这些边，只靠第一种边，他们此时也是连通的，因此在 $k$ 小的时候没必要删掉 $a$ 和 $a$ 相关的那些边，只要记得不要把 $a$ 统计进答案里面就行了。</p>
<p>所以所有边的左边界都可以设为 $1$ ，因此可以用并查集维护，此时正道题目时间复杂度为 $O(n\log{n})$ 。</p>
<p>题外话：因为只有第一种边时就已经满足 $x,y$ 之间连通等价于他们等价，所以理论上 $a$ 只需要和其中一个其能利用的节点连边就行了，第三种边的部分边可以不建立就是这个原理。</p>
<p>但是能不能在 $O(n\alpha(n))$ 的时间完成这道题目呢？</p>
<p>答案是可以，和我的做法同样的手法，按照 DFS 序放石子就行了，这样每个子树都是一个区间，上面所有的查询都变得十分简单，能够在 $O(1)$ 的时间得到，这样就不用线段树合并了，时间复杂度瓶颈变为并查集，总时间复杂度变为 $O(n\alpha(n))$。</p>
<p>写一下我对这个做法的评价：</p>
<p>首先我突然觉得我的做法比他的做法好想，我搞这个做法我会直接卡在那一步 $1,2\to 3$ ，直接放弃接下来的思考（虽然接下来的部分也不简单就是了）。</p>
<p>但就这个做法而言，我给予高度的评价，首先他这个做法并不像我的做法一样特化，我的做法是必须在 DFS 序这个结构上的，并不一般。而他这个做法在任意的石子局面下都能做到 $O(n\log{n})$ ，就已经比我的做法强了不知道多少了（我当时其实有试过把我的做法推向一般局面，但是失败了），而在 DFS 序下也能做到 $O(n\alpha(n))$ ，不输我的做法。</p>
<p>同时他的做法还引进了一个新的概念 $S(a)$ ，并且深挖出了很多和 $S(a)$ 有关的性质，我当时试图从这个角度上想，但是失败了，因此单就这个新的概念本身以及很多相关的性质，就又赢了我的做法很多。</p>
<p>反正我认为这个做法的意义是多方面的，在这当中我学到了很多新的东西。<del>虽然花了很多时间</del></p>
<p>此时再看看我的做法，也就胜在好想了。<del>但是这是比赛，好想胜过一切，我的做法，赢！</del></p></div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AGC066 D. A Independent Set</title>
    <url>/2024/05/13/AGC066-D-A-Independent-Set/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/agc066/tasks/agc066_d">https://atcoder.jp/contests/agc066/tasks/agc066_d</a></p>
<p>题目大意：给你一个 $AB$ 串，保证 $A\le \frac{n + 1}{2}$ ，每次可以交换 $i$ 和 $i + 1$ 的字符，代价为 $w_{i + 1}$ ，要求最小的代价满足：任意两个 $A$ 不相邻。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>观察到一个事情：考任意一种可能成为最优方案的方案，一定可以表示成某几个位置的展开。</p>
<p>展开的意思是是说：选择一个 $A$ ，然后从左到右依次将 $A$ 推开，直到某个小区间内没有 $A$ 相邻。</p>
<p>举个例子：$BBBAAABBB$ ，选择中间的 $A$ ，那么中间的 $A$ 就会想着把周围的 $A$ 推开，推成：$BBABABABB$ 。</p>
<p>证明的话，考虑每个 $A$ 是往左移还是往右移的，显然，每一段往左移和每一段往右移中间存在一个数字是不动，否则一定可以更加优秀，所以，每一个不动和左边的往左移动，和右边的往右移动构成了上面所描述的一个小区间。</p>
<p>那么处理出所有的这些区间就行了，处理方法就是把 $A$ 看成 $1$ ，把 $B$ 看成 $-1$ ，然后在折线法左右第一次出现等高的位置，就是区间的左右端点。</p>
<p>然后转移就行了，时间复杂度 ： $O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> st[N];</span><br><span class="line">    cin &gt;&gt; st;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, st, <span class="built_in">sizeof</span>(<span class="type">char</span>) * <span class="built_in">strlen</span>(st));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y, next;</span><br><span class="line">    LL c;</span><br><span class="line">&#125;a[N]; <span class="type">int</span> len, las[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, LL c)</span></span>&#123;a[++len] = &#123;y, las[x], c&#125;; las[x] = len;&#125;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> pre[N * <span class="number">2</span>], val[N];</span><br><span class="line"><span class="type">int</span> ll[N], rr[N];</span><br><span class="line">LL cost[N], f1[N], f2[N];</span><br><span class="line">LL dp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="built_in">get_char_array</span>(st + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        n += <span class="number">2</span>;</span><br><span class="line">        st[<span class="number">1</span>] = st[n] = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i] == <span class="string">&#x27;A&#x27;</span>) val[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> val[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LL ans = <span class="number">0ll</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt; n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; cost[i];</span><br><span class="line">            cost[i] += cost[i - <span class="number">1</span>];</span><br><span class="line">            f1[i] = f1[i - <span class="number">2</span>] + cost[i];</span><br><span class="line">            f2[i] = f2[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(val[i] == <span class="number">1</span>) f2[i] = f2[i] + cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = n;</span><br><span class="line">        <span class="built_in">fill</span>(pre + <span class="number">1</span>, pre + n + n + <span class="number">1</span>, <span class="number">-10ll</span>);</span><br><span class="line">        pre[n] = <span class="number">0ll</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            sum += val[i];</span><br><span class="line">            ll[i] = pre[sum] + <span class="number">1</span>;</span><br><span class="line">            pre[sum] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = n;</span><br><span class="line">        <span class="built_in">fill</span>(pre + <span class="number">1</span>, pre + n + n + <span class="number">1</span>, <span class="number">-10ll</span>);</span><br><span class="line">        pre[n] = (n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">            sum += val[i];</span><br><span class="line">            rr[i] = pre[sum] - <span class="number">1</span>;</span><br><span class="line">            pre[sum] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i] == <span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ll[i] &gt;= <span class="number">0</span> &amp;&amp; rr[i] &gt;= <span class="number">-1</span>)&#123;</span><br><span class="line">                    LL val = ((f2[i] - f2[ll[i] - <span class="number">1</span>]) - (f1[i] - f1[ll[i] - <span class="number">1</span>])) +</span><br><span class="line">                             ((f1[rr[i] - <span class="number">1</span>] - f1[i - <span class="number">2</span>]) - (f2[rr[i] - <span class="number">1</span>] - f2[i - <span class="number">1</span>]));</span><br><span class="line">                    <span class="built_in">ins</span>(ll[i], rr[i], val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">ins</span>(i - <span class="number">1</span>, i, <span class="number">0ll</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0ll</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dp[i] = <span class="number">1e18</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = las[i]; k; k = a[k].next)&#123;</span><br><span class="line">                <span class="type">int</span> y = a[k].y;</span><br><span class="line">                dp[y] = <span class="built_in">min</span>(dp[y], dp[i] + a[k].c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; dp[n] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) las[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不懂啊，感觉完全不如 $BCE$ 难，奇怪的难度评价。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方题解</summary><div class="toggle-content"><p>好吧，官方题解确实难想。</p>
<p>其先基于这么一个转化：如果在原字符串后面添上 $B$ ，那么原题可以转化为：花最小的代价使得原串可以被分割成 $AB,B$ 。</p>
<p>那么一个观察就是 $AB$ 中的 $A$ 一定不会跨过 $B$ ，否则 $A$ 与这个 $B$ 组合一定更优。</p>
<p>证明要详细写出来可能会比较麻烦，大致就是讨论一下，因为最优方案一定可以写成每个 $A$ 按顺序往某个方案移动，而且 $A/B$ 与 $A/B$ 之间不会交换，根据这个原理讨论一下就行了。</p>
<p>由这个观察，我们可以证明，满足这个观察的最优答案一定可以分成若干段，其中 $[l_i,r_i]$ 满足两个字符串在这个区间上的 $A,B$ 数量一样，且最终字符串要么是 $B$ ，要么是 $ABABAB…AB$ ，那么就能得到下面的 $dp$ 。</p>
<p>设 $dp[i]$ 表示前 $i$ 个字母变成可以分割成 $AB,B$ 的字符串最小代价。</p>
<p>如果 $i$ 后面是 $B$ ，则可以 $dp[i]\to dp[i+1]$ 。</p>
<p>或者可以在后面放 $AB$ ，根据上面的条件可以得到 $dp[i]\to dp[j]+cost(i+1,j)$ ，满足 $[i+1,j]$ 中的 $A,B$ 数量一样，可以注意到，等价于 $A$ 看成 $1$ ，$B$ 看成 $-1$ 后 $s_{i}=s_{j}$ ，而且又显然，$s_{i}$ 只需要更新到后面第一个满足要求的 $j$ 就行了，因为若 $j,k$ 都满足要求的话：$cost(i+1,k)=cost(i+1,j)+cost(j+1,k)$ ，所以只需要 $i\to j\to k$ 就行了。</p>
<p>至于算 $cost$ 的话，注意到，每一段的 $j$ 都是往一个方向移动的，所以可以很方便的算出 $cost$ 。（原因：根据上面的 $dp$ 过程不难得到，这一段的前缀和都是同号的，要么 $&gt;0$ ，要么 $&lt;0$ ，除了整段是 $=0$ 的）</p>
<p>综上，时间复杂度：$O(n)$ 。</p>
<p>这个做法比我的做法难想，但是比我的做法好写。</p>
<p>而且其中很多思考的细节是值得认真想想的，很有意义的一个做法，感觉能想明白这个做法对提升 $dp$ 能力很有帮助。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>AGC066 赛后总结</title>
    <url>/2024/04/02/AGC066-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://atcoder.jp/contests/agc066/tasks">https://atcoder.jp/contests/agc066/tasks</a></p>
<p>别TM出你那构造了，我TM真的要做吐了。</p>
<h1 id="A-Adjacent-Difference"><a href="#A-Adjacent-Difference" class="headerlink" title="A Adjacent Difference"></a>A Adjacent Difference</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc066/tasks/agc066_a">https://atcoder.jp/contests/agc066/tasks/agc066_a</a></p>
<p>题目大意：给一个 $n*n$ 的方阵，给一个数字增减 $x$ 的代价是 $|x|$ ，然后给出一种方案使得相邻数字差距 $\ge d$ ，同时代价 $\le \frac{dn^2}{2}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>一个经典的思考模型：由一般到特殊。</p>
<ol>
<li><p>如果 $d=1$ 怎么做？</p>
<p>我当时的想法是：奇数格子跑奇数或这偶数，偶数格子跑另外一类。</p>
</li>
<li><p>如果所有数字在 $[0,d]$ 内，怎么做？</p>
<p>我当时的想法是：奇数格子跑 $0$ 或者 $d$ ，偶数格子跑另外一类。</p>
</li>
</ol>
<p>这都指向了一个想法：奇数格跑向最近的 $0/d \mod{2d}$ ，然后偶数格子跑向另外一个。</p>
<p>至于证明，同样从一般到特殊，考虑上面两个问题，都是两种情况的和为 $dn^2$ ，则必定有一个 $\le \frac{dn^2}{2}$ 。</p>
<p>这个想法的证明也类似，不难发现，问题等价于：给偶数格子的值 $-d$ ，然后问所有格子最近的到 $0/d \mod{2d}$ ，是否有一种可能使得代价 $\le \frac{dn^2}{2}$ 。</p>
<p>不难发现，一个数字到达最近的 $0/d \mod{2d}$ ，两种情况的距离和是 $d$ 的，因此两种情况的代价是 $dn^2$ ，因此必定有一个情况 $\le \frac{dn^2}{2}$ ，证毕。</p>
<p>一个比较形象的图：</p>
<p><img src="1.png" alt=""></p>
<p>时间复杂度：$O(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, d;</span><br><span class="line"><span class="type">int</span> a[N][N], b[N][N];</span><br><span class="line"><span class="type">int</span> base;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="type">int</span> goal;</span><br><span class="line">            <span class="keyword">if</span>((i + j) &amp; <span class="number">1</span>) goal = base;</span><br><span class="line">            <span class="keyword">else</span> goal = base + d;</span><br><span class="line">            <span class="keyword">if</span>(goal &lt; a[i][j])&#123;</span><br><span class="line">                <span class="type">int</span> x = a[i][j] - goal;</span><br><span class="line">                x = x / (d + d) * (d + d) + goal;</span><br><span class="line">                <span class="keyword">if</span>( <span class="built_in">abs</span>(x - a[i][j]) &gt; <span class="built_in">abs</span>(x + d + d - a[i][j])) x += d + d;</span><br><span class="line">                goal = x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> x = goal - a[i][j];</span><br><span class="line">                x = goal - x / (d + d) * (d + d);</span><br><span class="line">                <span class="keyword">if</span>( <span class="built_in">abs</span>(x - a[i][j]) &gt; <span class="built_in">abs</span>(x - d - d - a[i][j])) x -= d + d;</span><br><span class="line">                goal = x;</span><br><span class="line">            &#125;</span><br><span class="line">            b[i][j] = goal;</span><br><span class="line">            cost += <span class="built_in">abs</span>(a[i][j] - b[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cost;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * <span class="built_in">solve</span>() &gt; d * n *n)&#123;</span><br><span class="line">        base = d;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="number">2</span> * <span class="built_in">solve</span>() &lt;= d * n * n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            cout &lt;&lt; b[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实感觉想的还是慢了点，感觉还能再快一点的。</p>
</div></details>
<h1 id="B-Decreasing-Digit-Sums"><a href="#B-Decreasing-Digit-Sums" class="headerlink" title="B Decreasing Digit Sums"></a>B Decreasing Digit Sums</h1><p>题目链接：<a href="https://atcoder.jp/contests/agc066/tasks/agc066_b">https://atcoder.jp/contests/agc066/tasks/agc066_b</a></p>
<p>题目大意：给一个长度不超过 $9999$ 的数字，满足乘 $50$ 次 $2$ 时每次乘之后数位和都严格下降。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>非常有意思的题目，有时候来这么几道确实能开阔视野，但是考场时恶心我也确实有一手。</p>
<p>首先注意到一个事情：$5$ 乘 $2$ 后会变成 $10$ ，不影响数位和，也就是对于 $5<em>x$ ，在乘 $2$ 后变成 $10</em>x$ ，等价于 $x$ ，也就是乘 $2$ 后数字反而减小了，那么直接搞一个 $5^50$ ，最后直接减小到 $1$ 。</p>
<p>但是数字在减小不代表数字的数位和在减少，事实也确实如此，那么怎么搞呢？</p>
<p>考虑 $n*5^{50}$ ，如果 $5x\le y$ ，虽然 $x$ 的数位和可能大于等于 $y$ ，但是 $nx$ 与 $ny$ 在 $n$ 不断变化时的平均值应该是满足：$nx\le ny$ 的。</p>
<p>因此，直接将不同的 $n$ 得到的 $n*5^{50}$ 拼在一起即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SN = <span class="number">1e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[SN], len;</span><br><span class="line">    <span class="built_in">node</span>()&#123;len = <span class="number">1</span>;<span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));&#125;</span><br><span class="line">&#125;a;</span><br><span class="line">node <span class="keyword">operator</span>*(node x, <span class="type">int</span> y)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x.len; i++) x.a[i] *= y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x.len; i++)&#123;</span><br><span class="line">        x.a[i + <span class="number">1</span>] += x.a[i] / <span class="number">10</span>;</span><br><span class="line">        x.a[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(x.a[x.len + <span class="number">1</span>])&#123;</span><br><span class="line">        x.len++;</span><br><span class="line">        x.a[x.len + <span class="number">1</span>] += x.a[x.len] / <span class="number">10</span>;</span><br><span class="line">        x.a[x.len] %= <span class="number">10</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> T;</span><br><span class="line">        cin &gt;&gt; T;</span><br><span class="line">    &#125;</span><br><span class="line">    a.a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    LL now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) a = a * <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">400</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        node b = a * i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b.len; j++) st[++n] = b.a[j] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + i &lt;= n; i++) <span class="built_in">swap</span>(st[i], st[n - i + <span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// cout &lt;&lt; n &lt;&lt; &#x27;\n&#x27; ;</span></span><br><span class="line">    cout &lt;&lt; st + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">反思</summary><div class="toggle-content"><p>特有的没做题，看题解后开始马后炮反思。</p>
<ol>
<li><p>思考是否是一些显性的数字组合，例如 ：5555，这种。</p>
<p>否决理由：可以控制很小的 $n$ ，但是 $n$ 比较大时根本控制不住。</p>
<p>特别发现： $9999…999$ ，只要 $n$ 的数量级小于位数的数量级，则位数和不变。</p>
</li>
<li><p>思考是否是分段加循环节，忽略一些小量的变化。</p>
<p>否决理由：循环起来可以发现平均变化量为 $0$ ，那么最终影响减小的还是总变化量。</p>
</li>
<li><p>开始思考可能是一些会损耗的构造，突然发现 $5*2=10$ ，逐步接近正解。</p>
<p>但以为是 $5^k$ 里面存在一段 $[l,r]$ 纯递增。</p>
<p>否决理由：试了，不存在这样的 $[l,r]$ 。</p>
</li>
<li><p>难道是 $n*5^k$ ？最接近正解的一集，可惜思维困在了找 $[l,r]$ 。</p>
<p>否决理由：试了，找不到。</p>
</li>
<li><p>难道不是 $5^k$ ，而是其他幂次，比如 $2^k$ ？。</p>
<p>否决理由：没找到，发现这么想其实已经和乱试没什么区别了，纯纯没有道理。</p>
</li>
<li><p>思考是否是搞几个串，不同的 $n$ 增量不同，然后列个方程，找个可行解。</p>
<p>否决理由：怎么判断方程是否有解，又怎么找到有解的方程。</p>
</li>
<li><p>回到第 $2$ 点，难道是列一堆状态，然后不同状态之间相互联动，然后用算法找一下可行解？</p>
<p>否决理由：根本没想出来个所以然，其实这个时候也知道这样想希望不大，没有正解的感觉，但也没有新的点子了。</p>
</li>
<li>投降，看题解，膜拜。</li>
</ol>
<p>回顾整个过程，其实可以发现做法就是 $3,4,6$ 的组合，但唯独就是没有想到小的数字虽然数位和不一定小，但是在乘 $n$ 后的平均值感觉上是小的。</p>
<p>回顾一下过程：</p>
<p>$1,2$ 步我认为是我目前必须经历的过程，尝试解法是很正常的，但重要的是要在更加短的时间否定这些想法，当能够大致的给出一个想法不对的点的时候，就应该去尝试想想其他想法了。</p>
<p>$3,4,6$ 步我认为没有问题，有一些新的想法是好事。</p>
<p>$5$ 纯粹的乱试，不过赛场也确实没有花太多时间在这一点上。</p>
<p>$7$ 的时候已经黔驴技穷了，也不知道自己在干嘛了，但又必须经历，感觉变强的过程就是在一步步经历 $7$ 的过程中，突然想到可以这么干的过程。但其实也不能硬撑，如果经历 $7$ 一段时间后还没想到新的点子（大概是半个小时到两个小时左右），大概率就是超能力范围了，这个时候硬想基本上是浪费时间，不如直接看题解，我认为在自己最困惑的时候，学习一下别人是怎么解决自己的困惑，是进步最快的方法。</p>
<p>当然，如果赛时进入 $7$ 阶段一小段时间的话，直接跳题才是收益最大化的选择，毕竟这场的 $E$ 我觉得不是不能做的，多一种选择就多一种可能。</p>
<p>怎么更快的想出这道题呢？关键的两点：</p>
<ol>
<li>$2*5=10$ 。（就算再难的构造也要有些比较关键的小性质，而注意到 $5$ 因子能够让数字“从小变大”变成“由大变小”是这道题目一个关键的突破。）</li>
<li>感觉上如果 $x&lt;y$ ，那么 $nx$ 和 $ny$ 的数位和的平均值应该会满足 $nx &lt; ny$ ，在有足够多且随机的 $n$ 时。（这个性质能够很好的利用 $5$ 由大变小的性质，并通过此题）</li>
</ol>
<p>提升“感觉”思维是我下次能够且更快做出这一类题目的关键。</p>
</div></details>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>题目大意：给一个只有 $A,B$ 的字符串，每次只能删除 $AAB$ 或者 $BAA$ ，问最多删除多少次。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>首先注意到一个事情，题目不能删除 $ABA$ 的字符串，这意味着单个的 $A$ 有可能被浪费，所以这道题目的核心就是如何减少 $A$ 的浪费。</p>
<p>在足够的思考后，观察到这么一个性质：如果把 $A$ 看成 $1$ ，$B$ 看成 $-2$ ，如果一个子串的和 $&gt;0$ ，那么这个子串一定可以变成一串 $A$ 。</p>
<p>原因是如果不是一串 $A$，最终一定是 $AB…BAB…BA…$ ，那么一定是 $\le 0$ 的。</p>
<p>因此这样合并条件就有了。</p>
<p>因此我们能够将原问题用该问题表示：用一些不相交的段覆盖所有的 $+1$ ，要求段的和 $&gt;0$，然后浪费的 $A$ 为和为奇数的段，最小化浪费。</p>
<p>这个时候其实已经可以 $dp$ 了。</p>
<p>使用某种数据结构维护一下转移过程就能 $O(n\log{n})$ 。</p>
<p>同时注意到，如果 $x\to x+2k$ ，那么一定有 $x\to x+2 \to x+2k$ ，因此转移能只从 $x-1,x-2$ 转移过来，时间复杂度：$O(n)$ 。</p>
<p>不过当时我没意识到到这就已经做完了，发现一个很自然的事情：如果和为奇数，代表可能有浪费，和为偶数，代表没有浪费，因此我们总是希望和为奇数，这个时候就很自然会想，奇数能不能分成两段 $&gt;0$ ？</p>
<p>答案是可以，对于一段我们先将正数合并，负数合并，两端是正数，然后从左边一段正数开始，然后另外一段是去掉下一段负数的右边，然后如果右边 $&lt;0$ ，那么左边的和大于中间负数段的绝对值，那么可以将左边往右推一格，由于最后会推到右边只有正数，所以一定存在一个时刻，左右两端都是正数，证毕。</p>
<p>因此，一段长度 $\ge 2$ 的 $&gt;0$ 一定能分成两段 $&gt;0$ ，综上，和为奇数的一定能分成一段奇数，一段偶数，所以奇数的长度可以至多为 $1$ 。</p>
<p>这样就得到了我的最终做法。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> &amp;n)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    n = <span class="built_in">strlen</span>(ss);</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> sum[N], a[N], dp[N];</span><br><span class="line"><span class="type">int</span> f[N * <span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">get_char_array</span>(st, n);</span><br><span class="line">        <span class="built_in">fill</span>(f, f + <span class="number">3</span> * n + <span class="number">2</span> + <span class="number">1</span>, inf);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i] == <span class="string">&#x27;A&#x27;</span>) a[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> a[i] = <span class="number">-2</span>;</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        f[n + n + <span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &lt; <span class="number">0</span>) dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>] + <span class="number">1</span>, f[sum[i] + (n + n + <span class="number">2</span>) - <span class="number">2</span>]);</span><br><span class="line">            f[sum[i] + (n + n + <span class="number">2</span>)] = <span class="built_in">min</span>(f[sum[i] + (n + n + <span class="number">2</span>)], dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> A = (sum[n] + n + n) / <span class="number">3</span>, B = n - A;</span><br><span class="line">        A -= dp[n];</span><br><span class="line">        <span class="built_in">assert</span>(A % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">min</span>(A / <span class="number">2</span>, B) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$O(n\log{n})$ 版的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> &amp;n)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    n = <span class="built_in">strlen</span>(ss);</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line">set&lt;PII&gt; f[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> sum[N], a[N], dp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">get_char_array</span>(st, n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i] == <span class="string">&#x27;A&#x27;</span>) a[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> a[i] = <span class="number">-2</span>;</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">0</span>].<span class="built_in">insert</span>(&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &lt; <span class="number">0</span>) dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> type = sum[i] &amp; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">auto</span> tmp = f[type].<span class="built_in">lower_bound</span>(&#123;sum[i], <span class="number">0</span>&#125;);</span><br><span class="line">                <span class="keyword">if</span>(tmp != f[type].<span class="built_in">begin</span>())&#123;</span><br><span class="line">                    tmp--;</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>((*tmp).second, dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> type = sum[i] &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">auto</span> tmp = f[type].<span class="built_in">lower_bound</span>(&#123;sum[i], dp[i]&#125;);</span><br><span class="line">                <span class="keyword">if</span>(tmp == f[type].<span class="built_in">end</span>()) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>((*tmp).second &gt;= dp[i]) f[type].<span class="built_in">erase</span>(tmp);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> tmp = f[type].<span class="built_in">upper_bound</span>(&#123;sum[i], dp[i]&#125;);</span><br><span class="line">            <span class="keyword">if</span>(tmp != f[type].<span class="built_in">begin</span>() &amp;&amp; (*(--tmp)).second &lt;= dp[i]);</span><br><span class="line">            <span class="keyword">else</span> f[type].<span class="built_in">insert</span>(&#123;sum[i], dp[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> A = (sum[n] + n + n) / <span class="number">3</span>, B = n - A;</span><br><span class="line">        A -= dp[n];</span><br><span class="line">        <span class="built_in">assert</span>(A % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">min</span>(A / <span class="number">2</span>, B) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        f[<span class="number">0</span>].<span class="built_in">clear</span>();</span><br><span class="line">        f[<span class="number">1</span>].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">反思</summary><div class="toggle-content"><p>想题过程：</p>
<ol>
<li>发现奇数个 $A$ 与浪费。</li>
<li><p>开始思考合并 $A$ 的条件，觉得可能和和有关。</p>
<p>否决理由：发现 $sum=0$ 时可以 $ABA$ 是反例。</p>
</li>
<li>开始思考能不能调整合并顺序。</li>
<li>发现非奇数的段可以直接与两端的最短的负数段合并，问题变成考虑奇数-负数-奇数-负数 … 。</li>
<li>手玩突然发现 $&gt;0$ 是充要条件。</li>
<li>证明分割的那个定理。</li>
<li>得到做法。</li>
<li>看题解发现可以线性，回来将自己的做法优化到线性。</li>
</ol>
<p>感觉这次想题的问题不大，第二步虽然很早的想到与和有关，这可以说是直觉，但是否决掉就说明实力还是有待提高，我并不觉得这个时候否决是多大的问题。</p>
<p>因为此时我的主要想法是通过调整合并顺序来实现更容易的合并，而 $&gt;0$ 这个条件如果是奇数，最后还会剩一个，如果是偶数，找 $B$ 一定能变成 $=0$ ，所以我当时就局限在我当时的思维卡了一下，以为条件如果有，一定是和为 $0$ 然后加上一些条件，但一直没找到就放弃这个想法了。</p>
<p>一直到后面手玩才发现 $ABB..BA…$ 这种东西和 $\le 0$ ，所以 $&gt;0$ 就是充要条件，你要说问题大吗？我觉得不大，因为当时的思维方向而否决掉一些对的想法这件事，我认为是正常的。</p>
<p>而最后第 $6$ 步也反映了这个想法，我当时觉得和为奇数一定会浪费一个，这种情况是不优且奇怪的，所以在明明已经能做的情况下，第一想法是找个方法把奇数段切割，直到奇数的长度为 $1$ 。</p>
<p>我认为这次的最大问题是思维局限住了，合并奇数的方法不止考虑调整合并顺序这么一种，假如不是运气好手玩发现了 $&gt;0$ 的这个充要条件，我估计要局限在这个思路很久。</p>
<p>当然在某种方向上想一段时间没有问题，保证深度，但是最大的问题是在这种方向上久久没有新的成果的时候，就要考虑换个方向想了，毕竟想题除了深度，还要考虑广度问题，而能有多广，就是实力问题了。</p>
<p>比如这题，我一开始的想法是调整，没有问题，否决掉正确想法，也没有问题，但是后面没有转换思维，去找其余可能的解决方法，就是我最大的问题，虽然最后运气好发现了，那也只能说 $&gt;0$ 这个条件还是比较浅，可以在不深挖的情况下就发现，一旦做法是需要深挖的话（指的是需要在另外一个方向深挖），这个时候不转换思维就只有死路一条。</p>
<p>因此在思路卡住的时候，最有效的解决方法就是跳出原有思路，扩宽想题广度。</p>
<p>（我其实觉得我现在和高中最大的区别就是广度变小了很多，导致我没法做很多我高中会做的题目，现在要注重培养想题的广度了）</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方做法</summary><div class="toggle-content"><p>坏了，非要说的话我一开始的想法还真没问题，真就和为 $0$ 且加一些条件就能判断这一段能不能被消除（虽然我当时的想法主要是减少奇数，减少浪费，因此也不太可能往这个方向想）。</p>
<p>菜就多练了只能说。</p>
<p>官方做法基于一个定理：</p>
<p>一个段能够完整的消除的充要条件：</p>
<p>能够分成多段使得每一段和为 $0$ 且两端中有一端为 $B$ 。</p>
<p>充分性：将 $B$ 去掉，这一段就 $&gt;0$ 了，可以只用 $A$ 表示，然后用 $B$ 消掉即可。</p>
<p>必要性：归纳。</p>
<p>然后直接 $dp$ 就行了，时间复杂度：$O(n)$ 。</p>
</div></details>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>独立成一篇题解。</p>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>独立成一篇题解。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>ARC170 E. BDFS</title>
    <url>/2024/02/20/ARC170-E-BDFS/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/arc170/tasks/arc170_e">https://atcoder.jp/contests/arc170/tasks/arc170_e</a></p>
<p>题目大意：现在有一个 $n$ 个点的环，然后每个点的权值 $a_i$ ，一开始都是 $-1$ ，然后有个队列，初始只有一个 $(1,0)$，</p>
<p>然后每次弹出队首 $(d,v)$，若 $a_d=-1$ ，则：</p>
<ol>
<li>$a_d=v$ 。</li>
<li>从小到大考虑 $d$ 相邻的权值为 $-1$ 的邻居 $x$ ，然后有 $p$ 的概率把 $(x,v+1)$ 加入队首，否则加入队尾。</li>
</ol>
<p>问最后所有点的权值和的期望。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>唐，太唐了，转换完题意不会做，一个经典的二阶期望不会，唐，太烫了。</p>
<p>首先，这道题目显然可以转换成这个题意：</p>
<p>现在有一个长度为二的数组：$a[0]=-1,a[1]=0$ ，然后 $type=0$ ，现在进行 $n-1$ 轮：</p>
<ol>
<li><code>a[type]++</code> 。</li>
<li>有 $p$ 的概率不发生变化，有 $1-p$ 的概率 <code>type^=1</code> 。</li>
</ol>
<p>问最后 $\frac{a<a href="a[0]+1">0</a>}{2}+\frac{a<a href="a[1]+1">1</a>}{2}$ 的期望值。</p>
<p>首先，多少阶的期望都是能做的，开对应阶数个状态就行了，像自然数幂求和那样推一下式子就行了。</p>
<p>这里是二阶期望，开两个状态即可。</p>
<p>但这里由于数组有两个位置，所以还要再多开一个状态，总共三个状态，分别为：</p>
<p>$f_{ans}[n]$ 表示 $n$ 轮后的期望答案，$f_0[n]$ 表示 $a[type]$ 的期望值，$f_1[n]$ 表示 $a[1-type]$ 的期望值。</p>
<p>则式子为：</p>
<script type="math/tex; mode=display">
\begin{align*}
    f_{ans}[n+1]&=f_{ans}[n]+f_{0}[n]+1\\
    f_{0}[n+1]&=p(f_{0}[n]+1)+(1-p)f_{1}[n]\\
    f_{1}[n+1]&=(1-p)(f_{0}[n]+1)+pf_{1}[n]\\
\end{align*}</script><p>然后直接矩阵快速幂就行了。</p>
<p>时间复杂度：$O(T\log{n})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span>&#123;</span><br><span class="line">    LL a[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">Matrix</span>()&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;O,tr;</span><br><span class="line">Matrix <span class="keyword">operator</span>*(Matrix x,Matrix y)&#123;</span><br><span class="line">    Matrix z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">3</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">3</span>;k++)&#123;</span><br><span class="line">                z.a[i][j]=(z.a[i][j]+x.a[i][k]*y.a[k][j])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line">Matrix <span class="keyword">operator</span>+(Matrix x,Matrix y)&#123;</span><br><span class="line">    Matrix z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">3</span>;j++)z.a[i][j]=(x.a[i][j]+y.a[i][j])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line">Matrix <span class="keyword">operator</span>%(Matrix x,LL y)&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">ksm</span><span class="params">(T x,LL y,T o)</span></span>&#123;</span><br><span class="line">    T ans=o;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x%mod;</span><br><span class="line">        x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        O.a[i][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        LL n,p;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;p);</span><br><span class="line">        p=p*<span class="built_in">ksm</span>(<span class="number">100ll</span>,mod<span class="number">-2</span>,<span class="number">1ll</span>)%mod;</span><br><span class="line">        LL pn=(<span class="number">1</span>-p+mod)%mod;</span><br><span class="line">        </span><br><span class="line">        tr.a[<span class="number">0</span>][<span class="number">0</span>]=tr.a[<span class="number">1</span>][<span class="number">0</span>]=tr.a[<span class="number">3</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        tr.a[<span class="number">1</span>][<span class="number">1</span>]=tr.a[<span class="number">3</span>][<span class="number">1</span>]=p;tr.a[<span class="number">2</span>][<span class="number">1</span>]=pn;</span><br><span class="line">        tr.a[<span class="number">1</span>][<span class="number">2</span>]=tr.a[<span class="number">3</span>][<span class="number">2</span>]=pn;tr.a[<span class="number">2</span>][<span class="number">2</span>]=p;</span><br><span class="line">        tr.a[<span class="number">3</span>][<span class="number">3</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        Matrix ans=<span class="built_in">ksm</span>(tr,n,O);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(ans.a[<span class="number">3</span>][<span class="number">0</span>]-ans.a[<span class="number">1</span>][<span class="number">0</span>]+mod)%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我当时其实写出了一个正确的式子，但我不知道怎么推了，在文章的最后放一下吧，悲。</p>
<script type="math/tex; mode=display">\frac{(n-1)n}{2}-\sum\limits_{x=1}^{n-1}(x-1)(n-x)\sum\limits_{i=1}^x\binom{x-1}{i}\binom{n-1-x}{i-1}p^{n-1-2i}(1-p)^{2i}+\binom{x-1}{i-1}\binom{n-1-x}{i-1}p^{n-2i}(1-p)^{2i-1}</script><p>唐，怎么每次碰到dp+矩阵快速幂的题都不会做啊，悲。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>概率与期望</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC190 D Matrix Pow Sum</title>
    <url>/2025/02/04/ARC190-D-Matrix-Pow-Sum/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/arc190/tasks/arc190_d">https://atcoder.jp/contests/arc190/tasks/arc190_d</a></p>
<p>题目大意：给一个 $n*n$ 的矩阵和素数值域 $p$ （接下来所有运算都在 $\mod{p}$ 意义下进行），然后矩阵中 $0$ 的位置可以是 $1\sim p-1$ 的任何一个数字，所以有 $(p-1)^{\mathrm{cnt}}$ 种不同的矩阵，$\mathrm{cnt}$ 表示矩阵中 $0$ 的个数，对于每个矩阵，其对答案的贡献为其的 $p$ 次方，求所有矩阵的贡献和（答案是一个矩阵）。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>设每个 $0$ 的位置是 $x_{1},…,x_{\mathrm{cnt}}$ ，那么答案中每个位置的答案就是关于 $x_{1},…,x_{\mathrm{cnt}}$ 的多元多项式，这启示我们去思考 $1^{k}+2^{k}+…+(p-1)^{k}\mod{p}$ 的值，然后打表可以发现只有当 $p-1$ 整除 $k$ 时为 $-1$ ，其余都为 $0$ 。这个的证明可以用那个经典的递推式证明，这里懒得展开了。</p>
<p>在知道这个后，我们就知道我们只关心多元多项式中每个未知数指数为 $0$ 或 $p-1$ 的项，然后就可以讨论了。</p>
<ol>
<li>当 $p=2$ 的时候，可以知道等价于把 $0$ 设置成 $1$ 。</li>
<li>当 $p≠2$ 的时候，可以知道所有关心的项至多涉及到一个未知数，这个未知数的指数为 $p-1$ ，这个时候接着讨论。如果这个未知数在乘积中存在相邻位置，那么可以知道这个未知数一定在 $(i,i)$ ，且已知数一定在开头和结尾；否则可以知道 $p=3$ ，且未知数落在开头和结尾，中间是已知数。</li>
</ol>
<p>讨论完毕。</p>
<p>时间复杂度：$O(n^3\log{n})$</p>
<p>空间复杂度：$O(n^3)$</p>
<p>和官方题解复杂度一致。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n; LL mod;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    LL a[N][N];</span><br><span class="line">    <span class="built_in">node</span>()&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">    LL* <span class="keyword">operator</span>[](<span class="type">int</span> x)&#123;<span class="keyword">return</span> a[x];&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(LL &amp;x, LL y)</span></span>&#123;x = (x + y) % mod;&#125;</span><br><span class="line">node <span class="keyword">operator</span> * (node x, node y)&#123;</span><br><span class="line">    node z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">                <span class="built_in">upd</span>(z[i][j], x[i][k] * y[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">ksm</span><span class="params">(node x, LL k)</span></span>&#123;</span><br><span class="line">    node ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) ans = ans * x;</span><br><span class="line">        x = x * x;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ksm</span><span class="params">(LL x, LL k)</span></span>&#123;</span><br><span class="line">    LL ans = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) ans = ans * x % mod;</span><br><span class="line">        x = x * x % mod;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; mod;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    node x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            cin &gt;&gt; x[i][j];</span><br><span class="line">            <span class="keyword">if</span>(x[i][j] == <span class="number">0</span> &amp;&amp; mod == <span class="number">2</span>)&#123;</span><br><span class="line">                x[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x[i][j] == <span class="number">0</span>) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node ans = <span class="built_in">ksm</span>(x, mod);</span><br><span class="line">    <span class="comment">// for(int i = 1; i &lt;= n; i++)&#123;</span></span><br><span class="line">    <span class="comment">//     for(int j = 1; j &lt;= n; j++) cout &lt;&lt; ans[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;---\n&quot;;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x[i][i] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="built_in">upd</span>(ans[j][i], x[j][i]);</span><br><span class="line">                <span class="built_in">upd</span>(ans[i][j], x[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mod == <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(x[i][j] == <span class="number">0</span>) <span class="built_in">upd</span>(ans[i][j], x[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL val = <span class="built_in">ksm</span>(mod - <span class="number">1</span>, cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) cout &lt;&lt; ans[i][j] * val % mod &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>ARC158 赛后总结</title>
    <url>/2025/02/04/ARC158-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>可以变为+1-1模型，做完。</p>
<p>有一个比较巧妙的点。</p>
<p>如何快速计算 $x,y,z$ 且 $+1-1$变成相等的点呢？</p>
<p>设 $p$ 为平均数，则为：$(|x-p|+|y-p|+|z-p|)/2$ 。</p>
<p><a href="https://atcoder.jp/contests/arc158/submissions/42216000">Submission #42216000 - AtCoder Regular Contest 158</a></p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>你可以进行讨论，发现三个数字要么是负数中的最大值或最小值（或次或次次），要么是正数…（同理）。</p>
<p>排序完后直接取出这些数字，然后 $O(n^3)$ 暴力枚举即可。</p>
<p><a href="https://atcoder.jp/contests/arc158/submissions/42233273">Submission #42233273 - AtCoder Regular Contest 158</a></p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>对每个位置排序然后双指针就行了。</p>
<p>我做复杂了。(悲</p>
<p><a href="https://atcoder.jp/contests/arc158/submissions/42228346">Submission #42228346 - AtCoder Regular Contest 158</a></p>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><h2 id="官方做法"><a href="#官方做法" class="headerlink" title="官方做法"></a>官方做法</h2><p>不会做。</p>
<p>顶级离谱，利用了指数差 $1$ 的性质。</p>
<p>概率的证明看不懂。</p>
<p><a href="https://atcoder.jp/contests/arc158/submissions/42233535">Submission #42233535 - AtCoder Regular Contest 158</a></p>
<h2 id="民间做法"><a href="#民间做法" class="headerlink" title="民间做法"></a>民间做法</h2><p><a href="https://www.luogu.com.cn/blog/Leasier/solution-ARC158D">题解 [ARC158D] Equation - CQ 最菜 OIer - 洛谷博客 (luogu.com.cn)</a></p>
<p>挺离谱的一个思路。</p>
<p>补充一个证明：$x,y,z$ 互不相等。</p>
<p>$r≠1$ ，则只有 $y,z$ 可能想等，即：$-x=rx$ ，即$(r+1)=0$ ，所以 $r=p-1$ 。</p>
<p>所以只要 $r≠1,p-1$ 就可以使得三者不成立。</p>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>TMD，原来不是性质题，是算法题啊。</p>
<h2 id="做法1"><a href="#做法1" class="headerlink" title="做法1"></a>做法1</h2><p>分治算法，排序差值，暴力开做。</p>
<p>时间复杂度：$O(n\log{n})$</p>
<h2 id="做法2"><a href="#做法2" class="headerlink" title="做法2"></a>做法2</h2><p>类似<a href="https://www.luogu.com.cn/blog/44599/solution-at-arc158-e">题解 ARC158E All Pair Shortest Paths - 加油机的博客 - 洛谷博客 (luogu.com.cn)</a></p>
<p>但是用另外一个方式描述，不是构建最短路径树，而是找到了一种递推关系。</p>
<p>时间复杂度：$O(n\log{n})$</p>
<h2 id="做法3"><a href="#做法3" class="headerlink" title="做法3"></a>做法3</h2><p>维护前面每个点到现在两个点的最短距离，考虑更新，就会发现更新的条件和那个差值有关，暴力修改，每一次额外的修改都会合并一个差值，所以 $O(n)$ 次。</p>
<p>同时因为插入的数字最多插在左右，所以只要用一个双端队列就可以 $O(n)$ 做了。</p>
<p><a href="https://www.luogu.com.cn/blog/Tony2/solution-at-arc158-e">arc158e题解 - Tony2 的小窝 - 洛谷博客 (luogu.com.cn)</a></p>
<p><a href="https://atcoder.jp/contests/arc158/submissions/42235100">Submission #42235100 - AtCoder Regular Contest 158</a></p>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>ARC190 C Basic Grid Problem with Updates</title>
    <url>/2025/02/04/ARC190-C-Basic-Grid-Problem-with-Updates/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/arc190/tasks/arc190_c">https://atcoder.jp/contests/arc190/tasks/arc190_c</a></p>
<p>题目大意：一个 $n*m$ 的网格，从左上走到右下且只能向下或者向右走的路径的权值为路径点权乘积，每次会从当前点往四个方向走一格并且修改当前位置的权值，输出每次移动后的所有路径权值和。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然会考虑根号做法，不妨假设 $n\le m$ ，我们可以发现，设 $l[i][j]$ 表示 $(1,1)\to (i,j)$ 的所有路径权值和，$r[i][j]$ 表示 $(i,j)\to (n,m)$ 的所有路径权值和。</p>
<p>设当前位置为 $(nx,ny)$ ，然后正确的维护 $l[1\sim n][1\sim ny],r[1\sim n][ny+1\sim m]$ ，可以发现每次移动的修改量是 $O(n)$ ，而且显然根据这个信息可以在 $O(n)$ 的时间得到答案，所以时间复杂度就是 $O(nm+\min(n,m)q)$ 。</p>
<p>至于我怎么想到的？想到是根号复杂度后感觉这个做法就比较自然了，大概。</p>
<p>和官方题解复杂度一致。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;LL&gt; VL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B = <span class="number">5e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, q, nx, ny, type = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> be[<span class="number">300</span>];</span><br><span class="line">VL a[B], ll[B], rr[B];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> col, <span class="type">int</span> dir)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(col == m + <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(!dir)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            ll[i][col] = (ll[i][col - <span class="number">1</span>] + ll[i - <span class="number">1</span>][col]) * a[i][col] % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">            rr[i][col] = (rr[i][col + <span class="number">1</span>] + rr[i + <span class="number">1</span>][col]) * a[i][col] % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printans</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LL ans = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = (ans + ll[i][ny] * rr[i][ny + <span class="number">1</span>]) % mod;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    be[<span class="string">&#x27;U&#x27;</span>] = <span class="number">0</span>; be[<span class="string">&#x27;R&#x27;</span>] = <span class="number">1</span>; be[<span class="string">&#x27;D&#x27;</span>] = <span class="number">2</span>; be[<span class="string">&#x27;L&#x27;</span>] = <span class="number">3</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; m)&#123;</span><br><span class="line">        type = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">swap</span>(n, m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        a[i].<span class="built_in">resize</span>(m + <span class="number">2</span>);</span><br><span class="line">        ll[i].<span class="built_in">resize</span>(m + <span class="number">2</span>);</span><br><span class="line">        rr[i].<span class="built_in">resize</span>(m + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ll[<span class="number">1</span>][<span class="number">0</span>] = rr[n][m + <span class="number">1</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">if</span>(!type)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) cin &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; q &gt;&gt; nx &gt;&gt; ny;</span><br><span class="line">    <span class="keyword">if</span>(type) <span class="built_in">swap</span>(nx, ny);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ny; i++) <span class="built_in">update</span>(i, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = m; i &gt; ny; i--) <span class="built_in">update</span>(i, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// for(int i = 1; i &lt;= n; i++)&#123;</span></span><br><span class="line">    <span class="comment">//     for(int j = 1; j &lt;= m; j++) cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// printans();</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">        <span class="type">char</span> st[<span class="number">10</span>]; LL tmp;</span><br><span class="line">        cin &gt;&gt; st &gt;&gt; tmp;</span><br><span class="line">        <span class="type">int</span> t = be[st[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">1</span>) t = <span class="number">3</span> - t;</span><br><span class="line">        nx += dx[t], ny += dy[t];</span><br><span class="line">        a[nx][ny] = tmp;</span><br><span class="line">        <span class="built_in">assert</span>(nx &gt;= <span class="number">1</span> &amp;&amp; ny &gt;= <span class="number">1</span> &amp;&amp; nx &lt;= n &amp;&amp; ny &lt;= m);</span><br><span class="line">        <span class="built_in">update</span>(ny, <span class="number">0</span>); <span class="built_in">update</span>(ny + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printans</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>ARC172 D. Distance Ranking</title>
    <url>/2024/03/18/ARC172-D-Distance-Ranking/</url>
    <content><![CDATA[<p>题目链接：<a href="https://atcoder.jp/contests/arc172/tasks/arc172_d">https://atcoder.jp/contests/arc172/tasks/arc172_d</a></p>
<p>题目大意：请你构造 $n$ 个 $n$ 维空间的整点，满足两点间距离的大小排序符合题目给的顺序。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>真TM人类智慧，根本想不到。</p>
<p>准确来说有想过先构造使得每条边都一样长，然后再微调，但是压根没想到微调的具体方法。</p>
<p>简单来说，设第 $i$ 个点的坐标是 $(a_{i,1},a_{i,2},…,a_{i,n})$ 。</p>
<p>先令 $a_{i,j}=[i=j]*K$ ，其中 $K$ 是一个很大的数字，显然，这样能使任意两点间的距离都等于 $\sqrt{2}K$ 。</p>
<p>现在的问题是怎么微调？我们假设给 $a_{i,1},a_{i,2},…,a_{i,n}$ 都加个相对于 $K$ 的小量，那么 $i$ 与别的点的距离会怎样变化呢?</p>
<p>将式子列出来可以发现，对于 $i,j$ 的距离的平方可以大致写成 $2K^2+c*K+O(1)$ ，其中 $c$ 与 $a_{i,i},a_{i,j}$ 有关，可以发现，这个式子的三个部分分别对应不同的量级。</p>
<p>对应任意两点的距离，都有 $2K^2$ 这一项，因此如果 $c*K$ 不一样，就可以用这一项控制相对大小了，显然此时 $O(1)$ 不影响相对大小。</p>
<p>接下来就很简单了，随便口胡一下就行了。</p>
<p>时间复杂度：$O(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i][i]=<span class="number">1e6</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*(n<span class="number">-1</span>)/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        a[x][y]+=n*(n<span class="number">-1</span>)/<span class="number">2</span>-i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>哎，菜就得多练了，根本想不到。</p>
<p>但多练真的有用吗？</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC159 赛后总结</title>
    <url>/2025/02/04/ARC159-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><strong>ARC159</strong></p>
<p>回归信息学做的第一场比赛啊。</p>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>看完第一眼就觉得应该是可以$\%n$ 做的，不难。</p>
<p>因为边的起点终点都是可以 $+n$ 的，但是比较麻烦的是自己到自己的 $+n$ 。</p>
<p>也就是说需要在 $n<em>n$ 的图中找环，可以写，但是有更加简单的做法，直接在 $2n</em>2n$ 的图上跑 Floyd 即可。</p>
<p>需要记住，在显示赛上，运行时间短并不是第一目的。</p>
<p>第一目的是最快的找到一个能做的做法，然后赛后再去想最优解。</p>
<p>$O(n^3+q)$</p>
<p><a href="https://atcoder.jp/contests/arc159/submissions/42207812">Submission #42207812 - AtCoder Regular Contest 159</a></p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>比较巧妙的一道题目，可以发现，减时差不变。</p>
<p>因此，最大公约数一定是差的因子。</p>
<p>因此我们可以每次把 $A,B$ 除掉当前的最大公因数，然后找下一个最早出现的因子是哪个，这样不断下去，每次至少 $/2$ 。</p>
<p>时间复杂度：$O(\log^2{max(A,B)}+\sqrt{|A-B|})$</p>
<p><a href="https://atcoder.jp/contests/arc159/submissions/42208144">Submission #42208144 - AtCoder Regular Contest 159</a></p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>好题。</p>
<p>显然，每次加 $\frac{n(n+1)}{2}$ 。</p>
<p>不妨考虑 $\%n$ 意义下，所以不能得到奇数的必要条件是 $\%n=0$ ，偶数的必要条件是 $\%{\frac{n}{2}}=0$ 。</p>
<p>但是是充分吗？</p>
<p>不妨考虑这么一组构造：</p>
<p>$1,2,…,n$</p>
<p>$n-1,n,n-2,n-3,…,1$</p>
<p>这样，一号位置相对 $-1$ ，二号位置相对$+1$ 。</p>
<p>显然奇数可以用这样的构造完成。</p>
<p>偶数且 $\%{n}=\frac{n}{2}$ 时就构造：$-\frac{n}{2}+1,…0,…\frac{n}{2}$ 。（这一串的和显然是 $\frac{n}{2}$ ）</p>
<p>然后一个$n,n-1,n-2,…,1$ 带走。</p>
<p>但是呢？</p>
<p>这样可能会有点慢。</p>
<p>考虑加速，我们可以不相对 $-1+1$ ，而是相对 $-k+k$ ，思考一下，类似的。</p>
<p>时间复杂度：$O(n^2)$</p>
<p><a href="https://atcoder.jp/contests/arc159/submissions/42209134">Submission #42209134 - AtCoder Regular Contest 159</a></p>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>比 $C$ 题简单。</p>
<p>直接离散化，然后段前段中用线段树处理一下就行了，搞两个 $key$ 值。</p>
<p>时间复杂度：$O(n\log{n})$</p>
<p><a href="https://atcoder.jp/contests/arc159/submissions/42209585">Submission #42209585 - AtCoder Regular Contest 159</a></p>
<p>但是呢，既然是复健训练，看看luogu题解。</p>
<p>woc，set+二分，对哦。</p>
<p>好打飞。</p>
<p>学之。</p>
<p><a href="https://atcoder.jp/contests/arc159/submissions/42212817">Submission #42212817 - AtCoder Regular Contest 159</a></p>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>不会做，看题解。</p>
<p>几个引理：</p>
<ol>
<li>x,x+1 在树上一定为祖先儿子关系。-》转化为树上距离。</li>
<li>加上dis(c,d)。-》由树上距离转为求虚树点的个数。</li>
<li>非[c,d]的点在虚树上都在c-&gt;d路径上。-》所有要求的量全部转化为了求出 $c-&gt;d$ 的路径。</li>
</ol>
<p>至此，又由于题目保证了 $max(\frac{a_i}{b_i},\frac{b_i}{a_i})≤2$ ，所以时间复杂度为 $\log{}$ 。</p>
<p>做完。</p>
<p>真的退化成原始人了，一点思路都没有了，悲QAQ。</p>
<p><a href="https://atcoder.jp/contests/arc159/submissions/42213921">Submission #42213921 - AtCoder Regular Contest 159</a></p>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>Border学习笔记</title>
    <url>/2024/02/11/Border%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.luogu.com.cn/blog/command-block/border-li-lun-xiao-ji">https://www.luogu.com.cn/blog/command-block/border-li-lun-xiao-ji</a></p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h2 id="Border"><a href="#Border" class="headerlink" title="Border"></a>Border</h2><p>$Border$ ：字符串的某个前缀（非原串），能与后缀完全匹配。</p>
<p>例：$S[1,m]=S[n-m+1,n]$ ，那么称 $S[1,m]$ 为 $S$ 的一个 $Border$ 。</p>
<p>接下来简称 $Border$ 为 $Bd$ 。</p>
<p>我们称 $mxBd(S)$ 为 $S$ 最长的 $Bd$ ，$Bd(S)$ 为 $S$ 的 $Bd$ 集合。</p>
<h2 id="周期"><a href="#周期" class="headerlink" title="周期"></a>周期</h2><p>若对于 $p$ ，有 $S[i]=S[i+p]$ ，称 $p$ 是 $S$ 的周期。</p>
<p>若 $p| |S|$ ，则称 $p$ 为整周期。</p>
<p>显然，$S[1,p]$ 是 $Bd$ $\Leftrightarrow$ $|S|-p$ 是周期。</p>
<h1 id="与-kmp-的关系"><a href="#与-kmp-的关系" class="headerlink" title="与 kmp 的关系"></a>与 kmp 的关系</h1><h2 id="求每个前缀的最长-Border"><a href="#求每个前缀的最长-Border" class="headerlink" title="求每个前缀的最长 Border"></a>求每个前缀的最长 Border</h2><p>显然，$fail[i]$ 表示的就是 $mxBd(S[1,i])$ 的长度。</p>
<h2 id="求一个串的-Bd-集合。"><a href="#求一个串的-Bd-集合。" class="headerlink" title="求一个串的 $Bd$ 集合。"></a>求一个串的 $Bd$ 集合。</h2><p>无脑 Hash 可以，但是有个更加有理有据的做法：</p>
<p>$Bd(S)=\{mxBd(S)\}+Bd(mxBd(S))$</p>
<p>然后直接用 kmp 的 fail 指针不断跳就行了，即 $Bd(S)$ 对应了 $fail$ 树上的一条链。</p>
<h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><h2 id="弱周期引理-Weak-Periodicity-Lemma，简称：WPL"><a href="#弱周期引理-Weak-Periodicity-Lemma，简称：WPL" class="headerlink" title="弱周期引理(Weak Periodicity Lemma，简称：WPL)"></a>弱周期引理(Weak Periodicity Lemma，简称：WPL)</h2><p>$p,q$ 都是 $S$ 的周期 ，且 $p+q\le |S|$ ，则 $gcd(p,q)$ 也是 $S$ 的周期。</p>
<p>证明：不妨假设 $p&lt;q$ 。</p>
<p>$S[i]=S[i+q]=S[i+q-p],i\le n-q$</p>
<p>$S[i]=S[i-p]=S[i+q-p],p\le n-q&lt;i\le n+q-p$</p>
<p>所以 $q-p$ 也是一个周期，辗转相减即可证明该结论。</p>
<p>PS：强周期定理：把条件改成 $p+q-gcd(p,q)\le n$ ，不会证明，大部分情况下用弱周期就行了，强周期了解即可。</p>
<p>推论：如果一个串有 $&lt;|S|$ 的整周期，则最小周期也是整周期。</p>
<h2 id="等差数列"><a href="#等差数列" class="headerlink" title="等差数列"></a>等差数列</h2><p><strong>性质 1</strong> ：$S,T,2|S|\ge |T|$ ，则 $S$ 在 $T$ 中的出现位置构成等差数列。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>如果出现次数小于 $3$ 次，显然成立。</p>
<p>考虑第一次出现位置 $S1$ 、第二次出现位置 $S2$ 和任意一次（除了前两次）出现位置 $S3$ ，假设 $S2-S1=l1,S3-S2=l2$ 。</p>
<p><img src="1.png" alt=""></p>
<p>现在证明 $l1 | l2$ ，考虑 $S1\cup S2$ 这个字符串，显然 $l1,l2$ 都是一个周期，且 $l2\le |S|$ ，则 $l1+l2\le l1+|S|=|S1\cup S2|$ ，所以 $gcd(l1,l2)$ 也是一个周期，如果 $gcd(l1,l2)&lt;l1$ ，则在 $S1$ 和 $S2$ 中间显然还出现了至少一次，与假设矛盾，证毕。</p>
<p>所以 $l1 | l2$ ，则结论显然成立 ，$l1$ 就是公差。</p>
</div></details>
<p><strong>性质 2</strong> ：一个字符串 $S$ 的长度 $\ge \frac{|S|}{2}$ 的 Border 构成等差数列。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>第一个证明方法是用周期和 Border 的等价性，然后用 WPL 很容易就能证明。</p>
<p>还有一个证明方法是用上面的性质 $1$ ，设 $s$ 为 $\ge \frac{|S|}{2}$ 的长度最短的 Border 。</p>
<p>考虑 $s$ 的所有出现位置，显然，一个 $\ge \frac{|S|}{2}$ 的 Border 对应一个 $s$ 的出现位置，只需要证明一个 $s$ 的出现位置（除了最后一个位置）也对应一个 Border 即可。</p>
<p>（对应方式为：除了最后一个出现位置外的出现位置，考虑这个出现位置的右端点，右端点对应的前缀就是一个 Border ，实际上，如果把原串也视作一个 border 的话，那么最后一个出现位置也有对应了）</p>
<p><img src="2.png" alt=""></p>
<p>证明方法为：观察性质 $1$ 的证明可以发现，$s$ 出现位置的公差就是 $S$ 的周期，所以显然除了最后一个位置外的每一个出现位置都对应了一个 Border 。</p>
<p>但是上面两个方法我还是推荐用周期进行考虑。</p>
</div></details>
<p><strong>性质 3</strong> ：一个字符串的 Border 从小到大排序可以划分成 $O(\log{|S|})$ 个等差数列。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>考虑 $\ge \frac{|S|}{2}$ 的 Border 构成等差数列，然后考虑 $&lt;\frac{|S|}{2}$ 的最大的 Border ，显然，剩下的 Border 也是这个 Border 的 Border ，然后接着考虑就行了，所以至多 $O(\log{|S|})$ 个。</p>
</div></details>
<p>事实上，通过上面的描述，不难发现：</p>
<p>长度在 $(\frac{|S|}{2},|S|],(\frac{|S|}{4},\frac{|S|}{2}],(\frac{|S|}{8},\frac{|S|}{4}],(\frac{|S|}{16},\frac{|S|}{8}]…$ 即 $(\frac{|S|}{2^{k+1}},\frac{|S|}{2^k}]$ 的 Border 构成等差数列。</p>
<p>或者长度在 $[1,2),[2,4),…,[2^i,2^{i+1}),[2^{i+1},|S|]$ 的 Border 也构成等差数列。（ $|S|&lt;2^{i+2}$ ）</p>
<p>显然，长度在 $<a href="2a\ge b">a,b</a>$ 的 Border 都构成等差数列。</p>
<h2 id="失配树"><a href="#失配树" class="headerlink" title="失配树"></a>失配树</h2><p>对于一个串，考虑对于每个前缀建立一个节点，其父亲是其的 $mxBd$ ，这样构成的一棵根为空串的树叫做失配树，显然，Kmp 的 fail 数组就代表了这棵树。</p>
<p>这棵树有很多性质。</p>
<p><strong>性质 1</strong> ：根据 $Bd(S)=\{mxBd(S)\}+Bd(mxBd(S))$ 可以得出，一个前缀的所有 Bd 就是到父亲的这条链。</p>
<p>这个性质可以用于解决这个题目：</p>
<p><a href="https://www.luogu.com.cn/problem/P5829">https://www.luogu.com.cn/problem/P5829</a></p>
<p>题目大意：给一个串，$q$ 次询问，每次询问询问两个前缀的最长公共 border 长度。</p>
<p>显然就是失配树上找 LCA 就行了。</p>
<p><strong>性质 2</strong> ：每个点到根节点的路径可以划分成 $O(\log)$ 段，每段父子间长度差恒定。（也就是上面 $O(\log)$ 段等差数列的失配树版本）</p>
<p>这个性质可以产生上面那道题目的另外一个做法：</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>首先，先介绍一种常数更加小的划分 Border 的方式：</p>
<p>如果 $2fail[x]\ge x$ ，令 $p=x-fail[x]$ ，那么 $x$ 到 $x\mod {p}+p$ 构成等差数列，否则 $x$ 自己就是个等差数列。</p>
<p>然后令 $x$ 跳到最大的没有被划分进等差数列的位置就行了，实操中当 $2fail[x]\ge x$ 时，往往直接跳到 $x\mod {p}+p$ ，即认为等差数列间可以有交叉，这样处理方便一些，而且显然，不难证明这么跳 $x’&lt;\frac{2x}{3}$ ，所以仍然是 $O(\log)$ 段。</p>
<p>（这个划分方式还有个小性质，如果 $2fail[x]\ge x$ ，则等差数列至少有两项，否则只有一项）</p>
<p>在划分完 Border 后，显然可以用扩展欧几里得去处理，但是这样是两个 $\log$ 的，而且写起来还没 LCA 好写。</p>
<p>考虑利用性质进行优化，现在考虑找 $x,y$ 前缀的最长公共 Bd ，不妨认为原串也算 Bd，且 $x&gt;y$ ，考虑上述划分中 $x$ 的第一个等差数列。</p>
<p>如果 $2fail[x]&lt;x$，那么显然 $x=fail[x]$ 即可。</p>
<p>如果 $2fail[x]\ge x$ ，那么显然如果 $x\equiv y\mod p$ ，则 $y$ 就是最长公共 Bd ，否则考虑 $y$ 的长度：</p>
<ol>
<li>如果 $y&lt;2p$ ，那么显然这个等差数列，也就是分配树上的这条链除了链头没有别的串可能是公共 Bd 。</li>
<li>如果 $y\ge 2p$ ，显然 $y$ 的最小周期也是 $p$ ，则根据 WPL 可以得出链上 $\ge 2p$ 的点都不可能是公共 Bd（考虑 $x,y$ $\ge 2p$ 的所有 Bd ，显然互不相同），也即只有链头还有可能成为答案，所以 $x=x\mod p+p$。</li>
</ol>
<p>不难发现，这个做法的复杂度与 $x,y$ 按照上述方法划分的等差数列个数同阶（因为上面的过程其实就是从一个等差数列的列尾，跳到下一个等差数列的列尾），也就是 $O(n+q\log{n})$ ，而且显然好写很多，空间也只用 $O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> fail[N],n,q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);n=<span class="built_in">strlen</span>(st+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    fail[<span class="number">0</span>]=<span class="number">-1</span>;<span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(now!=<span class="number">-1</span> &amp;&amp; st[now+<span class="number">1</span>]!=st[i])now=fail[now];</span><br><span class="line">        fail[i]=++now;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        x=fail[x];y=fail[y];</span><br><span class="line">        <span class="keyword">while</span>(x!=y)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;y)<span class="built_in">swap</span>(x,y);</span><br><span class="line">            <span class="keyword">if</span>(fail[x]*<span class="number">2</span>&lt;x)x=fail[x];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">assert</span>(x);</span><br><span class="line">                <span class="type">int</span> d=x-fail[x];</span><br><span class="line">                <span class="keyword">if</span>(x%d==y%d)x=y;</span><br><span class="line">                <span class="keyword">else</span> x=x%d+d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h2 id="一些其他性质"><a href="#一些其他性质" class="headerlink" title="一些其他性质"></a>一些其他性质</h2><ol>
<li><p>如果一个串 $S$ 有 $\ge \frac{|S|}{2}$ 的 Border，则最小的 $\ge \frac{|S|}{2}$ 的 Border 长度 $&lt;\frac{3|S|}{4}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>假如最小周期 $p\le \frac{|S|}{4}$ ，则显然 Border $\ge \frac{3|S|}{4}$ 时，还能再去掉一个周期，直到 $&lt;\frac{3|S|}{4}$ 。</p>
<p>假如 $&gt;$ ，显然所有的 Border 都 $&lt;\frac{3|S|}{4}$ ，所以也显然成立。</p>
<p>证毕。</p>
</div></details>
</li>
<li><p>如果一个串 $s$ 有一个 $t$ 作为 mxBd ，且 $2|t|\ge|s|$ ，那么 $t$ 在 $s$ 中只出现了两次。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>由性质 $1$ 知道出现位置是等差数列，如果出现 $3$ 次及以上可以构造出更长的 Bd ，矛盾。</p>
<p>这个证法和性质 2 的证明 2 挺像的，都是利用了某个 Bd 的出现位置和一些 Bd 的对应关系。</p>
</div></details>
<p>这个性质可以应用在某些 Bd 优化题中，以确定 mxBd 上次出现的位置。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Border</tag>
      </tags>
  </entry>
  <entry>
    <title>CCPC 2023 网络赛赛后总结</title>
    <url>/2025/02/04/CCPC-2023-%E7%BD%91%E7%BB%9C%E8%B5%9B%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>一个经典的 trick ：</p>
<p>$(x+1)^k$ 可以用 $x^k,x^{k-1}…x,1$ 表示出来，所以如果一个维护段数的 $k$ 次方的转移只需要同时维护 $x^k,x^{k-1}…$ 的值就可以转移了。</p>
<p>具体来说，这道题目可以用 Hash+二分 非常轻松的求出以一个位置为起点的合法分割位置的最远处。</p>
<p>然后如何做呢？</p>
<p>考虑 $f_i$ 表示以 $i$ 开始的后缀的权值和（包括方案数、段数和、段数平方和），那么设 $g_i$ 表示在 $f_i$ 的基础上再增加一段的权值和。</p>
<p>然后 $g$ 后缀和，每次需要的时候提取区间和就行了。</p>
<p>时间复杂度：$O(n\log{n})$</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>我的做法：</p>
<p>其实我在赛场上想的是点分治+树链剖分，$log^2$ 的，太屎了，没写，但是实际上如果我当时注意到时间复杂度其实和点分治没有太大关系，就应该意识到这道题目应该可以不用点分治，直接暴力 $DFS$ 枚举链的 $lca$ 。</p>
<p>具体来说，我的做法这样：</p>
<p>考虑序列怎么做？对于每个区间 $[l,r]$ ，从大到小处理 $l$ ，然后线段树找前缀 $r-1$ 的最大值 +2 ，然后在 $r$ 处插入供后面的位置更新。</p>
<p>对于树也类似，考虑把点对分成两种类型：</p>
<ol>
<li>点对的一个点是另外一个点的祖先。</li>
<li>以及其余情况。</li>
</ol>
<p>首先 DFS 一整棵树，然后考虑当一个点的子树遍历完时，开始考虑这个点作为回文子序列的根。</p>
<p>把每个点对扔到其的 $lca$ 上，当考虑 $x$ 为根时，考虑把 $x$ 身上的所有点对排序，按照点对中 $dfs$ 序最小值从小到大排序。</p>
<p>然后依次遍历点对。</p>
<p>假设点对中 $dfs$ 序小的点为 $l$ ，大的点为 $r$ ，这个点对作为回文子序列外边界的最长长度为 $r$ 到根的最大权值 和 $l$ 到根的最大权值的最大值 $+2$ ，得到权值后把权值填在 $r$ 。</p>
<p>同时点对的影响可能会被撤销，具体来说，如果这个点对是 $2$ 类型，设这个点对为 $l_1,r_1$ ，当前点对为 $l_2,r_2$ ，如果 $l_1$ 不是 $l_2$ 的祖先，就把 $r_1$ 的贡献撤销掉。</p>
<p>那么就只需要一个单点修改，到根节点最大权值的数据结构，树剖即可。</p>
<p>经典序列上树了，属于是。</p>
<p>举个例子吧：</p>
<p><img src="1.png" alt=""></p>
<p>首先是绿点对更新，然后红点对再更新，蓝点对再更新。</p>
<p>其次，其实没必要查询到根节点路径上的最大权值，查到 $x$ 就可以了，不过鉴于 $fa_x-&gt;$ 根的路径上没有权值，所以影响不大。</p>
<p>然后多考虑一点细节应该就可以了。</p>
<p>这题的重点就是该转移的一定要转移，例如红点对一定要在蓝点对之前更新，且一定要有方式能够转移到蓝点对。</p>
<p>不能转移的一定不能够转移，比如撤销操作。</p>
<p>考虑清楚转移顺序这道题目其实就做完了。</p>
<p>时间复杂度：$O(n\log^2{n})$</p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>不会。</p>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>不会</p>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>暴力题。</p>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p>显然只需要保留很少的点就行了。</p>
<p>重点是要保留多少点，当时分析 SB 了，以为需要保留至多 $7$ 个点。</p>
<p>同机房别的队是 $5$ 个点。他们的说法是：最大值 $a_1$ 、与 $a_1$ 不同行的最大值 $a_2$、与 $a_1$ 不同行与 $a_2$ 不同列的最大值，$a_3,a_4$ 与 $a_2,a_3$ 类似。</p>
<p>其实分析一下可以发现最多是 $4$ 个点，上面其实有两个点是重复的。</p>
<details class="toggle" ><summary class="toggle-button" style="">官方题解</summary><div class="toggle-content"><p>不过官方题解的做法感觉也非常的精妙：</p>
<p>考虑 $f(x,y)$ 为与 $(x,y)$ 不同行列的最大值（就是询问的那玩意）。</p>
<p>从大到小考虑，点对 $(x,y,w)$ 为考虑把十字以外的部分都给赋上自己的值，如果一个点对没有更新任何一个位置的值，其就是无用的。</p>
<p>整个图的状态有以下几种：</p>
<p>全集、十字、一条竖线、一条横线、两个不在同行同列的格子、一个格子，空集。</p>
<p>根据转移，显然只会有四个有用格子。</p>
<p>排除格子的方式也很简单，把所有当前有用的格子从大到小排序，然后维护图的状态，转移，转移失败就将点对标为无效然后继续。</p>
</div></details>
<p>时间复杂度：$O(q)$</p>
<p>空间复杂度：$O(1)$</p>
<h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p>不难。</p>
<p>首先当 $m=2$ 时显然只有一种合法情况，直接找到输出。</p>
<p>对于 $m&gt;2$ 的情况，我们可以定义一种字符的权值为：把不是这个字符的位置赋值为 $0$ ，是这个字符的位置赋值为 $1$ 得到的 $m$ 进制数。</p>
<p>然后我们就可以得到 $cnt$ 个权值，$cnt$ 为不同字符数量。</p>
<p>我们设 $A$ 为一种合法情况。</p>
<p>先说一个等式：$gcd(a,b)=gcd(a,a-b)$，考虑通过调整得到所有合法情况。</p>
<ol>
<li><p>当 $cnt&lt;m$ ，对于任意一个字符，都存在一种合法情况 $B$ 可以使这个字符的代表数值 +1 得到新的合法情况 $B’$ ，根据上面的等式，我们可以知道，我们的答案一定是所有字符权值的一个公因数。</p>
<p>我们设 $d$ 就是所有字符权值的公因数，这是必要条件，考虑充分性，任意一个合法权值都是字符权值的线性组合，所以 $d$ 也是所有合法权值的因子，证毕。</p>
</li>
<li><p>当 $cnt=m$ 时，显然这个时候交换两个字符代表的权值就能得到所有合法情况，但是因为当 $m=2$ 时，首字母不能自由交换，所以要特判，$m&gt;2$ 的情况显然首字母只要不和 $0$ 交换就行，想要和一个字符交换，如果是 $0$ 先移走就行了，而这个移走就需要 $m\ge 3$ 。<br>考虑两个字符上面的数值的差是 $d$ ，那么前后方案数的差为 $d*(val_1-val_2)$ ，$val$ 表示两种字符的权值，显然，$d$ 可以为 $1$ 。<br>这样就变成了求任意两种权值差值的 gcd ，显然，任意两种权值的差值的自由元是 $cnt-1$ 个，即：$a-c=(a-b)+(b-c)$ ，这样把所有自由元 $gcd$ 起来就行了。</p>
</li>
</ol>
<p>时间复杂度：$O(T(|P|+m+\log{A}))$</p>
<h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>显然，$n≤5000$ 暴力。（UPD:这里错了，暴力复杂度是 $n^3$ 的，正确的做法看改造。）</p>
<p>设最大度数的点的度数为 $n-1-x$ ，首先 $nx\le 2m$。</p>
<p>显然，如果两个点之间的距离 $&gt;2$ 的必要条件是度数和 $\le n-2$ ，所以不能和最大度数的点达成这个必要条件的度数必须 $&lt;x$ ，设这种点数量为 $y$ ，设关键点数量为 $y$ 则 $(n-x)y\le 2m$ 。</p>
<p>发现当 $n\ge 5000$ 时 $x$ 最大为 $80$ （其实 $x$ 的量级为：$O(\frac{m}{n})$），则 $(n-x)$ 接近 $n$ ，所以 $y\le O(\frac{m}{n})$ 。</p>
<p>显然，对于非关键点的图，可以直接处理，因为距离 $\le2$ 把距离 $=2$ 的处理出来就行了。</p>
<p>对于包含关键点的图，考虑重构图，关键点之间的连边保留。</p>
<p>考虑 $dis[x][y]$ 表示关键点 $x$ 到非关键 $y$ 的距离，同时有限制，必须每条边都走到非关键点，显然这样走要么到达不了，要么距离 $\le 3$ ，考虑暴力走两步，时间复杂度：$y<em>x</em>n\le O((\frac{m}{n})^2*n=\frac{m^2}{n})$ ，然后把两端不是都是关键点的边删了，连接新边：$x,y$ 连边，权值为 $dis[x][y]$ 。（其实思考一下可以发现不用连 $dis[x][y]=3$ 的边）</p>
<p>然后以每个关键点为起点跑最短路或者边权 $\le 3/2$ 的 BFS ，然后就做完了。</p>
<p>时间复杂度：$O(min(\frac{m^2}{n},n^2))$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">改造</summary><div class="toggle-content"><p>看了官方题解，重新审视了一下我的做法。</p>
<p>可以发现，开始的暴力不跑会导致哪些权值的量级受到影响：</p>
<p>$x-O(\frac{m}{n})$ ，不受影响。</p>
<p>$y$ 因为我们估计了，会受到影响，但是我们不妨重新估计一下。</p>
<ol>
<li>假如 $x\le \frac{n}{2}$ ，那么 $n-O(\sqrt{m})$ ，所以 $y\le n$ ，所以 $y-O(\sqrt{m})$ 的，此时与 $O(\frac{m}{n})$ 同阶。</li>
<li>当 $x&gt; \frac{n}{2}$ 时， $(n-x)-O(n)$ ，所以也是 $O(\frac{m}{n})$ 的。</li>
</ol>
<p>所以实际上，不跑那个暴力，我的做法依旧是 $O(\frac{m^2}{n})$ 的。</p>
<p>同时，其实可以发现一个事情：$O(\frac{m}{n})\le O(\sqrt{m})$ 因为 $m\le \frac{n(n-1)}{2}$ 。</p>
<p>所以，我的做法就和题解时间复杂度一样了：$O(m\sqrt{m})$ 。</p>
</div></details></div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方做法</summary><div class="toggle-content"><p>首先，题解提到的补图单源最短路我猜测是：每个点只走向目前没有被更新到的点，那么每个点被访问的次数总和显然是 $O(n+m)$ 的。</p>
<p>然后，其实在我的做法中的改造中也提到了，如果我们把度数小于 $\frac{n}{2}$ 的点都设为关键点，复杂度实际上是不变的。</p>
<p>官方做法也是类似，只不过是直接以关键点跑单源补图最短路，时间复杂度就是 $O(\frac{m^2}{n})=O(m\sqrt{m})$ 。（就是涉及关键点的部分我是改造了一下图再跑的，官方题解是直接跑单源补图最短路）</p>
<p>现在问题就是，怎么在 $O(n+m)$ 的时间内跑出单源补图最短路。（之前的做法空间是 $O(n^2)$ 的）</p>
<p>考虑当前跑到了 $x$ ，把 $x$ 所有不能到达的点标记一下，暴力跑当前没有跑到的点，如果没有被标记就是可以跑到，这样时间复杂度是对的。</p>
<p>标记的部分是 $O(m)$ 的，所有点都走一遍是 $O(n)$ 的，同时遍历时一个点有标记的次数总和也是 $O(n+m)$ 的，所以总时间复杂度是： $O(n+m)$ 的。</p>
<p>然后就做完了。</p>
<p>根本不需要什么复杂的改造原图的过程，也不需要什么大型的分类讨论，关键点非关键点乱搞一通，删边再连边啥的，代码会好写很多。</p>
<p>直接跑几遍朴实无华的单源补图最短路就做完了，但是可惜啊，在做这道题目之前，我并不会这个科技啊QAQ。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">扩展</summary><div class="toggle-content"><ol>
<li>图中 $\ge 2$ 或者不能到达的点对个数为恰好 $m$ 个。<br>因为充要条件为 $x,y$ 之间的边被删除了。</li>
<li>路径长度至多是 $O(\sqrt{m})$ 的。<br>因为路径上的非相邻点之间的边都必须被删除，所以假如路径长度为 $x$ ，那么被删除的边的数量级就是 $O(x^2)$ 的。</li>
</ol>
<p>这两个性质我赛场上一个都没有发现，乐。</p>
</div></details>
<h1 id="I"><a href="#I" class="headerlink" title="I"></a>I</h1><p>不会。</p>
<h1 id="J"><a href="#J" class="headerlink" title="J"></a>J</h1><p>显然，平面两种情况，三个点在一个面上（$n^4$），和两个面上各有两个点（$n^5$）。</p>
<p>直接 $n^5$ 可以过。</p>
<p>原因：常数极小，比如一个线段只用枚举一次，就可以除 $2$ ，两条线段就是除 $4$ ，然后还有可能还没枚举完就判 NO 等等，都导致这个做法实际上常数很小。</p>
<p>所以 $n^5$ 可以直接过，乐。</p>
<h1 id="K"><a href="#K" class="headerlink" title="K"></a>K</h1><p>不会</p>
<h1 id="L"><a href="#L" class="headerlink" title="L"></a>L</h1><p>非常有意思的一道题目。</p>
<p>准确来说，我们可以这么模拟这个过程，钦定一个 $b_{limit}$ ，然后对于 $b_i\le b_{limit}$ 的所有 $a_i$ 中挑选个前 $k$ 小的。</p>
<p>这样，存在决策单调：</p>
<p>$k_1&lt;k_2$ ，那么 $k_1$ 的最优决策对应的 $b$ 要 $≤$  $k_2$ 最优决策对应的 $b$ 。</p>
<p>然后直接分治就做完了。</p>
<p>证明也是非常简单，显然 $b_{limit}$ 越大 ，$a$ 的选择越多，所以 $b_{limit}$ 越大，在 $k$ 增大的过程中新加的数字肯定会越优秀。</p>
<p>所以当 $k$ 增大时，小的 $b_{limit}$ 会越来越劣，大的 $b_{limit}$ 会越来越优，然后就证完了。</p>
<p>可以在分治过程中线段树/平衡树，也可以直接上主席树+分治。</p>
<p>时间复杂度：$O(n\log^2{n})$ 。</p>
<h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><ol>
<li>等gym出了补题，顺便补一下地址。</li>
<li>亲手写一些代码，例如：口胡或者知道做法但是没有写的题目。</li>
<li>把没有做的题目自己做一遍。</li>
<li>自己去看一遍官方题解并且补充一下官方题解的做法。</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>Bridge Elimination</title>
    <url>/2024/02/02/Bridge-Elimination/</url>
    <content><![CDATA[<p>题目链接：<a href="https://qoj.ac/contest/1499/problem/8180">https://qoj.ac/contest/1499/problem/8180</a></p>
<p>题目大意：给定 $n$ 个点的点权，求 $n$ 个点的所有图的权值和，一个图的权值定义为：如果不连通，则为 $0$ ，联通则为所有边双的点权和的乘积。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>知道 Cayley 公式乱做。（但是我赛时不知道这个公式 QAQ ）</p>
<p>时间复杂度：$O(n^3)$ 。</p>
<p>解释一下代码：</p>
<p>$cn[i]$ 是 $i$ 个点的联通图的数量。</p>
<p>$dp[i][j]$ 表示有 $j$ 个点，恰好有 $i$ 个连通块的图的权值和（一个图的权值定义为每个连通块大小的乘积）</p>
<p>$bn[i]$ 表示 $i$ 个点的边双联通块数量。</p>
<p>$ff[i]$ 表示 $n$ 个点中，指定的 $i$ 个点各在一个边双，且联通，且恰有 $i$ 个边双的图的数量。</p>
<p>$ge[i]$ 表示从 $n$ 个点中选 $i$ 个点的点权乘积的和。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;LL a[N];</span><br><span class="line">LL fc[N],nfc[N];</span><br><span class="line"><span class="function">LL <span class="title">ksm</span><span class="params">(LL x,LL y)</span></span>&#123;</span><br><span class="line">    LL ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x%mod;</span><br><span class="line">        x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line"><span class="keyword">namespace</span> Graph&#123;</span><br><span class="line">    LL cn[N],dp[N][N],bn[N];</span><br><span class="line">    LL f[N][N],ff[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cn[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            cn[i]=<span class="built_in">ksm</span>(<span class="number">2</span>,i*(i<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)cn[i]=(cn[i]-cn[j]*<span class="built_in">ksm</span>(<span class="number">2</span>,(i-j)*(i-j<span class="number">-1</span>)/<span class="number">2</span>)%mod*<span class="built_in">C</span>(i<span class="number">-1</span>,j<span class="number">-1</span>)%mod+mod)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;j;k++)&#123;<span class="comment">//pre size</span></span><br><span class="line">                    <span class="type">int</span> cnt=j-k;</span><br><span class="line">                    dp[i][j]=(dp[i][j]+dp[i<span class="number">-1</span>][k]*cn[cnt]%mod*<span class="built_in">C</span>(j<span class="number">-1</span>,cnt<span class="number">-1</span>)%mod*cnt)%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            bn[i]=cn[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;<span class="comment">//1&#x27;s size</span></span><br><span class="line">                LL now=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=i-j;k++)&#123;</span><br><span class="line">                    now=now*j%mod;</span><br><span class="line">                    bn[i]=(bn[i]-bn[j]*<span class="built_in">C</span>(i<span class="number">-1</span>,j<span class="number">-1</span>)%mod*dp[k][i-j]%mod*now%mod+mod)%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;j;k++)&#123;</span><br><span class="line">                    <span class="type">int</span> cnt=j-k;</span><br><span class="line">                    f[i][j]=(f[i][j]+f[i<span class="number">-1</span>][k]*<span class="built_in">C</span>(j-i,cnt<span class="number">-1</span>)%mod*bn[cnt]%mod*cnt)%mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ff[<span class="number">1</span>]=bn[n];<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)ff[i]=f[i][n]*<span class="built_in">ksm</span>(n,i<span class="number">-2</span>)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">LL ge[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    Graph::<span class="built_in">init</span>();</span><br><span class="line">    ge[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;=<span class="number">1</span>;j--)ge[j]=(ge[j<span class="number">-1</span>]*a[i]+ge[j])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans=(ans+ge[i]*Graph::ff[i])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>Prüfer序列</tag>
      </tags>
  </entry>
  <entry>
    <title>CCPC Final 2022 赛后总结</title>
    <url>/2025/02/04/CCPC-Final-2022-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><a href="https://qoj.ac/contest/1244">https://qoj.ac/contest/1244</a></p>
<p>被折磨哩QAQ。</p>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>每个点拆成两个点，如果有一条边 $(x,y)(x&lt;y)$ ，那么连边：$(x+n,y)$。</p>
<p>然后除了 $1,2n$ 以外的每个点选择一条边，其中 $2$~$n$ 表示这条边是第一棵树上指向父亲的边，而 $n+1$~$2n-1$ 表示的是这个点第二棵树上指向父亲的边。</p>
<p>然后检查图中是不是基环森林，每有一棵基环树答案乘 $2$ 。</p>
<p>时间复杂度：$O(n)$</p>
<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>显然，这是一个 $2n-2$ 个点和边的图，然后如果图中没有孤立点（有显然是无解的），显然构成的图就是一个基环树森林，然后一个基环树的贡献显然只有基环的两种方向。</p>
</div></details>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>注：代码与做法有点区别。</p>
<p>但本质相同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="心路历程"><a href="#心路历程" class="headerlink" title="心路历程"></a>心路历程</h2><p>实际上我赛场想的做法并不是这个做法，这个做法是别的队的，这个做法的最大有点就是：本质，好写。</p>
<p>我写写我的想法吧。</p>
<p>我并没有拆点，这是导致我做的慢的原因，然后，我对于一个点把边分成了两种，指向编号大的和指向编号小的，看起来和拆点类似，但是实际上差别很大，至少证明会复杂很多。</p>
<p>然后如果有点的某一种边只有一条且其没有选择这个方向上的父亲时，就直接选择。（补充一下，不难发现，这其实就是每一棵树/森林的叶子节点可以找到另一棵树/森林上其的父亲，然后不断确定边，最后把两棵树都拆成一堆森林）</p>
<p>显然，最后两棵树可能会剩下一堆森林交错，无法具体确定哪条边应该归属到哪棵树中。</p>
<p>因此，我们尝试先进行一次选择，即指定一个点的某条边一定在某棵树中，观察一下具体会发生什么。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>CCPC Final 2023 赛后总结</title>
    <url>/2024/04/10/CCPC-Final-2023-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>这就最纯粹的坐牢的乐趣啊。</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>题目大意：</p>
<p>一个合法的字符串数组（不是字符数组），满足：</p>
<ol>
<li>$1\le |S_i| \le n$</li>
<li>$S_{i}$ 是 $S_{i+1}$ 的周期。</li>
<li>$S_i$ 互不相同</li>
</ol>
<p>这里 $S$ 是 $T$ 的周期的定义是：</p>
<p>如果 $|S|&gt;|T|$ ，则 $T$ 是 $S$ 的前缀，否则和一般的周期定义一致。</p>
<p>问对于 $n$ 从 $1$ 到 $n$ ，每个 $n$ 能构造的最大的合法字符串数组有多大。</p>
<details class="toggle" ><summary class="toggle-button" style="">观察</summary><div class="toggle-content"><p>这是个计数题，但我们首先要知道我们在记什么。</p>
<p>一个基本的观察是：</p>
<p>我们构造 $S_1$ 为 $n$ 个不同的字符组成。</p>
<p>那么一个显然的上界是：能由 $S_1$ 的所有前缀拼接出来的不同字符串数量。</p>
<p>现在证明这个上界是对的：</p>
<p>我们可以将上面的字符串集建成一棵字典树，我们令这棵字典树左儿子为这个位置在 $S_1$ 中的下一个字符（这个位置指的是在前缀中的位置），右儿子为第一个字符。</p>
<p>然后考虑做中序遍历，得到的就是一个合法的构造。</p>
<p>证毕。</p>
<p>但是字符集是小写字母咋办，其实可以发现，把 $S_1$ 换成 $ab….$ 仍然成立，只要满足任意一个字符串的 $S_1$ 的前缀表示不存在或者唯一即可。</p>
<p>而这样的字符串构造也非常的简单，只要字符串中除了第一个位置以外的其余位置都和第一个位置不一样就行了，这是充要条件。</p>
<p>那么现在问题可以等价的转换为：</p>
<p>问多少个数列满足：</p>
<p>$1 \le \sum a_i \le n, a_{i}\le a_1$</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">大佬做法</summary><div class="toggle-content"><p>来自于机房的大佬。</p>
<p>首先根据上面的说法，我们不难设计一个计数方法：</p>
<p>$dp[i][j]$ 表示第一个数字为 $i$ ，同时当前的 $\sum a_i = j$ 的方案数。</p>
<p>初始时 $dp[i][i] = dp[i][i + 1] = 1$ 。</p>
<p>当 $j &gt; i + 1$ 时，满足 $dp[i][j] = dp[i][j - 1] * 2 - dp[i][j - i -1]$ 。</p>
<p>原因是你可以在 $dp[i][j - 1]$ 的基础上选择使最后一个 $a_m+1$ 或者新增一个 $a_m=1$ ，当需要容斥掉 $a_m&gt;i$ 的情况。</p>
<p>另外一方面，从背包的角度看：</p>
<p>$dp[i][j] = \sum\limits_{k=1}^{i}dp[i][j-k]$ 。</p>
<p>然后用 $dp[i][j]$ 的式子减去 $dp[i][j - 1]$ 的式子即可得到上面的转移式。</p>
<p>我们设 $f[n]$ 为 $\sum a_i = n, a_{i}\le a_1$ 的方案数，显然这就是答案的差分，又显然 $f[n] = \sum dp[i][n]$</p>
<p>那么如何维护 $dp[i][n]$ 呢？</p>
<p>可以发现，对于 $dp[i][n]$ ，显然我们只要知道 $dp[i][n],dp[i][n-i],dp[i][n-2i]…$ 就足以完成转移。</p>
<p>即：$b[j]=dp[i][n-(j-1)i]$ 。</p>
<p>显然，下一次：$b[i]=b[i]*2-b[i+1]$ 。</p>
<p>观察到多个 $dp$ 数组的 $b$ 数组转移类似，可以直接累加，而 $b_{1}$ 即为所求。</p>
<p>但是这样还是 $O(n^2)$ ，怎么优化？</p>
<p>注意到当 $i&gt;\sqrt{n}$ 时，$b$ 数组只会开到 $\sqrt{n}$ ，所以直接暴力处理 $i\le \sqrt{n}$ 的 $dp$ 数组，大的用 $b$ 数组转移即可做到 $O(n\sqrt{n})$ 的复杂度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B1 = <span class="number">450</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B2 = <span class="number">450</span>;</span><br><span class="line">LL mod;</span><br><span class="line">LL ans[N];</span><br><span class="line">LL a[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, LL val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i * i &lt;= x; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> j = x / i;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; B1)&#123;</span><br><span class="line">                a[j] = (a[j] + val) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j != i &amp;&amp; j &gt; B1)&#123;</span><br><span class="line">                a[i] = (a[i] + val) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= B1; i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">        a[i] = <span class="number">1</span>;</span><br><span class="line">        a[i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">2</span>; j &lt;= n; j++) a[j] = (a[j - <span class="number">1</span>] * <span class="number">2</span> - a[j - i - <span class="number">1</span>] + mod) % mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) ans[j] = (ans[j] + a[j]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= B2; j++)&#123;</span><br><span class="line">            a[j] = (a[j] * <span class="number">2</span> - a[j + <span class="number">1</span>] + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">add</span>(i, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(i - <span class="number">1</span>, mod - <span class="number">1</span>);</span><br><span class="line">        ans[i] = (ans[i] + a[<span class="number">1</span>]) % mod;</span><br><span class="line">        ans[i] = (ans[i] + ans[i - <span class="number">1</span>]) % mod;</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我观察到了一般，可惜一没观察到 $b$ 是可以合并的，二没观察到可以根号分治（不过一没观察到自然也就观察不到二了）。</p>
<p>对于这个做法一个更加形象的解释是：</p>
<p><img src="1.png" alt=""></p>
<p>如果把 $b[i]$ 看成维护一条条直线的话，那么 $b[i]$ 的斜率就是 $i-1$ ，因此在 $i&gt;\sqrt{n}$ 后，直线就只会处在 $i&lt;\sqrt{n}$ 的位置了，直接根号分治，这样就只用维护 $\sqrt{n}$ 条直线了。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方做法</summary><div class="toggle-content"><p>我最学不懂的东西，生成函数启动！</p>
<p>考虑做法 $1$ 中背包的角度开始算生成函数：</p>
<p>先枚举第一个数字是啥，再枚举有多少个 $a$ ，则对于 $n$ 的答案就是：</p>
<script type="math/tex; mode=display">\begin{align*}

 & [x^{n}]\frac{1}{1-x}\sum\limits_{k=1}^n x^{k} \sum\limits_{i=0}^{\infty} (x\frac{1-x^{k}}{1-x})^i \\
 = & [x^{n}]\frac{1}{1-x}\sum\limits_{k=1}^n \frac{x^{k}}{1-x\frac{1-x^k}{1-x}} \\
 = & [x^{n}]\sum\limits_{k=1}^n \frac{x^{k}}{(1-x)-x+x^k} \\
 = & [x^{n}]\sum\limits_{k=1}^n \frac{x^{k}}{1-2x+x^k}
\end{align*}</script><p>然后这个咋处理呢？</p>
<p>不会。</p>
</div></details>
<h1 id="L"><a href="#L" class="headerlink" title="L"></a>L</h1><p>另外开了篇题解详细讲述。</p>
<h1 id="K"><a href="#K" class="headerlink" title="K"></a>K</h1><p>题目大意：</p>
<p>给一个 $n*n$ 的网格，要求在网格上放一些顶着上边界的竖棒或者贴着左边界的横棒，要求棒之间不能相交，且要求一些位置不能被棒覆盖，一些位置必须被棒覆盖，问有多少种合法的放棒方案，两种方案不同当且仅当被覆盖的位置集合不同。</p>
<p>形式化的：</p>
<p>合法的 $a,b$ 数组（长度都为 $n$ ，$a$ 表示横着的棒长，$b$ 表示竖着的棒长）需要满足：</p>
<p>$0\le a_{i},b_{i} \le n$</p>
<p>$[a_{i}\ge j] \ne [b_{j}\ge i]$ </p>
<p>且有一些额外的要求：</p>
<p>$[a_{c_{k}}\ge d_{k}]+[b_{d_{k}}\ge c_{k}]=1$</p>
<p>$[a_{c’_{k}}\ge d_{k}]+[b_{d_{k}}\ge c’_{k}]=0$</p>
<p>但是不是问有多少种不同的合法数组，具体见原题意。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>我们要计数的话，更好计数的是合法的 $a,b$ 数组个数，而不大可能去以覆盖的位置集合为状态去计数（后效性太强）。</p>
<p>但是问题是：不同的 $a,b$ 数组可能是同一个放棒方案。</p>
<p>因此我们需要给合法的 $a,b$ 数组加上一些限制，使其与放棒方案构成双射。</p>
<p>我加上的条件是：</p>
<p>$\forall 1 \le i\le n : a_{b_{i} + 1} \ne i$</p>
<p>证明：</p>
<p>单射：</p>
<p>假设有两组 $a,b$ 、$a’,b’$ 不同但对应的是同一个放棒方案。</p>
<p>不妨设 $b_{i} &gt; b’_{i}$ ，那么 $a’_{b’_{i} + 1} \ge i$ 。</p>
<p>那么显然：$\forall i\le j \le a’_{b’_{i} + 1}:b_{j}\ge b’_{i} + 1,b’_{j} = b’_{i}$ 。</p>
<p>因此 $a’_{1+b’_{a’_{b’_{i} + 1}}} = a’_{b’_{i} + 1}$ ，所以 $a’,b’$ 不是合法的，矛盾。</p>
<p><img src="2.png" alt=""></p>
<p>满射：</p>
<p>对于任意一个没加限制的合法的 $a,b$ 数组，如果违反了限制，那么显然可以让 $b_{i}+1$ ，$a_{b_{i}+1}-1$ ，这样就得到了一个覆盖位置集合不变的新的 $a,b$ 数组，由于 $\sum b$ 在不断增加，因此这个过程一定可以停下来，所以是个满射。</p>
<p>证毕。</p>
<p>接下来就是计数了，还挺麻烦的。</p>
<p>设 $dp[i][j]$ 表示前 $i-1$ 个 $b$ 的值都 $&lt;j$ 且 $b_{i}=j$ ，且已经填了 $a_{1}\sim a_{j}$ 的方案数。</p>
<p>$dp[i][j]\to dp[i’][j’]$ 需要考虑的贡献有 $i\to i’$ 的贡献（填 $b$ 的方案）和 $j\to j’$ 的贡献（填 $b$ 的方案）。</p>
<p>然后优化这个 $dp$ 过程就行了。</p>
<p>时间复杂度 ： $O(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">LL nf[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    nf[<span class="number">0</span>] = nf[<span class="number">1</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">max</span>(n, m); i++) nf[i] = (mod - mod / i) * nf[mod % i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Key</span>&#123;</span><br><span class="line">    LL val;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> row[N][N], col[N][N];</span><br><span class="line"><span class="type">bool</span> br[N][N], bc[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> st[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getst</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) s[i + <span class="number">1</span>] = ss[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//g is consider next row</span></span><br><span class="line">LL f[N], g[N], tmp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    m = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">getst</span>(st[i]);</span><br><span class="line">        st[i][m + <span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m++;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        br[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> cnt = row[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">bool</span> lock = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(lock) cnt = <span class="number">0ll</span>;</span><br><span class="line">                <span class="keyword">else</span> cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(st[i][j] == <span class="string">&#x27;0&#x27;</span>) lock = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!lock) cnt++;</span><br><span class="line">            <span class="keyword">if</span>(!lock) br[i][j] = <span class="number">1</span>;</span><br><span class="line">            row[i][j] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">        bc[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> cnt = col[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">bool</span> lock = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(lock) cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(st[i][j] == <span class="string">&#x27;0&#x27;</span>) lock = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!lock) cnt++;</span><br><span class="line">            <span class="keyword">if</span>(!lock) bc[i][j] = <span class="number">1</span>;</span><br><span class="line">            col[i][j] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1ll</span>;</span><br><span class="line">    g[<span class="number">0</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) tmp[i] = g[i];</span><br><span class="line">        LL now = <span class="number">0ll</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            now = now * row[i][j - <span class="number">1</span>] % mod;</span><br><span class="line">            <span class="keyword">if</span>(i)&#123;</span><br><span class="line">                now = (now + tmp[i - <span class="number">1</span>]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!bc[i][j]) now = <span class="number">0ll</span>;</span><br><span class="line">            <span class="keyword">if</span>(i != n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(st[i + <span class="number">1</span>][j] != <span class="string">&#x27;1&#x27;</span>) g[i] = g[i] * col[i][j] % mod;</span><br><span class="line">                <span class="keyword">else</span> g[i] = <span class="number">0ll</span>;</span><br><span class="line">                <span class="keyword">if</span>(i &amp;&amp; br[i + <span class="number">1</span>][j] &amp;&amp; st[i][j] != <span class="string">&#x27;1&#x27;</span>) g[i] = (g[i] + f[i] * col[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">                <span class="keyword">if</span>(st[i + <span class="number">1</span>][j] != <span class="string">&#x27;1&#x27;</span>) g[i] = (g[i] + now * row[i + <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            f[i] = (f[i] * col[i][j] + now) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大概的优化就是注意到 $a$ 的贡献可以用类似前缀和的方式搞搞，也就是代码中的 $now$ 。</p>
<p>而 $b$ 的贡献也是类似前缀和，在每一列的转移结束后，用 $O(n)$ 的时间维护一下 $b$ 的贡献，就可以得到对下一列的贡献了。</p>
<p>大概解释一下 $f,g$ ，就是注意到 $a$ 的贡献中，恰好处于 $j + 1$ 位置的行的贡献，由于限制的存在，这一行的限制要比其余行的限制要多，因此 $g$ 就是存储考虑 $j+1$ 行的列的贡献，而 $f$ 就是不考虑 $j+1$ 行的列的贡献，作用是去维护出新的 $g$ 。</p>
<p>我感觉正解肯定不是这么做的，感觉这个做法有一种力大砖飞的感觉，太不优美了。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方做法</summary><div class="toggle-content"><p>如何判断一个 $01$ 矩阵是合法的？（下面以 $f$ 为 $01$ 矩阵）</p>
<p>只需要找到一条从左上到右下的路径（只能向下或者向右），满足左边的都是横条，上面的都是竖条。</p>
<p>但问题是，一个矩阵可能对应多条路径，怎么办？</p>
<p>我们设 $a$ 数组满足：$a_{i}$ 是最小的满足：$f_{i,a_{i}}=0,f_{i,a_{i}+1}=1$ ，如果这一行没有这种东西则认为 $a_{i}=0$ 。</p>
<p>可以用 $a$ 可以表示出一条路径 $p_{l}$ ，同理，可以用 $b$ 表示列，然后同样表示出一条路径 $p_r$ 。</p>
<p>如果这个矩阵是合法的，则一条路径是合法的充要条件是在 $p_l,p_r$ 之间。</p>
<p>显然，$f$ 合法当且仅当 $p_l,p_r$ 合法，因此只需要将 $f$ 放在 $p_l$ 或者 $p_r$ 计数就行了。</p>
<p>简单来说，用 $dp$ 计算每个 $p$ 作为 $p_l$ 时有多少合法的 $f$ 与其对应就行了。</p>
<p>时间复杂度：$O(n^2)$ 。</p>
<p>可以发现，与 $p_r$ 对应的合法的 $f$ 的充要条件就是我的做法所加的那个新限制。</p>
<p>非常的 $interesting$ ，相当于是从不同的角度得到了同一个做法了。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">更好的实现：</summary><div class="toggle-content"></div></details>
<h1 id="M"><a href="#M" class="headerlink" title="M"></a>M</h1><p>题目大意：在一个数轴上有 $n+1$ 个洞 $n$ 个球，间隔分布，然后假设球的滚动方向确定，你可以自由确定球的滚动顺序使最大化不会落入相邻洞的球的数量，然后现在给你一些球的滚动方向，要求你确定一些球的滚动方向使最大化数量。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>这道题目最难的就是：假设确定了滚动方向，如何找出最大数量。</p>
<p>这个问题可以等价的转化为：将 $&gt;$ 变成 $($ ，将 $&lt;$ 变成 $)$ ，删除若干个括号，使得最终是个合法括号序列，那么这个删法的贡献为：删除的括号数量加上，原来的 $()$ 且最后没有删除其中任何一个括号的数量。</p>
<p>这里可以解释以下后面那个的数量代表什么：和 $&gt;&lt;$ 一定会至少浪费一个球的原因一致。</p>
<p>首先，上面的一种删法可以对应一种顺序。</p>
<p>证明：</p>
<p>首先，对于一个区间的球，其能覆盖的洞的情况分三种：左闭右开，左开右闭，左闭右闭中间开。</p>
<p>但无论是哪种，对于 $()$ ，只要中间其实是有球且已经滚完了，都一定存在一种方式使得这两个球都不会被浪费，滚完以后认为 $()$ 已经被删了就行，所以，初始条件就是对于所有的 $()$ ，要么中间已经有球，要么一开始就是 $()$ ，因此综上，至多浪费上面那个数量，证毕。</p>
<p>其次，最优顺序一定对应上面的一种删法。</p>
<p>证明：</p>
<p>考虑最优顺序一定可以调整成下面的情况：先让所有被浪费的球滚进去，然后每次让一个球跨过一个区间。</p>
<p>现在归纳的证明：对于任意一个左闭右开的区间，一定存在一个上面的一个删法使得在浪费的数量相等的情况下，剩下的括号序列要么是合法的，要么多一个 $)$ ，左开右闭则是 $($ 。</p>
<p>比如一开始有个 $)$ ，那么形成的就是一个左闭右开的洞，所以下次如果有洞跨过它一定是左边有一个 $($ 跨过来，那么合法多个 $($ ，$)$ 和 $($ 匹配，同时左闭右开变成左开右闭。</p>
<p>区间合并同理。</p>
<p>证毕。</p>
<p>然后直接拿着这东西 DP 一下就行了，时间复杂度：$O(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> dp[N][N][<span class="number">2</span>];<span class="comment">//need destroy?</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; (st + <span class="number">1</span>);</span><br><span class="line">        n = <span class="built_in">strlen</span>(st + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i] == <span class="string">&#x27;&gt;&#x27;</span>) st[i] = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(st[i] == <span class="string">&#x27;&lt;&#x27;</span>) st[i] = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++) dp[i][j][<span class="number">0</span>]=dp[i][j][<span class="number">1</span>]=inf;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">1</span>; t++)&#123;</span><br><span class="line">                    <span class="comment">//add &#x27;(&#x27;</span></span><br><span class="line">                    <span class="keyword">if</span>(st[i] != <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                        dp[i][j + <span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">min</span>(dp[i][j + <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][j][t]);</span><br><span class="line">                        dp[i][j + <span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i][j + <span class="number">1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][j][t] + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(st[i] != <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(j &amp;&amp; t) dp[i][j - <span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][j][t]);</span><br><span class="line">                        <span class="keyword">if</span>(j) dp[i][j - <span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i][j - <span class="number">1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][j][t] + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[i][j][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i][j][<span class="number">1</span>], dp[i<span class="number">-1</span>][j][t] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; n-<span class="built_in">min</span>(dp[n][<span class="number">0</span>][<span class="number">0</span>], dp[n][<span class="number">0</span>][<span class="number">1</span>]) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">反思</summary><div class="toggle-content"><p>感觉这一类题目就是没想出来脑子里面就是一坨，想出来了就豁然开朗。</p>
<p>赛时花了很多时间还没有做出来，我的问题。</p>
<p>感觉确实难，但做这么久确实蠢。</p>
<p>基本上这道题目知道如何根据滚动方向判断出最大数量就做完了。</p>
<p>但这一步我就卡了很久，下面是最小化浪费的球数。</p>
<ol>
<li><p>首先以为是当成括号匹配，然后是 $&gt;&lt;$ 的数量加上失配的数量。<br>否决理由：</p>
<p>$&gt;&lt;&lt;$，注意到 $&gt;&lt;$ 可以把洞填成左开右闭和左闭右开。</p>
</li>
<li><p>然后以为是相邻两个失配的 $&lt;$ 中间如果有匹配的括号对，那么右边的 $&lt;$ 不会浪费。<br>否决理由：</p>
<p>$&gt;&lt;&gt;&lt;&lt;&lt;$，注意到只有 $&gt;&lt;$ 会浪费中间的洞。</p>
</li>
<li>发现只要有一个 $&gt;&lt;$ 就可以改变一次洞的分布，得到最终做法。</li>
</ol>
<p>别看上面这个过程非常短，实际过了很长的时间。</p>
<p>虽然我认为这里犯了和之前一样的错误：没有先想着证伪（找例子），而是先想着证明（这个往往是困难的），但是我认为以我当时觉得很对的脑子，我觉得我也找不到例子。（虽然这个时候更好的解决方法是找队友，询问他们对这个正确性的看法，因为队友没经过错误的思考回路，当局者迷，旁观者清，反而更容易找到错误）</p>
<p>可以发现，上面最终发现错误的原因都是：找到了个反例，从而加深了对这道题目的认知，最终更加靠近了正解。</p>
<p>然而我找到上面反例的过程都是写了代码，发现没过样例，发现样例里面就有反例。</p>
<p>因此改进措施为（仅针对比较难的题目）：</p>
<ol>
<li>比赛时先手玩一遍数据（非比赛时不手玩是因为我觉得这样其实比较应试，找数据也是实力的一部分）</li>
<li>难题多想一想比较极端或者有代表性的数据，很多时候，在大多数情况足够最优就是在全体情况足够最优，某些数据的最优解法是能够指引最终做法的，我认为这不是一种应试，因为找到数据并说明这个数据的最优做法我认为也是实力的一部分。（简单来说，就是用更多手玩数据的过程去代替更多想证明的过程）</li>
</ol>
<p>第二条其实已经比较接近队长的思考方式了，就是先想一些极端数据，然后找到一个在这些极端数据下仍然对的做法，根据对的理由思考出最终做法，然后再基于大量数据的思考下，给出最终做法的正确性，这其实是一个很好的思考方式，至少比抓瞎要好得多。</p>
<p>希望下一次能够更快的想出这些题目。</p>
</div></details>
<p>官方题解没看懂，感觉非常的奇妙。</p>
<p>还有一些奇奇怪怪的做法，比如花费 $1$ 的代价删除具有某种形式的子串等等，感觉这个题目的做法很多，在此就不一一赘述了。<del>其实是因为我都没看懂</del></p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>CCPC final 2023 L. Exchanging Kubic(最大子段和的深入分析)</title>
    <url>/2024/04/28/CCPC-final-2023-L-Exchanging-Kubic-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C%E7%9A%84%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>题目大意：</p>
<p>交互题，你可以询问一个区间的最大子段和，要求在 $2n$ 的询问次数内给出一个和原数组的最大子段和处处相等的数组。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>首先第一步是花 $n$ 步的次数，问出所有点的正负，这样我们能知道所有的正值，和所有的非负值的位置。</p>
<p>现在要在 $n$ 的次数问出所有非负值的位置。</p>
<p>先把所有连通的正值放在一起，而连通的负值可以等价的认为只有一个，所以原问题可以转化为：+-+-…+，问所有负值的数值。</p>
<p>考虑这么一个询问：+-+ ，假如最终得到的结果等于左右两个 $+$ 值的其中一个，说明 $-$ 起码小于等于两个 $+$ 中最小值的负值。</p>
<p>又可以发现：如果 -+- 且 -+ 和 +- 的和都是 $\le 0$ 的，那么最大子段和一定要么同时包含 -+- ，要么不包含，因此可以将 -+- 合并起来。</p>
<p>因此做法就出来了：每次找到最小的 + ，然后询问其和临近 + 的最大子段和，如果有更大的最大子段和，将这个 + 和临近的 + 合并（此时能够确定中间的 - 值），否则和临近的 - 合并，这样至多两次少一个 + 。</p>
<p>当只剩下一个 + 时，得到的数组就是一个合法的答案，显然，询问次数不超过 $2n-1$ 次。</p>
<p>时间复杂度：$O(n^2)$ 。</p>
<p>可以优化到 $O(n\log{n})$ ，同时这也是这个做法的下界，因为这个做法要找最小值，可以构造：$a_1,-inf,a_2,…,a_m$ ，这样该做法等价于排序 $a_1,…,a_m$ ，因此这个做法的时间复杂度下界就是 $O(n\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL inf = <span class="number">1e15</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="built_in">assert</span>(cnt &lt;= n + n);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;? &quot;</span> &lt;&lt; l &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; r &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    <span class="type">static</span> LL c;</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">LL ans[N];</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line"><span class="function">LL <span class="title">querysum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    LL now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i++) now += ans[i];</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findpos</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!v[i]) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, LL c, <span class="type">int</span> type)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    LL x = <span class="built_in">querysum</span>(l, r);</span><br><span class="line">    x = c - x;</span><br><span class="line">    <span class="keyword">if</span>(!type) x = <span class="built_in">min</span>(<span class="number">0ll</span>, x);</span><br><span class="line">    <span class="type">int</span> pos = <span class="built_in">findpos</span>(l, r);</span><br><span class="line">    ans[pos] += x;</span><br><span class="line">    <span class="keyword">if</span>(type)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i++) v[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    LL c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) v[i] = <span class="number">0</span>, ans[i] = <span class="number">0ll</span>;</span><br><span class="line">        vector&lt;node&gt; a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a.<span class="built_in">push_back</span>(&#123;i, i - <span class="number">1</span>, <span class="number">0ll</span>&#125;);</span><br><span class="line">        a.<span class="built_in">push_back</span>(&#123;n + <span class="number">1</span>, n, <span class="number">0ll</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span>(a.<span class="built_in">size</span>() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> minpos = <span class="number">0</span>;</span><br><span class="line">            LL c = a[<span class="number">0</span>].c;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; a.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i].c &lt; c)&#123;</span><br><span class="line">                    c = a[i].c;</span><br><span class="line">                    minpos = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> [l, r, tmp] = a[minpos];</span><br><span class="line">            <span class="keyword">if</span>(minpos)&#123;</span><br><span class="line">                <span class="keyword">auto</span>&amp; [ll, rr, cc] = a[minpos - <span class="number">1</span>];</span><br><span class="line">                LL val = <span class="built_in">query</span>(ll, r);</span><br><span class="line">                <span class="keyword">if</span>(val &lt;= cc) <span class="built_in">add</span>(rr + <span class="number">1</span>, l - <span class="number">1</span>, -c, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    rr = r;</span><br><span class="line">                    <span class="built_in">add</span>(ll, rr, val, <span class="number">1</span>);</span><br><span class="line">                    cc = val;</span><br><span class="line">                    a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>() + minpos);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(minpos + <span class="number">1</span> &lt; a.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="keyword">auto</span>&amp; [ll, rr, cc] = a[minpos + <span class="number">1</span>];</span><br><span class="line">                LL val = <span class="built_in">query</span>(l, rr);</span><br><span class="line">                <span class="keyword">if</span>(val &lt;= cc) <span class="built_in">add</span>(r + <span class="number">1</span>, ll - <span class="number">1</span>, -c, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    ll = l;</span><br><span class="line">                    <span class="built_in">add</span>(ll, rr, val, <span class="number">1</span>);</span><br><span class="line">                    cc = val;</span><br><span class="line">                    a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>() + minpos);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>() + minpos);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;!&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cout &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans[i] ;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个做法的灵感是这样子的：</p>
<p>对于任意一个最大子段和，可以发现，一定存在一个前缀和一个后缀仍然是最大子段和。</p>
<p>也就是说，我们可以这么想象这么一个过程，就好像是一开始所有的 + 值都想要合并出最大的子段和，然后不断吞并中间的 - 值和周围的 + 值合并的过程，而上面就是一个比较良好的合并过程。</p>
<p>正确性分析：</p>
<p>可以发现，上面的过程都是选择相邻的三个数字，合并，或者是一开始相邻两个正数合并或者非负数合并。</p>
<p>因此只需要证明，一个合法的合并后的数组，在合并前也是合法的。</p>
<p>这个证明也不难，只需要小小讨论一下就行了，在此不再赘述。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">更加正确的分析</summary><div class="toggle-content"><p>在看了题解后感受颇深，感觉自己之前的证明可能伪了，但后面看了下，确实可以这么证明，就没有删除原来的证明。</p>
<p>最后决定将这更加详细的证明新开一个板块，保留以前写的东西，同时这个板块我认为是更加重要的，新开一个板块来讲我认为很合适。</p>
<p>定义一个子段为可能最大子段和，当且仅当其大于其任何真子段和（不是自己的子段）。</p>
<p>充要条件：这个子段的任何前缀和后缀都 $&gt;0$ 。</p>
<p>性质 1 ：这个子段的任意一个前缀的最大子段和是其的前缀，这个子段的任意一个后缀的最大子段和是其后缀。</p>
<p>性质 2 ：对于可能最大子段和 $[l_1,r_1],[l_2,r_2]$ ，如果 $l_1\le l_2,r_1\le r_2,l_2\ge r_1$ ，那么 $[l_2,r_1]$ 也是可能最大子段和。</p>
<p>性质 3 ：如果知道了所有的最大子段和，显然能知道哪些段是可能的最大子段和。</p>
<p>性质 4 ：如果 $[l1,r1],[l2,r2]$ 是可能最大子段和，且满足：$l1\le l2 - 1\le r1\le r2$ ，那么 $[l1,r2]$ 也是可能最大子段和。</p>
<p>现在，回顾一下我之前的灵感中的最大子段和合并的过程，可以发现，里面提到的最大子段和就是可能最大子段和，当时提到了一个词：合并，但是这个合并到达是什么意思呢？</p>
<p>总不能就是感觉上的抽象的合并吧？就两个可能最大子段和合并成一个的过程吧？</p>
<p>接下来我将详细的、具体的描述这个过程：</p>
<p>假设我们知道了 $[l,r]$ 的和，且也有一了一个 $[l,r]$ 的数组满足 $[l,r]$ 内部要求的 $mss$ ，那么我们能不能将 $[l,r]$ 看成一个数字去研究接下来的问题呢？</p>
<p>可以发现，我的做法中，一开始合并两个正数，以及后面的 $+-+$ 的合并都属于这个类型。</p>
<p>这个问题可以这么说：假设我将 $[l,r]$ 看成一个数字，忽略与 $[l,r]$ 有交集但不包含的 $mss$ ，得到了一个合法的数组后，能够在将 $[l,r]$ 展开后，仍然满足所有的 $mss$ 。</p>
<p>又可以这么说：将 $[l,r]$ 看成一个数字，在忽略掉与 $[l,r]$ 有交集但不包含的 $mss$ ，能否唯一决定与 $[l,r]$ 有交集但不包含的 $mss$ 。</p>
<p>而事实上，如果 $[l,r]$ 的数组的得到过程只依赖于 $[l,r]$ 内部的 $mss$ 数组，那么这个问题又可以这么说：能否利用与 $[l,r]$ 有交集但不包含的 $mss$ 以外的 $mss$ 唯一决定这一部分的 $mss$ 。</p>
<p>现在给一个定理：如果 $[l,r]$ 是一个可能的最大子段和，那么上述问题成立。</p>
<p>证明：</p>
<p>考虑计算 $[l’,r’]$ 的 $mss$ ，不妨认为：$l’&lt;l,l\le l’\le r$ ，那么 $mss(l’,r’)=max(mss(l’,l-1),mss(l,r’),K)$ 。</p>
<p>其中 $K$ 表示什么，设最小的 $i$ 满足：$l’\le i &lt; l:[i,r]$ 是可能最大子段和。（没有则 $K=-\infty$）</p>
<p>则 $K=mss(i,r)-mss(l,r)+mss(l,r’)$ ，这一段成立的原因是，如果 $<a href="l\le y \le r">x,y</a>$ 是可能最大子段和，则 $[x,r]$ 也是。</p>
<p>然后显然最大贡献需要挑其中最大的，就是 $[i,r]$ ，然后考虑其的贡献一定是 $sum(i,l-1)$ 加上最大的前缀在 $[l,r’]$ ，显然这个就为 $mss(l,r’)$ 。</p>
<p>因此是可以计算的，证毕。</p>
<p>因此，$[l,r]$ 实际上可以看成一个数字，内部和外部分隔开来，忽略到多余的 $mss$ 不会影响整个 $mss$ 的合法性，我认为这就是上面说的那个合并过程的具体表述。</p>
<p>不过事实上从最终做法也可以看出，决定所有 $mss$ 所需要的 $mss$ 只需要 $O(n)$ 就行了。</p>
<p>区间包含单调性：$mss(l_1,r_1)\ge mss(l_2,r_2),l_1\le l_2,r_1\ge r_2$ 。</p>
<p>四边形不等式：$mss(l_1,r_1)+mss(l_2,r_2)\le mss(l_1,r_2)+mss(l_2,r_1)$ ，$l1\le l_2\le r_2\le r_1$ 。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>只需要证明 $mss(l-1,r+1)-mss(l-1,r)\le mss(l,r+1)-mss(l,r)$ 。</p></p>
<p>考虑 $p(l,r)$ 表示 $\max\limits_{l\le i\le r} sum(i,r)$ ，显然如果 $mss(l,r+1)&gt;mss(l,r)$ ，那么 $mss(l,r+1)=a_{i}+p(l,r)$ ，因此只需要证明：$mss(l-1,r)-p(l-1,r)\ge mss(l,r)-p(l,r)$ 。</p>
<p>设 $[l_1,r_1]$ 为 $mss(l-1,r)$ 的区间， $[l_2,r]$ 为 $p(l-1,r)$ 的区间，$[l_3,r_3]$ 为 $mss(l,r)$ 的区间，$[l_4,r]$ 为 $p(l,r)$ 的区间。</p>
<p>那么显然可以有 $l_1\le l_2, l_3 \le l_4$ ，若有 $l_2\ge l-1$ ，则 $l_2=l_4$ ，则显然成立，所以不妨认为：$l_1 = l_2 = l - 1$ ，此时显然可以有 $r_1&lt;l_3$。</p>
<p>故 $mss(l_1,r)-p(l-1,r)-mss(l,r)+p(l,r)=-sum(r_1+1,l_4-1)\ge 0$ 。</p>
<p>证毕。</p>
</div></details>
<p>最大子段和还有很多其他性质，等待补充。</p>
<p>遇到一道疑似有关这个概念的题目，但是苦于没有提交链接，故先放在这里吃灰：</p>
<p>meta camp 2022 T5 最大子段和，出现链接：<a href="https://www.zhihu.com/question/546431239">https://www.zhihu.com/question/546431239</a> 。</p></div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方题解</summary><div class="toggle-content"><p>看懂了做法，迷迷糊糊的明白了为什么是对的，但是感觉我不太能很好的说明其为什么是对的。（题解看的也不太懂）</p>
<p>我从我的角度去阐述这个做法：</p>
<p>还是跟之前做法一样，先全问一遍，然后合并，变成 $+-+-+-…$ 的形式。</p>
<p>考虑用增量法，即考虑维护一个正确的前缀。</p>
<p>注意到在假如在新添加字符后，我们肯定想知道哪个后缀成为了可能最大子段和。</p>
<p>假设前面的数字是 $a_1,…,a_{t-1}$ ，一个简单粗暴的想法是找到 $l$ ，满足：$mss(l,t) &gt; max(mss(l,t-1), mss(l+1,t))$ ，这样就可以将 $[t,l]$ 合并为一个数字，但是这样子要问 $O(n^2)$ 次，考虑优化。</p>
<p>注意到如果 $[l,t]$ 如果是可能最大子段和的话，那么 $mss(k,t) &gt; mss(k,t-1)(l\le k\le t-1)$ ，因此如果这一条不满足的话，就可以直接退出，但是这样子并没有优化最坏时间复杂度，悲。</p>
<p>接着思考，考虑如果 $mss(k,t)&gt;mss(k,t-1)$ 且 $mss(k,t)=mss(k+1,t)$ ，那究竟意味着什么？如果 $a_{k}\le 0$ 那么显然满足，但是如果 $a_{k}&gt;0$ 时呢？考虑一种简单情况，也就是：$+-+$ ，这个时候也就说明中间 $-$ 的绝对值大于左边的 $+$ 。</p>
<p>注意到，我们有可能永远不可能知道中间 $-$ 的值，因为我们要知道这个 $-$ 的充要条件是有一个可能最大子段和包含它且其余值我们都知道，但是前缀已经写成了 $+-+-+-$ 的形式，且 $-$ 值都不知道，因此这个充要条件感觉上不太可能成立。</p>
<p>这启示我们能不能贪心的给这个位置赋值，也就是给中间的 $-$ 赋值上左边正值的负数（能赋的值中的最大值，显然右边的 $+$ 大于左边的 $+$ 值）。</p>
<p>这样就能利用上每一次询问，根据这个想法，就可以得到题解的做法。</p>
<p>时间复杂度：$O(n)$ 。</p>
<p>具体过程感兴趣的话看代码吧，感觉不太能讲明白。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function">std::mt19937 <span class="title">rnd</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="type">int</span> n, cnt;</span><br><span class="line"><span class="function">LL <span class="title">mss</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;? &quot;</span> &lt;&lt; l &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; r &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">fflush</span>(stdout);</span><br><span class="line">    LL res;</span><br><span class="line">    cin &gt;&gt; res;</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="built_in">assert</span>(cnt &lt;= n + n &amp;&amp; l &gt;= <span class="number">1</span> &amp;&amp; r &lt;= n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r, p;</span><br><span class="line">    LL preval;</span><br><span class="line">&#125;sta[N]; <span class="type">int</span> top;</span><br><span class="line">LL a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, mid, r;</span><br><span class="line">    LL sum = <span class="number">0ll</span>;</span><br><span class="line">&#125;s[N]; <span class="type">int</span> m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">    <span class="comment">// while(1)&#123;</span></span><br><span class="line">        top = cnt = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="comment">// generater();</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = <span class="built_in">mss</span>(i, i);</span><br><span class="line">        <span class="comment">// for(int i = 1; i &lt;= n; i++) a[i] = mss(i, i, b);</span></span><br><span class="line">        m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l - <span class="number">1</span>;</span><br><span class="line">            LL sum = <span class="number">0ll</span>;</span><br><span class="line">            <span class="keyword">while</span>(mid &lt; n &amp;&amp; a[mid + <span class="number">1</span>] &gt; <span class="number">0</span>) mid++, sum += a[mid];</span><br><span class="line">            <span class="type">int</span> r = mid;</span><br><span class="line">            <span class="keyword">while</span>(r &lt; n &amp;&amp; a[r + <span class="number">1</span>] == <span class="number">0</span>) r++;</span><br><span class="line">            s[++m] = &#123;l, mid, r, sum&#125;;</span><br><span class="line">            l = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i].mid == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            LL val = s[i].sum;</span><br><span class="line">            <span class="type">int</span> p = s[i].l;</span><br><span class="line">            LL preval = s[i].sum;</span><br><span class="line">            <span class="keyword">while</span>(top)&#123;</span><br><span class="line">                val = <span class="built_in">mss</span>(sta[top].p, s[i].mid);</span><br><span class="line">                <span class="comment">// val = mss(sta[top].p, s[i].mid, b);</span></span><br><span class="line">                <span class="keyword">if</span>(val &gt; sta[top].preval)&#123;</span><br><span class="line">                    a[sta[top].r] = val - sta[top].preval - preval;</span><br><span class="line">                    <span class="keyword">if</span>(val &gt; preval) p = sta[top].p, preval = val;</span><br><span class="line">                    top--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> l = sta[top].l + <span class="number">1</span>;</span><br><span class="line">            sta[++top] = &#123;l, s[i].r, p, preval&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= top; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!a[sta[i].r]) a[sta[i].r] = <span class="number">-1e15</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;!&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a[i];</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正确性可以感受一下，在每个 $-$ 值处放上能放的最大值，就可以在出现可能最大子段和的时候，使得放下的最后那个决定性的 $-$ 值是合法的，反之，如果在之前的 $-$ 值放下 $-inf$，那么在出现最大子段和时甚至可能在 $-$ 的位置放下正数，这显然是不合法的，这类似一种贪心思想。</p>
<p>再放一个东西：</p>
<p>对于一个 $+-+-+-…+$ 的序列 $a_1,..,a_n$ ，满足 $mss(1,n)=sum(1,n),mss(l,r)=\max\limits_{l\le i\le r}(0,a_{i})([l,r]\ne[1,n])$ ，则一定有以下结论：</p>
<p>$a_1,a_n$ 是 $a$ 序列中的最大值和次大值。</p>
<p>$mss(1,n)\le a_1+a_n-\max\limits_{2\le i \le n - 1}a_i$ 。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>反证法：$\exists i: 2\le i \le n - 1:a_{i}&gt;a_1$（存在多个就找最小的 $i$ ），则 $mss(1,n)+mss(i,i)\le mss(1,i)+mss(i,n)$ ，推出：$mss(1,n)=mss(i,n)$ ，与定义矛盾，第一条证毕。</p></p>
<p>$mss(1,n)+mss(i,i)\le mss(1,i)+mss(i,n)=a_{1}+a_{n}$ ，整理一下可以得到第二条，证毕。</p>
</div></details>
<p>这个性质可以用于证明最后放下的那个负数的合法性。</p>
<p>但我感觉题解肯定不是这个意思，至少正确性应该不是这么丑陋的证明，肯定有更加高深的东西我没看懂，至于是啥，读者只能自行体会或者去看题解了，博主水平有限了。</p></div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>交互</tag>
      </tags>
  </entry>
  <entry>
    <title>CF Round 681 Div.2 赛后总结</title>
    <url>/2025/02/05/CF-Round-681-Div-2-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>比赛链接：<a href="https://codeforces.com/contest/1443">https://codeforces.com/contest/1443</a></p>
<p>ZWQking AK啦！！！！！！！Orz</p>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>题意：有 $n$ 个小孩，有 $4n$ 个位置，要求你安排小孩坐位置，使得被坐的位置的编号 $a,b$ 满足：$gcd(a,b)≠1,a,b$。</p>
<p>做法：构造法，让他们坐 $2n+2,2n+4,2n+6,…,4n$ 的位置即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>  T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span>  n;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">		<span class="type">int</span>  limit=<span class="number">4</span>*n,ed=<span class="number">2</span>*n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  i=limit;i&gt;ed;i-=<span class="number">2</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>题意：给你一个字符串，$1$的位置有地雷，$0$没有，你可以花$a$代价引爆连续一段的雷，或者花$b$代价埋一颗雷。</p>
<p>做法：</p>
<ol>
<li>DP做法，$dp[i][0/1]$ 分别表示这个位置没有地雷和有地雷的转移。</li>
<li>赛后想了想，可以贪心，计算中间的每一段连续的 $0$ 填满的代价，如果小于 $a$ 则填满，否则不填满，直接两端引爆。</li>
</ol>
<p>我才用的是 $DP$ 做法。</p>
<p>两种做法时间复杂度都是：$O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  N  110000</span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">int</span>  <span class="title">mymin</span><span class="params">(<span class="type">int</span>  x,<span class="type">int</span>  y)</span></span>&#123;<span class="keyword">return</span>  x&lt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">int</span>  <span class="title">mymax</span><span class="params">(<span class="type">int</span>  x,<span class="type">int</span>  y)</span></span>&#123;<span class="keyword">return</span>  x&gt;y?x:y;&#125;</span><br><span class="line"><span class="type">int</span>  dp[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span>  st[N];</span><br><span class="line"><span class="type">int</span>  n,a,b;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>  T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">2</span>);</span><br><span class="line">		n=<span class="built_in">strlen</span>(st+<span class="number">2</span>)+<span class="number">2</span>;</span><br><span class="line">		st[<span class="number">1</span>]=st[n]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)dp[i][<span class="number">0</span>]=dp[i][<span class="number">1</span>]=<span class="number">999999999</span>;</span><br><span class="line">		dp[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(st[i]==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][<span class="number">0</span>]=<span class="built_in">mymin</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]+a);</span><br><span class="line">				dp[i][<span class="number">1</span>]=<span class="built_in">mymin</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>])+b;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>  dp[i][<span class="number">1</span>]=<span class="built_in">mymin</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dp[n][<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>题意： 给你 $a$ 数组和 $b$ 数组，对于每个 $i$ ，要么让小明多花 $b_{i}$ 的时间，要么直接多出一个人花 $a_{i}$ 的时间。</p>
<p>然后问你如何安排才可以让花费时间最大的人最小。</p>
<p>做法：二分答案，还算简单。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  N  210000</span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">int</span>  <span class="title">mymax</span><span class="params">(<span class="type">int</span>  x,<span class="type">int</span>  y)</span></span>&#123;<span class="keyword">return</span>  x&gt;y?x:y;&#125;</span><br><span class="line"><span class="type">int</span>  a[N],b[N],n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">bool</span>  <span class="title">check</span><span class="params">(<span class="type">int</span>  k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>  shit=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]&gt;k)</span><br><span class="line">		&#123;</span><br><span class="line">			shit+=b[i];</span><br><span class="line">			<span class="keyword">if</span>(shit&gt;k)<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>  T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">		<span class="type">int</span>  l=<span class="number">1</span>,r=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">			r=<span class="built_in">mymax</span>(r,a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">		<span class="type">int</span>  mid,ans=r;</span><br><span class="line">		<span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">		&#123;</span><br><span class="line">			mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">check</span>(mid)==<span class="number">1</span>)r=mid<span class="number">-1</span>,ans=mid;</span><br><span class="line">			<span class="keyword">else</span>  l=mid+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>题意： 给你一个 $a$ 数组，你有两种操作：</p>
<ol>
<li>选择一个 $i$，让 $1\sim i$ 的位置全部减一。</li>
<li>选择一个 $i$，让 $i\sim n$ 的位置全部减一。<br>问是否可以把 $a$ 数组全部变成 $0$ 。</li>
</ol>
<p>做法：<del>他们都说很简单，就我想了挺久的。</del></p>
<p>我们不妨处理 $1$ 操作，设 $b$ 数组，$b_{i}$ 表示第 $i$ 个位置经过 $1$ 操作减去了 $b_{i}$ 。</p>
<p>$b_{i}≥b_{i+1}$。</p>
<p>这样，只需要构造一个合法的 $b$ 数组使得 $a$ 数组减完 $b$ 数组后从右往左到最后一个非 $0$ 数字非严格单调递减。</p>
<p>然后就开始考虑差分约束，$b_{i}≥b_{i+1}$，$i+1$ 向 $i$ 连一条 $0$ 的边，因为要 $a_{i}-b_{i}≤a_{i+1}-b_{i+1}$，所以 $a_{i}-a_{i+1}+b_{i+1}≤b_{i}$，$i+1$ 向 $i$ 连接一条边权 $a_{i}-a_{i+1}$ 的边，从 $n$ 点开始跑最长路，然后最后检查 $b_{i}≤a_{i}$ 即可，但是后面发现了一个事情，边只会从 $i+1$ 连向 $i$ ，直接一遍扫过去就行了啊(╯‵□′)╯︵┻━┻。</p>
<p>当然，你可以直接默认 $b_{n}$ 为 $0$ ，因为如果 $b_{n}&gt;0$ ，完全可以把 $1\sim n$ 的 $1$ 操作拆成一个 $1$ 操作一个 $2$ 操作来搞，所以可以直接默认 $b_{n}=0$ 。</p>
<p>时间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  N  31000</span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="type">int</span>  dp[N],n,a[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">int</span>  <span class="title">mymax</span><span class="params">(<span class="type">int</span>  x,<span class="type">int</span>  y)</span></span>&#123;<span class="keyword">return</span>  x&gt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>  T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">		<span class="type">bool</span>  bk=<span class="number">0</span>;</span><br><span class="line">		dp[n]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]&gt;a[i+<span class="number">1</span>])dp[i]=dp[i+<span class="number">1</span>]+a[i]-a[i+<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">else</span>  dp[i]=dp[i+<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span>(dp[i]&gt;a[i])</span><br><span class="line">			&#123;</span><br><span class="line">				bk=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!bk)<span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span>  <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>题意：默认现在是字典序最小的全排列（即：$1,2,3,4,…,n$），长度为$n$，然后有两个操作：</p>
<ol>
<li>统计 $[l,r]$ 的区间和。</li>
<li>假设现在的全排列字典序排名为 $x$ ，给你一个 $y$ ，让你把全排列变成字典序排名为 $x+y$ 的全排列。</li>
</ol>
<p>做法： 和康托展开非常有关系，因为全排列排名总和为 $1e12$ ，发现 $16!$ 已经大于这个数字，暴力维护后面 $16$ 个数字，然后暴力统计即可。</p>
<p>时间复杂度：$O(q16^2)$<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  N  210000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  NN  410000</span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">long</span>  <span class="type">long</span>  LL;</span><br><span class="line"><span class="type">int</span>  a[N],b[<span class="number">20</span>],n,q;</span><br><span class="line">LL  fc[<span class="number">20</span>];</span><br><span class="line"><span class="type">bool</span>  v[N];</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">kangtuo</span><span class="params">(<span class="type">int</span>  l,LL  k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>  top=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=l;i&lt;=n;i++)b[++top]=i,v[top]=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">sort</span>(b+<span class="number">1</span>,b+top+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=top;i&gt;=<span class="number">2</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		LL  shit=k/fc[i<span class="number">-1</span>];k%=fc[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  j=<span class="number">1</span>;j&lt;=top;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!shit  &amp;&amp;  !v[j])</span><br><span class="line">			&#123;</span><br><span class="line">				a[top-i+l]=b[j];</span><br><span class="line">				v[j]=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(!v[j])shit--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=top;i++)<span class="keyword">if</span>(!v[i])a[n]=b[i];</span><br><span class="line">&#125;</span><br><span class="line">LL  nowcnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  LL  <span class="title">getsum</span><span class="params">(<span class="type">int</span>  l,<span class="type">int</span>  r)</span></span>&#123;<span class="keyword">return</span>  (LL)(l+r)*(r-l+<span class="number">1</span>)/<span class="number">2</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);</span><br><span class="line">	fc[<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=<span class="number">16</span>;i++)fc[i]=fc[i<span class="number">-1</span>]*(LL)i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)a[i]=i;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span>  ll=n<span class="number">-16</span>+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(ll&lt;=<span class="number">0</span>)ll=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span>  type;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;type);</span><br><span class="line">		<span class="keyword">if</span>(type==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span>  l,r;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">			<span class="keyword">if</span>(r&lt;ll)<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">getsum</span>(l,r));</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				LL  sum=<span class="number">0</span>;</span><br><span class="line">				<span class="type">int</span>  lll=ll;</span><br><span class="line">				<span class="keyword">if</span>(l&gt;=ll)lll=l;</span><br><span class="line">				<span class="keyword">else</span>  sum=<span class="built_in">getsum</span>(l,ll<span class="number">-1</span>);</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span>  i=lll;i&lt;=r;i++)sum+=a[i];</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span>  x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">			nowcnt+=x;</span><br><span class="line">			<span class="built_in">kangtuo</span>(ll,nowcnt);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p>题意：给你一个 $a$ 数组，长度为 $n$ ，可以操作 $k$ 次，第 $t$ 次操作，你可以删掉第 $i(1≤t≤n-t+1)$ 个数字，然后把 $a_{i+1}$ 或者 $a_{i-1}$（必须满足被贴的数字有意义，即在数组范围内，且必须贴数字）贴到 $b$ 数组最右边（ $b$ 数组一开始为空），然后把 $a_{i}\sim a_{n}$ 全部往左移一位，现在给你 $a,b$ 数组（ $a,b$ 数组的数字都是不同的），问你操作序列能有多少个。</p>
<p>做法： 首先化一下题意：$b$ 数组在 $a$ 数组中对应的位置被锁上了，也就是不能被删除，然后对于 $b_{1}$ ，其在 $a$ 数组对应的位置为 $a_{i}$ ，如果 $i+1,i-1$ 的位置都被锁上了，这个 $b$ 数组绝对得不到，否则，假设 $i-1$ 解锁了，相当于牺牲掉 $i-1$ 的位置给 $i$ 位置解锁。</p>
<p>在上述过程中，不难发现，如果对于一个上锁的位置 $i$ ，左边如果没有被锁，或者解锁的时间早于它，那么在解锁 $i$ 时，左边一定是未锁上的位置（因为如果左边牺牲自己去解锁更左边的位置，那么更左边就变成了未锁上的左边），右边同理。</p>
<p><img src="1.png" alt="在这里插入图片描述"></p>
<p>橙色为锁上的位置，红色为未锁上的位置，蓝色代表牺牲。</p>
<p>这样，就只需要在开始的时候判断每个位置是否可以牺牲左边或者右边即可。</p>
<p>时间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  N  210000</span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">long</span>  <span class="type">long</span>  LL;</span><br><span class="line"><span class="type">const</span>  LL  mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span>  a[N],b[N],c[N],n,k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  LL  <span class="title">ksm</span><span class="params">(LL  x,LL  y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL  ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(LL  i=<span class="number">1</span>;i&lt;=y;i++)ans=ans*x%mod;</span><br><span class="line">	<span class="keyword">return</span>  ans; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>  T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);c[i]=<span class="number">0</span>;&#125;</span><br><span class="line">		<span class="type">int</span>  cnt=<span class="number">0</span>;LL  ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">			c[b[i]]=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(c[a[i]]&gt;<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>((c[a[i]]&lt;c[a[i+<span class="number">1</span>]]  &amp;&amp;  c[a[i]]&lt;c[a[i<span class="number">-1</span>]])  ||  (i==<span class="number">1</span>  &amp;&amp;  c[a[i+<span class="number">1</span>]]&gt;c[a[i]])  ||  (i==n  &amp;&amp;  c[a[i<span class="number">-1</span>]]&gt;c[a[i]]))</span><br><span class="line">				&#123;</span><br><span class="line">					ans=<span class="number">-1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>  <span class="keyword">if</span>(i!=<span class="number">1</span>  &amp;&amp;  i!=n  &amp;&amp;  c[a[i<span class="number">-1</span>]]&lt;c[a[i]]  &amp;&amp;  c[a[i+<span class="number">1</span>]]&lt;c[a[i]])cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ans==<span class="number">-1</span>)<span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span>  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">ksm</span>(<span class="number">2</span>,cnt));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>   <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>CF Round 921 Div.1 赛后总结</title>
    <url>/2024/02/01/CF-Round-921-Div-1-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://codeforces.com/contest/1924/problem/D">https://codeforces.com/contest/1924/problem/D</a></p>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>弱智题，每次选最远就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">26</span>;</span><br><span class="line"><span class="type">int</span> nex[N][M],las[M];</span><br><span class="line"><span class="type">char</span> st[N],ans[N];</span><br><span class="line"><span class="type">int</span> n,k,m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;k,&amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)las[i]=m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;k;j++)nex[i][j]=las[j];</span><br><span class="line">        las[st[i]-<span class="string">&#x27;a&#x27;</span>]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;k;j++)nex[<span class="number">0</span>][j]=las[j];</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> maxpos=<span class="number">0</span>,num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;k;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nex[now][j]&gt;maxpos)maxpos=nex[now][j],num=j;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i]=num+<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        now=maxpos;</span><br><span class="line">        <span class="keyword">if</span>(now&gt;m)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)ans[j]=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            ans[n+<span class="number">1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="comment">// T=1;</span></span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">work</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;No\n%s\n&quot;</span>,ans+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>典中典线段树题，我还以为有高论，想多了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN=<span class="number">6e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Segment</span>&#123;</span><br><span class="line">    <span class="type">int</span> lc,rc;</span><br><span class="line">    LL lazy,c1,c2,d1,d2;</span><br><span class="line">&#125;tr[NN];<span class="type">int</span> len;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    tr[x].c1=tr[tr[x].lc].c1+tr[tr[x].rc].c1;</span><br><span class="line">    tr[x].c2=tr[tr[x].lc].c2+tr[tr[x].rc].c2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushlazy</span><span class="params">(<span class="type">int</span> x,LL c)</span></span>&#123;</span><br><span class="line">    tr[x].c1+=c*tr[x].d1;</span><br><span class="line">    tr[x].c2+=c*tr[x].d2;</span><br><span class="line">    tr[x].lazy+=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].lazy)&#123;</span><br><span class="line">        <span class="built_in">pushlazy</span>(tr[x].lc,tr[x].lazy);</span><br><span class="line">        <span class="built_in">pushlazy</span>(tr[x].rc,tr[x].lazy);</span><br><span class="line">        tr[x].lazy=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bt</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=++len;</span><br><span class="line">    tr[x].d1=r-l+<span class="number">1</span>;tr[x].d2=<span class="number">1ll</span>*(r+l)*(r-l+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        tr[x].lc=<span class="built_in">bt</span>(l,mid);</span><br><span class="line">        tr[x].rc=<span class="built_in">bt</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ll,<span class="type">int</span> rr,LL c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ll&gt;rr || r&lt;ll || l&gt;rr)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=ll &amp;&amp; r&lt;=rr)&#123;</span><br><span class="line">        <span class="built_in">pushlazy</span>(x,c);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">change</span>(tr[x].lc,l,mid,ll,rr,c);</span><br><span class="line">    <span class="built_in">change</span>(tr[x].rc,mid+<span class="number">1</span>,r,ll,rr,c);</span><br><span class="line">    <span class="built_in">updata</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">findans</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;id)<span class="keyword">return</span> <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=id)<span class="keyword">return</span> (id+<span class="number">1</span>)*tr[x].c1-tr[x].c2;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">findans</span>(tr[x].lc,l,mid,id)+<span class="built_in">findans</span>(tr[x].rc,mid+<span class="number">1</span>,r,id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; pos;</span><br><span class="line">LL V[N];<span class="type">bool</span> v[N];<span class="type">int</span> p[N];</span><br><span class="line"><span class="type">int</span> ll[N];<span class="comment">//(ll[i],i)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modif</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,LL c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r,c);</span><br><span class="line">    <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,r+<span class="number">1</span>,r+<span class="number">1</span>,-c*(r-l+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,<span class="built_in">findans</span>(<span class="number">1</span>,<span class="number">1</span>,n,i)-<span class="built_in">findans</span>(<span class="number">1</span>,<span class="number">1</span>,n,i<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);x=n-x+<span class="number">1</span>;</span><br><span class="line">        v[x]=<span class="number">1</span>;</span><br><span class="line">        p[i]=x;</span><br><span class="line">        pos.<span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        LL x;<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x);</span><br><span class="line">        V[p[i]]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bt</span>(<span class="number">1</span>,n);</span><br><span class="line">    <span class="type">int</span> pre=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!v[i])<span class="keyword">continue</span>;</span><br><span class="line">        ll[i]=pre;pre=i;</span><br><span class="line">        <span class="built_in">modif</span>(ll[i]+<span class="number">1</span>,i<span class="number">-1</span>,V[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// print();</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="type">int</span> t;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">        <span class="keyword">if</span>(t==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x,val;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;val);x=n-x+<span class="number">1</span>;</span><br><span class="line">            v[x]=<span class="number">1</span>;V[x]=val;pos.<span class="built_in">insert</span>(x);</span><br><span class="line">            <span class="type">int</span> nex=*pos.<span class="built_in">upper_bound</span>(x);</span><br><span class="line">            <span class="built_in">modif</span>(ll[nex]+<span class="number">1</span>,nex<span class="number">-1</span>,-V[nex]);</span><br><span class="line">            ll[x]=ll[nex];</span><br><span class="line">            <span class="built_in">modif</span>(ll[x]+<span class="number">1</span>,x<span class="number">-1</span>,V[x]);</span><br><span class="line">            ll[nex]=x;</span><br><span class="line">            <span class="built_in">modif</span>(ll[nex]+<span class="number">1</span>,nex<span class="number">-1</span>,V[nex]);</span><br><span class="line">            <span class="comment">// print();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> l,r;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);l=n-l+<span class="number">1</span>;r=n-r+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">swap</span>(l,r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">findans</span>(<span class="number">1</span>,<span class="number">1</span>,n,r)-<span class="built_in">findans</span>(<span class="number">1</span>,<span class="number">1</span>,n,l<span class="number">-1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>一个显然的事情，你考虑在折过一次的的纸上，去考虑接下来折纸产生的折痕，在这一次折纸展开后会变成什么样，可以发现：</p>
<script type="math/tex; mode=display">(M,V)=(\frac{M'+V'}{\sqrt{2}},\frac{M'+V'+4}{\sqrt{2}})</script><p>赛时唐了，以为要写矩阵，但实际上不用，直接推式子就行了。</p>
<p>最终 $\frac{M}{V}=1-\frac{2}{\sqrt{2}^{n+1}+\sqrt{2}^{n}-\sqrt{2}}$ ，直接算就行了。</p>
<p>题解说奇怪的模数是为了保证分母不为 $0$ ，说是不能让 $2$ 能够开根，我推测用上面的式子精细的讨论一下 $n$ 的奇偶，可能也能分析出来，但我懒得想了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">999999893</span>,ni2=(mod+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    LL x,y;<span class="comment">//x+y*sqrt(2)</span></span><br><span class="line">&#125;;</span><br><span class="line">node <span class="keyword">operator</span>*(node x,node y)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(x.x*y.x+x.y*y.y*<span class="number">2</span>)%mod,(x.x*y.y+x.y*y.x)%mod&#125;;</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span>*(node x,LL y)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(x.x*y)%mod,(x.y*y)%mod&#125;;</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span>+(node x,node y)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(x.x+y.x)%mod,(x.y+y.y)%mod&#125;;</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span>-(node x,node y)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(x.x-y.x+mod)%mod,(x.y-y.y+mod)%mod&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">ksm</span><span class="params">(node x,LL y)</span></span>&#123;</span><br><span class="line">    node ans=&#123;<span class="number">1ll</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x;</span><br><span class="line">        x=x*x;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ksm</span><span class="params">(LL x,LL y)</span></span>&#123;</span><br><span class="line">    LL ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x%mod;</span><br><span class="line">        x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> n;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        node x=&#123;<span class="number">0ll</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        node y=<span class="built_in">ksm</span>(x,n+<span class="number">1</span>)-node&#123;<span class="number">0ll</span>,<span class="number">1</span>&#125;+<span class="built_in">ksm</span>(x,n);</span><br><span class="line">        node z=node&#123;y.x,mod-y.y&#125;*<span class="built_in">ksm</span>( (y.x*y.x-y.y*y.y*<span class="number">2</span>%mod+mod)%mod ,mod<span class="number">-2</span>);</span><br><span class="line">        node ans=node&#123;<span class="number">1ll</span>,<span class="number">0ll</span>&#125;-z*<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>唐了。</p>
<p>这道题目我一开始的思路是，一个显然的事情，最终序列一定是一堆合法括号序列，然后用 $)))((($ 插入到两个合法括号序列中间，然后就有了我最开始的做法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L=<span class="number">10000</span>;</span><br><span class="line">LL fc[N],nfc[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=L;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=L;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;y || y&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">goal_fu</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    x--;len--;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)x=-x;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;len)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">assert</span>((len&amp;<span class="number">1</span>)==(x&amp;<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">C</span>(len,(len-x)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">goal</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">goal_fu</span>(x,len)-<span class="built_in">goal_fu</span>(-x,len)+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> n,m,k;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">        <span class="keyword">if</span>(n&lt;k || m&lt;k)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n-=k;m-=k;</span><br><span class="line">        LL ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">            LL now=<span class="built_in">goal</span>(i,k+k-i);</span><br><span class="line">            ans=(ans+now*<span class="built_in">C</span>(n+m+i,i))%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但实际上可以直接用折线法得到最终答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L=<span class="number">10000</span>;</span><br><span class="line">LL fc[N],nfc[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=L;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=L;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> n,m,k;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">        <span class="keyword">if</span>(n&lt;k || m&lt;k)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(<span class="built_in">C</span>(n+m,k)-<span class="built_in">C</span>(n+m,k<span class="number">-1</span>)+mod)%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然两种做法后面一种更加优秀，而且也不算难。</p>
<p>但是赛时就是没想出来，警钟敲烂。</p>
<p>已将上面两种做法的最关键部分全部写入组合计数练习，引以为戒，警钟敲烂。</p>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>做法已加入《组合计数练习》。</p>
<p>简单来说就是用排列考虑就行了。</p>
<p>时间复杂度：$O(n+m)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line">LL nfc[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> L=<span class="number">2e6</span>+<span class="number">1</span>;</span><br><span class="line">    nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=L;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        LL n,m,k;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;k);k--;</span><br><span class="line">        <span class="keyword">if</span>(n*m&lt;=k)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LL ans=<span class="number">1</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            LL l=k/n+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;m;i++)ans=(ans+nfc[n<span class="number">-1</span>+i])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            LL l=k/m+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;n;i++)ans=(ans+nfc[i+m<span class="number">-1</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">                LL l=k/i+<span class="number">1</span>,r=m<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(l&lt;=r)ans=(ans+<span class="number">2</span>*(nfc[i+l<span class="number">-1</span>]-nfc[i+r]+mod))%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>在想这道题目的时候发现了一个具有意思的组合意义，可惜没法扩展。</p>
<p>考虑一个弱化版的问题：</p>
<p>令 $m=1$ ，问出现 $k*1$ 的纸张的概率。</p>
<p>这么考虑这个问题：</p>
<p>现在从 $n-1$ 开始考虑，考虑到 $x$ 时，有 $\frac{1}{x}$ 的概率选中他，不难发现这与原过程等价。</p>
<p>这样，问题转化为选中 $k$ 的概率，显然就是 $\frac{1}{k}$ 了。</p>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p>咕咕咕。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>CF Round 940(Div 2) F2. Frequency Mismatch</title>
    <url>/2024/06/04/CF-Round-940-Div-2-F2-Frequency-Mismatch/</url>
    <content><![CDATA[<p>题目链接：<a href="https://codeforces.com/contest/1957/problem/F2">https://codeforces.com/contest/1957/problem/F2</a></p>
<p>题目链接：每次询问给你两条链，输出出现次数不同的颜色，至多只用输出 $k$ 个颜色。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>不是哥们，这都要分个 easy 和 hard 吗？</p>
<p>感觉没什么区别啊。</p>
<p>考虑多项式 Hash ，考虑 Hash 值为：$\sum\limits_{i=0}cnt_iBase^i$ ，其中 $i$ 是颜色编号。</p>
<p>直接线段树合并跑出到根节点路径上的 Hash 值，然后差分一下得到路径就行了。</p>
<p>有点卡常数，需要精细实现。</p>
<p>时间复杂度：$O((n+qk)\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SN = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L = <span class="number">18</span>;</span><br><span class="line"><span class="type">const</span> LL M1 = <span class="number">1000000181ll</span>, A1 = <span class="number">1145141ll</span>;</span><br><span class="line"><span class="type">const</span> LL M2 = <span class="number">998244353ll</span>, A2 = <span class="number">1145141ll</span>;</span><br><span class="line">LL f1[N], f2[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f1[<span class="number">0</span>] = f1[<span class="number">1</span>] = f2[<span class="number">0</span>] = f2[<span class="number">1</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= M; i++) f1[i] = f1[i - <span class="number">1</span>] * A1 % M1, f2[i] = f2[i - <span class="number">1</span>] * A2 % M2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">upd1</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> x &gt;= M1 ? x - M1 : x;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">upd2</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> x &gt;= M2 ? x - M2 : x;&#125;</span><br><span class="line">PII <span class="keyword">operator</span> + (PII x, PII y)&#123;<span class="keyword">return</span> &#123;<span class="built_in">upd1</span>(x.first + y.first), <span class="built_in">upd2</span>(x.second + y. second)&#125;;&#125;</span><br><span class="line">PII <span class="keyword">operator</span> - (PII x, PII y)&#123;<span class="keyword">return</span> &#123;<span class="built_in">upd1</span>(x.first - y.first + M1), <span class="built_in">upd2</span>(x.second - y. second + M2)&#125;;&#125;</span><br><span class="line">PII <span class="keyword">operator</span> * (PII x, <span class="type">int</span> y)&#123;<span class="keyword">return</span> &#123;x.first * (M1 + y) % M1, x.second * (M2 + y) % M2&#125;;&#125;</span><br><span class="line">PII <span class="keyword">operator</span> * (<span class="type">int</span> x, PII y)&#123;<span class="keyword">return</span> y * x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> lc, rc;</span><br><span class="line">    PII val;</span><br><span class="line">&#125;tr[SN]; <span class="type">int</span> cnt, rt[N];</span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"><span class="type">int</span> col[N];</span><br><span class="line"><span class="comment">// void update(int x)&#123;tr[x].val = tr[tr[x].lc].val + tr[tr[x].rc].val; tr[x].cnt = tr[tr[x].lc].cnt + tr[tr[x].rc].cnt;&#125;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">link</span><span class="params">(<span class="type">int</span> &amp;x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    tr[++cnt] = tr[x];</span><br><span class="line">    x = cnt;</span><br><span class="line">    tr[x].val = tr[x].val + PII&#123;f1[p], f2[p]&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(p &lt;= mid) <span class="built_in">link</span>(tr[x].lc, l, mid, p);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">link</span>(tr[x].rc, mid + <span class="number">1</span>, r, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">PII <span class="title">calc</span><span class="params">(<span class="type">const</span> vector&lt;PII&gt; &amp;x)</span></span>&#123;</span><br><span class="line">    PII ans = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [p, type] : x)&#123;</span><br><span class="line">        ans = ans + tr[p].val * type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;PII&gt; <span class="title">gleft</span><span class="params">(vector&lt;PII&gt; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [p, type] : x) p = tr[p].lc;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;PII&gt; <span class="title">gright</span><span class="params">(vector&lt;PII&gt; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; [p, type] : x) p = tr[p].rc;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findans</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> limit, vector&lt;PII&gt; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(limit &gt; r || <span class="built_in">calc</span>(x) == PII&#123;<span class="number">0</span>, <span class="number">0</span>&#125;) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(limit &lt;= mid) ans = <span class="built_in">findans</span>(l, mid, limit, <span class="built_in">gleft</span>(x));</span><br><span class="line">    <span class="keyword">if</span>(ans == <span class="number">-1</span>) ans = <span class="built_in">findans</span>(mid + <span class="number">1</span>, r, limit, <span class="built_in">gright</span>(x));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> y, next;</span><br><span class="line">&#125;a[N * <span class="number">2</span>]; <span class="type">int</span> len, las[N];</span><br><span class="line"><span class="type">int</span> fa[N][L], dep[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;a[++len] = &#123;y, las[x]&#125;; las[x] = len;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; L; i++) fa[x][i] = fa[fa[x][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">link</span>(rt[x], <span class="number">1</span>, M, col[x]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = las[x]; k; k = a[k].next)&#123;</span><br><span class="line">        <span class="type">int</span> y = a[k].y;</span><br><span class="line">        <span class="keyword">if</span>(y == fa[x][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        rt[y] = rt[x];</span><br><span class="line">        fa[y][<span class="number">0</span>] = x;</span><br><span class="line">        dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findlca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &lt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = L - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[x] - dep[y] &gt;= (<span class="number">1</span> &lt;&lt; i)) x = fa[x][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = L - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; col[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="built_in">ins</span>(x, y);</span><br><span class="line">        <span class="built_in">ins</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    dep[<span class="number">1</span>] = <span class="number">1</span>; <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2, cnt;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; cnt;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        vector&lt;PII&gt; t;</span><br><span class="line">        t.<span class="built_in">resize</span>(<span class="number">8</span>);</span><br><span class="line">        <span class="type">int</span> lca = <span class="built_in">findlca</span>(x1, y1);</span><br><span class="line">        t[<span class="number">0</span>]=&#123;rt[x1], <span class="number">1</span>&#125;;</span><br><span class="line">        t[<span class="number">1</span>]=&#123;rt[y1], <span class="number">1</span>&#125;;</span><br><span class="line">        t[<span class="number">2</span>]=&#123;rt[lca], <span class="number">-1</span>&#125;;</span><br><span class="line">        t[<span class="number">3</span>]=&#123;rt[fa[lca][<span class="number">0</span>]], <span class="number">-1</span>&#125;;</span><br><span class="line">        lca = <span class="built_in">findlca</span>(x2, y2);</span><br><span class="line">        t[<span class="number">4</span>]=&#123;rt[x2], <span class="number">-1</span>&#125;;</span><br><span class="line">        t[<span class="number">5</span>]=&#123;rt[y2], <span class="number">-1</span>&#125;;</span><br><span class="line">        t[<span class="number">6</span>]=&#123;rt[lca], <span class="number">1</span>&#125;;</span><br><span class="line">        t[<span class="number">7</span>]=&#123;rt[fa[lca][<span class="number">0</span>]], <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++)&#123;</span><br><span class="line">            pre = <span class="built_in">findans</span>(<span class="number">1</span>, M, pre + <span class="number">1</span>, t);</span><br><span class="line">            <span class="keyword">if</span>(pre == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(pre);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : ans) cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看了下题解，题解说的有道理，给每个权值随一个随机数也可以。</p>
<p>总之只要 Hash 支持可加就行了。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>Hash</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1493 赛后总结</title>
    <url>/2025/02/05/CF1493-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>仅仅是做，并没有实际参与比赛，且F题并没有代码参考。</p>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p><a href="https://www.luogu.com.cn/problem/CF1493A">题目</a></p>
<p>个数非常显然的是$n-\left\lfloor\frac{k}{2}\right\rfloor$</p>
<p>至于为什么，这里证明一下：</p>
<p>首先，在 $[1,k-1]$ 中，你选了一个数字，那么 $k-x$ 的数字就不能选，因此小于 $k$ 中你最多选 $\left\lceil\frac{k-1}{2}\right\rceil$ 个数字，同时我们也能构造出这种方案，就是$\left\lceil\frac{k}{2}\right\rceil$ 一直到 $k-1$ 全部选上。</p>
<p>这样子的话选了 $k-1-\left\lceil\frac{k}{2}\right\rceil+1=\left\lceil\frac{k-1}{2}\right\rceil$</p>
<p>刚刚好，然后把大于 $k$ 的算上就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>  T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span>  n,k;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">		<span class="type">int</span>  mid=(k+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n-mid);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  j=mid;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(j!=k)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,j);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p><a href="https://www.luogu.com.cn/problem/CF1493B">题目</a></p>
<p>这道题目就更加简单了，不难发现只有 $0,1,2,5,8$ 会翻转，直接暴力枚举，时间复杂度：$O(625n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>  x,y;<span class="comment">//分别表示小时和分钟 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span>  n,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">bool</span>  <span class="title">check</span><span class="params">(node  x)</span></span>&#123;<span class="keyword">return</span>  x.x&lt;n  &amp;&amp;  x.y&lt;m;&#125;</span><br><span class="line"><span class="keyword">inline</span>  <span class="type">int</span>  <span class="keyword">operator</span>-(node  x,node  y)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(x.x&lt;y.x  ||  (x.x==y.x  &amp;&amp;  x.y&lt;y.y))x.x+=n;</span><br><span class="line">	<span class="keyword">return</span>  (x.x-y.x)*m+x.y-y.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>  yuan[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="type">int</span>  huan[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>&#125;;</span><br><span class="line">node  sh1,sh2;</span><br><span class="line">node  ans;<span class="type">int</span>  limitans;</span><br><span class="line">node  goal;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">dfs</span><span class="params">(<span class="type">int</span>  dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep==<span class="number">5</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(sh2)==<span class="number">1</span>  &amp;&amp;  <span class="built_in">check</span>(sh1)==<span class="number">1</span>  &amp;&amp;  sh1-goal&lt;limitans)limitans=sh1-goal,ans=sh1;</span><br><span class="line">		<span class="keyword">return</span>  ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">0</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			sh1.y=(sh1.y/<span class="number">10</span>)*<span class="number">10</span>+yuan[i];</span><br><span class="line">			sh2.x=(sh2.x%<span class="number">10</span>)+huan[i]*<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>  <span class="keyword">if</span>(dep==<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			sh1.y=(sh1.y%<span class="number">10</span>)+yuan[i]*<span class="number">10</span>;</span><br><span class="line">			sh2.x=(sh2.x/<span class="number">10</span>)*<span class="number">10</span>+huan[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>  <span class="keyword">if</span>(dep==<span class="number">3</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			sh1.x=(sh1.x/<span class="number">10</span>)*<span class="number">10</span>+yuan[i];</span><br><span class="line">			sh2.y=(sh2.y%<span class="number">10</span>)+huan[i]*<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			sh1.x=(sh1.x%<span class="number">10</span>)+yuan[i]*<span class="number">10</span>;</span><br><span class="line">			sh2.y=(sh2.y/<span class="number">10</span>)*<span class="number">10</span>+huan[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(dep+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">getz</span><span class="params">(<span class="type">int</span>  &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x=<span class="number">0</span>;<span class="type">char</span>  c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&gt;<span class="string">&#x27;9&#x27;</span>  ||  c&lt;<span class="string">&#x27;0&#x27;</span>)c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;=<span class="string">&#x27;9&#x27;</span>  &amp;&amp;  c&gt;=<span class="string">&#x27;0&#x27;</span>)x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=<span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">print</span><span class="params">(<span class="type">int</span>  x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">10</span>)<span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>  T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">		<span class="built_in">getz</span>(goal.x);<span class="built_in">getz</span>(goal.y);</span><br><span class="line">		sh1.x=<span class="number">0</span>;sh1.y=<span class="number">0</span>;sh2.x=<span class="number">0</span>;sh2.y=<span class="number">0</span>;</span><br><span class="line">		limitans=<span class="number">999999999</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">print</span>(ans.x);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">		<span class="built_in">print</span>(ans.y);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p><a href="https://www.luogu.com.cn/problem/CF1493C">题目</a></p>
<p>基本思路就是前面尽量迎合原字符串，显然，从起始位置开始和原字符串连续相同的字符越多的字符串，字典序应该是越小的。</p>
<p>比如说现在我在处理 $i$ 这个位置，那么，我需要干两个事情，第一个，我能不能在这个位置放上一个比这个位置大的字符，如果可以，用 $ans$ 记录下这个位置，然后再判断我现在能不能在这个放上这个位置的字符，如果不可以，直接退出输出答案。</p>
<p>当然，如果原来的字符串就可以满足要求先输出原来的字符串。</p>
<p>输出答案也很简单，再模拟一边，然后模拟到 $ans$ 时填一个尽可能接尽原位置字符的字符，然后如果还可以申请字符，就全部填充上 $a$ ，然后后面从小到达输出。</p>
<p>这里讲一个错误的思路：</p>
<p>如果不用申请字符就可以填充这个位置的话，就不去判断这个位置能不能更新 $ans$ ，这是错误的，因为存在 $z$ 这个字符是无法被超越的，比如下面这个例子：</p>
<p>$n=6,m=2$<br>$abbzzz$</p>
<p>这个时候，$ans$ 在 $2$ 时被更新以后在 $4$ 往后的位置都不可能被更新，如果不能在 $3$ 更新答案就错了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  N  210000</span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="type">int</span>  need[<span class="number">30</span>],now[<span class="number">30</span>],cnt;</span><br><span class="line"><span class="type">int</span>  n,k;</span><br><span class="line"><span class="type">int</span>  pre;</span><br><span class="line"><span class="type">char</span>  st[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">bool</span>  <span class="title">check</span><span class="params">(<span class="type">int</span>  x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(now[x]==need[x])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(cnt==n)<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">		need[x]+=k,cnt+=k;</span><br><span class="line">	&#125;</span><br><span class="line">	now[x]++;</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">int</span>  <span class="title">findc</span><span class="params">(<span class="type">int</span>  limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(limit==<span class="number">25</span>)<span class="keyword">return</span>  <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span>  <span class="keyword">if</span>(cnt&lt;n)<span class="keyword">return</span>  limit+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  i=limit+<span class="number">1</span>;i&lt;=<span class="number">25</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(now[i]&lt;need[i])<span class="keyword">return</span>  i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>  <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span>  T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)</span><br><span class="line">	&#123;</span><br><span class="line">		pre=<span class="number">1</span>;<span class="built_in">memset</span>(need,<span class="number">0</span>,<span class="built_in">sizeof</span>(need));</span><br><span class="line">		<span class="built_in">memset</span>(now,<span class="number">0</span>,<span class="built_in">sizeof</span>(now));cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(n%k!=<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			need[st[<span class="number">1</span>]-<span class="string">&#x27;a&#x27;</span>]+=k;</span><br><span class="line">			now[st[<span class="number">1</span>]-<span class="string">&#x27;a&#x27;</span>]++;cnt+=k;</span><br><span class="line">			<span class="type">bool</span>  bk=<span class="number">1</span>;<span class="comment">//用来存是否能够相等，主动break=0 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span>  type=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span>((type=<span class="built_in">findc</span>(st[i]-<span class="string">&#x27;a&#x27;</span>))!=<span class="number">-1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(now[type]&lt;need[type]  ||  cnt&lt;n)pre=i;<span class="comment">//考虑一下放他上一个的情况</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">check</span>(st[i]-<span class="string">&#x27;a&#x27;</span>)==<span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					bk=<span class="number">0</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(bk==<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">memset</span>(need,<span class="number">0</span>,<span class="built_in">sizeof</span>(need));</span><br><span class="line">				<span class="built_in">memset</span>(now,<span class="number">0</span>,<span class="built_in">sizeof</span>(now));</span><br><span class="line">				cnt=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;pre;i++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">check</span>(st[i]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,st[i]);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="type">int</span>  shit=<span class="built_in">findc</span>(st[pre]-<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">				<span class="built_in">check</span>(shit);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,shit+<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">				need[<span class="number">0</span>]+=n-cnt;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">0</span>;i&lt;=<span class="number">25</span>;i++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">while</span>(now[i]&lt;need[i])</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,i+<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">						now[i]++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p><a href="https://www.luogu.com.cn/problem/CF1493D">题目</a></p>
<p>做这种题目我就比较快了。</p>
<p>可以发现直接离线，然后对于每一种质因子直接做一个线段树判断现在是不是所有的位置都含有这个质因子。</p>
<p>时间复杂度：$O((n+m)\log^2{n})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  N  210000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NN 410000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  NNN  8100000</span></span><br><span class="line"> <span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"> <span class="keyword">typedef</span>  <span class="type">long</span>  <span class="type">long</span>  LL;</span><br><span class="line"> <span class="type">const</span>  LL  mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"> <span class="type">int</span>  n,m;</span><br><span class="line"> <span class="keyword">struct</span>  <span class="title class_">node</span></span><br><span class="line"> &#123;</span><br><span class="line"> 	<span class="type">int</span>  lc,rc,c;</span><br><span class="line"> 	<span class="type">bool</span>  bk;<span class="comment">//清空符号。 </span></span><br><span class="line"> 	<span class="type">int</span>  lazy;</span><br><span class="line"> &#125;tr[NN];<span class="type">int</span>  len;</span><br><span class="line"> <span class="function"><span class="type">void</span>  <span class="title">bt</span><span class="params">(<span class="type">int</span>  l,<span class="type">int</span>  r)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> 	<span class="type">int</span>  now=++len;</span><br><span class="line"> 	<span class="keyword">if</span>(l&lt;r)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		<span class="type">int</span>  mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"> 		tr[now].lc=len+<span class="number">1</span>;<span class="built_in">bt</span>(l,mid);</span><br><span class="line"> 		tr[now].rc=len+<span class="number">1</span>;<span class="built_in">bt</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">jian</span><span class="params">(<span class="type">int</span>  x,<span class="type">int</span>  k)</span></span>&#123;tr[x].lazy+=k;tr[x].c-=k;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">clea</span><span class="params">(<span class="type">int</span>  x)</span></span>&#123;tr[x].bk=<span class="number">1</span>;tr[x].c=<span class="number">0</span>;tr[x].lazy=<span class="number">0</span>;&#125;</span><br><span class="line"> <span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">pushdown</span><span class="params">(<span class="type">int</span>  x)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> 	<span class="keyword">if</span>(tr[x].bk)<span class="built_in">clea</span>(tr[x].lc),<span class="built_in">clea</span>(tr[x].rc),tr[x].bk=<span class="number">0</span>;</span><br><span class="line"> 	<span class="built_in">jian</span>(tr[x].lc,tr[x].lazy);<span class="built_in">jian</span>(tr[x].rc,tr[x].lazy);</span><br><span class="line"> 	tr[x].lazy=<span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">inline</span>  <span class="type">int</span>  <span class="title">mymin</span><span class="params">(<span class="type">int</span>  x,<span class="type">int</span>  y)</span></span>&#123;<span class="keyword">return</span>  x&lt;y?x:y;&#125;</span><br><span class="line"> <span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">pushup</span><span class="params">(<span class="type">int</span>  x)</span></span>&#123;tr[x].c=<span class="built_in">mymin</span>(tr[tr[x].lc].c,tr[tr[x].rc].c);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">change</span><span class="params">(<span class="type">int</span>  now,<span class="type">int</span>   l,<span class="type">int</span>  r,<span class="type">int</span>  k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">pushdown</span>(now);</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;tr[now].c++;<span class="keyword">return</span>  ;&#125;</span><br><span class="line">	<span class="type">int</span>  mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(k&lt;=mid)<span class="built_in">change</span>(tr[now].lc,l,mid,k);</span><br><span class="line">	<span class="keyword">else</span>  <span class="keyword">if</span>(mid&lt;k)<span class="built_in">change</span>(tr[now].rc,mid+<span class="number">1</span>,r,k);</span><br><span class="line">	<span class="built_in">pushup</span>(now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>  minin[N];<span class="comment">//最小的因子 </span></span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">Query</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>  y,hou,ti<span class="comment">/*表示加入的时间*/</span>;</span><br><span class="line">&#125;b[NNN];<span class="type">int</span>  dnt,lbst[N],hea[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">ins</span><span class="params">(<span class="type">int</span>  x,<span class="type">int</span>  y,<span class="type">int</span>  ti)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dnt++;<span class="keyword">if</span>(!hea[x])hea[x]=dnt;</span><br><span class="line">	b[dnt].y=y;b[dnt].ti=ti;b[lbst[x]].hou=dnt;lbst[x]=dnt;</span><br><span class="line">&#125;</span><br><span class="line">LL  pre[N];<span class="comment">//保存答案用的</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">work</span><span class="params">(<span class="type">int</span>  val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">clea</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  k=hea[val];k;k=b[k].hou)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span>  y=b[k].y;</span><br><span class="line">		<span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,y);</span><br><span class="line">		<span class="keyword">if</span>(tr[<span class="number">1</span>].c==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			pre[b[k].ti]*=(LL)val;</span><br><span class="line">			pre[b[k].ti]%=mod;</span><br><span class="line">			<span class="built_in">jian</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>  sta[N],top;</span><br><span class="line"><span class="type">bool</span>  v[N];</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=m;i++)pre[i]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">2</span>;i&lt;=<span class="number">200000</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!v[i])</span><br><span class="line">		&#123;</span><br><span class="line">			minin[i]=i;</span><br><span class="line">			sta[++top]=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  j=<span class="number">1</span>;j&lt;=top  &amp;&amp;  sta[j]*i&lt;=<span class="number">200000</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			v[i*sta[j]]=<span class="number">1</span>;</span><br><span class="line">			minin[i*sta[j]]=sta[j];</span><br><span class="line">			<span class="keyword">if</span>(i%sta[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//找到最小的因子 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span>  x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">		<span class="keyword">while</span>(x&gt;<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">ins</span>(minin[x],i,<span class="number">1</span>);</span><br><span class="line">			x/=minin[x];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span>  x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">		<span class="keyword">while</span>(y&gt;<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">ins</span>(minin[y],x,i);</span><br><span class="line">			y/=minin[y];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">bt</span>(<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=top;i++)<span class="built_in">work</span>(sta[i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">2</span>;i&lt;=m;i++)pre[i]=(pre[i]*pre[i<span class="number">-1</span>])%mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,pre[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p><a href="https://www.luogu.com.cn/problem/CF1493E">题目</a></p>
<p>这道题目的话比较阿巴，我还看错题了(╯‵□′)╯︵┻━┻。</p>
<p>首先，如果首位置不同，那么直接 $0111111…$ 和 $1000000….$ 就可以轻松达到最大。</p>
<p>如果首位置相同，特判一下三种情况：<br>两个字符串相同，直接输出。<br>两个字符串除了最后一个位置都相同，直接输出大的字符串。<br>两个字符串除了最后两个位置都相同，直接输出大的字符串。</p>
<p>至于为什么要特判，看完你应该就可能明白了。（可能判多了）</p>
<p>注：二进制第 $1$ 位为 $x[n]$ </p>
<p>首先，一个基本的知识：$f(1,x)=?$</p>
<ol>
<li>$x$是奇数，那么 $n$ 除了最后一位全部保留，反之全部为 $0$ 。</li>
<li>如果 $x[n-1]=1,x[n]=0$ 或者 $x[n-1]=0,x[n]=1$ ，那么最后一位为 $1$ ，反之为 $0$ 。</li>
</ol>
<p>那么，假设字符串在第 $k$ 个位置出现不同，记第 $k$ 个位置为 $1$ 的字符串为 $A$ ，另外一个为 $B$ 。</p>
<p>这里直接说结论，如果 $A$ 中 $k+1$ 到 $n$ 中存在一个为 $1$ 的数字，或者 $B$ 中 $k+1$ 到 $n$ 的位置存在一个位置为 $0$ ，那么答案为 $A$ 的 $1$ 到 $n-1$ 位以及最后一位为 $1$ ，否则为 $A$ 的 $1$ 到 $n-1$ 位以及最后一位为 $0$ 。</p>
<p>至于证明，比较难写下来，建议自己想，其实证明起来比较轻松。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1100000</span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="type">int</span>  n;</span><br><span class="line"><span class="type">char</span>  a[N],b[N];</span><br><span class="line"><span class="type">char</span>  t[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">fu1</span><span class="params">(<span class="type">int</span>  id)</span></span>&#123;<span class="keyword">for</span>(<span class="type">int</span>  i=id;i&lt;=n;i++)t[i]=<span class="string">&#x27;1&#x27;</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;std.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//	freopen(&quot;vio.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,b+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>  &amp;&amp;  a[<span class="number">1</span>]==<span class="string">&#x27;0&#x27;</span>  &amp;&amp;  b[<span class="number">1</span>]==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(a[<span class="number">1</span>]!=b[<span class="number">1</span>])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fu1</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,t+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>  <span class="keyword">if</span>(a[<span class="number">1</span>]==b[<span class="number">1</span>])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span>  pre=n+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]==b[i])<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,a[i]);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(b[<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)<span class="built_in">swap</span>(a,b);</span><br><span class="line">				pre=i;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(pre==n+<span class="number">1</span>)<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(pre==n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(pre==n<span class="number">-1</span>)<span class="comment">//再特判一种情况 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%c%c\n&quot;</span>,a[n<span class="number">-1</span>],a[n]);</span><br><span class="line">			<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">bool</span>  bk=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  i=pre+<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(b[i]==<span class="string">&#x27;0&#x27;</span>  ||  (a[i]==<span class="string">&#x27;1&#x27;</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				bk=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(bk)a[n]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  i=pre;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,a[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p><a href="https://www.luogu.com.cn/problem/CF1493F">题目</a></p>
<p>这道题目的要求比较苛刻，我没有做出来(╯‵□′)╯︵┻━┻。</p>
<p>当然，我们可以把行和列独立，并且行和列一定存在一个最小的循环节。</p>
<p>这些都是字符串的基本理论了。</p>
<p>当然，现在检验行，我们存不存在一种方法能够在$\frac{3}{2}\left\lfloor\log{(n+m)}\right\rfloor$的时间内处理出行的最小循环节。</p>
<p>当然是有的，首先，我们把 $m$ 质因数分解成：$\prod\limits_{i=1}^kp_{i}^{a_{i}}$，我们知道，最小循环节肯定是 $m$ 的因数，那么 $\frac{m}{循环节长度}$ 也就是被分成的节的个数也是个整数，我们尝试找出节的个数的最大值，也就是尝试能不能将字符串分成 $p_{i}^{t}(1≤i≤k,t≤a_{i})$个循环节，然后就可以得到节的个数的最大值的因子，然后乘起来即可。</p>
<p>至于判断能不能将字符串分成 $p_{i}^{t}(1≤i≤k,t≤a_{i})$个循环节，我们转化为一下问题，已知有 $k$ 个数字，如何花最小的步数判断他们相等。</p>
<p>如果 $k=2$ ，那么直接判断。</p>
<p>如果 $k&gt;2$ ，如果 $k$ 是偶数，则仍然只用判断 $1,2$ 号数字，因为 $\frac{k}{2}$ 块肯定检验通过了，如果 $k$ 是奇数，那么设 $y$ 满足$2y+1=k$ ，那么只用比较 $[1,y],[y+1,k-1],[y+2,k]$ ，至于为什么，知道 $kmp$ 找循环节的人应该都知道，不知道的话我也讲不清楚。</p>
<p>至于为什么能过，因为这样的最坏次数是：$2log_{3}{n}=\log_{3}{4}*\log_{2}{n}$（$log$向下取整），显然满足要求。</p>
<p>横竖都做一遍即可。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>CF1987 赛后总结</title>
    <url>/2024/07/04/CF1987-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://codeforces.com/contest/1987">https://codeforces.com/contest/1987</a></p>
<h1 id="A-Upload-More-RAM"><a href="#A-Upload-More-RAM" class="headerlink" title="A. Upload More RAM"></a>A. Upload More RAM</h1><p>题目链接：<a href="https://codeforces.com/contest/1987/problem/A">https://codeforces.com/contest/1987/problem/A</a></p>
<p>题目大意：略。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>答案是 ：$(n-1)k+1$ 。</p>
</div></details>
<h1 id="B-K-Sort"><a href="#B-K-Sort" class="headerlink" title="B.K-Sort"></a>B.K-Sort</h1><p>题目链接：<a href="https://codeforces.com/contest/1987/problem/B">https://codeforces.com/contest/1987/problem/B</a></p>
<p>题目大意：略。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然每个数字最多变到前缀 max 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[N], n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">    LL ans = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        pre = <span class="built_in">max</span>(pre, a[i]);</span><br><span class="line">        a[i] = pre - a[i];</span><br><span class="line">        ans += a[i];</span><br><span class="line">        val = <span class="built_in">max</span>(val, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ans += val;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="C-Basil’s-Garden"><a href="#C-Basil’s-Garden" class="headerlink" title="C. Basil’s Garden"></a>C. Basil’s Garden</h1><p>题目链接：<a href="https://codeforces.com/contest/1987/problem/C">https://codeforces.com/contest/1987/problem/C</a></p>
<p>题目大意：略。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>倒着做，答案要么是他自己，要么是后面的答案加一。</p>
</div></details>
<h1 id="D-World-is-Mine"><a href="#D-World-is-Mine" class="headerlink" title="D. World is Mine"></a>D. World is Mine</h1><p>题目链接：<a href="https://codeforces.com/contest/1987/problem/D">https://codeforces.com/contest/1987/problem/D</a></p>
<p>题目大意：略。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>首先，基于后手一个不改变答案的选项：不吃。</p>
<p>然后决定好哪些蛋糕是要吃的，且吃了某种蛋糕就一定要全部吃完，显然一定可以按照从左到右的顺序吃（不可以就说明这个方案不优）。</p>
<p>然后可以发现，任意一个前缀，只关心两个值：剩下的蛋糕的种类数，需要吃的蛋糕数，只要任意前缀前者大于等于后者，这个方案就是合法方案。</p>
<p>注意到，现在是三元组：前缀、剩余蛋糕种类数、需要吃的蛋糕数。</p>
<p>因此不妨考虑，在需要吃的蛋糕数相同的情况下，只维护最小的剩余蛋糕种类数。</p>
<p>原因是：假设只有需要吃的蛋糕数不同的情况下，假设 X 方案 &gt; Y 方案的。</p>
<p>假设 X 在后面能到 Z 方案，把 X 方案后面需要吃的 $X-Y$ 种蛋糕全部不吃，并且前面换成 Y 方案，可以发现，这仍然是一个合法方案，而且需要吃的蛋糕数更少，也就是更优，所以 X 所能到的方案严格劣于 Y 能到的方案。</p>
<p>至于严谨证明，可以从前缀开始，每次把一定不可能产生答案的三元组扔掉，答案一定产生于剩下的三元组中，然后前缀从左往右扫就可以证明了。</p>
<p>时间复杂度：$O(n^2)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n, dp[N][N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++) dp[i][j] = -inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="type">int</span> r = l;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; n &amp;&amp; a[r + <span class="number">1</span>] == a[l]) r++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; l; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[l - <span class="number">1</span>][j] == -inf) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> x = dp[l - <span class="number">1</span>][j];</span><br><span class="line">            dp[r][j] = <span class="built_in">max</span>(dp[r][j], x);</span><br><span class="line">            <span class="keyword">if</span>(cnt - (x + <span class="number">1</span>) &gt;= j + r - l + <span class="number">1</span>)&#123;</span><br><span class="line">                dp[r][j + r - l + <span class="number">1</span>] = <span class="built_in">max</span>(dp[r][j + r - l + <span class="number">1</span>], x + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        l = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) ans = <span class="built_in">min</span>(ans, cnt - dp[n][i]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<p>没怎么看官方题解，官方题解也是类似的 $n^2$ dp ，估计区别不大。</p>
<details class="toggle" ><summary class="toggle-button" style="">别的做法</summary><div class="toggle-content"><p>看题解说能 $n\log{n}$ ，先自己想了一个。</p>
<p>首先注意到，我们可以把颜色数记录成一个数组，排序，然后全体 $+1$ 。</p>
<p>这样问题就变成了，你可以选择一些颜色，满足前 $i$ 种颜色选择的数字和 $\le i$ 对于所有的 $i$ 都满足。</p>
<p>那么显然，按数量从小到大考虑每一种颜色是对的，不难证明，不再赘述。</p>
<p>下面是用 $O(n^2)$ 实现的版本，可以用线段树做到 $O(n\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[N], n, m, id[N], b[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        m = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)&#123;</span><br><span class="line">            <span class="type">int</span> r = l;</span><br><span class="line">            <span class="keyword">while</span>(r &lt; n &amp;&amp; a[r + <span class="number">1</span>] == a[r]) r++;</span><br><span class="line">            a[++m] = r - l + <span class="number">2</span>;</span><br><span class="line">            l = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) id[i] = i, b[i] = i;</span><br><span class="line">        <span class="built_in">sort</span>(id + <span class="number">1</span>, id + m + <span class="number">1</span>, [](<span class="type">int</span> x, <span class="type">int</span> y)&#123;<span class="keyword">return</span> a[x] &lt; a[y];&#125;);</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="type">int</span> x = id[i];</span><br><span class="line">            <span class="type">bool</span> bk = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = x; j &lt;= m; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(b[j] &lt; a[x]) &#123;bk = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!bk) <span class="keyword">continue</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = x; j &lt;= m; j++) b[j] -= a[x];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; m - cnt &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后一翻 CF 评论区，发现有一种比我这好写的多的单 log 做法。</p>
<p>就是从左到右，直接贪心，每次尝试直接吃完这个颜色，不能吃完就尝试替换之前吃过的颜色。</p>
<p>用一个堆就可以做到 $O(n\log{n})$ ，非常的好写。</p>
<p>这乍一看很对，但是怎么证明呢？</p>
<p>我们需要证明一个引理：</p>
<p>设吃了 $k$ 种颜色的最优方案，则 $k-1$ 种颜色的最优方案就是 $k$ 种颜色最优方案的子集，（证明采用上面那个模型）</p>
<p>考虑 $k$ 种颜色的最优方案和 $k-1$ 种颜色的最优方案，消去相同的选择。</p>
<p>得到：$\{x_1,x_2,x_3,…,x_{m+1}\},\{y_1,y_2,…,y_{m}\}$ （递增排列）</p>
<p>如果存在一个 $L,t$ 满足 $x_{t},y_{t}\le L, x_{t+1},y_{t+1}&gt;L$ 吗，下标不存在认为是 $\infty$ 。</p>
<p>那么这两者一定可以交换且不影响双方的值，因为最优，所以消掉，下面认为不存在这种情况。</p>
<p>则一定有 $y_{1}&gt;x_{2}$ ，考虑对于任意 $i$ ，即 $X$ 集合的贡献为： $\sum\limits_{\forall 2\le j \le m+1,x_j\le i}cnt_{x_j}$ ，同理，$Y$ 集合有：$\sum\limits_{\forall 1\le j \le m,y_j\le i}cnt_{y_j}$ ，根据前面的说法，$X$ 合法的 $j$ 的个数 $\ge$ $Y$ 集合的，而且知道 $X$ 集合的贡献 $\ge$ $Y$ 集合的，否则交换可以使 $Y$ 集合个数不减的同时更优。</p>
<p>综上，最后，我们可以交换 $\{x_{2},…,x_{m+1}\}$ 和 $\{y_1,y_2,…,y_{m}\}$ ，得到不劣的 $X$ ，但又最优，则两者和相等，证毕。（注：上面过程之所以这么繁琐是为了交换完后仍然合法）</p>
<p>因此，我们只需要时时刻刻维护以选择颜色数为第一权重，要吃掉的食物为第二权重的最优方案就行了，也就是上面那个做法。即上面那个做法可以归纳的证明，其每次得到的方案就是方才说的最优方案。</p>
<p>这样正确性就证明完毕了。</p>
<p>这里贴一份别人的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://codeforces.com/contest/1987/submission/268356662</span></span><br><span class="line"><span class="comment">// Problem: D. World is Mine</span></span><br><span class="line"><span class="comment">// Contest: Codeforces - EPIC Institute of Technology Round Summer 2024 (Div. 1 + Div. 2)</span></span><br><span class="line"><span class="comment">// URL: https://codeforces.com/contest/1987/problem/D</span></span><br><span class="line"><span class="comment">// Memory Limit: 256 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 2000 ms</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AC ios::sync_with_stdio(0); cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;Ofast&quot;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//suppose b should eat 2 1 to let a - 2</span></span><br><span class="line"><span class="comment">//but in the gready approach, b will eat 1 first and can&#x27;t eat 2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	AC;</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">		map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; ma;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="type">int</span> temp; cin &gt;&gt; temp;</span><br><span class="line">			ma[temp]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> skip = <span class="number">0</span>;</span><br><span class="line">		priority_queue&lt;<span class="type">int</span>&gt; pque;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[i, j] : ma) &#123;</span><br><span class="line">			<span class="keyword">if</span> (skip &gt;= j) &#123;</span><br><span class="line">				skip -= j;</span><br><span class="line">				pque.<span class="built_in">push</span>(j);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!pque.<span class="built_in">empty</span>() &amp;&amp; pque.<span class="built_in">top</span>() &gt; j) &#123; <span class="comment">//check if current one costs less skip points</span></span><br><span class="line">				<span class="comment">//if so, reverse the prevoius operation where b stops a</span></span><br><span class="line">				skip += pque.<span class="built_in">top</span>() + <span class="number">1</span>;</span><br><span class="line">				pque.<span class="built_in">pop</span>();</span><br><span class="line">				ans++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (skip &gt;= j) &#123; <span class="comment">//let b stops a in the better scenario, which costs least skip points</span></span><br><span class="line">				skip -= j;</span><br><span class="line">				pque.<span class="built_in">push</span>(j);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ans++;</span><br><span class="line">			skip++;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="E-Wonderful-Tree"><a href="#E-Wonderful-Tree" class="headerlink" title="E. Wonderful Tree!"></a>E. Wonderful Tree!</h1><p>题目链接：<a href="https://codeforces.com/contest/1987/problem/E">https://codeforces.com/contest/1987/problem/E</a></p>
<p>题目大意：略。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>感觉有点简单了，但是有趣。</p>
<p>注意到 $dp[x][i]$ 表示 $x$ 值为 $i$ 的时候的最小代价。</p>
<p>可以发现这是凸性的，而且斜率范围在 $[0,size]$ ，所以直接转移就行了。</p>
<p>当然这也有实际意义，差分一下，表示用代价 $k$ 让 $x$ 增加 $1$ 的操作至多能进行多少次，按照这个思路 dp 转移式就很容易列出来了。（想到这个意义并且证明这是对的还是花了我一定的时间）</p>
<p>时间复杂度：$O(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n, p[N], siz[N], a[N];</span><br><span class="line">LL f[N][N], dp[N], sum[N];</span><br><span class="line"><span class="comment">// vector&lt;int&gt; son[N];</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        siz[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">        <span class="comment">// son[p[i]].push_back(i);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(siz[i] == <span class="number">1</span>) sum[i] = inf;</span><br><span class="line">        LL res = a[i] - sum[i];</span><br><span class="line">        <span class="keyword">if</span>(res &lt; <span class="number">0</span>) f[i][<span class="number">1</span>] = -res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n &amp;&amp; res &gt; <span class="number">0</span>; j++)&#123;</span><br><span class="line">            LL s = <span class="built_in">min</span>(res, f[i][j]);</span><br><span class="line">            res -= s;</span><br><span class="line">            f[i][j] -= s;</span><br><span class="line">            dp[i] += (j - <span class="number">1</span>) * s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        siz[p[i]] += siz[i];</span><br><span class="line">        sum[p[i]] += a[i];</span><br><span class="line">        dp[p[i]] += dp[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) f[p[i]][j + <span class="number">1</span>] += f[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="comment">// son[i].clear();</span></span><br><span class="line">        dp[i] = sum[i] = <span class="number">0ll</span>;</span><br><span class="line">        <span class="built_in">memset</span>(f[i], <span class="number">0</span>, <span class="built_in">sizeof</span>(f[i]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方做法</summary><div class="toggle-content"><p>你是真的笨啊，都长成父亲和儿子权值和的比较了，还想不到差分吗？那我只能说你是真 FW 啊。</p>
<p>总之，看了题解后，我觉得我这道题目只是根据见识硬做出来的，其实我根本就没有真正会这道题目。我有个可以过的做法，但是我并未真正触及其本质。</p>
<p>注意到这个不等式可以写成：</p>
<script type="math/tex; mode=display">a_{v}-\sum\limits_{u\in son_{v}}a_{u}\le 0</script><p>其中，如果没有儿子，就认为左式为 $-\infty$ 。</p>
<p>那么这个时候就很显然了，每次操作会把一个点 $+1$ ，父亲 $-1$ 。</p>
<p>要求用最少的步数把所有点变成 $\le 0$ 的。</p>
<p>注意到如果把每次操作，让这个点的父亲向其连一条边，表示父亲的一个 $1$ 流向了这个点，那么操作完后的图一定可以把所有边分成若干条路径，满足不存在一条路径的终点和另外一条路径的起点相同，可以看到，每条路径反映了一个 $1$ 的流向，起点包含了所有正点，终点一定是负点，贡献就是路径长度。</p>
<p>注意到最优方案中，只有正点可能作为起点，且作为起点的次数一定是其的值。（答案一定出在这个集合中）</p>
<p>那么问题可以等价的转化成求这个问题的最优解：每次将一个正点和子树内一个负电匹配，代价是距离，然后把正点 $-1$ ，负电 $+1$ ，直到没有正点为止。</p>
<p>这显然是一个费用流，所以在 CF 评论区和 luogu 都看到了赛时写费用流过题的佬。</p>
<p>当然，因为这个匹配非常简单，显然可以模拟，也不用写费用流。</p>
<p>先回看我上面的做法，实际上是在维护离当前点距离为 $d$ 的负数点能提供多少个匹配，这样就一目了然了。</p>
<p>当然，题解提供了种更好写的做法：每个点 BFS 一遍。</p>
<p>优化一下复杂度，做到 $O(n\log{n})$ 不难，把上面的数组合并写成可并堆的形式就行了。（能不能数组用启发式合并呢？不行，因为还有一个时间复杂度瓶颈是在做单点匹配的时候，需要弹出当前的最小值，数组用遍历的话复杂度仍然是 $O(n^2)$ 的）</p>
<p>能不能再快点？</p>
<p>在原图上，按深度从浅到深遍历每一个负数点，然后并查集维护到祖先的正数点，时间复杂度：$O(n\alpha(n))$ 。</p>
<p>能不能再快点？</p>
<p>可以，长链剖分，每个点用链表维护，合并的时候，两个链表至多弹出短链长度个，所以合并是 $O(n)$ 的，由于链表中的点数至多 $O(n)$ 个，所以弹出最小值也是 $O(n)$ 的。（之所以这样子归并复杂度不是两个数组长度和，是因为我实际上限制了值域范围，而不是限制了弹出个数。归并是两个数组长度和是因为短数组的最大值可能大过长数组的）</p>
<p>综上，时间复杂度为：$O(n)$ 。</p>
<p>最后说个幽默的事情，我在赛后说能启发式合并优化到 $n\log{n}$ ，因为我首先没想到弹出最小值的事情，其次我以为数组长度是和 $size$ 相关，后面问了人才发现，原来是和深度相关的。</p>
<p>很有意思。</p>
</div></details>
<h1 id="F-Interesting-Problem-Hard-Version"><a href="#F-Interesting-Problem-Hard-Version" class="headerlink" title="F. Interesting Problem (Hard Version)"></a>F. Interesting Problem (Hard Version)</h1><p>直接上 Hard Version 吧，我两个一起做的。</p>
<p>题目链接：<a href="https://codeforces.com/contest/1987/problem/F2">https://codeforces.com/contest/1987/problem/F2</a></p>
<p>题目大意：略。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>这里，我采用复盘的形式写出我的做法，因为我觉得看懂最终做法不难，但是明白中间犯了什么错是至关重要的，以及怎么避免犯同样的错误。</p>
<p>首先可以注意到，如果在一开始就规定某些数字是作为 $a[i]=i$ 的位置被删除的，那么可以类似括号匹配一样，找到和其一起被删除的位置。</p>
<p>那么我一开始就想，会不会只要在一个位置前面能被删除的数字个数是 $\frac{i-a[i]}{2}$ ，这个位置就一定能被删除，所有都满足就合法吧。</p>
<p>当时的逻辑是，假设每次都有能删除的数字，每次选择最右边的数字删除，一定不会影响左边，而且还能贡献给右边的数字，让他们也能删除，而且最左边的数字一定能被删除。</p>
<p>然后喜提 WA ，原因：可能删除了两个左括号。</p>
<p>然后我就开始想，也就是说括号嵌套的时候，不能让内层括号的消除时间晚于外层括号，怎么办到呢？</p>
<p>显然从左往右 dp 是办不到的，不可能记录这么多信息，但是发现这是括号序列啊，这不直接区间 dp 。</p>
<p>但“晚于”这个词有点过于模糊不清了，有没有具体点的说法？</p>
<p>当时提出了一种想法，$f[l][r]$ 表示前面需要额外删多少个数字这个区间才可以完整消完（维护最小可能的解，至于为什么，写博客的时候感觉并不是很显然，但是当时很自然的就这么想了，也没质疑，反正都红了。但其实正确性也并不难，只要知道了括号序列合并和嵌套的充要条件，就可以发现维护最小值在任何时候都是最优的，所以直接维护最小值就行了，但前提是充要条件是对的），嵌套的要求一定要求外层的括号所需要删除的数字一定严格大于等于内层的。（但是具体怎么想的也忘了，太红了，但是反正差不多）</p>
<p>就关于 $f$ 的维护我就写了好几种逆天的东西，包括当不限于：找于 l 同奇偶的位置的 a 的最小值、必须要求外层有嵌套等，反正很逆天就是了，感觉就是纯红。</p>
<p>后面发现可以这么维护，区间合并的时候，前一个区间可以对后一个区间产生贡献就行了（至于为什么，也没细想），反正此时终于走上正轨了。</p>
<p>在正确的实现完这个做法后就过了。</p>
<p>时间复杂度：$O(n^3)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">8e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((x &amp; <span class="number">1</span>) != (a[x] &amp; <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[x] &gt; x) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">return</span> (x - a[x]) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> v[N][N];</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">20</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) v[i][i - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len += <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l + len - <span class="number">1</span> &lt;= n; l++)&#123;</span><br><span class="line">            <span class="type">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> mid = l; mid &lt; r; mid++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v[l][mid] &gt; n &amp;&amp; v[mid + <span class="number">1</span>][r] &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">                v[l][r] = <span class="built_in">min</span>(<span class="built_in">max</span>(v[l][mid], v[mid + <span class="number">1</span>][r] - (mid - l + <span class="number">1</span>) / <span class="number">2</span>), v[l][r]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> val = <span class="built_in">calc</span>(l);</span><br><span class="line">            <span class="keyword">if</span>(val == <span class="number">-1</span> || v[l + <span class="number">1</span>][r - <span class="number">1</span>] &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(val &gt;= v[l + <span class="number">1</span>][r - <span class="number">1</span>]) v[l][r] = <span class="built_in">min</span>(val, v[l][r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[j + <span class="number">1</span>][i] &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[j] &gt;= v[j + <span class="number">1</span>][i]) dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + (i - j) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">solve</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回忆一下，我当时几乎证明了这个做法是对的，但当时非常的红温，现在来看，确实这个做法是对的，而且证明起来并不困难，但反正当时就是红温，好想只证明了嵌套和合并的条件是当下充要的，并没有考虑后效性什么的，也就是零零散散的给了些部分的证明，并没有串在一起，给一个整体的、完整的证明，当因为在比赛，这也能理解，毕竟 WA 了再想也不迟。虽然但是，我觉得这不是并不证明的借口，我认为比赛时尤其是模拟赛，该证明的东西就应该证明，先不提不会假这种显性收益，不依赖比赛反馈做题的这种习惯是可以带来很多隐形收益的，包括对自己实力的提升和心态的考验。</p>
<p>你要说这场比赛我证明了吗？几乎所有做法我都在写之前给了些零散的证明，但有用吗？没有用，该 WA 还是得 WA ，为什么？首先证明是会假的，但我认为赛时给出正确而不假的证明也是实力的一部分。其次，其实这场比赛很多时候我都知道，我给的证明并不足以称为证明，即很多时候我只给出了局部的正确性，或者是可能能证明的一个方向，我并没有给出具体的，完整的，不容易出现瑕疵的证明，这场的 D,F,G 都是这样，D,G 都可以理解，简单题和时间不够，但是 F 在这一场，就是因为这个问题 WA 了一遍又一遍，但凡我当时多动点脑子，也不至于出现这种情况。将这种碎片化的证明当成证明，等于没有证明，在赛时给出一个正确的证明，我认为这也是比赛考验我们的东西，为了 rating 而舍弃掉证明，靠比赛反馈做题，依赖应试技巧，这和高考有什么区别，抛开这些不谈，我认为过度依赖这种应试技巧，终究会被反噬，所得到的分数，不过也是虚假的分数，不足以反映真正的实力。</p>
<p>但是这又出现了一个问题，为什么队长没证明，却几乎每次都能给出一个不会假的做法。首先队长赛时不证明很久了，因此自然也有规避错误的方法，这个方法是什么呢？我觉得就是想一些极端例子，在这些极端例子下是 well done 的，这相比相信一个不完整的证明，并且没有尝试证伪好多了。简单来说，队长多了个证伪的过程，而且队长证伪能力很强（相应的，他构造水平很高），证伪也是一种能力，至少比纯猜靠反馈要好的多。但你要说这也是种应试技巧，那也算是。但是很多时候极端证伪的过程和证明几乎也没有区别了，所以自然几乎次次都能证伪的话，证明的能力自然也不会差，在比赛时不失为一种策略，虽然我仍然不觉得这是赛时能够考验自己真正实力的习惯。但是队长真正实力也确实很厉害，那我只能认为队长每次的证伪其实和证明已经没有区别了，也就是换个说法的问题。（事实也是每次和他一起打比赛，让他给证明的时候他也能给出证明，队长厉害，无需多言）</p>
<p>所以我认为，比赛时该证明的时候，就要给出一个好的证明，不要过度关注那些排名和 rating 啥的，导致忽略了真正的修行。</p>
<p><strong>回归正题</strong>，怎么证明这个 dp 是充要的呢？</p>
<p>首先明确给出 dp[l][r] 的定义，最小的数 $x$ 满足前面在删除 $2x$ 个数字后，区间 [l,r] 内的数字可以全部删除。</p>
<p>根据前面的说法来看，我们只需要证明采用以下方案可以删除完整个序列就行了。</p>
<p>每次删除最右边的合法括号，这对括号满足：a[i]=i ，内层为空。</p>
<p>这完全等价于什么呢？设任意一个括号序列，对于任意一对括号，其的可删除括号为，所有 () 满足 () 都在其的左括号左边，可删除左括号个数 * 2 $\ge i-a[i]$ 。</p>
<p>用这个性质证明 dp 就显然了。</p>
<p>以下皆是吹水。</p>
<p>你要说我当时知道这么证明纯属狗屁，首先这个性质是在我写博客的时候才想到的，其次我当时只证明了两个括号序列合并，两个括号序列嵌套，那个条件似乎足够充要，但是实际上，为什么要设最小的次数，为什么满足就一定有解呢？当时我是一定没想的。即使现在，我也想不太明白，因为如果纯从局部去证明整体，我很难去说明为什么局部满足这个条件，整体就一定满足，难道归纳吗？拿这又是一个很屎的过程，因为一定会用到优先删右边这个性质，很不巧，这是个整体性质，把整体性质用在局部的归纳法就是一坨屎，就只能说隐隐感觉这样子看非常的正确，但实际书写书写不出来。</p>
<p>一般发生这种情况是因为，我们在想这个问题的时候，默认的使用了某些性质，比如这里就默认使用了能删优先删右边，所以即使左边删多了也不要紧这个性质。但是默认使用的这个性质，在我们并不知情的情况下，是对的吗？用对了没？我们都不知道，所以你要说隐隐感觉对就是对的，我觉得纯放屁，到时候正式赛假了就直接寄了，痛哭流涕。</p>
<p>那如果要从整体去证明，我觉得就不能叫从这个 dp 的角度去证明了，两者的关系大概率是整体证明了一个性质，然后用 dp 维护，这里 dp 就只是维护工具，并不作为证明的载体，但我当时肯定不是这么想的，我是直接想的 dp ，并没有说先找到性质，然后再想办法用 dp 维护这么一个思考过程。</p>
<p>反正我觉得，有些 dp ，先想到一个感觉正确的 dp ，再从这个 dp 去证明做法正确性就是耍流氓。</p>
<p>我个人觉得做大部分 dp ，正确的流程就应该是，我先想到这个题目的一些充要的性质啥的，然后再尝试用 dp 去维护这些充要的性质。</p>
<p>即不是从 dp 本身去证明 dp 的正确性，而是先把 dp 要维护的东西证明了，这样使用 dp 维护就完全正确了。</p>
<p>所以我认为，这道题目正确的、自然的思考过程大体上应该是这样：</p>
<ol>
<li><p>以任意路线发现充要条件：可以采用后面这个方案删除完整个序列：每次删除最右边的合法括号，这对括号满足：a[i]=i ，内层为空。</p>
</li>
<li><p>然后再发现一个等价的充要条件：对于一个括号序列，对于任意一对括号，其的可删除括号为，所有 () 满足 () 都在其的左括号左边，可删除左括号个数 * 2 $\ge i-a[i]$ （或者是等效的可以方便导出 dp 方程的充要条件）。</p>
</li>
<li><p>使用 dp 维护这个过程，取得 AC 。</p>
</li>
</ol>
<p>总之我认为，做一个 dp 题目肯定是先提出充要条件，再维护，而不是先提出 dp ，再证明。</p>
</div></details>
<p>和官方做法没啥区别。</p>
<h1 id="G-Spinning-Round"><a href="#G-Spinning-Round" class="headerlink" title="G. Spinning Round"></a>G. Spinning Round</h1><h2 id="Easy-Version"><a href="#Easy-Version" class="headerlink" title="Easy Version"></a>Easy Version</h2><p>题目链接：<a href="https://codeforces.com/contest/1987/problem/G1">https://codeforces.com/contest/1987/problem/G1</a></p>
<p>题目大意：给你一个排列，每个点可以向左边最近的比它大的点连边，或者向右边，问得到的联通图的直径的最大值是多少。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>首先在笛卡尔树上考虑，发现每个点只可能连向自己的祖先，而且根节点一定是自环，可以知道连通的充要条件是除了根节点外的所有点不自环，而且最终一定是一棵树。</p>
<p>所以可以知道求直径等价于求新树中的直径，这样就好求多了。</p>
<p>我们考虑每条路径在这条路径的 LCA 处考虑。</p>
<p>有两种情况：</p>
<ol>
<li>来自不同的儿子。</li>
<li>来自相同的儿子。</li>
</ol>
<p>情况 $1$ 是简单的，重点是情况下，可以发现，他们都一定来自于：</p>
<p>左儿子-右儿子-右儿子-右儿子-右儿子… 这条链，或者反过来。（下面假设就在这条链上处理，反过来同理）</p>
<p>直接在这条链上找就行了，只要一条链能线性处理，则时间复杂度是 ：$O(n)$ 的。</p>
<p>注意到在这条链上选择了一深一浅两个点，浅的点一定会沿着这条链到达 LCA ，然后深的点直接连向 LCA 。（注意，这里浅的点会选择其所在路径与链交集的最深的点，深的点会选择最浅的点，下同）</p>
<p>难点在于发现这个过程可以嵌套，距离来说，如果在链上选择的两个点是相邻的，则下面的路径有可能同时来自于浅的点的子树，导致嵌套。</p>
<p><img src="1.png" alt=""></p>
<p>上面是一个例子，蓝色是新树，当然，这个例子新树的构建不止这一种，这里只是给出上面那种嵌套情况会发生的新树，显然存在以这种情况为唯一最优的树。</p>
<p>用 dp 额外维护就行了，dp[x] 表示现在有两条链，一条连向 $x$ ，一条连向 $x$ 的父亲的长度和。</p>
<p>时间复杂度：$O(n)$ 。</p>
<p>当然，你可能会问，这种讨论题你怎么保证自己能讨论对的，我经常漏情况，要怎么处理？</p>
<p>虽然我主观上认为，讨论的难度反比于你的实力，你的实力越高，你在一开始就越容易找到方便讨论的角度和做法。但是实际上我完全不知道怎么保证自己能讨论对，因为：</p>
<p><img src="2.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(ss) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, sta[N], top, p[N];</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> ss[N];</span><br><span class="line"><span class="type">int</span> d[N], ans;</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y = son[x][t];</span><br><span class="line">    <span class="type">int</span> now = son[x][t], cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> base = d[son[now][t]] + <span class="number">1</span> + cnt;</span><br><span class="line">    <span class="keyword">while</span>(son[now][t ^ <span class="number">1</span>])&#123;</span><br><span class="line">        dp[y] = <span class="built_in">max</span>(dp[y], base + d[son[now][t ^ <span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">        dp[y] = <span class="built_in">max</span>(dp[y], dp[son[now][t ^ <span class="number">1</span>]] + cnt + <span class="number">1</span>);</span><br><span class="line">        now = son[now][t ^ <span class="number">1</span>];</span><br><span class="line">        cnt++;</span><br><span class="line">        base = <span class="built_in">max</span>(base, d[son[now][t]] + <span class="number">1</span> + cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, dp[y] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">0</span>]) <span class="built_in">dfs</span>(son[x][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">1</span>]) <span class="built_in">dfs</span>(son[x][<span class="number">1</span>]);</span><br><span class="line">    d[x] = <span class="built_in">max</span>(d[son[x][<span class="number">0</span>]] + <span class="number">1</span>, d[son[x][<span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, d[son[x][<span class="number">0</span>]] + d[son[x][<span class="number">1</span>]] + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">0</span>]) <span class="built_in">work</span>(x, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">1</span>]) <span class="built_in">work</span>(x, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">        son[i][<span class="number">0</span>] = son[i][<span class="number">1</span>] = d[i] = dp[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">get_char_array</span>(ss);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(top &amp;&amp; p[sta[top]] &lt; p[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre) son[sta[top]][<span class="number">1</span>] = pre;</span><br><span class="line">            pre = sta[top--];</span><br><span class="line">        &#125;</span><br><span class="line">        son[i][<span class="number">0</span>] = pre;</span><br><span class="line">        sta[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = top - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) son[sta[i]][<span class="number">1</span>] = sta[i + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">dfs</span>(sta[<span class="number">1</span>]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误回顾：</p>
<p> WA 的主要原因：</p>
<ol>
<li>没有发现嵌套的情况。</li>
<li>代码写错了。</li>
</ol>
</div></details>
<h2 id="Hard-Version"><a href="#Hard-Version" class="headerlink" title="Hard Version"></a>Hard Version</h2><p>题目链接：<a href="https://codeforces.com/contest/1987/problem/G2">https://codeforces.com/contest/1987/problem/G2</a></p>
<p>题目大意：有些点会固定连向左边或者右边。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>书接上回，证明合不合法简单的。</p>
<p>问题在于，当某些点的方向固定后，很多原来可以扔掉的劣的情况，就必须重新考虑了。</p>
<p>首先大的情况还是那么几种（依旧认为是左儿子-右儿子-右儿子-右儿子-右儿子… 这条链）：</p>
<ol>
<li>来自不同子树，不同在于，来自一个子树的最长路不一定来自儿子。</li>
<li><p>来自相同子树。</p>
<p>一样的，我们还是在链上考虑，先假设枚举一深一浅的两个点不相邻，但是有两点不同。</p>
<ol>
<li>浅的点不一定会沿着链到 LCA 。</li>
<li>浅的点所在的路径的下方不一定来自其左儿子。</li>
</ol>
<p><img src="3.png" alt=""></p>
<p>其中 1 好解决，2 不好解决，这需要我们在每个点额外维护一个东西，从这个子树出发向外连边是 L 或者是 R 的最长路径，这样就能维护不相邻的情况。</p>
<p>相邻呢？</p>
<p>还是一样，维护 dp ，而这与上面出现了相同的两个问题，用相同的办法解决就行了。</p>
</li>
</ol>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(ss) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, sta[N], top, p[N];</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> ss[N];</span><br><span class="line"><span class="type">int</span> d[N][<span class="number">2</span>], g[N][<span class="number">2</span>], ans;</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t) <span class="keyword">return</span> ss[x] == <span class="string">&#x27;?&#x27;</span> || ss[x] == <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ss[x] == <span class="string">&#x27;?&#x27;</span> || ss[x] == <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y = son[x][t];</span><br><span class="line">    d[x][t] = g[y][t];</span><br><span class="line">    g[x][t ^ <span class="number">1</span>] = <span class="built_in">max</span>(g[x][t ^ <span class="number">1</span>], g[y][t ^ <span class="number">1</span>]);</span><br><span class="line">    dp[y] = <span class="built_in">max</span>(d[y][<span class="number">0</span>], d[y][<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> now = y, cnt = <span class="number">0</span>, ncnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*distance between top/or now_top*/</span></span><br><span class="line">    <span class="type">int</span> pre = d[y][t] + <span class="number">1</span>, npre = d[y][t];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">pd</span>(y, t)) cnt = -inf, pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(son[now][t ^ <span class="number">1</span>])&#123;</span><br><span class="line">        now = son[now][t ^ <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> pre1 = g[son[now][t]][t ^ <span class="number">1</span>] + <span class="number">1</span> + cnt;</span><br><span class="line">        <span class="type">int</span> npre1 = g[son[now][t]][t ^ <span class="number">1</span>] + ncnt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pd</span>(now, t))&#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp[now] + cnt + <span class="number">2</span>);</span><br><span class="line">            dp[y] = <span class="built_in">max</span>(dp[y], dp[now] + ncnt + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">pd</span>(now, t ^ <span class="number">1</span>)) cnt = <span class="number">0</span>, ncnt = -inf;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">pd</span>(now, t)) cnt ++;</span><br><span class="line">        <span class="keyword">else</span> cnt = <span class="built_in">max</span>(cnt + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        ncnt++;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pd</span>(now, t))&#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(d[now][<span class="number">0</span>], d[now][<span class="number">1</span>]) + <span class="number">1</span> + pre);</span><br><span class="line">            dp[y] = <span class="built_in">max</span>(dp[y], <span class="built_in">max</span>(d[now][<span class="number">0</span>], d[now][<span class="number">1</span>]) + <span class="number">1</span> + npre);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = <span class="built_in">max</span>(pre, d[now][t] + <span class="number">1</span> + cnt);</span><br><span class="line">        pre = <span class="built_in">max</span>(pre, pre1);</span><br><span class="line">        npre = <span class="built_in">max</span>(npre, d[now][t] + ncnt);</span><br><span class="line">        npre = <span class="built_in">max</span>(npre, npre1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> state)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(state == <span class="number">1</span> &amp;&amp; !<span class="built_in">pd</span>(x, <span class="number">0</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(state == <span class="number">2</span> &amp;&amp; !<span class="built_in">pd</span>(x, <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">dfs</span>(son[x][<span class="number">0</span>], state | <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">work</span>(x, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">dfs</span>(son[x][<span class="number">1</span>], state | <span class="number">2</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">work</span>(x, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pd</span>(x, <span class="number">0</span>)) g[x][<span class="number">0</span>] = <span class="built_in">max</span>(g[x][<span class="number">0</span>], <span class="built_in">max</span>(d[x][<span class="number">0</span>], d[x][<span class="number">1</span>]) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pd</span>(x, <span class="number">1</span>)) g[x][<span class="number">1</span>] = <span class="built_in">max</span>(g[x][<span class="number">1</span>], <span class="built_in">max</span>(d[x][<span class="number">0</span>], d[x][<span class="number">1</span>]) + <span class="number">1</span>);</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, d[x][<span class="number">0</span>] + d[x][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">        son[i][<span class="number">0</span>] = son[i][<span class="number">1</span>] = d[i][<span class="number">0</span>] = d[i][<span class="number">1</span>] = g[i][<span class="number">0</span>] = g[i][<span class="number">1</span>] = dp[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">get_char_array</span>(ss);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(top &amp;&amp; p[sta[top]] &lt; p[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre) son[sta[top]][<span class="number">1</span>] = pre;</span><br><span class="line">            pre = sta[top--];</span><br><span class="line">        &#125;</span><br><span class="line">        son[i][<span class="number">0</span>] = pre;</span><br><span class="line">        sta[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = top - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) son[sta[i]][<span class="number">1</span>] = sta[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">dfs</span>(sta[<span class="number">1</span>], <span class="number">0</span>)) cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>犯错记录：</p>
<ol>
<li>代码写错了。</li>
<li>发现忘记浅点的路径可以来自其右儿子的左二子。</li>
<li>发现但是用了错误的方法解决，后面新维护了一个 dp 解决了这个问题，最后 AC 了。</li>
</ol>
<p>感觉这种题目就是很屎，很需要讨论，很看你的讨论功底的题目。</p>
</div></details>
<h2 id="别的做法"><a href="#别的做法" class="headerlink" title="别的做法"></a>别的做法</h2><details class="toggle" ><summary class="toggle-button" style="">在提交中找到的一份做法</summary><div class="toggle-content"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://codeforces.com/contest/1987/submission/268586570</span></span><br><span class="line"><span class="comment">// LUOGU_RID: 163845250</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">400005</span>];</span><br><span class="line"><span class="type">char</span> s[<span class="number">400005</span>];</span><br><span class="line"><span class="type">int</span> st[<span class="number">400005</span>],top;</span><br><span class="line"><span class="type">int</span> ch[<span class="number">400005</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">400005</span>][<span class="number">3</span>],ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ch[x][<span class="number">0</span>])<span class="built_in">dfs</span>(ch[x][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(ch[x][<span class="number">1</span>])<span class="built_in">dfs</span>(ch[x][<span class="number">1</span>]);</span><br><span class="line">    dp[x][<span class="number">0</span>]=dp[ch[x][<span class="number">0</span>]][<span class="number">0</span>];</span><br><span class="line">    dp[x][<span class="number">1</span>]=dp[ch[x][<span class="number">1</span>]][<span class="number">1</span>];</span><br><span class="line">    dp[x][<span class="number">2</span>]=dp[ch[x][<span class="number">0</span>]][<span class="number">0</span>]+dp[ch[x][<span class="number">1</span>]][<span class="number">1</span>];</span><br><span class="line">    ans=<span class="built_in">max</span>(ans,dp[ch[x][<span class="number">0</span>]][<span class="number">1</span>]+dp[ch[x][<span class="number">1</span>]][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(s[x]!=<span class="string">&#x27;R&#x27;</span>)&#123;</span><br><span class="line">        dp[x][<span class="number">0</span>]=<span class="built_in">max</span>(&#123;dp[x][<span class="number">0</span>],dp[ch[x][<span class="number">0</span>]][<span class="number">1</span>]+<span class="number">1</span>,dp[ch[x][<span class="number">1</span>]][<span class="number">0</span>]+<span class="number">1</span>&#125;);</span><br><span class="line">        dp[x][<span class="number">2</span>]=<span class="built_in">max</span>(&#123;dp[x][<span class="number">2</span>],dp[ch[x][<span class="number">0</span>]][<span class="number">1</span>]+dp[ch[x][<span class="number">1</span>]][<span class="number">1</span>]+<span class="number">1</span>,dp[ch[x][<span class="number">1</span>]][<span class="number">2</span>]+<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">if</span>(a[x]&lt;n)ans=<span class="built_in">max</span>(&#123;ans,dp[ch[x][<span class="number">0</span>]][<span class="number">0</span>]+dp[ch[x][<span class="number">1</span>]][<span class="number">0</span>]+<span class="number">1</span>,dp[ch[x][<span class="number">0</span>]][<span class="number">2</span>]+<span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s[x]!=<span class="string">&#x27;L&#x27;</span>)&#123;</span><br><span class="line">        dp[x][<span class="number">1</span>]=<span class="built_in">max</span>(&#123;dp[x][<span class="number">1</span>],dp[ch[x][<span class="number">0</span>]][<span class="number">1</span>]+<span class="number">1</span>,dp[ch[x][<span class="number">1</span>]][<span class="number">0</span>]+<span class="number">1</span>&#125;);</span><br><span class="line">        dp[x][<span class="number">2</span>]=<span class="built_in">max</span>(&#123;dp[x][<span class="number">2</span>],dp[ch[x][<span class="number">0</span>]][<span class="number">0</span>]+dp[ch[x][<span class="number">1</span>]][<span class="number">0</span>]+<span class="number">1</span>,dp[ch[x][<span class="number">0</span>]][<span class="number">2</span>]+<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">if</span>(a[x]&lt;n)ans=<span class="built_in">max</span>(&#123;ans,dp[ch[x][<span class="number">0</span>]][<span class="number">1</span>]+dp[ch[x][<span class="number">1</span>]][<span class="number">1</span>]+<span class="number">1</span>,dp[ch[x][<span class="number">1</span>]][<span class="number">2</span>]+<span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,mx=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;mx)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==<span class="string">&#x27;L&#x27;</span>)<span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="built_in">void</span>();</span><br><span class="line">                s[i]=<span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mx=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n,mx=<span class="number">0</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;mx)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==<span class="string">&#x27;R&#x27;</span>)<span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="built_in">void</span>();</span><br><span class="line">                s[i]=<span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mx=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    top=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)ch[i][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> lst=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(top&amp;&amp;a[st[top]]&lt;a[i])lst=st[top--];</span><br><span class="line">        ch[st[top]][<span class="number">1</span>]=i;</span><br><span class="line">        ch[i][<span class="number">0</span>]=lst;</span><br><span class="line">        st[++top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(ch[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> _;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;_);</span><br><span class="line">    <span class="keyword">while</span>(_--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思考一个事情，我的做法相当于是直接在路径的 LCA 上考虑，这样考虑的好处是：</p>
<ol>
<li>直观，很容易想到这个做法，而且明确知道自己只需要讨论什么东西就足以完成此题。</li>
<li>可实现，在讨论完后所需要维护的东西一般都是可以简单维护的。</li>
</ol>
<p>但是坏处也是显然的：</p>
<p>讨论以后得到的每个部分相对独立，很难整合起来，因此码量比较大。</p>
<p>但是如果我们换个角度看，从下往上考虑，即考虑两条路径什么时候交到一起。</p>
<p>依旧是两种情况：</p>
<ol>
<li>两条路径，一条往左，一条往右，交到一个点上。</li>
<li>两条往同个方向，交到一个点上。</li>
</ol>
<p>注意到这个路径往左往右，也就是这个子树往外的第一条边往左往右，在我的做法中也有类似的定义：$g[x][0/1]$ 表示 $x$ 子树内往外的第一条边是什么方向。</p>
<p>顺着这个思路想，那怎么维护 $2$ 呢？注意到，肯定会有一个时间点，这两条路径一定会从 $x$ 子树的左儿子和右儿子内出来，其中左儿子往左，右儿子往右，所以维护 $g[x][2]$ 表示子树内有两条不相交的路径，一条往左，一条往右的长度。</p>
<p>因此就得到了上面那个做法 ，$g$ 也就是上面的 $dp$ 。</p>
<p>实际上，这个做法所维护的 $g[x][2]$，放到我那个做法中，就是把来自同一子树的两条链在较浅的那个点中产生并一路维护上来，相当于直接在遍历树的过程完成了转移，而不是单独再开一个部分计算答案。同时这个单条链的维护的过程和嵌套转移的过程是一样的，可以直接用一个转移过程，所以就可以少处理很多东西了。</p>
<p>这个思路相较于我的思路，明显的优势就是考虑主体变少了，从一条条链变成了一个个点，自然要好写好想（这里的好想指的是在初始方向正确的情况下，后面的细节都很简单，不是说这个思路好想）。</p>
<p>反思一下，虽然说做法是同构的，但是从这个做法想出那个做法，我感觉要难于直接换个角度考虑。就像很多题目直接考虑考虑不出来，但是换个角度就能考虑出来，做法本质就在那，都是一样的，但是换个角度难度就能大幅减少。</p>
<p>因此，考虑简化做法的时候不要只寄希望于优化当前的做法，因为将其直接优化到更加简洁的做法或许难度很大，有时候可以尝试换个角度观察这个做法，或许能很轻松的得到一个简洁得多的做法。</p>
</div></details>
<p>官方做法没看懂，感觉思考起来不太自然，而且看起来实现也很麻烦，咕了。不过能不在笛卡尔树上完成这道题目确实厉害，我只能说。</p>
<h1 id="比赛小结"><a href="#比赛小结" class="headerlink" title="比赛小结"></a>比赛小结</h1><p>评价一下，打的一坨，还好最后 G1 撞对了，否则坠机了。</p>
<p>比赛小结已经写在了 $F$ 的做法中。</p>
<p>总结下来就一句话 ：</p>
<p><strong>模拟赛</strong>时的题目该证明的就要给出完整的证明，不要搞一些自欺欺人的事情，不要过度的关注排名和 rating 。（当然时间不够的时候猜猜结论也是可以的，猜结论也是能力的一环，但是时间充足的时候或者中期的题目就别猜了，要给出完整的证明）</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>CF1499G Graph Coloring</title>
    <url>/2025/02/05/CF1499G-Graph-Coloring/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>后续把这个比赛的其他题目一起补上来吧。</p>
<h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p><a href="https://www.luogu.com.cn/problem/CF1499G">题目</a></p>
<p>这道题目思路还是很简单的。</p>
<p>首先考虑图权值最优下限，肯定就是度数是奇数的点数个数，但是是不是一定能到达这个下限呢？基本上只要能想懂这个的证明就知道该怎么做了。</p>
<p>先提供暴力思路：</p>
<p>一个十分明显的思路是，把一个奇数点找到一个与与他相联通的奇数点，然后合成成一条路径，在原图中去掉这条路径，这条路径作为一个子图，其上面的点除了端点外的其余点的度数都是偶数，所以只要我们边红蓝相邻染色就可以完成端点颜色特异，其余点相连的红色边和蓝色边数量相同。</p>
<p>而去掉若干条路径的原图度数都是偶数，则直接欧拉回路，也是红蓝染色，这样构造，就可以达到下限。</p>
<p>思考怎么维护？</p>
<p>一个非常粗暴的方法就是直接维护一个平衡树，其中每个点的附加权值是边的编号，而这个平衡树的中序遍历可以还原这个路径从一个端点走到另一个端点所走过的编号。</p>
<p>这样，考虑连上的边，要么出现一条新的路径，长度为 $1$ ，要么延长原有路径，要么合并原有路径，要么把路径变为回路，变为回路直接暴力把回路遍历就行了，因为一条边最多变为一次路径，再变为回路也只会被遍历一遍，此后就都在回路中存在了，所以这个操作整体是 $O(m+q)$ 的。</p>
<p>当然，因为中间涉及到了平衡树，所以$O((m+q)\log{(m+q)})$。</p>
<p>当然，输出的时间复杂度暴力遍历就行啦。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  N  410000</span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">long</span>  <span class="type">long</span>  LL;</span><br><span class="line"><span class="type">const</span>  LL  mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>  T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">zwap</span><span class="params">(T  &amp;x,T  &amp;y)</span></span>&#123;x^=y^=x^=y;&#125;</span><br><span class="line"><span class="type">int</span>  e[N];<span class="type">int</span>  ecnt;</span><br><span class="line">LL  v2[N];<span class="comment">//2^i</span></span><br><span class="line">LL  has=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>  y,next;</span><br><span class="line">	<span class="type">bool</span>  bk;</span><br><span class="line">&#125;a[N];<span class="type">int</span>  len=<span class="number">1</span>,last[N],du[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">ins</span><span class="params">(<span class="type">int</span>  x,<span class="type">int</span>  y)</span></span>&#123;len++;a[len].y=y;a[len].next=last[x];last[x]=len;du[y]++;&#125;</span><br><span class="line"><span class="type">int</span>  root[N],rcnt,lian[N][<span class="number">2</span>];</span><br><span class="line">LL  rval[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span>  be[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">xiao</span><span class="params">(<span class="type">int</span>  x)</span></span>&#123;(has-=rval[x][<span class="number">0</span>]-mod)%=mod;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">tian</span><span class="params">(<span class="type">int</span>  x)</span></span>&#123;(has+=rval[x][<span class="number">0</span>])%=mod;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span>  siz[N],val[N],key[N],son[N][<span class="number">2</span>],cnt;</span><br><span class="line"><span class="type">bool</span>  lazy[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">pushlazy</span><span class="params">(<span class="type">int</span>  x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">zwap</span>(son[x][<span class="number">0</span>],son[x][<span class="number">1</span>]);</span><br><span class="line">	lazy[x]^=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">plazy</span><span class="params">(<span class="type">int</span>  id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">zwap</span>(lian[id][<span class="number">0</span>],lian[id][<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">zwap</span>(rval[id][<span class="number">0</span>],rval[id][<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">pushlazy</span>(root[id]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">pushup</span><span class="params">(<span class="type">int</span>  x)</span></span>&#123;siz[x]=siz[son[x][<span class="number">0</span>]]+siz[son[x][<span class="number">1</span>]]+<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">pushdown</span><span class="params">(<span class="type">int</span>  x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(lazy[x])lazy[x]=<span class="number">0</span>,<span class="built_in">pushlazy</span>(son[x][<span class="number">0</span>]),<span class="built_in">pushlazy</span>(son[x][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">int</span>  <span class="title">mer</span><span class="params">(<span class="type">int</span>  A,<span class="type">int</span>  B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!A   ||  !B)<span class="keyword">return</span>  A+B;</span><br><span class="line">	<span class="keyword">if</span>(val[A]&lt;=val[B])<span class="built_in">pushdown</span>(A),son[A][<span class="number">1</span>]=<span class="built_in">mer</span>(son[A][<span class="number">1</span>],B),<span class="built_in">pushup</span>(A);</span><br><span class="line">	<span class="keyword">else</span>  <span class="built_in">pushdown</span>(B),son[B][<span class="number">0</span>]=<span class="built_in">mer</span>(A,son[B][<span class="number">0</span>]),<span class="built_in">pushup</span>(B),<span class="built_in">zwap</span>(A,B);</span><br><span class="line">	<span class="keyword">return</span>  A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">add</span><span class="params">(<span class="type">int</span>  k,<span class="type">int</span>  to,<span class="type">int</span>  type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(type==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(siz[root[to]]&amp;<span class="number">1</span>)(rval[to][<span class="number">1</span>]+=v2[k])%=mod;</span><br><span class="line">		<span class="keyword">else</span>  (rval[to][<span class="number">0</span>]+=v2[k])%=mod,(has+=v2[k])%=mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">xiao</span>(to);<span class="built_in">zwap</span>(rval[to][<span class="number">0</span>],rval[to][<span class="number">1</span>]);</span><br><span class="line">		(rval[to][<span class="number">0</span>]+=v2[k])%=mod;<span class="built_in">tian</span>(to);</span><br><span class="line">	&#125;</span><br><span class="line">	cnt++;siz[cnt]=<span class="number">1</span>;val[cnt]=<span class="built_in">rand</span>();key[cnt]=k;</span><br><span class="line">	<span class="keyword">if</span>(!type)root[to]=<span class="built_in">mer</span>(cnt,root[to]);</span><br><span class="line">	<span class="keyword">else</span>  root[to]=<span class="built_in">mer</span>(root[to],cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">he</span><span class="params">(<span class="type">int</span>  x,<span class="type">int</span>  y,<span class="type">int</span>  t1,<span class="type">int</span>  t2,<span class="type">int</span>  k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t1==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!(siz[root[x]]&amp;<span class="number">1</span>))<span class="built_in">zwap</span>(rval[x][<span class="number">0</span>],rval[x][<span class="number">1</span>]),(has+=rval[x][<span class="number">0</span>]-rval[x][<span class="number">1</span>]+mod)%=mod;</span><br><span class="line">		<span class="built_in">zwap</span>(lian[x][<span class="number">0</span>],lian[x][<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">pushlazy</span>(root[x]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">add</span>(k,x,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(t2==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!(siz[root[y]]&amp;<span class="number">1</span>))<span class="built_in">zwap</span>(rval[y][<span class="number">0</span>],rval[y][<span class="number">1</span>]),(has+=rval[y][<span class="number">0</span>]-rval[y][<span class="number">1</span>]+mod)%=mod;</span><br><span class="line">		<span class="built_in">zwap</span>(lian[y][<span class="number">0</span>],lian[y][<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">pushlazy</span>(root[y]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">xiao</span>(x);<span class="built_in">xiao</span>(y);</span><br><span class="line">	be[lian[x][<span class="number">1</span>]]=be[lian[y][<span class="number">0</span>]]=<span class="number">0</span>;be[lian[y][<span class="number">1</span>]]=x;</span><br><span class="line">	lian[x][<span class="number">1</span>]=lian[y][<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span>(siz[root[x]]&amp;<span class="number">1</span>)(rval[x][<span class="number">0</span>]+=rval[y][<span class="number">1</span>])%=mod,(rval[x][<span class="number">1</span>]+=rval[y][<span class="number">0</span>])%=mod;</span><br><span class="line">	<span class="keyword">else</span>  (rval[x][<span class="number">0</span>]+=rval[y][<span class="number">0</span>])%=mod,(rval[x][<span class="number">1</span>]+=rval[y][<span class="number">1</span>])%=mod;</span><br><span class="line">	root[x]=<span class="built_in">mer</span>(root[x],root[y]);</span><br><span class="line">	<span class="built_in">tian</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">dfs1</span><span class="params">(<span class="type">int</span>  x,<span class="type">int</span>  id,<span class="type">int</span>  co)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(du[x]&amp;<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		lian[id][<span class="number">1</span>]=x;du[x]--;</span><br><span class="line">		be[x]=id;</span><br><span class="line">		<span class="keyword">return</span>  ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  &amp;k=last[x];k;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[k].bk==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			a[k].bk=<span class="number">1</span>,a[k^<span class="number">1</span>].bk=<span class="number">1</span>;</span><br><span class="line">			<span class="type">int</span>  y=a[k].y;</span><br><span class="line">			<span class="built_in">add</span>(k/<span class="number">2</span>,id,<span class="number">1</span>);</span><br><span class="line">			k=a[k].next;</span><br><span class="line">			<span class="built_in">dfs1</span>(y,id,co^<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">return</span>  ;</span><br><span class="line">		&#125;</span><br><span class="line">		k=a[k].next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span>  shi[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">dfs2</span><span class="params">(<span class="type">int</span>  x,<span class="type">int</span>  co)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	shi[x]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  &amp;k=last[x];k;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span>  y=a[k].y;</span><br><span class="line">		<span class="keyword">if</span>(a[k].bk==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			a[k].bk=a[k^<span class="number">1</span>].bk=<span class="number">1</span>;e[k/<span class="number">2</span>]=co;</span><br><span class="line">			<span class="keyword">if</span>(co==<span class="number">0</span>)(has+=v2[k/<span class="number">2</span>])%=mod;</span><br><span class="line">			k=a[k].next;</span><br><span class="line">			<span class="built_in">dfs2</span>(y,co^<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>  k=a[k].next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>  sta[N],top;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">dfs3</span><span class="params">(<span class="type">int</span>  x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x)<span class="keyword">return</span>  ;</span><br><span class="line">	<span class="built_in">pushdown</span>(x);</span><br><span class="line">	<span class="built_in">dfs3</span>(son[x][<span class="number">0</span>]);</span><br><span class="line">	sta[++top]=key[x];</span><br><span class="line">	<span class="built_in">dfs3</span>(son[x][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">fu</span><span class="params">(<span class="type">int</span>  x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	top=<span class="number">0</span>;<span class="built_in">dfs3</span>(root[x]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=top;i++)e[sta[i]]=!(i&amp;<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">mie</span><span class="params">(<span class="type">int</span>  x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fu</span>(x);</span><br><span class="line">	be[lian[x][<span class="number">0</span>]]=be[lian[x][<span class="number">1</span>]]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>  n1,n2,m,n;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n1,&amp;n2,&amp;m);n=n1+n2;ecnt=m;</span><br><span class="line">	v2[<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=<span class="number">400000</span>;i++)v2[i]=(v2[i<span class="number">-1</span>]*<span class="number">2</span>)%mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span>  x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);y+=n1;</span><br><span class="line">		<span class="built_in">ins</span>(x,y);<span class="built_in">ins</span>(y,x);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(du[i]&amp;<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			du[i]--;be[i]=++rcnt;</span><br><span class="line">			lian[rcnt][<span class="number">0</span>]=i;</span><br><span class="line">			<span class="built_in">dfs1</span>(i,rcnt,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!shi[i])<span class="built_in">dfs2</span>(i,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span>  q;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span>  type;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;type);</span><br><span class="line">		<span class="keyword">if</span>(type==<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span>  x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);y+=n1;</span><br><span class="line">			++ecnt;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(be[x]  &amp;&amp;  be[y])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(be[x]==be[y])</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">mie</span>(be[x]),e[ecnt]=<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span>  <span class="built_in">he</span>(be[x],be[y],lian[be[x]][<span class="number">1</span>]==x,lian[be[y]][<span class="number">1</span>]==y,ecnt);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>  <span class="keyword">if</span>(be[x]+be[y]&gt;<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span>  rt=be[x]+be[y],pi=be[x]?x:y;</span><br><span class="line">				<span class="keyword">if</span>(lian[rt][<span class="number">0</span>]==pi)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">add</span>(ecnt,rt,<span class="number">0</span>);</span><br><span class="line">					be[lian[rt][<span class="number">0</span>]]=<span class="number">0</span>;be[lian[rt][<span class="number">0</span>]=pi^x^y]=rt;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">add</span>(ecnt,rt,<span class="number">1</span>);</span><br><span class="line">					be[lian[rt][<span class="number">1</span>]]=<span class="number">0</span>;be[lian[rt][<span class="number">1</span>]=pi^x^y]=rt;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				be[x]=be[y]=++rcnt;lian[rcnt][<span class="number">0</span>]=x;lian[rcnt][<span class="number">1</span>]=y;</span><br><span class="line">				<span class="built_in">add</span>(ecnt,rcnt,<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,has);</span><br><span class="line">			<span class="built_in">fflush</span>(stdout);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span>  rans=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(be[i]  &amp;&amp;  lian[be[i]][<span class="number">0</span>]==i)<span class="built_in">fu</span>(be[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=ecnt;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(e[i]==<span class="number">0</span>)rans++;</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,rans);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=ecnt;i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(e[i]==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">			&#125; </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">			<span class="built_in">fflush</span>(stdout);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，可不可以更快？</p>
<p>当然可以。</p>
<p>看以上过程，发现，我们平衡树可以维护整个路径，但是有必要吗？</p>
<p>没有必要，我们只要记录这条边在路径上的奇偶位置即可。</p>
<p>那么就用并查集维护，时间复杂度 ：$O(nα(n))$。（具体的可以看<a href="https://www.luogu.com.cn/blog/Troverld/solution-cf1499g）">https://www.luogu.com.cn/blog/Troverld/solution-cf1499g）</a></p>
<p>下面仅仅口胡，感觉是正确的，欢迎 diss 。</p>
<p>但是如果你仔细的观察一下代码，你就会发现维护平衡树的部分和维护链信息的部分其实根本就不互相干扰，因此我们其实可以把平衡树部分拖到 $2$ 询问一次解决。</p>
<p>具体的，维护链信息的 $Hash$ 值的代码不变，但是，链的形态每变一次，就新建一个链并向原本的链连边，边信息就是改变的信息，同时合理安排左右儿子（左儿子的链在次链的左边，右儿子同理），然后在询问的时候从上到下模拟，同时带上翻转标记，这样处理就可以单次询问 $O(m)$ ，修改询问 $O(1)$ 了。（当然，路径变成回路还是要处理）</p>
<p>时间复杂度喜闻乐见的 $O(m+q)$ 。（但是因为这道题目我调试都已经调吐了，就不想再打这道题目了）</p>
<h1 id="有趣的事情"><a href="#有趣的事情" class="headerlink" title="有趣的事情"></a>有趣的事情</h1><p>我看错输出格式发了个帖子问人。。。</p>
<p>main函数中du[i]&amp;1写成du[i]==1调了一个下午。。。</p>
<p>为了交代码把打代码时的所有中文注释全删了。（但是这么丑陋的代码估计加了注释也不会有人看吧）</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>欧拉回路</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1526 E. Oolimry and Suffix Array(从后缀数组反推字符串)</title>
    <url>/2024/02/16/CF1526-E-Oolimry-and-Suffix-Array-%E4%BB%8E%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%E5%8F%8D%E6%8E%A8%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>题目链接：<a href="https://codeforces.com/contest/1526/problem/E">https://codeforces.com/contest/1526/problem/E</a></p>
<p>题目大意：字符集大小为 $n$ ，询问有多少个字符串的后缀数组就是给定的后缀数组。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>其实我也不太清楚我是怎么想到这个做法的，反正就是想什么时候两个位置的字符能够相同，然后就知道怎么做了。</p>
<p>看到一个题解说的很有道理：<a href="https://www.luogu.com.cn/blog/namelessgugugu/solution-cf1526e">https://www.luogu.com.cn/blog/namelessgugugu/solution-cf1526e</a></p>
<p>这么说的：知道 $s[i,n]&lt;s[j,n]$ ，就知道 $s[i]\le s[j]$ ，问题是什么时候能够相等，显然是 $s[i+1,n]&lt;s[j+1,n]$ 的时候能够相等。</p>
<p>所以做法就出来了：显然后缀数组上每个位置的字符是非严格递增的，问题是相邻的位置字符能否相等，显然条件就是上面那个，假设我们已经知道了至少需要有 $now$ 个不同的字符，则答案为：</p>
<script type="math/tex; mode=display">\sum\limits_{i=0}^{\min(n,K)-now}\binom{K}{i+now}\binom{n-now}{i}</script><p>显然，这已经足以通过此题，但是还能再简化：</p>
<script type="math/tex; mode=display">
\begin{align*}
&\sum\limits_{i=0}^{\min(n,K)-now}\binom{K}{i+now}\binom{n-now}{i}\\
=& \sum\limits_{i=0}^{\min(n,K)-now}\binom{K}{i+now}\binom{n-now}{n-now-i}\\
=& \sum\limits_{i=0}^{n}\binom{K}{i}\binom{n-now}{n-i}\\
\end{align*}</script><p>最后一步是因为超出来的范围都因为组合数不合法所以值为 $0$ ，不会对结果产生影响。</p>
<p>所以显然，最终化简结果为：$\binom{K+n-now}{n}$ 。</p>
<p>时间复杂度：$O(n+K)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line">LL fc[N],nfc[N];</span><br><span class="line"><span class="type">int</span> n,K,sa[N],rk[N];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;K);</span><br><span class="line">    fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">max</span>(n,K);i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="built_in">max</span>(n,K);i++)fc[i]=fc[i<span class="number">-1</span>]*i%mod,nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;sa[i]);</span><br><span class="line">        rk[sa[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// rk[n+1]=0;</span></span><br><span class="line">    <span class="type">int</span> now=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(rk[sa[i<span class="number">-1</span>]+<span class="number">1</span>]&gt;rk[sa[i]+<span class="number">1</span>])&#123;</span><br><span class="line">            now++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i+now&lt;=n &amp;&amp; i+now&lt;=K;i++)&#123;</span><br><span class="line">        ans=(ans+<span class="built_in">C</span>(K,i+now)*<span class="built_in">C</span>(n-now,i))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title>CF745 Div.1 赛后总结</title>
    <url>/2025/02/03/CF745-Div-1-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这场比赛是真的离谱，做了一道题目就可以上分了。</p>
<p><a href="http://codeforces.com/contest/1580">比赛链接</a></p>
<p>只会三道题目，第二道题目会个思路，不会卡常。</p>
<p><del>我这个分Div1比Div2还好上分</del></p>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>一个合格的子矩阵要求除了四个角以外，四条边是 1 ，中间为 0 ，且子矩阵长宽至少是多少（题目给出限制），然后问题目给出矩阵的哪个子矩阵只需要最少的操作次数便能合格，并输出操作次数。</p>
<p>考虑枚举子矩阵的最低行和最高行以及最高列，然后最低列在枚举的时候直接在前面取最小值即可，具体看代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 410</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[N][N],n,m;</span><br><span class="line"><span class="type">char</span> st[N][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">fuck</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> lie)</span></span>&#123;<span class="keyword">return</span> a[r][lie]-a[l<span class="number">-1</span>][lie];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> st[x][y]==<span class="string">&#x27;0&#x27;</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">mymin</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&lt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st[i]+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)a[i][j]=a[i<span class="number">-1</span>][j]+(st[i][j]==<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> ans=<span class="number">999999999</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l=n<span class="number">-4</span>;l&gt;=<span class="number">1</span>;l--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> r=l+<span class="number">4</span>;r&lt;=n;r++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> now=<span class="number">0</span>,minsum=(r-l<span class="number">-1</span>)-<span class="built_in">fuck</span>(l+<span class="number">1</span>,r<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">3</span>;i++)now+=<span class="built_in">fuck</span>(l+<span class="number">1</span>,r<span class="number">-1</span>,i)+<span class="built_in">pd</span>(l,i)+<span class="built_in">pd</span>(r,i);</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">4</span>;i&lt;=m;i++)</span><br><span class="line">				&#123;</span><br><span class="line">					ans=<span class="built_in">mymin</span>(ans,now+minsum+(r-l<span class="number">-1</span>)-<span class="built_in">fuck</span>(l+<span class="number">1</span>,r<span class="number">-1</span>,i));</span><br><span class="line">					<span class="type">int</span> x=<span class="built_in">fuck</span>(l+<span class="number">1</span>,r<span class="number">-1</span>,i<span class="number">-2</span>)+<span class="built_in">pd</span>(l,i<span class="number">-2</span>)+<span class="built_in">pd</span>(r,i<span class="number">-2</span>);</span><br><span class="line">					now-=x;now+=<span class="built_in">fuck</span>(l+<span class="number">1</span>,r<span class="number">-1</span>,i)+<span class="built_in">pd</span>(l,i)+<span class="built_in">pd</span>(r,i);</span><br><span class="line">					minsum=<span class="built_in">mymin</span>(minsum+x,(r-l<span class="number">-1</span>)-<span class="built_in">fuck</span>(l+<span class="number">1</span>,r<span class="number">-1</span>,i<span class="number">-2</span>));</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)a[i][j]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>如果一个排列中包含下标为 $i$ 的子区间的有 $m$ 个不同的最大值，则称 $i$ 为 $m$ 好数。</p>
<p>现在要统计有多少个排列恰好含有 $k$ 个 $m$ 好数。</p>
<p>感觉思路很像鹰蛋，不知道是不是我的错觉。</p>
<p>$f[i][j][k]$ 表示长度为 $i$ ，刚好有 $k$ 个 $j$ 好数的排列数量。</p>
<p>考虑排列最大值在哪个位置，然后左边右边的 $k$ 好数同时变成 $k+1$ 好数。</p>
<p>时间复杂度：$O(n^2mk^2)$  （官方复杂度也是这个）</p>
<p><del>想不到竟然是这么离谱的时间复杂度吧</del></p>
<p>当然，因为我是 for 循环 DP ，所以比较容易 DP 出很多无用状态，而且我常数不够优秀，T 了，100 100 100 本机跑了个 15.74s，懒得优化了。</p>
<p>官方给出的代码是类似记忆化搜索的DP。</p>
<p><del>RNM卡常题</del></p>
<p>我的代码（TLE12）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 110</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">mymin</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&lt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">mymax</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line">LL n,m,K,mod;</span><br><span class="line">LL dp[N][N][N],C[N][N],fc[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>,&amp;n,&amp;m,&amp;K,&amp;mod);</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=dp[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;dp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]=dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=m;j++)dp[<span class="number">1</span>][j][<span class="number">0</span>]=dp[<span class="number">0</span>][j][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	C[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;fc[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		C[i][<span class="number">0</span>]=<span class="number">1</span>;fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)C[i][j]=(C[i<span class="number">-1</span>][j]+C[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dp[i][<span class="number">0</span>][<span class="number">0</span>]=dp[i][<span class="number">1</span>][<span class="number">1</span>]=fc[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;=m;k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> l=<span class="built_in">mymin</span>(j<span class="number">-1</span>,K);l&gt;=<span class="number">0</span>;l--)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> r=<span class="built_in">mymin</span>(i-j,K-l);r&gt;=<span class="number">0</span>;r--)(dp[i][k][l+r]+=dp[j<span class="number">-1</span>][k<span class="number">-1</span>][l]*dp[i-j][k<span class="number">-1</span>][r]%mod*C[i<span class="number">-1</span>][j<span class="number">-1</span>])%=mod;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dp[n][m][K]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>官方代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_N = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k, P;</span><br><span class="line"><span class="type">int</span> fac[MAX_N], c[MAX_N][MAX_N], f[MAX_N][MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b &lt; P ? a + b : a + b - P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> sz, <span class="type">int</span> cnt, <span class="type">int</span> dep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[dep][sz][cnt] != <span class="number">-1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> &amp;F = f[dep][sz][cnt] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!sz) &#123;</span><br><span class="line">        F = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((m - dep &lt; <span class="number">7</span> &amp;&amp; (<span class="number">1</span> &lt;&lt; (m - dep)) &lt; cnt) || (cnt &amp;&amp; sz &lt; m - dep)) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (dep == m) &#123;</span><br><span class="line">        F = (cnt == <span class="number">1</span> ? fac[sz] : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sz; i ++) &#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="type">int</span> fi = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">register</span> <span class="type">int</span> *fl = f[dep + <span class="number">1</span>][i], *fr = f[dep + <span class="number">1</span>][sz - i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="built_in">max</span>(<span class="number">0</span>, cnt + i + <span class="number">1</span> - sz); j &lt;= <span class="built_in">min</span>(cnt, i); j ++)</span><br><span class="line">            <span class="keyword">if</span> (fl[j] &amp;&amp; fr[cnt - j]) &#123;</span><br><span class="line">                <span class="built_in">dp</span>(i, j, dep + <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">dp</span>(sz - i - <span class="number">1</span>, cnt - j, dep + <span class="number">1</span>);</span><br><span class="line">                fi = (fi + <span class="number">1ll</span> * fl[j] * fr[cnt - j]) % P;</span><br><span class="line">            &#125;</span><br><span class="line">        F = (F + <span class="number">1ll</span> * fi * c[sz - <span class="number">1</span>][i]) % P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; P; m --;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = c[<span class="number">0</span>][<span class="number">0</span>] = fac[<span class="number">0</span>] = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">        c[i][<span class="number">0</span>] = c[i][i] = <span class="number">1</span>;</span><br><span class="line">        fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % P;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j ++) c[i][j] = <span class="built_in">add</span>(c[i - <span class="number">1</span>][j - <span class="number">1</span>], c[i - <span class="number">1</span>][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">dp</span>(n, k, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; f[<span class="number">0</span>][n][k] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>每辆车运作 $xi$ 的时间，维修 $yi$ 的时间如此往复，有 $n$ 种车，一开始没有车，每次操作会加入车（原本没有这种车），或者删除车（有这种车），然后问每次操作后有多少个车在维修。</p>
<p><del>应该是在操作后吧，因为我赛后五天才写的总结，所以忘题了</del></p>
<p>考虑根号分治。</p>
<p>先把答案差分一下。</p>
<p>然后题目可以拆成从 $x$ 修改，每隔 $y$ 个修改一次，最多改 $k$ 次。</p>
<p>具体就是每次在维修开始时 +1 ，在运作开始时 -1 ，然后最后前缀和即可。</p>
<p>而这个可以修改又可以拆成两个修改，一个 $+1$ ，一个 $-1$ ，把最多改 $k$ 次这个限制取消，改成只要 $y$ 不超过 $m$ 即可。</p>
<p>然后考虑如果 $y≥\sqrt{m}$ 时，暴力修改，$y&lt;\sqrt{m}$ 时，则存下此次修改，在最后遍历 $\sqrt{m}$ 遍数组暴力修改。</p>
<p>时间复杂度：$O(n\sqrt{m})$</p>
<p>空间复杂度：$O(n+m)$</p>
<p>然后有些细节字节想想吧。</p>
<p>这道题目难倒是不难，但是我一开始以为过不了，而且我 B 题还没做出来，于是最后四十分钟才开始码这道题，然后没调出来光荣GG。<del>码力是真的差</del></p>
<p>但是还好能上分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SN 510</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 210000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NN 410000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> id,k,next;</span><br><span class="line">&#125;a[NN];<span class="type">int</span> len,last[SN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> id,<span class="type">int</span> k)</span></span>&#123;len++;a[len].id=id;a[len].k=k;a[len].next=last[x];last[x]=len;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">car</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">&#125;c[N];</span><br><span class="line"><span class="type">int</span> sum[N],n,sn,m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">change1</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;<span class="keyword">while</span>(id&lt;=m)sum[id]+=k,id+=y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">change2</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> y,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(id&gt;m)<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span>(y&gt;sn)<span class="built_in">change1</span>(id,y,k);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">ins</span>(y,id,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">change3</span><span class="params">(<span class="type">int</span> id,<span class="type">int</span> y,<span class="type">int</span> k,<span class="type">int</span> limit)</span><span class="comment">//左闭右开 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(limit&lt;=id || id&gt;m)<span class="keyword">return</span> ;</span><br><span class="line">	limit=((limit-id<span class="number">-1</span>)/y+<span class="number">1</span>)*y+id;</span><br><span class="line">	<span class="built_in">change2</span>(id,y,k);<span class="built_in">change2</span>(limit,y,-k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> NM[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!last[id])<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=last[id];k;k=a[k].next)NM[a[k].id]+=a[k].k;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum[i]+=NM[i];</span><br><span class="line">		<span class="keyword">if</span>(i+id&lt;=m)NM[i+id]+=NM[i];</span><br><span class="line">		NM[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> pre[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);sn=<span class="built_in">sqrt</span>(m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;c[i].x,&amp;c[i].y);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> op,k;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;op,&amp;k);</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>)pre[k]=i;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">change3</span>(pre[k]+c[k].x,c[k].x+c[k].y,<span class="number">1</span>,i);</span><br><span class="line">			<span class="built_in">change3</span>(pre[k]+c[k].x+c[k].y,c[k].x+c[k].y,<span class="number">-1</span>,i);</span><br><span class="line">			<span class="type">int</span> fuck=(i-pre[k])%(c[k].x+c[k].y)+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(fuck&gt;c[k].x+<span class="number">1</span> || fuck==<span class="number">1</span>)sum[i]--;</span><br><span class="line">			pre[k]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(pre[i])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">change3</span>(pre[i]+c[i].x,c[i].x+c[i].y,<span class="number">1</span>,m+<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">change3</span>(pre[i]+c[i].x+c[i].y,c[i].x+c[i].y,<span class="number">-1</span>,m+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=sn;i++)<span class="built_in">solve</span>(i);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,sum[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>Cool Slogans</title>
    <url>/2025/02/04/Cool-Slogans/</url>
    <content><![CDATA[<p>题目：<a href="https://www.luogu.com.cn/problem/CF700E">https://www.luogu.com.cn/problem/CF700E</a></p>
<p>思路：</p>
<p>SAM上DP。</p>
<ol>
<li>首先可以注意到我们可以限制DP的转移，使得短串向长串转移时必须是长串的后缀。（加限制）</li>
<li>然后可以注意到此时每个子串一定向SAM子树的子串转移，同时同一个节点的子串无法互相转移。</li>
<li>发现同一个节点的非最长串的转移（向他转移和他向别人转移）一定被包含在最长串的转移。</li>
<li>考虑每个节点最长串的转移子串（即谁向他转移的）一定可以是其祖先节点的最长串。</li>
<li>于是考虑限制只在每个节点最长串上转移，删掉了转移，答案只会非严格减少，同时由第四条可以知道，答案不会减少，综上，加上如上限制答案不变。</li>
<li>如果考虑从下往上DP，则需要倍增+线段树合并，两个log。</li>
<li>但是如果是从上到下更新，由于具有：能更新我父亲节点最长串的子串也一定能更新我自己的最长串的特点，每个节点要么等于父亲节点的dp值，要么+1，+1只需要判断父亲这条dp值相同的链的链头是否能转移到自己即可，行就+1，不行就不加，直接继承，这样子做是一个log的，只需要线段树合并。</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S 2021 游记</title>
    <url>/2025/02/03/CSP-S-2021-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>CSP的初赛为什么这么TM的难。</p>
<p>高二最后一年OI，放手一搏！！！</p>
<h1 id="初赛"><a href="#初赛" class="headerlink" title="初赛"></a>初赛</h1><p>考前日常失眠，习惯了┑(￣Д ￣)┍。</p>
<p>考试当天8:00坐车，提前一小时到达教室，好TM大的教室。</p>
<p>甚至还没有老师。</p>
<p>考前注意到了好像没有AB卷，这么离谱，缺经费了？</p>
<p>考试的时候才发现没有带表，失策了。</p>
<p>考试的时候监考官说的话也没有听清，又失策了。</p>
<p>甚至在发完卷子后才叫我们把书包上交，这次轮到监考官失策了。（这么搞就不怕有人作弊，还有初中生和小学生的人数变多了呢）</p>
<p>刚发下卷子一看，前面选择题挺简单的，甚至还有原题，感觉稳了，但是第一道题考 Linux 常识有点伤，他考 Windows 我都不一定会，还 Linux 的，但是我知道 cd 是进入，ls 说不定是 list 列表的意思，三个中选了一个，赛后发现对了。</p>
<p>当看到阅读程序时，开始觉得不对劲了，为什么考球体的体积方程，还好不是完善程序，如果是，这场初赛估计直接爆炸，虽然最后一个 else 没看懂，但是因为代码给出来了，直接硬算就行了，还不算太难。</p>
<p>第二道字符串，十分神奇，想了好一会才发现第二部分是压缩，第一部分是解压，想明白后做出来还挺快的，但是我忘记了一个二进制末尾可以有一串 0 的情况，给我的分数造成了不小的打击，这道题目的最后一道选择题也是在最后十五分钟回头做做出来的，中途忘记了 0 的 ASCII 码，但突然想起了快读中打的 c^48 ，然后有惊无险的暴力模拟了出来。</p>
<p>第三道题求最大连续子序列，惯性思维以为两个都是 nlogn ，结果太自信导致了错误。</p>
<p>完善程序一年比一年阴间，以前的题目你看到题干会做了之后，只要按着自己的想法去对答案差不多就能做出来，这次不行了，你还要去看他给出来的是什么NM思路才可以，甚至最后一道题直接现场学算法，考了一个 $O(n)$ 的静态RMQ，我直接裂开，唯一会这个的大佬退役了QAQ，<del>但是当场就看懂了，真好</del>，还行，但是最后一个选择题我以为他在地下停车场，我在天台，考后才发现他在月球的地下停车场。（同机房的神仙 $CLB$ 当场手推了笛卡尔树，难道看柯南和福尔摩斯的Oier都这么神吗，比我这个只看宅区和二次元的臭鱼烂虾强多了）</p>
<p>车上在聊卷子，同机房神仙 $ZWQ$ 不会笛卡尔树，最后一道题靠看代码硬推，不过还是没能现场推出笛卡尔树（虽然我觉得他随便过初赛，毕竟其他题目对他应该没有难度），有一说一，虽然 $ZWQ$ 智商是真的离谱，但是要论推理，有时候 $CLB$ 才是真神，$CLB$ 十分自信，估分 $80+$ ，我没敢估，我TMD原本想草草 RUSH 一遍，然后最后检查，结果只剩十几分钟，所以我对我的分数十分不自信，毕竟草草做的谁有把握啊。（貌似只有我最拉）</p>
<p>赛后回家，晚上无聊对了答案，估分 85 分，十分神奇的事情是我十分自信能对的题目占了我错的题目的大半，但是我没自信对的题目几乎都对了，AZ，估计进复赛了，颓废！！！（估计 $CLB$ 最高）</p>
<p>当然，初赛最大的收获就是多学了个算法，就离谱。</p>
<h1 id="复赛"><a href="#复赛" class="headerlink" title="复赛"></a>复赛</h1><p>赛前，一直在玩《我就是太阳》、《看花眼了吗》，上头了，虽然不怎么影响状态。<del>策划，加强一下李信</del></p>
<p>不怎么紧张，反正有分就能进，只要不打错文件名什么的，暴力都能拿到分。</p>
<p>进考场了，先咪了一会，让我紧张的不是比赛，而是我认为的机房最强的神仙ZWQ就坐在我右后方，让我十分紧张<del>毕竟我好胜心比较强，难道有人会愿意在做题的时候看着周围的人AK完后翘着二郎腿在扫雷吗？</del>。</p>
<p>开始比赛了，输密码，突然血压高了！！！</p>
<p><del>什么垃圾键盘，艹，按下去一点感觉都没有，反馈差的一逼，SB东西。</del></p>
<p>当然，还好有多桌面，我习惯一个桌面看题，一个桌面想题。<del>我甚至没有发现没有计算器</del></p>
<p>开始看第一道题，看了好一会的题意，什么国内飞机国外飞机，什么牛马。<br>看完之后，突然发现貌似每次飞机都停编号最小的那个飞机场不会影响最多停的飞机数，这就说明不管多少个飞机场，每个飞机停到的飞机场编号是固定的，要么不停，那么直接前缀和处理即可。<del>但说句实话，感觉还是有点不对，当时还畏畏缩缩了一会，但是后面感觉有点合理，还是打了</del></p>
<p>半个小时内切掉第一题。</p>
<p>开始看第二道题，加 $<em>$ 做个屁，先优先考虑没有 $</em>$ 的，突然发现加了 $*$ 只要多一个数组维护即可，显然 $n^3$ 做法。</p>
<p><del>赛后才突然想起来n^3超一亿了，但是没有关系，常数小，跑不满，少爷机</del></p>
<p>细节稍微有点多，在一个小时十分钟切掉第二题，状态十分不错。<del>看样子是得到了太阳之力和中二之力</del></p>
<p>看第三道题，感觉不是很可做，看第四题，这不是个最小割吗，但是会超时，不过约束很多，应该要转成 DP 或者是贪心，但是不会，模拟网络流又不太可能，算了，先跳了，先思考第三题吧，仔细思考，突然发现因为每次放一个数字后另一个只能最后在放，所以合法方案中间一定会凝成一个区间，每次在区间左右扩即可。</p>
<p>但是突然又感觉不是很对，如果都可以扩的话，先扩左边和先扩右边有区别吗？直觉告诉我没有区别，但是我还是要证明一下，然后又花了十几二十分钟，搞出一个还行的证明：</p>
<p>如果两次卡住，假设中间区间的大小相同（如果不同也类似证明）：</p>
<p>一个左边扔了 $l1$ 个，右边扔了 $r1$ 个，另外一个 $l2,r2$ 。</p>
<p>假设 $l1&lt;l2$ ，那么 $l1+1$ 的位置一定在第一个区间的左右，矛盾，证毕。（大概就这个意思，差不多感性理解，后面写题解再详细说）</p>
<p>然后开打，细节挺多，但是还是两个小时十分钟的时候写出来了。</p>
<p>开始想最后一道题。</p>
<p>这个Dinic怎么可能优化的了啊！！！</p>
<p>有个边权 $log$ 的优化，可以把做法优化到 $Tn^4\log{c}$ 。</p>
<p>当时以为是 $Tn^3\log{c}$ ，想了个证明<del>但是事实证明想错了</del>，估计能多骗点分，而且代码难打，剩一个小时就开打了。</p>
<p>结果还是没调出来(╯‵□′)╯︵┻━┻，我可悲的代码实现能力啊。</p>
<p><del>确实没有想到对偶问题</del></p>
<p>最好能 $300+$ 吧，最后洛谷 335 ，还不错。</p>
<p>不过最后题目我确实做不出来。</p>
<p>如果这场比赛广东有超过 $8$ 人AK估计我就可以宣告退役了。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>CF774 Div.2 赛后总结</title>
    <url>/2025/02/03/CF774-Div-2-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/contest/1646">Dashboard - Codeforces Round #774 (Div. 2) - Codeforces</a></p>
<p>好耶，AK了。</p>
<p>总算是AK了一场div2</p>
<p>开局好巧不巧，电脑卡了，重启，撞更新了，结果赛后五分钟才进去。</p>
<p>最后剩五分钟惊险AK。</p>
<p>刚开始状态极差，大概在 E 题 AC 的时候状态慢慢上来了。</p>
<p>最后 F 题半小时 AC 也多亏了状态上来。</p>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>十分显然的结论：答案为 $\frac{s}{n^2}$</p>
<p>但是这难道不是多解吗？</p>
<p>可以发现没有 $n^2$ 拉满也就 $n^2-1$ ，所以 $n^2$ 的值一定是 $n^2$ 贡献的。</p>
<p><a href="https://codeforces.com/contest/1646/submission/148308492">Submission #148308492 - Codeforces</a></p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>排序+前缀和判定。</p>
<p><a href="https://codeforces.com/contest/1646/submission/148315665">Submission #148315665 - Codeforces</a></p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>暴力判断，当时发现二进制可以直接统计 $1$ 的个数判定，所以考虑 DFS 减阶乘。</p>
<p>一副能过得样子，就直接写了，之后发现其实这个的复杂度是确定的。</p>
<p>设 $top$ 是阶乘的上界，那么时间复杂度就是：$O(T2^{top}\log{n})$ ，经测试 $top=14$ ，搭配小常数和 CF 优秀的机子，跑的飞快，事实上算一下就会发现这个复杂度完全能过，只要常数不是特别爆炸。</p>
<p><a href="https://codeforces.com/contest/1646/submission/148330270">Submission #148330270 - Codeforces</a></p>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>可以发现除了 $n=2$ 不会出现两个相邻的满足要求的点。</p>
<p>$n=2$ 特判，$n≠2$ 的话，只要两个满足要求的点不相邻就是合法的，不满足要求的点值等于 $1$ 就行了。</p>
<p>然后树形 DP 搞定。</p>
<p><a href="https://codeforces.com/contest/1646/submission/148366316">Submission #148366316 - Codeforces</a></p>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>怎么说呢，会做了又不完全会做，专门恶心我这种不用纸想题，想题又只想个大概的人的。</p>
<p>交出了三记罚时，被迫赛事写了个暴力，来辅助调试和想出正解。</p>
<p>首先我看到的第一眼，先来个质因数分解：$\prod p_{i}^{a_{i}}$</p>
<p>设 $k$ 为 $a$ 的最大公因数，$mind$ 为 $k$ 的最小质因子，那么这个数字的贡献是 $m-\frac{m}{mind}$ 。（分数向下取整）</p>
<p>因为我想的是对于 $x^{k<em>i}=x^{\frac{k}{mind}</em>i<em>mind}$ ，结果 WA4 了，再写了暴力之后，我发现我目光还是狭隘了，事实上不仅 $k$ 能给 $i$ 因子， $i$ 也能给 $k$ 因子，他们甚至能交换因子，比如：$2^{3</em>2}=2^{2*3}$</p>
<p>也就是说不止要考虑 $k$ 的因子，还要考虑交换。</p>
<p>当时着实让我有点难受，当然，也不至于太难受，可以发现，当 $k=1$ 的时候贡献一定是 $m$ 的，因为数字没有交换的筹码了，而且因为交换因子只能从 $k$ 中调入调出，所以实际上一个数字的贡献是由 $k$ 决定的，不由这个数字的质因子决定。</p>
<p>设 $dp[i]$ 表示一个数字的 $k=i$ 时其的贡献，那么这个可以直接 $O(m\log{n})$ 遍历 $m$ 求出。（交换因子是什么花里胡哨的说法，还是暴力来的实在）</p>
<p>然后就做完了，$O((n+m)\log{n})$ ，但这道题目我还是有值得反思的地方的，至少从我罚时了三发以及刚开始做法假了的情况来看，我做这道题的经历绝对不能说是优秀的，还需要改进，下次还需要注意，这是应该进步的地方。</p>
<p><a href="https://codeforces.com/contest/1646/submission/148360488">Submission #148360488 - Codeforces</a></p>
<p>赛后看QQ群，发现复杂度可以脱离 $m$ 的束缚？</p>
<p>然后思考了一下，容斥应该就可以了。</p>
<p>具体的说对于幂次 $x$ ，如果对于 $i$ 存在 $j≤m$ 使得 $ij=x$ ，那么说 $i$ 对 $x$ 满足要求。</p>
<p>可以发现，如果 $i,j$ 都对 $x$ 满足，那么 $lcm(i,j)$ 也对 $x$ 满足，这是容斥的正确性保证。</p>
<p>我们的时间复杂度瓶颈在求 $dp$ 数组，考虑优化，容斥求出，经典新手向容斥。</p>
<p>假设我们现在要求出 $dp[x]$ ，设对 $y$ 满足要求且小于等于 $x$ 的数组为 $a$ ，大小为 $len$ 。（默认升序排序、 $x$ 对 $y$ 满足要求）</p>
<p>如果 $len=1$ 则会对 $dp[x]$ 产生贡献，否则不会。</p>
<p>不难发现，直接上个容斥，一个子集只对最大元素贡献即可，正确性显然，如果实在要证明，拿上面的 $a$ 数组手操就会发现不符合要求的会被容斥掉，即可证明。</p>
<p>时间复杂度：$O(n\log{n})$ ，加个线性筛可以优化到 $O(n\log{\log{n}})$ （辗转相除法的复杂度），预处理 $\log$ 以内的 $gcd$ 可以 $O(n)$ 解决。</p>
<p><del>具体复杂度由实现决定</del></p>
<p>当然，没有代码，仅限口胡，口胡真快乐。</p>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p>这道题目是真的NB啊。</p>
<p>一开始想直接暴力模拟构造，于是开始找规律，但是发现这种情况难以处理：</p>
<p>1 2 3</p>
<p>1 2 3</p>
<p>2 1 3</p>
<p>于是另辟途径，突然发现如果按下面方式构造出结果只需要 $\frac{n(n-1)}{2}$ 次。</p>
<p>1 1 1</p>
<p>2 2 2</p>
<p>3 3 3</p>
<p>这个 $\frac{n(n-1)}{2}$ 以及这个方式看起来就十分的可做，于是我便认为这应该就是正解的其中一步，事实上当时也就半小时时间了，这是我十几分钟思考中比较有用的成果，也只能用这个了。</p>
<p>但是关键是怎么构造出这个样子呢？</p>
<p>感觉这个题目的操作杂乱无章，找规律暴力构造应该是不太行了，应该需要思考一个量和操作绑定，证明操作数上界是 $\frac{n(n-1)}{2}$ 的。</p>
<p>于是过了不久想到一个值：每种数字按照最优策略分布，每个数字离最终所在位置的距离和。</p>
<p>比如：如果 $1$ 都在 $1$ 号柱子，最终肯定是要每个柱子都有一个 $1$ ，所以是 $\frac{n(n-1)}{2}$ 的。</p>
<p>对于任意一种局面怎么求这个呢？</p>
<p>考虑 $a$ 数组，表示某种数字 $x$ 在某个柱子上的数量，$b$ 是 bool 数组。</p>
<p>求的方法就是每次找到一个 $a[i]&gt;0$ 的位置 $i$ ，向右走到第一个 $b[j]=0$ 的位置，然后 $a[i]—,b[j]=1$ ，同时加上往右走的次数。</p>
<p>这个为什么是对的呢，而且找的 $i$ 顺序不同不会影响结果吗？存在 $i,i+1$ （证明后面给出），使得往右走的过程中不可能从 $i$ 走到 $i+1$ ，断开，转成序列问题，这个时候结果就显然了。为什么要保证 $j$ 是往右走到的第一个呢？不仅是为了保证最优策略（可以证明不劣于不这样做），也是为了能支持断开的这个性质。（不劣于说明可能存在多个形式不同的最优策略）</p>
<p>而且不难看出这个数值的上界是 $\frac{n^2(n-1)}{2}$ 。</p>
<p>那么如何一次操作削掉 $n$ 个数值呢？</p>
<p>随便找到一对 $i,j$ ，满足第 $i$ 个柱子有至少两个 $j$ ，不断往右运 $j$ ，直到没有 $j$ 的柱子，因为没有 $j$ ，所以存在另外一个数字是有两个的，继续运，知道没有或者等于 $i$ 。</p>
<p>可以发现，这样可以稳定使数值减 $n$ ，所以总操作次数：$n(n-1)$ ，可以通过。</p>
<p>时间复杂度：$O(n^4)$，直接每个柱子维护大于 $1$ 个数的数字可以做到 $O(n^3)$ ，但没有必要。</p>
<p><a href="https://codeforces.com/contest/1646/submission/148380191">Submission #148380191 - Codeforces</a></p>
<p>当然，赛时肯定是没想这么多的，感觉对就直接用了QMQ。</p>
<p>证明：</p>
<p>将所有位置的 $a$ 减减，随便选择一个位置断开成序列，然后跑前缀和，问题可以转化成证明存在一个位置断开使得所有前缀和非负，断开后跑前缀和，找到第一个负数位置前缀和，从后面一个位置断开，可以证明该过程一定会停下来。</p>
<p>再证明一下为什么该策略一定是最优策略：</p>
<p>首先过程一个抽象成另外一个过程：</p>
<ol>
<li>选择一个 $a[i]&gt;0$ 的位置 $i$ ，再随便选择一个空的坑位，可以发现任何策略都可以通过这种方式选出。</li>
<li>证明每一次选择选择右边第一个空的坑位不劣于其余选择，因此最优策略一定会出在经过调整过的选择策略中。</li>
<li>利用上面的证明证明这种决策的所有情况最终结果相同，所以是经过调整后的选择策略选出来的一定是最优策略。</li>
</ol>
<p>当然，这个证明赛后补的，本来不打算补的，但是觉得这个问题十分的经典，就补了。</p>
<p>证明的时候有一种错觉，不需要证明最优策略，只需要证明操作上界即可，但是后面想想，发现不太对，其实确实可以不证明最优策略，但是一定要证明这种选择最终跑出来的操作一定要是一样的，不然选择不同的 $i$ 操作数不同就搞笑了。</p>
<p>顺便最后说个性质，从过程中看，操作数一定是 $n$ 的倍数。</p>
<p>总结一下，就是发现了局面 $B$ 可以以 $\frac{n(n-1)}{2}$ 的代价变成所求局面 $A$ ，然后通过和操作数绑定证明了某种策略可以以 $\frac{n(n-1)}{2}$ 的代价变成局面 $B$ ，最终以 $n*(n-1)$ 的代价通过此题。</p>
<p>不错的构造题，十分的妙。</p>
<p>不过最高兴的事情还是：我上 2300+ 了，好耶。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>Cola</title>
    <url>/2024/01/29/Cola/</url>
    <content><![CDATA[<p>题目链接：<a href="https://contest.ucup.ac/contest/1499/problem/8171">https://contest.ucup.ac/contest/1499/problem/8171</a></p>
<p>题目大意： $A$ 手里有个排列，$B$ 能问 $A$ 一个排列，如果排列完全匹配上，那就 $B$ 胜利，否则 $A$ 回答前 $x$ 个位置都是正确的，$x+1$ 的位置是错误的，如果 $m$ 次询问 $B$ 没有胜利就 $A$ 胜利。问 $B$ 在最优决策下， $A$ 随机拿到一个排列时 $B$ 的获胜概率。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然要对所有排列计数，而 $B$ 的最优策略就是变 $x+1$ 的位置，然后后面的位置从小到大排序（反正是随机拿一个排列，后面的部分随便一个都行，不会影响答案，从小到大好计数）。</p>
<p>所以问题等价于，有多少个 $n-1$ 的序列 $a$ ，满足：</p>
<p>$0\le a_i\le i,\sum\limits_{i=1}^{n-1}a_i\le m-1$ 。</p>
<p>那么等价于求：$[x^{m-1}]\frac{\prod\limits_{i=1}^{n-1}(1-x^i)}{(1-x)^{n+1}}$ ，但是注意到 $m\le n$ .</p>
<p>所以又等价于求： $[x^{m-1}]\frac{\prod\limits_{i=1}^{\infty}(1-x^i)}{(1-x)^{n+1}}$</p>
<p>分母是经典的高维前缀和，可以用组合意义快速计算 $x^i$ 的系数，分子是五边形数定理，直接算就行了。</p>
<p>时空复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e7</span>+<span class="number">5</span>;</span><br><span class="line">LL fc[N],nfc[N];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(LL x,LL y)</span></span>&#123;<span class="keyword">return</span> fc[x]*nfc[y]%mod*nfc[x-y]%mod;&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);n--;m--;</span><br><span class="line">    <span class="keyword">if</span>(!n)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nfc[<span class="number">0</span>]=nfc[<span class="number">1</span>]=fc[<span class="number">0</span>]=fc[<span class="number">1</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n+n+<span class="number">1</span>;i++)nfc[i]=(mod-mod/i)*nfc[mod%i]%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n+n+<span class="number">1</span>;i++)nfc[i]=nfc[i<span class="number">-1</span>]*nfc[i]%mod,fc[i]=fc[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=i*(<span class="number">3</span>*i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;m)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>)ans=(ans+(mod<span class="number">-1</span>)*<span class="built_in">C</span>(n+<span class="number">1</span>+m-x,n+<span class="number">1</span>))%mod;</span><br><span class="line">        <span class="keyword">else</span> ans=(ans+<span class="built_in">C</span>(n+<span class="number">1</span>+m-x,n+<span class="number">1</span>))%mod;</span><br><span class="line">        x=i*(<span class="number">3</span>*i+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;m || !i)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>)ans=(ans+(mod<span class="number">-1</span>)*<span class="built_in">C</span>(n+<span class="number">1</span>+m-x,n+<span class="number">1</span>))%mod;</span><br><span class="line">        <span class="keyword">else</span> ans=(ans+<span class="built_in">C</span>(n+<span class="number">1</span>+m-x,n+<span class="number">1</span>))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans*nfc[n+<span class="number">1</span>]%mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>组合意义</tag>
        <tag>五边形数定理</tag>
      </tags>
  </entry>
  <entry>
    <title>ECNU 2023.8 C. Kaleidoscope</title>
    <url>/2023/09/02/ECNU-2023-8-C-Kaleidoscope/</url>
    <content><![CDATA[<p>题目链接：<a href="https://acm.ecnu.edu.cn/contest/695/problem/C/">https://acm.ecnu.edu.cn/contest/695/problem/C/</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>我是状压 DP 做的，不难发现，我们可以把这一行被上一行占用的位置保存下来，然后转移。</p>
<p>显然如果 $x$ 转移到 $y$ ，那么 $x\And y=0$ ，而这是一个经典的 trick ，这样子转移的复杂度是 $O(3^m)$ 的，所以最终时间复杂度就是：$O(n3^m)$ 。</p>
<p>不过看题解说其实有效转移 $&lt;6000$ ？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 310</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 160</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">26</span>],len,fa;</span><br><span class="line">&#125;tr[N];<span class="type">int</span> tot,last;</span><br><span class="line"><span class="type">char</span> st[M];<span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=last;<span class="type">int</span> np=last=++tot;</span><br><span class="line">    tr[np].len=tr[p].len+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;p &amp;&amp; !tr[p].a[c];p=tr[p].fa)tr[p].a[c]=np;</span><br><span class="line">    <span class="keyword">if</span>(!p)tr[np].fa=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> q=tr[p].a[c];</span><br><span class="line">        <span class="keyword">if</span>(tr[q].len==tr[p].len+<span class="number">1</span>)tr[np].fa=q;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> nq=++tot;</span><br><span class="line">            tr[nq].fa=tr[q].fa;tr[q].fa=nq;</span><br><span class="line">            tr[nq].len=tr[p].len+<span class="number">1</span>;<span class="built_in">memcpy</span>(tr[nq].a,tr[q].a,<span class="built_in">sizeof</span>(tr[q].a));</span><br><span class="line">            tr[np].fa=nq;</span><br><span class="line">            <span class="keyword">for</span>(;p &amp;&amp; tr[p].a[c]==q;p=tr[p].fa)tr[p].a[c]=nq;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> dp[N][M][M];</span><br><span class="line"><span class="type">int</span> m,X;<span class="type">char</span> ans[M];<span class="type">int</span> fuck;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getval</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fucklen)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fucklen;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[x].a[ans[i]-<span class="string">&#x27;a&#x27;</span>])x=tr[x].a[ans[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">else</span> x=tr[<span class="number">1</span>].a[ans[i]-<span class="string">&#x27;a&#x27;</span>],cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> v[<span class="number">40</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fuck!=m)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=tot;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="built_in">getval</span>(i,fuck);</span><br><span class="line">            <span class="keyword">if</span>(x&lt;=X &amp;&amp; dp[i][m-fuck][X-x+<span class="number">1</span>])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">getval</span>(tr[<span class="number">1</span>].a[ans[m]-<span class="string">&#x27;a&#x27;</span>],m<span class="number">-1</span>)==X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;X);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">        tot=last=<span class="number">1</span>;<span class="built_in">memset</span>(tr,<span class="number">0</span>,<span class="built_in">sizeof</span>(tr));<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="built_in">sizeof</span>(v));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+i&lt;=n;i++)<span class="built_in">swap</span>(st[i],st[n-i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">add</span>(st[i]-<span class="string">&#x27;a&#x27;</span>),v[st[i]-<span class="string">&#x27;a&#x27;</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// for(int i=1;i&lt;=tot;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     printf(&quot;%d %d\n&quot;,tr[i].fa,tr[i].len);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">25</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[<span class="number">1</span>].a[i])dp[tr[<span class="number">1</span>].a[i]][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=tot;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=i &amp;&amp; t&lt;=X;t++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!dp[j][i][t])<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// if(i==1 &amp;&amp; j==5 &amp;&amp; t==1)printf(&quot;OK\n&quot;);</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">25</span>;k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(tr[j].a[k])dp[tr[j].a[k]][i+<span class="number">1</span>][t]=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(tr[<span class="number">1</span>].a[k] &amp;&amp; t&lt;X)dp[tr[<span class="number">1</span>].a[k]][i+<span class="number">1</span>][t+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for(int i=1;i&lt;=tot;i++)printf(&quot;%d:%d %d\n&quot;,i,tr[i].len,tr[i].fa);</span></span><br><span class="line">        <span class="comment">// printf(&quot;%d %d %d\n&quot;,dp[4][2][1],tr[5].a[0],dp[5][1][1]);</span></span><br><span class="line">        <span class="type">bool</span> bk=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)bk|=dp[i][m][X];</span><br><span class="line">        <span class="keyword">if</span>(!bk)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)<span class="built_in">memset</span>(dp[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(dp[i]));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ans[1]=ans[2]=&#x27;a&#x27;;printf(&quot;%d\n&quot;,getval(5,2));</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            fuck=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">25</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!v[j])<span class="keyword">continue</span>;</span><br><span class="line">                ans[i]=j+<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">work</span>()==<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[m+<span class="number">1</span>]=<span class="string">&#x27;\0&#x27;</span>;<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,ans+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)<span class="built_in">memset</span>(dp[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(dp[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>官方做法：</p>
<p>可以发现 $(i,j)$ 至多从 $(i-1,j-1)$ 转移过来，所以可以直接轮廓线 DP ，保存所有需要位置的状态就行了。</p>
<p>时间复杂度：$O(nm2^m)$ 。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>经典trick</tag>
        <tag>状压dp</tag>
        <tag>轮廓线dp</tag>
      </tags>
  </entry>
  <entry>
    <title>ECNU 2023.8 B. Bare Minimum Difference</title>
    <url>/2023/09/02/ECNU-2023-8-B-Bare-Minimum-Difference/</url>
    <content><![CDATA[<p>题目链接：<a href="https://acm.ecnu.edu.cn/contest/695/problem/B/">https://acm.ecnu.edu.cn/contest/695/problem/B/</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>题弱智但我也弱智，看错题了，以为要求方案数，乐，而且还以为会有负数。</p>
<p>我的做法是枚举 $n^2$ 个下界，然后 DP 维护最小上界，时间复杂度：$O(n^4)$。</p>
<p>然而看了题解后发现如果二分上界的话实际上可以配合滑动窗口之类的东西做到 $O(n)$ check 。</p>
<p>所以最优秀的时间复杂度是：$o(n^3\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 110</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">999999999</span>;</span><br><span class="line"><span class="type">int</span> a[N],n,dp[N],b[N],m;</span><br><span class="line"><span class="type">int</span> ans=inf;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> type=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> limit)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)b[i]+=b[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">20</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">// if(type)printf(&quot;OK %d\n&quot;,limit);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b[i]-b[j]&lt;limit)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;<span class="built_in">max</span>(dp[j],b[i]-b[j]))dp[i]=<span class="built_in">max</span>(b[i]-b[j],dp[j]);</span><br><span class="line">            <span class="comment">// if(type==1 &amp;&amp; i==3 &amp;&amp; j==0)printf(&quot;%d\n&quot;,dp[i]);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if(type==1)printf(&quot;%d\n&quot;,dp[m]);</span></span><br><span class="line">    <span class="keyword">return</span> dp[m];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// type=0;</span></span><br><span class="line"></span><br><span class="line">            sum+=a[j];<span class="keyword">if</span>(i==<span class="number">1</span> &amp;&amp; j==n)<span class="keyword">continue</span>;</span><br><span class="line">            m=i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;i;k++)b[k]=a[k];</span><br><span class="line">            <span class="type">int</span> now=<span class="built_in">solve</span>(sum);</span><br><span class="line">            m=n-j;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=j+<span class="number">1</span>;k&lt;=n;k++)b[k-j]=a[k];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if(i==1 &amp;&amp; j==3)type=1;</span></span><br><span class="line">            <span class="comment">// else type=0;</span></span><br><span class="line"></span><br><span class="line">            now=<span class="built_in">max</span>(<span class="built_in">solve</span>(sum),now);</span><br><span class="line">            <span class="comment">// if(i==1 &amp;&amp; j==3)printf(&quot;%d\n&quot;,now);</span></span><br><span class="line">            ans=<span class="built_in">min</span>(now-sum,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>Exact Subsequences</title>
    <url>/2024/06/26/Exact-Subsequences/</url>
    <content><![CDATA[<p>题目链接：<a href="https://qoj.ac/problem/6351">https://qoj.ac/problem/6351</a></p>
<p>题目大意：问你内恰有 $n$ 个本质不同子序列的且字典序排名为 $k$ 的 $01$ 串是啥。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>非常 amazing 的一道题目。</p>
<p>首先想想对于一个 $01$ 串怎么求本质不同的 $01$ 串个数，因为我记得之前队友做过一道这样的题目，做法是万能欧几里得。</p>
<p>设 $f_0$ 表示添加 $0$ 后变成新的子序列的串，$f_1$ 同理。</p>
<p>初始时 $f_0=f_1=1$ ，可以发现，转移就是：</p>
<p>$f_0=f_0+f_1$ （添加 $1$）</p>
<p>$f_1=f_0+f_1$ （添加 $0$）</p>
<p>而子序列个数恰好等于 $f_0+f_1-2$ 。</p>
<p>可以发现，这个过程是 gcd 的逆过程（把取模的过程看成一个个减的过程），因此顺过来看，$f_0$ 必须满足和 $n+2$ 互质，即任意一个本质不同字串个数等于 $n+2$ 的串对应一个与 $n+2$ 互素的数字，而 $01$ 串其实就是其 gcd 的过程。（因此无解就是 $&gt;\phi(n+2)$）</p>
<p>因此现在就是要找过程字典序第 $k$ 小的与 $n+2$ 互素的 $x$ 。</p>
<p>这怎么找呢？设数字为 $(x,y=n-x)$ （为了方便，后面都认为 $n=n+2$ ），不妨考虑逆着求本质不同子序列个数，这样来做一一对应，其过程就等价于这样的字符串：</p>
<p>从左到右，出现 $0$ 就 ：$y-x$ ，出现 $1$ 就 $x-y$ ，做完后 $x=y=1$ 。</p>
<p>注：这同时也证明了，对于一个 $01$ 串，拿着 $(1,1)$ 正着跑和倒着跑最后得到的 $x+y$ 的值是一样的。同时，在后面会频繁出现拿着 $(x,y)$ 跑一遍字符串这种话，一般情况下，如果 $x,y\le 1$ ，做的是加法的那种跑，否则是减法的那种跑。</p>
<p>这样就可以二分了，由于我们知道 $gcd$ 的过程中，$01$ 转化不会超过 $O(\log)$ 次，所以总时间复杂度为 $O(\log^2)$ 的。</p>
<p>由于具体过程中并不知道二分的上界，我选择倍增。</p>
<p>倍增是这样子倍增：$x’=ax-bn,y’=-cx+dn$ ，其中要求 $x’\ge 0, y’ \ge 0,x\ge 1$ ，从而得到初值 $x$ 的上界和下界，然后上界等于下界时，得到最终答案 $x$ 。</p>
<p>当我们想要确定 $0$ 的数量时，我们就设 $y’’=y’-kx’$ ，可以发现如果 $(x’,y’)$ 对应的区间为 $[l,r]$ ，那么 $(x’,y’’)$ 对应的区间为 $[l,r’]$ ，只要确保其中的数字够 $k$ 就行了。</p>
<p>$1$ 的数量类似，不过我们需要先计算出其是这个区间中字典序排名第几大的，相当于取个反。</p>
<p>感觉还是蛮有细节需要证明的，有些东西不会证明就直接判掉了。</p>
<p>细节 1 ：$\exist x\in[l,r]:gcd(x,n)=1,$ 且 $(x,n-x)$ 进行当前跑出来的 $01$ 串能够变成 $(1,0)/(0,1)/(1,1)$ 的必要条件是 $l=r$ 或者 $l=n-1,r=n$ 。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>$(1,1)$ ：</p></p>
<p>$ax-bn\ge0, -cx+dn\ge0$ 在取到特解 $x’$ 时满足：$ax-bn=1, -cx+dn=1$ 。</p>
<p>可以发现，上界 $\ge x’$ 。</p>
<p>$-c(x’+1)+dn=1-c$ ，当 $c&gt;1$ 时上界 $=x’$ ，否则此时 $c=1$，意味着 $d=1$ ，所以上界为 $n$ ，$x’=n-1$ ，又 $n\ge 3$ ，所以至少有一个 $1$ ，由下面的讨论知道 $l=n-1,r=n$ 。</p>
<p>$a(x’-1)-bn=1-a$ ，当 $a&gt;1$ 时下界 $&gt;x’-1$ 。</p>
<p>$a=1$ 意味着 $b=0$ ，所以过程是 $00000…$ ，这个时候可以发现下界为 $0$ ，故 $x’=1$ ，但又有额外要求：$x\ge 1$ ，所以此时区间中只有一个数字。</p>
<p>剩下的两个状态一定会经过 $(1,1)$ ，证毕。</p>
</div></details>
<p>细节 2 ：过程中的 $a,b,c,d$ 会不会爆 long long （一旦区间中只有一个数字就退出）。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>不难发现，我们可以将倍增过程中的减号全部变成加号，状态改成 $(ax+bn,cx+dn)$ ，不会影响 $a,b,c,d$ ，这样我们只要拿着 $(1,1)/(1,0)$ 倒着跑一遍就可以得到 $a,b,c,d$ 的精确值。</p>
<p>首先倍增过程中一致保持着 $[l,r]$ 中是有合法解的，因此区间中一旦只有两个数字，分为两种情况讨论：</p>
<ol>
<li>此时这个唯一的合法解超过 $(1,1)$ ，即恰好或者还没到，因此绝对 $\ge (1,1)$ 。注 ：我们认为 $(a,b)\ge(c,d)$ 等价于 $a\ge c,b\ge d$ ，直接拿着 $(1,1)$ 倒着跑，就可以得到范围 $\le n$ ，不会爆。</li>
<li><p>$(0,1)/(1,0)$ ，以 $(1,0)$ 举例，初始区间为 $[1,n]$ ，因此过程是非空的，又由于是区间长度一为 $1$ 我们就退出，我们先假设上一步中的区间不是 $[n-1,n]$ ，那么过程最后一个字符一定为 $0$ ，扔掉这个字符后的结果为 $(1,1)$ ，因此我们从左边拿着 $(1,1)$ 走完这个字符串得到的结果 $\le 2n$ 。</p>
<p>如果是 $[n-1,n]$，那么 $a=n,b=n-1,c=1,d=1$ ，在倍增一次后变成：$a=n,b=n-1,c=n+1,d=n$ ，直接退出，因此，范围还是在 $O(n)$ 的。</p>
</li>
</ol>
<p>综上，范围是在 $O(n)$ 的，不会爆 long long 。</p>
</div></details>
<p>其余小的细节就不再赘述了。</p>
<p>最终时间复杂度：$O(T\sqrt{n}\log^2n)$ 。（还要算区间中与 $n$ 互素的数字个数）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line">PLL <span class="keyword">operator</span>+(PLL x, PLL y)&#123;<span class="keyword">return</span> &#123;x.first + y.first, x.second + y.second&#125;;&#125;</span><br><span class="line">PLL <span class="keyword">operator</span>-(PLL x, PLL y)&#123;<span class="keyword">return</span> &#123;x.first - y.first, x.second - y.second&#125;;&#125;</span><br><span class="line">PLL <span class="keyword">operator</span>*(PLL x, LL y)&#123;<span class="keyword">return</span> &#123;x.first * y, x.second * y&#125;;&#125;</span><br><span class="line">PLL <span class="keyword">operator</span>*(LL x, PLL y)&#123;<span class="keyword">return</span> y * x;&#125;</span><br><span class="line"><span class="comment">//x.first * t + y.second * n</span></span><br><span class="line">LL n, K;</span><br><span class="line"><span class="function">PLL <span class="title">getrange</span><span class="params">(PLL l, PLL r)</span></span>&#123;<span class="keyword">return</span> &#123;<span class="built_in">max</span>((l.first - <span class="number">1</span> - l.second * n) / l.first, <span class="number">1ll</span>), - r.second * n / r.first&#125;;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printans</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    vector&lt;PLL&gt; ans;</span><br><span class="line">    LL y = n - x;</span><br><span class="line">    <span class="keyword">while</span>(x &gt; <span class="number">1</span> || y &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">assert</span>(x &amp;&amp; y);</span><br><span class="line">        <span class="keyword">if</span>(x &gt; y)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;<span class="number">1ll</span>, x / y&#125;);</span><br><span class="line">            x %= y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(&#123;<span class="number">0ll</span>, y / x&#125;);</span><br><span class="line">            y %= x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans.<span class="built_in">back</span>().second--;</span><br><span class="line">    cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (*ans.<span class="built_in">begin</span>()).first &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [d, cnt] : ans) cout &lt;&lt; cnt &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;LL&gt; p;</span><br><span class="line">vector&lt;LL&gt; fac;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    LL ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; fac.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(__builtin_popcount(i) &amp; <span class="number">1</span>) ans -= x / fac[i];</span><br><span class="line">        <span class="keyword">else</span> ans += x / fac[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(LL l, LL r)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">query</span>(r) - <span class="built_in">query</span>(l - <span class="number">1</span>);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p.<span class="built_in">clear</span>();</span><br><span class="line">    fac.<span class="built_in">clear</span>();</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; K;</span><br><span class="line">    n += <span class="number">2</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        LL now = n;</span><br><span class="line">        <span class="keyword">for</span>(LL i = <span class="number">2</span>; i * i &lt;= now; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(now % i != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            p.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">while</span>(now % i == <span class="number">0</span>) now /= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(now &gt; <span class="number">1ll</span>) p.<span class="built_in">push_back</span>(now);</span><br><span class="line">        fac.<span class="built_in">push_back</span>(<span class="number">1ll</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : p)&#123;</span><br><span class="line">            <span class="type">int</span> pre = fac.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; pre; i++) fac.<span class="built_in">push_back</span>(fac[i] * x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">query</span>(<span class="number">1</span>, n) &lt; K)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    PLL left, right;</span><br><span class="line">    left = &#123;<span class="number">1ll</span>, <span class="number">0ll</span>&#125;;</span><br><span class="line">    right = &#123;<span class="number">-1ll</span>, <span class="number">1ll</span>&#125;;</span><br><span class="line">    <span class="type">int</span> type = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">auto</span> [l1, r1] = <span class="built_in">getrange</span>(left, right);</span><br><span class="line">        <span class="keyword">if</span>(l1 == r1) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(!type)&#123;<span class="comment">//determine 0 cnt</span></span><br><span class="line">            LL k;</span><br><span class="line">            <span class="keyword">for</span>(LL k = <span class="number">1ll</span>;;k *= <span class="number">2</span>)&#123;</span><br><span class="line">                PLL nex = right - left * k;</span><br><span class="line">                <span class="keyword">auto</span> [l2, r2] = <span class="built_in">getrange</span>(left, nex);</span><br><span class="line">                <span class="keyword">if</span>(l2 &gt; r2 || <span class="built_in">query</span>(l1, r2) &lt; K) <span class="keyword">break</span>;</span><br><span class="line">                right = nex;</span><br><span class="line">                <span class="keyword">if</span>(l2 == r2) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(; k; k /= <span class="number">2</span>)&#123;</span><br><span class="line">                PLL nex = right - left * k;</span><br><span class="line">                <span class="keyword">auto</span> [l2, r2] = <span class="built_in">getrange</span>(left, nex);</span><br><span class="line">                <span class="keyword">if</span>(l2 &gt; r2 || <span class="built_in">query</span>(l1, r2) &lt; K) <span class="keyword">continue</span>;</span><br><span class="line">                right = nex;</span><br><span class="line">                <span class="keyword">if</span>(l2 == r2) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            LL k;</span><br><span class="line">            <span class="keyword">for</span>(k = <span class="number">1ll</span>;;k *= <span class="number">2</span>)&#123;</span><br><span class="line">                PLL nex = left - right * k;</span><br><span class="line">                <span class="keyword">auto</span> [l2, r2] = <span class="built_in">getrange</span>(nex, right);</span><br><span class="line">                <span class="keyword">if</span>(l2 &gt; r2 || <span class="built_in">query</span>(l2, r1) &lt; K) <span class="keyword">break</span>;</span><br><span class="line">                left = nex;</span><br><span class="line">                <span class="keyword">if</span>(l2 == r2) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(; k; k /= <span class="number">2</span>)&#123;</span><br><span class="line">                PLL nex = left - right * k;</span><br><span class="line">                <span class="keyword">auto</span> [l2, r2] = <span class="built_in">getrange</span>(nex, right);</span><br><span class="line">                <span class="keyword">if</span>(l2 &gt; r2 || <span class="built_in">query</span>(l2, r1) &lt; K) <span class="keyword">continue</span>;</span><br><span class="line">                left = nex;</span><br><span class="line">                <span class="keyword">if</span>(l2 == r2) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> [l2, r2] = <span class="built_in">getrange</span>(left, right);</span><br><span class="line">        K = <span class="built_in">query</span>(l2, r2) - K + <span class="number">1</span>;</span><br><span class="line">        type ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printans</span>(<span class="built_in">getrange</span>(left, right).first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感觉我的做法有点麻烦了，看看正解。</p></div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方做法</summary><div class="toggle-content"><p>在除了实现以外的部分基本一样，但最后还是唐了，终究逃不出唐的魔爪。</p>
<p>注意到一个事情，我们在二分 $0$ 的个数的时候，上界向下，这启示我们 $x$ 越小字典序越小。</p>
<p>$1$ 的个数的时候，下界网上，这启示我们 $x$ 越大字典序越大。</p>
<p>这两件事综合起来就可以证明：$x$ 的大小等价于字典序的大小。</p>
<p>事实上，也可以直接去证明，对于 $(x_1,y_1)/(x_2,y_2)\to (1,1)$ 的过程，如果 $x_1<x_2,y_1>y_2$ ，可以用归纳法加一些小讨论证明前者的过程要 $&lt;$ 后者的过程。（注意：$gcd(x_1,y_1)=1,gcd(x_2,y_2)=1$ ）</p>
<p>然后直接二分就行了。</p>
<p>完了，感觉自己唐完了。我记得我有过这个想法，但是在发现二分 $1$ 的时候 $1$ 下界是往上走时就觉得错完了，但是忘记下界往上走对应 $1$ 的个数更多，对应字典序越大，实际上是对完了，结果就是我唐完了。</p>
<p>真是艹了，这样确实好写多了，不过我也懒得再写一遍了。</p>
<p>时间复杂度 ：$O(T\sqrt{n}\log{n})$ 。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title>ECNU 2023.8 D. Mutton string</title>
    <url>/2023/09/02/ECNU-2023-8-D-Mutton-string/</url>
    <content><![CDATA[<p>题目链接：<a href="https://acm.ecnu.edu.cn/contest/695/problem/D/">https://acm.ecnu.edu.cn/contest/695/problem/D/</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>引理 $1$ ：优先加入符合要求的最长子串。（把后一个子串的前缀拿过来显然不劣）</p>
<p>到这里其实就差不多了，子串显然能够想到那个算法：SAM 。</p>
<p>如果给你一个字符串，怎么求出其的最小操作数呢？显然是拉上 SAM 上跑一遍，现在要我们确定一个最小操作数为 $x$ 的字符串，显然也是在 SAM 上 DP 一下就行了。</p>
<p>如果没有字典序的约束，这道题目就是：$dp[i][j]<a href="bool">k</a>$ 表示是否存在一个方案满足终止位置 SAM 上的第 $i$ 个节点，目前长度为 $j$ ，已经有了 $k$ 段，然后直接转移就行了。</p>
<p>但是因为我赛时分析错了复杂度，以为是四次方的，就没有往下接着想了，但实际上是三次方的。</p>
<p>显然时间复杂度是：$O(26nmx)$ ，而且如果实现的足够精妙能够到达 $O(nmx)$ ，因为考虑固定 $j,k$ ，这样对于 $i$ 的转移分两种，跑存在的边（ SAM 边的数量级是 $O(n)$ 的），跑不存在的边（可以状压，也可以调整搜索顺序，优先跑 $26$ ，然后去找可行且不能到达的状态（因此需要提前把可行的状态记录一下））。</p>
<p>但是如果要求字典序最小的字符串呢？</p>
<p>显然，我们必须要查询对于一个前缀，是否存在满足要求的答案，为此，我们不妨考虑整个字符串是倒着加子串的，然后把 $A$ 翻转，反着跑一遍 $DP$ ，然后枚举刚好跑到前缀时位于哪个点，然后继续扔到后缀数组上跑，看看能否凑出一个 $X$ 段出来。</p>
<p>时间复杂度：$O(26nmx)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 310</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 160</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">26</span>],len,fa;</span><br><span class="line">&#125;tr[N];<span class="type">int</span> tot,last;</span><br><span class="line"><span class="type">char</span> st[M];<span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=last;<span class="type">int</span> np=last=++tot;</span><br><span class="line">    tr[np].len=tr[p].len+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;p &amp;&amp; !tr[p].a[c];p=tr[p].fa)tr[p].a[c]=np;</span><br><span class="line">    <span class="keyword">if</span>(!p)tr[np].fa=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> q=tr[p].a[c];</span><br><span class="line">        <span class="keyword">if</span>(tr[q].len==tr[p].len+<span class="number">1</span>)tr[np].fa=q;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> nq=++tot;</span><br><span class="line">            tr[nq].fa=tr[q].fa;tr[q].fa=nq;</span><br><span class="line">            tr[nq].len=tr[p].len+<span class="number">1</span>;<span class="built_in">memcpy</span>(tr[nq].a,tr[q].a,<span class="built_in">sizeof</span>(tr[q].a));</span><br><span class="line">            tr[np].fa=nq;</span><br><span class="line">            <span class="keyword">for</span>(;p &amp;&amp; tr[p].a[c]==q;p=tr[p].fa)tr[p].a[c]=nq;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> dp[N][M][M];</span><br><span class="line"><span class="type">int</span> m,X;<span class="type">char</span> ans[M];<span class="type">int</span> fuck;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getval</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fucklen)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=fucklen;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tr[x].a[ans[i]-<span class="string">&#x27;a&#x27;</span>])x=tr[x].a[ans[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">else</span> x=tr[<span class="number">1</span>].a[ans[i]-<span class="string">&#x27;a&#x27;</span>],cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> v[<span class="number">40</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fuck!=m)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=tot;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="built_in">getval</span>(i,fuck);</span><br><span class="line">            <span class="keyword">if</span>(x&lt;=X &amp;&amp; dp[i][m-fuck][X-x+<span class="number">1</span>])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">getval</span>(tr[<span class="number">1</span>].a[ans[m]-<span class="string">&#x27;a&#x27;</span>],m<span class="number">-1</span>)==X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;X);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">        tot=last=<span class="number">1</span>;<span class="built_in">memset</span>(tr,<span class="number">0</span>,<span class="built_in">sizeof</span>(tr));<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="built_in">sizeof</span>(v));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+i&lt;=n;i++)<span class="built_in">swap</span>(st[i],st[n-i+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">add</span>(st[i]-<span class="string">&#x27;a&#x27;</span>),v[st[i]-<span class="string">&#x27;a&#x27;</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// for(int i=1;i&lt;=tot;i++)&#123;</span></span><br><span class="line">        <span class="comment">//     printf(&quot;%d %d\n&quot;,tr[i].fa,tr[i].len);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">25</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tr[<span class="number">1</span>].a[i])dp[tr[<span class="number">1</span>].a[i]][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=tot;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=i &amp;&amp; t&lt;=X;t++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!dp[j][i][t])<span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// if(i==1 &amp;&amp; j==5 &amp;&amp; t==1)printf(&quot;OK\n&quot;);</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">25</span>;k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(tr[j].a[k])dp[tr[j].a[k]][i+<span class="number">1</span>][t]=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(tr[<span class="number">1</span>].a[k] &amp;&amp; t&lt;X)dp[tr[<span class="number">1</span>].a[k]][i+<span class="number">1</span>][t+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for(int i=1;i&lt;=tot;i++)printf(&quot;%d:%d %d\n&quot;,i,tr[i].len,tr[i].fa);</span></span><br><span class="line">        <span class="comment">// printf(&quot;%d %d %d\n&quot;,dp[4][2][1],tr[5].a[0],dp[5][1][1]);</span></span><br><span class="line">        <span class="type">bool</span> bk=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)bk|=dp[i][m][X];</span><br><span class="line">        <span class="keyword">if</span>(!bk)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)<span class="built_in">memset</span>(dp[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(dp[i]));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ans[1]=ans[2]=&#x27;a&#x27;;printf(&quot;%d\n&quot;,getval(5,2));</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            fuck=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">25</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!v[j])<span class="keyword">continue</span>;</span><br><span class="line">                ans[i]=j+<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">work</span>()==<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[m+<span class="number">1</span>]=<span class="string">&#x27;\0&#x27;</span>;<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,ans+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)<span class="built_in">memset</span>(dp[i],<span class="number">0</span>,<span class="built_in">sizeof</span>(dp[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>官方做法：</p>
<p>不得不说这应该是经典 trick 但是我忘了，在遇到 DP + 字符串 + 字典序最小就应该马上意识过来才对。</p>
<p>简单来说，用 BFS 更新 DP 状态，这样只要更新出了最终状态那么这条更新路径就是答案，而且不止最终状态，准确来说对于每个状态其的更新路径都是字典序最小的路径。（那这样是不是 DFS 也可以啊，只要加个记忆化就行了，本质应该是一样的）</p>
<p>原因：队列中对于两个长度相等的状态，一定满足更新路径字典序小的在前面，大的在后面，同时只要前面符合这种情况，后面也一定符合这种情况，想想就知道了，挺有意思的，</p>
<hr>
<p>队友的做法：</p>
<p>赛后讨论了一下，他的做法是正着做，反过来标记每个状态如果要到达最终状态的最优决策是什么（实际上只要处理出能否到达最终状态就行了），然后在正着处理出答案。</p>
<p><del>然而，我突然发现，实际上倒着跑就可以只跑两遍了，先倒着跑一遍 DP ，处理出每个位置的最优，然后正着跑出结果就行了。</del> (错误原因：一个点可能有多个点走同一个字符的边转移过来，因此无法在常数的时间判断出来哪个是最优决策)</p>
<hr>
<p>同机房同学的做法：</p>
<p>非常的有意思，我只能说不愧是他，A不了，但是可以看一下。</p>
<p>观察发现实际上会出问题当且仅当某个子串的下一个位置和下一个子串的首位置相等，所以一个操作次数 $≥2$ 的子串的某个前缀一定是由一个子串+某个字符构成的（且这个前缀不是一个子串），不妨考虑处理出所有这样的字符串（最多 $26n^2$ 个），然后排序，可以发现，这样的字符串具有一个性质，不存在一个字符串是另外一个字符串的前缀，这个性质后面有用。</p>
<p>然后设 $f[i][j][k]$ 表示长度为 $j$ ，首字母为 $i$ ，最小操作次数为 $k$ 的最小字典序的字符串（其实也不需要保留字符串，保留转移就行了）。</p>
<p>这样，转移的时候只需要从小到达遍历前面那个字符串，能转移就转移，不难发现这就是最优的决策。</p>
<p>但是仔细计算一下复杂度是 $O(26^2nmx)$ ，非常遗憾不能通过此题，但是我个人感觉这个思想非常的有意思，所以就把它给记录下来了，而且也很有启示意义，就是很多时候可以尝试一下脱离算法思考，可以发现这个方法并不依赖任何字符串算法，却得到了一个非常有意思的方法（这个老哥就是这个想法的忠实拥护者，不怎么学算法，坚信大部分题目都是可以用思维解决，所以他的思维就非常的厉害）。</p>
<hr>
<p>听说同机房还有基于字典树和 bitset 优化的四方做法过了，厉害厉害。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>经典trick</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title>Game of Connect(Shannon&#39;s Switching Game)</title>
    <url>/2024/01/31/Game-of-Connect-Shannon-s-Switching-Game/</url>
    <content><![CDATA[<p>题目链接：<a href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3792">https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=3792</a></p>
<p>题目大意：给一张图，先手先选定两个不同的点 $A,B$ ，然后开始游戏，每轮先手指定一个未固定的边删掉，后手指定一个没被固定的边固定，如果 $A,B$ 最后联通，则后手获胜，否则先手获胜，问后手是否必胜。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>这道题目非常经典，又叫：Shannon’s Switching Game。</p>
<p>又有个变体问题：没有指定 $A,B$ 了，后手的目的是最后要是个联通图。</p>
<p>这两个问题的后手必胜的充要条件是：图中有两个交集为 $0$ 的生成树。</p>
<p>对于变体问题的充分性是比较好证明的，采用归纳+缩边的方法就行，详情请看：<a href="https://zhuanlan.zhihu.com/p/33862629">https://zhuanlan.zhihu.com/p/33862629</a> 。</p>
<p>也可以用拟阵中的基进行证明，这里不再赘述。</p>
<p>但是必要性我不会证明，所以这道题目在此留一个坑，就此作罢。</p>
<h6 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h6><p>学会 Shannon’s Switching Game 。</p>
<p>知道这个判定条件后后面就好搞了，怎么判定呢？</p>
<p>要有个生成树，且在这个生成树外还有一个生成树，前者是图拟阵，后者是图拟阵的对偶拟阵，所以就是图拟阵与图拟阵的对偶拟阵的拟阵交。</p>
<p>时间复杂度：$O(Tm^3)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">没有，不会证明，懒得写代码了。</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>拟阵</tag>
      </tags>
  </entry>
  <entry>
    <title>FHQ-正反弧ETT学习笔记</title>
    <url>/2025/02/03/FHQ-%E6%AD%A3%E5%8F%8D%E5%BC%A7ETT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前在学 2018 国家集训队的某篇论文时，举步为艰，怪自己太高傲自大，选了个比较难的论文，哎。</p>
<p>当然，除了自大，还有一个原因，里面的不少题目和算法都找不到，哎，所以那个时候和同学一起学论文，我的收获是最小的QAQ，可能也是现在我菜的原因之一吧。</p>
<p>但是呢！！！</p>
<p>在洛谷日报，我发现了之前没发现的东西， ETT ！！！</p>
<p>但是后来发现原来还是伪 ETT ，不禁十分失落，但是又又又突然发现评论区竟然有位神仙有写这方面的博客，叫 jerry3128，写了篇ETT的博客，而且不是伪的。后来又发现其还有好几篇高端的数据结构博客（这位神犇是啃发明者论文自己钻研写出来的），深深的折服了我，让我对他愈加敬佩，这就是数据结构带师吗，NB。（虽然我没想明白头像能代表什么 XP ）</p>
<p>回归正题，目前没学会 LCT-ETT ，只学了 FHQ - 正反弧 ETT ，为什么呢，因为不考，所以只是当成一种休闲娱乐吧。（毕竟学算法确实比做题学文化课轻松多了）</p>
<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><p>一个能够维护区间的数据结构。（我才用简单易懂FHQ）</p>
<p>有一定动态树基础最好。</p>
<p>欧拉环游序：普通 DFS 序只在访问时记录，但是欧拉环游序在访问到节点以及访问完一个儿子回溯时都会记录，即一棵树的一条边记左右端点，同时根节点开始记一次。（当然，在后文请忽略根节点开始记一次这一句话，相当于欧拉环游序只剩下了 $2(n-1)$ 个点）</p>
<p><img src="1.png" alt=""></p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>给 $n$ 个点，需要你支持连边，删边，查询两点是否联通，保证连边后图仍然为森林。</p>
<h1 id="算法粗略讲解"><a href="#算法粗略讲解" class="headerlink" title="算法粗略讲解"></a>算法粗略讲解</h1><p>ETT是什么，据说只要是用数据结构维护欧拉环游序，就可以叫做ETT，全称 Euler - Tour - Tree。</p>
<h2 id="正反弧"><a href="#正反弧" class="headerlink" title="正反弧"></a>正反弧</h2><p>拿上面那张图距离，欧拉环游序为  2 4 2 1 4 1 。</p>
<p>我们需要储存一个点在环游序中的下标，但是一个点可能会出现多次怎么办？观察到一条边会将其两个端点全部记录一遍，因此我们可以开个 $map$ 数组，$map[x][y]$ 表示对于 $x-y$ 这条边，当从 $x$ 遍历到 $y$ 时，$y$ 记录在数组中的下标，比如 $map[1][2]=1,map[4][2]=3$ 。</p>
<p>不过准确来说不能叫下标，为什么，因为这只是针对欧拉环游序不会变的情况，这可是动态树，随时都会变，难道改一次全部改坐标？我们给环游序每个位置给予一个新编号，存的不是下标，而是这个编号。</p>
<p> 看不懂往下看就完了。</p>
<h2 id="FHQ维护环游序"><a href="#FHQ维护环游序" class="headerlink" title="FHQ维护环游序"></a>FHQ维护环游序</h2><p>我们用FHQ维护欧拉环游序，FHQ最大的好处就是处理区间异常方便。</p>
<p>回收上面的话，我们在维护欧拉环游序时每个位置会在FHQ中有个作为结点的编号，进行区间操作，即使欧拉环游序位置变了，但是在FHQ中对应的节点编号不会改变，而 $map$ 存的就是这个编号。</p>
<p>回归正题，如何维护呢？</p>
<h3 id="换根"><a href="#换根" class="headerlink" title="换根"></a>换根</h3><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.luogu.com.cn/blog/user27338/">jerry3128的博客</a></p>
<p>与jerry3128的私信</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>ETT</tag>
      </tags>
  </entry>
  <entry>
    <title>Grand Prix of Urals 赛后小结</title>
    <url>/2024/07/19/Grand-Prix-of-Urals-%E8%B5%9B%E5%90%8E%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://qoj.ac/contest/975?v=1">https://qoj.ac/contest/975?v=1</a></p>
<p>开头 A, L, G 三道签到题，很快的过了。</p>
<p>后面 I 又不知道被谁秒了。</p>
<p>然后是 M ，我想的是用数据结构维护，但是感觉怎么写怎么难写，后面 imakf 下机后跟他交流了一下，他给出了一种更加好写的写法，直接遍历，然后括号就是调整遍历的顺序（从左到右或者从右到左），也就是在 $()$ 里面的话，遍历顺序转一下（引用群友的一句话：为啥我就想不到呢。恼，这样确实好些多了）。</p>
<p>感觉能这样做一个很关键的原因是翻转操作是嵌套的，没有相交不包含的情况，学到了。</p>
<p>后面 C 被队长秒了，做法是类似可持久化，每次 fuse 就新建一个节点，指向那两个拼起来的节点，太对了。</p>
<p>后面的 B 和队长交流了下，后面队长开始口胡，我听着听着发现他的做法讨论一下就对了，然后讨论了下上机过了。</p>
<p>下机后想了想 D ，发现 $n^2$ 可能没有特殊含义，只是方便分解质因数，又有 $(x+y)(x^2-xy+y^2)=x^3+y^3$ ，所以枚举 $x+y$ ，然后二次函数求解就行了。</p>
<p>队长上去秒了 F 。</p>
<p>然后开始进入超长待机，我开始玩 K ，队长写 J ，imakf 写 E ，玩得太入迷了，其实没怎么注意发生了什么，只知道出题人卡空间。</p>
<p>最后在结束前半个小时，E J 过了，我声称我写不出来了，队长上去 try H ，失败了，最后 20 min 我上去写暴力，结果发现小范围很快跑出解了，在赛后 20 min 过了此题。</p>
<p>反思一下我的问题：</p>
<ol>
<li>首先我高估了代码复杂度，其实 K 想清楚有可能半个小时写出来。</li>
<li><p>其次我 K 的做法其实在剩一个半小时的时候就给出来了，后面其实贡献基本为 $0$ ，一直没玩出来小范围的解，同时也没给出其余好的搞法，其实我确实应该想想暴力怎么写，上去要 15 min 的机时，显然有暴力和没暴力玩这道题目是两回事，而且如果直接过了收益很高，没过这个暴力在后面魔改一下也能尝试别的做法，而且如果是一时半会跑不出解的，更能多挂一会，说不定出解了，总之，多出来的这些选择都是需要写暴力才有的，15 min 的机时就能换回这么多东西，我认为是血赚的，至少我认为 15 min 机时换我手玩暴力的时间绝对是血赚的，感觉我在手玩暴力的时间其实和挂机没有区别，而且写了暴力最后通过 K 的概率直线上升，真得写暴力吧，而且中间队友也红了，他们的机上效率也没有拉满，让他们下来冷静一下也合理。</p>
<p>所以真得上机写个暴力吧，我感觉我没要还有一个原因就是我压根没觉得能过 K ，恐惧了，给吓到了。只能说不尝试怎么知道，没有梦想怎能成功。</p>
</li>
</ol>
<p>我对机时的理解还是太差了，队长来肯定就直接赶人了。</p>
<p>队长伟大，无需多言。</p>
<p>这里放一下 K 的某个可行做法：</p>
<p>首先队长给出观察：穿越可以让你原路返回，所以只需要找哈密顿路径。（当时不觉得这关键，但是最后成了关键一步，队长伟大，无需多言）</p>
<p>然后开始手玩的过程中，开始想把问题规模缩小，发现没法完美缩小，因此尝试在加一些限制的情况下缩小（即缩小后的问题是比原题更加强的问题），然后又注意到只看一个棋子的话，马的行走路径非常的 shit ，玩的非常痛苦。</p>
<p>突然注意到 $2*2$ 的矩阵移动是非常方便的：</p>
<p><img src="1.png" alt=""></p>
<p>所以通过 $2*2$ 的矩阵的移动，可以轻松构造出 $4$ 条路径，希望能用这 $4$ 条路径走遍大部分的格子，然后剩下的一小部分格子直接暴力。</p>
<p>显然的，希望这四条路径起终点在 $m*m$ 的网格内，而且外面的点都被经过了，$m$ 很小。</p>
<p>但发现好像不镜像的话，完成这个事情有点苦难，于是用到了队长的话，我们不妨只考虑遍历完外面的点，然后镜像原路返回，那么起点就是四个格子，终点就是这四个格子的镜像，子问题是要求在这 $m<em>m</em>2-4$ 的格子内存在哈密顿路径，且必须经过这四个格子跑到镜像的这条边（这条边就是前面四条路径的压缩）。</p>
<p>遍历方式：</p>
<p><img src="2.png" alt=""></p>
<p>每次都从一个矩形右下角的 $2*2$ 矩形出发，出去扫一圈，两个角落的移动要特殊处理一下，因为 $(1,1),(n,n)$ 被 ban 了，所以所有的圈扫一起来都要在这两个对应的角落特殊处理一下。</p>
<p>最后停在 $n*n$ 矩形的左下角，镜像跑回来就行了。</p>
<p>当 $m=4,6$ 的时候，子问题很快就跑出解了，然后就做完了。</p>
<p>时间复杂度：$O(nm+\mathrm{暴力时间})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> array&lt;<span class="type">int</span>, 3&gt; AI;</span><br><span class="line"><span class="type">int</span> lx, ly;</span><br><span class="line"><span class="type">int</span> id[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">vector&lt;PII&gt; path[<span class="number">4</span>];</span><br><span class="line">vector&lt;AI&gt; ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gid</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> x * <span class="number">2</span> + y;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gid</span><span class="params">(PII x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">gid</span>(x.first, x.second);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t == <span class="number">0</span>)&#123; <span class="comment">//up</span></span><br><span class="line">		path[id[<span class="number">1</span>][<span class="number">0</span>]].<span class="built_in">push_back</span>(&#123;lx - <span class="number">1</span>, ly + <span class="number">1</span>&#125;);</span><br><span class="line">		path[id[<span class="number">1</span>][<span class="number">1</span>]].<span class="built_in">push_back</span>(&#123;lx - <span class="number">1</span>, ly&#125;);</span><br><span class="line">		<span class="built_in">swap</span>(id[<span class="number">1</span>][<span class="number">0</span>], id[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">swap</span>(id[<span class="number">0</span>][<span class="number">0</span>], id[<span class="number">1</span>][<span class="number">0</span>]); <span class="built_in">swap</span>(id[<span class="number">0</span>][<span class="number">1</span>], id[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">		lx--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(t == <span class="number">1</span>)&#123; <span class="comment">// right</span></span><br><span class="line">		path[id[<span class="number">0</span>][<span class="number">0</span>]].<span class="built_in">push_back</span>(&#123;lx + <span class="number">1</span>, ly + <span class="number">2</span>&#125;);</span><br><span class="line">		path[id[<span class="number">1</span>][<span class="number">0</span>]].<span class="built_in">push_back</span>(&#123;lx, ly + <span class="number">2</span>&#125;);</span><br><span class="line">		<span class="built_in">swap</span>(id[<span class="number">0</span>][<span class="number">0</span>], id[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">swap</span>(id[<span class="number">0</span>][<span class="number">0</span>], id[<span class="number">0</span>][<span class="number">1</span>]); <span class="built_in">swap</span>(id[<span class="number">1</span>][<span class="number">0</span>], id[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">		ly++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(t == <span class="number">2</span>)&#123; <span class="comment">// down</span></span><br><span class="line">		path[id[<span class="number">0</span>][<span class="number">0</span>]].<span class="built_in">push_back</span>(&#123;lx + <span class="number">2</span>, ly + <span class="number">1</span>&#125;);</span><br><span class="line">		path[id[<span class="number">0</span>][<span class="number">1</span>]].<span class="built_in">push_back</span>(&#123;lx + <span class="number">2</span>, ly&#125;);</span><br><span class="line">		<span class="built_in">swap</span>(id[<span class="number">0</span>][<span class="number">0</span>], id[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">swap</span>(id[<span class="number">0</span>][<span class="number">0</span>], id[<span class="number">1</span>][<span class="number">0</span>]); <span class="built_in">swap</span>(id[<span class="number">0</span>][<span class="number">1</span>], id[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">		lx++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(t == <span class="number">3</span>)&#123; <span class="comment">// left</span></span><br><span class="line">		path[id[<span class="number">0</span>][<span class="number">1</span>]].<span class="built_in">push_back</span>(&#123;lx + <span class="number">1</span>, ly - <span class="number">1</span>&#125;);</span><br><span class="line">		path[id[<span class="number">1</span>][<span class="number">1</span>]].<span class="built_in">push_back</span>(&#123;lx, ly - <span class="number">1</span>&#125;);</span><br><span class="line">		<span class="built_in">swap</span>(id[<span class="number">0</span>][<span class="number">1</span>], id[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">		<span class="built_in">swap</span>(id[<span class="number">0</span>][<span class="number">0</span>], id[<span class="number">0</span>][<span class="number">1</span>]); <span class="built_in">swap</span>(id[<span class="number">1</span>][<span class="number">0</span>], id[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">		ly--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> MinS&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> N2 = <span class="number">15</span>;</span><br><span class="line">	<span class="type">int</span> v[N2][N2][<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> dx[] = &#123;<span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">	<span class="type">int</span> dy[] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-2</span>&#125;;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> dep, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">		v[x][y][t] = dep;</span><br><span class="line">		<span class="keyword">if</span>(dep == n * n * <span class="number">2</span> - <span class="number">4</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">abs</span>(x - <span class="number">1</span>) == <span class="number">2</span> &amp;&amp; <span class="built_in">abs</span>(y - <span class="number">1</span>) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">abs</span>(x - <span class="number">1</span>) == <span class="number">1</span> &amp;&amp; <span class="built_in">abs</span>(y - <span class="number">1</span>) == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			v[x][y][t] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!v[x][y][t ^ <span class="number">1</span>])&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">dfs</span>(dep + <span class="number">1</span>, x, y, t ^ <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(x &lt;= <span class="number">2</span> &amp;&amp; y &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">				v[x][y][t] = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">7</span>; k++)&#123;</span><br><span class="line">			<span class="type">int</span> tx = x + dx[k], ty = y + dy[k];</span><br><span class="line">			<span class="keyword">if</span>(tx &gt;= <span class="number">1</span> &amp;&amp; ty &gt;= <span class="number">1</span> &amp;&amp; tx &lt;= n &amp;&amp; ty &lt;= n &amp;&amp; !v[tx][ty][t])&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">dfs</span>(dep + <span class="number">1</span>, tx, ty, t)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		v[x][y][t] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> S, <span class="type">int</span> base)</span></span>&#123;</span><br><span class="line">		n = S;</span><br><span class="line">		v[n][<span class="number">1</span>][<span class="number">0</span>] = v[n][<span class="number">1</span>][<span class="number">1</span>] = v[<span class="number">1</span>][n][<span class="number">0</span>] = v[<span class="number">1</span>][n][<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">		<span class="built_in">assert</span>(<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n * n * <span class="number">2</span> - <span class="number">4</span>; k++)&#123;</span><br><span class="line">			<span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> tt = <span class="number">0</span>; tt &lt;= <span class="number">1</span>; tt++)&#123;</span><br><span class="line">						<span class="keyword">if</span>(v[i][j][tt] == k)&#123;</span><br><span class="line">							x = i;</span><br><span class="line">							y = j;</span><br><span class="line">							t = tt;</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span>(x) <span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(x) <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ans.<span class="built_in">push_back</span>(&#123;x + base, y + base, t&#125;);</span><br><span class="line">			<span class="keyword">if</span>(x &lt;= <span class="number">2</span> &amp;&amp; y &lt;= <span class="number">2</span> &amp;&amp; v[x][y][t ^ <span class="number">1</span>] == v[x][y][t] + <span class="number">1</span>)&#123;</span><br><span class="line">				<span class="type">int</span> id = <span class="built_in">gid</span>(x - <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">auto</span> [xx, yy] : path[id]) ans.<span class="built_in">push_back</span>(&#123;xx, yy, t&#125;);</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">auto</span> i = path[id].<span class="built_in">rbegin</span>(); i != path[id].<span class="built_in">rend</span>(); i++)&#123;</span><br><span class="line">					<span class="keyword">auto</span> [xx, yy] = (*i);</span><br><span class="line">					ans.<span class="built_in">push_back</span>(&#123;xx, yy, t ^ <span class="number">1</span>&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">1</span>; j++) id[i][j] = <span class="built_in">gid</span>(i, j);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> f = <span class="number">4</span>;</span><br><span class="line">	<span class="keyword">if</span>(n % <span class="number">4</span> == <span class="number">2</span>) f = <span class="number">6</span>;</span><br><span class="line">	lx = ly = (n - f) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = (n - f) / <span class="number">4</span>, sz = f + <span class="number">4</span>; i &gt;= <span class="number">1</span>; i--, sz += <span class="number">4</span>)&#123;</span><br><span class="line">		<span class="built_in">move</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">move</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">5</span>; j &lt; sz; j++) <span class="built_in">move</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">move</span>(<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">move</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">4</span>; j &lt;= sz; j++) <span class="built_in">move</span>(<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = sz - <span class="number">2</span>; j &gt; <span class="number">1</span>; j--) <span class="built_in">move</span>(<span class="number">3</span>);</span><br><span class="line">		<span class="built_in">move</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">move</span>(<span class="number">3</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = sz - <span class="number">3</span>; j &gt;= <span class="number">1</span>; j--) <span class="built_in">move</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	MinS::<span class="built_in">work</span>(f, (n - f) / <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">assert</span>(ans.<span class="built_in">size</span>() == n * n * <span class="number">2</span> - <span class="number">4</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> [x, y, t] : ans)&#123;</span><br><span class="line">		x = n - x + <span class="number">1</span>;</span><br><span class="line">		cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>H 认输，不会，先不说会不会，这种类型的题目我几乎就没有熟练度，非常的捞，你猜我为什么玩了一整场 K 。</p>
<p>所以我还有一个很严重的问题，真得多练 H 这种题吧，不可能每次都丢给队友吧，真得多练吧，加训！狠狠的加训！菜就多练。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>Line Painting(维护线段的线段树)</title>
    <url>/2025/02/03/Line-Painting-%E7%BB%B4%E6%8A%A4%E7%BA%BF%E6%AE%B5%E7%9A%84%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<h1 id="Line-Painting"><a href="#Line-Painting" class="headerlink" title="Line Painting"></a>Line Painting</h1><p><a href="https://acm.timus.ru/problem.aspx?space=1&amp;num=1019">1019. Line Painting @ Timus Online Judge</a></p>
<p>题目大意，给你一个线段，每次会在线段上一个区间染色（初始白色，染色黑白），然后最后问你最长的白色线段的两端在哪。</p>
<p>显然，线段长度初始 $10^9$ ，离散化一手，接下来该怎么做？</p>
<p>$5000$ ，直接暴力估计都可以直接搞了，不过这道题目放在数据结构当中应该是想让我们用线段树做，那就老老实实用线段树吧。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 31000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NN 61000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> lc,rc,co,d;</span><br><span class="line">&#125;tr[NN];<span class="type">int</span> len;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushlazy</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;tr[x].co=k;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[tr[x].lc].co==tr[tr[x].rc].co)tr[x].co=tr[tr[x].lc].co;</span><br><span class="line">	<span class="keyword">else</span> tr[x].co=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[x].co!=<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">pushlazy</span>(tr[x].lc,tr[x].co);</span><br><span class="line">		<span class="built_in">pushlazy</span>(tr[x].rc,tr[x].co);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> be[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bt</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=++len;tr[x].co=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l+<span class="number">1</span>&lt;r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		tr[x].lc=len+<span class="number">1</span>;<span class="built_in">bt</span>(l,mid);</span><br><span class="line">		tr[x].rc=len+<span class="number">1</span>;<span class="built_in">bt</span>(mid,r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ll,<span class="type">int</span> rr,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[x].co==k)<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span>(l==ll &amp;&amp; r==rr)&#123;<span class="built_in">pushlazy</span>(x,k);<span class="keyword">return</span> ;&#125;</span><br><span class="line">	<span class="built_in">pushdown</span>(x);</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(rr&lt;=mid)<span class="built_in">change</span>(tr[x].lc,l,mid,ll,rr,k);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(mid&lt;=ll)<span class="built_in">change</span>(tr[x].rc,mid,r,ll,rr,k);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">change</span>(tr[x].lc,l,mid,ll,mid,k),<span class="built_in">change</span>(tr[x].rc,mid,r,mid,rr,k);</span><br><span class="line">	<span class="built_in">updata</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ansl,ansr,suml,sumr;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">gen</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(be[sumr]-be[suml]&gt;be[ansr]-be[ansl])ansl=suml,ansr=sumr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[x].co==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">gen</span>();suml=sumr=r;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(tr[x].co==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sumr=r;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">Query</span>(tr[x].lc,l,mid);<span class="built_in">Query</span>(tr[x].rc,mid,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ll[N],rr[N],type[N],m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Lisan</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> *x,val;</span><br><span class="line">&#125;li[N];<span class="type">int</span> top,n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(Lisan x,Lisan y)</span></span>&#123;<span class="keyword">return</span> x.val&lt;y.val;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);m++;</span><br><span class="line">	ll[<span class="number">1</span>]=<span class="number">0</span>;rr[<span class="number">1</span>]=<span class="number">1e9</span>;type[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	li[++top].x=&amp;ll[<span class="number">1</span>];li[top].val=ll[<span class="number">1</span>];</span><br><span class="line">	li[++top].x=&amp;rr[<span class="number">1</span>];li[top].val=rr[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">char</span> st[<span class="number">10</span>];<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>,&amp;ll[i],&amp;rr[i],st+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(st[<span class="number">1</span>]==<span class="string">&#x27;b&#x27;</span>)type[i]=<span class="number">1</span>;</span><br><span class="line">		li[++top].x=&amp;ll[i];li[top].val=ll[i];</span><br><span class="line">		li[++top].x=&amp;rr[i];li[top].val=rr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(li+<span class="number">1</span>,li+top+<span class="number">1</span>,cmp);</span><br><span class="line">	n=*li[<span class="number">1</span>].x=<span class="number">1</span>;be[<span class="number">1</span>]=li[<span class="number">1</span>].val;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=top;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(li[i].val!=li[i<span class="number">-1</span>].val)n++,be[n]=li[i].val;</span><br><span class="line">		*li[i].x=n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">bt</span>(<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++)<span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,ll[i],rr[i],type[i]);</span><br><span class="line">	<span class="built_in">Query</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="built_in">gen</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,be[ansl],be[ansr]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下建立在线段区间上的线段树应该怎么写：</p>
<ol>
<li>线段树的端点直接维护的便是一段区间，区间长度为 $1$ 的点是叶子节点。</li>
<li>强行将线段上一个个长度为 $1$ 的区间看成点，然后像普通数组一样维护，至于点的编号可以采取左（右）端点的编号，或者用其余方法赋予编号，反正方法很多，看个人喜好，我个人喜欢直接采取左端点编号，简单好想好思考。</li>
</ol>
<p>当然，我个人推荐第一种。为什么，因为第一种离散化考虑起来比较方便，第二种就比较麻烦了。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>GDOI2021 爆零记</title>
    <url>/2025/02/05/GDOI2021-%E7%88%86%E9%9B%B6%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Day0"><a href="#Day0" class="headerlink" title="Day0"></a>Day0</h1><p>进到耀华的宿舍，这不比母校华丽:)，一看学费五位数，反复吃惊。</p>
<p>晚上快乐的打王者:)。</p>
<h1 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h1><p>早上早早的吃完饭，在教室外干等着。</p>
<p>一进去，看了眼题，T1十几分钟想到了二分的做法，但是觉得可以 $O(n)$，继续接着想，加上对拍，结果花了一个半小时，心态直接炸掉。</p>
<p>T2看了一眼，很快发现通过一种巧妙的方法把 $b$ 差分一下，就可以把每个格子用一个差分后的 $b$ 和三个 $a$ 表示出来。</p>
<p>然后就不会做了QAQ，嫩是拿着一坨不等式找规律找了半天也不会做，水过了三小时。</p>
<p>T3打爆力只有 $16$ 分，干脆就不打了，思考人生去了。</p>
<p>结果赛后听说T3暴力不止 $16$ 分QAQ。</p>
<p>晚上愤怒狼人杀┗|｀O′|┛，起跳预言家好多把┗|｀O′|┛。</p>
<h1 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h1><p>早晨跳了一把预言家，结果考试满脑子都是预言家….</p>
<p>T1 一看，马上想到了分块，花了三个小时码了个树上分块，结果大洋里开了O2还要2.9s ，基本没了QAQ，预估个60吧。</p>
<p>T2打了个玄学的状压，然后…，就没时间了？？？</p>
<p>最后十几分钟马上打了T3暴力。</p>
<p>最后一分钟怒合键盘，望着天花板发呆。</p>
<h1 id="赛后"><a href="#赛后" class="headerlink" title="赛后"></a>赛后</h1><p>好像同房奆佬ZWQ也有点爆炸，神犇CLB直接起飞了，肯定是机房最高分了，现在就等着ZFY请吃饭了QMQ，算是本蒟蒻爆零前的最后一丝安慰吧。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>Graffiti</title>
    <url>/2024/02/05/Graffiti/</url>
    <content><![CDATA[<p>题目链接：<a href="https://contest.ucup.ac/contest/1511/problem/8213">https://contest.ucup.ac/contest/1511/problem/8213</a></p>
<p>题目大意：</p>
<p>给一个树，给一个长度不超过 $3$ 的串，然后问：每个点填一个字母，最大化满足经过的点构成的字符串等于给定串的有向路径数量，输出数量。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然只有长度为 $3$ 的串需要思考，当只有两个不同的字母的时候，会发现如果使用 $dp[x][0/1]$ 的 dp 方式，会无法处理从 $x$ 的儿子的儿子，到 $x$ 的路径，所以我们需要再多添加一维，表示父亲填的字母，相当于提前知道了父亲填的字母，然后父亲在转移的时候直接调用就行了。</p>
<p>但是会发现我们仍然无法处理三个字母都不同的情况，因为儿子有三种选择。</p>
<p>但是注意到第一个字母和第三个字母并没有本质区别，将一个子树的第一个字母和第三个字母全部颠倒不会影响这个子树的贡献，所以也就只需要知道儿子应该选一/三字母或者第二个字母就行，排个序枚举一下就行了。</p>
<p>时间复杂度：$O(n\log{n})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN=<span class="number">6e5</span>+<span class="number">5</span>;</span><br><span class="line">LL dp[N][<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> ss[<span class="number">4</span>],n,m,C;<span class="type">char</span> st[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> vis[<span class="number">300</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y,next;</span><br><span class="line">&#125;a[NN];<span class="type">int</span> len,las[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;a[++len]=&#123;y,las[x]&#125;;las[x]=len;&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(m==<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> (x==ss[<span class="number">1</span>] &amp;&amp; y==ss[<span class="number">2</span>]) || (x==ss[<span class="number">2</span>] &amp;&amp; y==ss[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(m==<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> (x==ss[<span class="number">1</span>] &amp;&amp; y==ss[<span class="number">2</span>] &amp;&amp; z==ss[<span class="number">3</span>]) || (x==ss[<span class="number">3</span>] &amp;&amp; y==ss[<span class="number">2</span>] &amp;&amp; z==ss[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">count</span><span class="params">(LL c1,LL c2,<span class="type">int</span> fc)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(C&gt;<span class="number">1</span>);</span><br><span class="line">    LL tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(C==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">1</span>,ss[<span class="number">2</span>],<span class="number">1</span>)==<span class="number">1</span>)tmp+=c1*(c1<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// if(pd(2,ss[2],2)==1)tmp+=c2*(c2-1)/2; impossible</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">1</span>,ss[<span class="number">2</span>],<span class="number">2</span>)==<span class="number">1</span>)tmp+=c1*c2;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">1</span>,ss[<span class="number">2</span>],fc)==<span class="number">1</span>)tmp+=c1;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">2</span>,ss[<span class="number">2</span>],fc))tmp+=c2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fc==<span class="number">1</span> || fc==<span class="number">3</span>)&#123;</span><br><span class="line">            LL c3=(c1+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            tmp+=c3*(c1-c3)+c3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            LL c3=c1/<span class="number">2</span>;</span><br><span class="line">            tmp+=c3*(c1-c3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">LL sta[N];<span class="type">int</span> top;</span><br><span class="line">VI son[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=las[x];k;k=a[k].next)&#123;</span><br><span class="line">        <span class="type">int</span> y=a[k].y;<span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        son[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=C;i++)&#123;</span><br><span class="line">            LL now=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> y:son[x])&#123;</span><br><span class="line">                LL tmp=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=C;j++)&#123;</span><br><span class="line">                    tmp=<span class="built_in">max</span>(dp[y][i][j],tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                now+=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> fc=<span class="number">1</span>;fc&lt;=C;fc++)&#123;<span class="comment">//father color</span></span><br><span class="line">                <span class="keyword">if</span>(x!=<span class="number">1</span> &amp;&amp; <span class="built_in">pd</span>(i,fc))dp[x][fc][i]=now+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[x][fc][i]=now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//m=3</span></span><br><span class="line">        <span class="built_in">assert</span>(m==<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=C;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=ss[<span class="number">2</span>])&#123;<span class="comment">//only up</span></span><br><span class="line">                LL now=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> y:son[x])&#123;</span><br><span class="line">                    LL tmp=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=C;j++)&#123;</span><br><span class="line">                        tmp=<span class="built_in">max</span>(tmp,dp[y][i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    now+=tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> fc=<span class="number">1</span>;fc&lt;=C;fc++)&#123;<span class="comment">//father color</span></span><br><span class="line">                    dp[x][fc][i]=now;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(C==<span class="number">1</span>)&#123;</span><br><span class="line">                LL siz=son[x].<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> y:son[x]) dp[x][<span class="number">1</span>][<span class="number">1</span>]+=dp[y][<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">                dp[x][<span class="number">1</span>][<span class="number">1</span>]+=siz*(siz<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(x!=<span class="number">1</span>)dp[x][<span class="number">1</span>][<span class="number">1</span>]+=siz;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                top=<span class="number">0</span>;</span><br><span class="line">                LL ini=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> y:son[x])&#123;</span><br><span class="line">                    sta[++top]=dp[y][i][<span class="number">2</span>]-dp[y][i][<span class="number">1</span>];</span><br><span class="line">                    <span class="built_in">assert</span>(C!=<span class="number">3</span> || dp[y][i][<span class="number">1</span>]==dp[y][i][<span class="number">3</span>]);</span><br><span class="line">                    ini+=dp[y][i][<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">sort</span>(sta+<span class="number">1</span>,sta+top+<span class="number">1</span>,[](LL x,LL y)&#123;<span class="keyword">return</span> x&gt;y;&#125;);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> fc=<span class="number">1</span>;fc&lt;=C;fc++)&#123;</span><br><span class="line">                    LL now=<span class="number">0</span>,tmp=ini;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=top;j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(x!=<span class="number">1</span>)now=<span class="built_in">max</span>( now , tmp+<span class="built_in">count</span>(top-j,j,fc) );</span><br><span class="line">                        <span class="keyword">else</span> now=<span class="built_in">max</span>( now , tmp+<span class="built_in">count</span>(top-j,j,<span class="number">0</span>) );</span><br><span class="line">                        <span class="keyword">if</span>(j!=top) tmp+=sta[j+<span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[x][fc][i]=now;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);m=<span class="built_in">strlen</span>(st+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">ins</span>(x,y);<span class="built_in">ins</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[st[i]])vis[st[i]]=++C;</span><br><span class="line">        ss[i]=vis[st[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span>)<span class="keyword">return</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=C;i++)ans=<span class="built_in">max</span>(ans,dp[<span class="number">1</span>][<span class="number">1</span>][i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ss[<span class="number">1</span>]==ss[m])ans*=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">work</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题外话：<br>其实这个 dp 设计非常有意思。</p>
<ol>
<li><p>从树的角度考虑，我们其实有另外一种设计思路是，多添加几维表示这个节点的每个颜色的儿子选了多少个，但是可以发现这种设计是显然会超时的。</p>
<p>这是因为一个节点的儿子数量可以很多，而父亲至多一个，因此，我们更希望通过父亲解决问题，而不是通过儿子。</p>
<p>一个类似的例子是：一个数据结构题目，每次能够给一个点周围的所有点的点权加上 $c$ ，做法为：父亲的点权直接加上，儿子的点权加在自己身上，等查询一个点点权的时候让他自己来问父亲。</p>
<p>当然，上面那个例子还有个单 log 做法，就是利用 BFS 序+线段树，因为 BFS 序上儿子的编号是连续的。</p>
</li>
<li><p>从预知未来的角度考虑：</p>
<p>每个点先预知未来的一些信息，在这道题目上的作用是，让我们能够处理了一些本来无法处理的信息。</p>
<p>当然也可以有其他作用，举个减少时间复杂度的例子（某一年提高组初赛的题目，忘记是哪一年了）：</p>
<h6 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h6><p>这道题目到底是哪一年的。</p>
<p>求长度恰好为 $k$ 且相邻数字的异或的和最大的子序列，输出最大的和，值域 $2^{8}-1$。</p>
<p>做法为 $dp[i][x][y]$ ，$i$ 是已经有几个数字，$x$ 表示子序列目前最后一个数字的上 $4$ 位，$y$ 表示我们期望下一个数字的下 $4$ 位是多少。</p>
<p>这样就能在 $O(n^2*2^4)$ 的复杂度处理这个问题，相较于 $dp[i][x]$ 少了 $2^4$ 。</p>
</li>
</ol>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Lyndon &amp; Runs 学习笔记</title>
    <url>/2024/08/11/Lyndon-Runs-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="概念定义与符号约定"><a href="#概念定义与符号约定" class="headerlink" title="概念定义与符号约定"></a>概念定义与符号约定</h1><p>字符串一般记大写字母 $S,A,B$ （下面的字符串基本都不能是空的，但还是请根据语境自行判断），空字符串用 $\emptyset$ ，确定的字符用字体 $\mathrm{abcde}$ 表示（基本不会在定理和证明中出现，只会在例子中出现），不定字符用小写字母 $xyz$ 表示。</p>
<p>对于字符串 $S$ ：</p>
<ul>
<li><strong>长度</strong>：$|S|$ ，有时候用 $n$ 代替。</li>
<li><strong>字符</strong>：$S[i]$ 表示字符串的第 $i$ 个字符，下标从 $1$ 开始。</li>
<li><strong>字符集</strong>：$\sum_{S}$</li>
<li><strong>子串</strong>：$s[l,r]$ 表示 $s[l]s[l+1]…s[r]$ 。</li>
<li><p><strong>前缀&amp;后缀</strong>：$S\langle i]=S[1,i]$，$S[i\rangle=S[i,n]$ 。</p>
<p>称一个前缀/后缀为严格的，单且仅当它≠原串 $S$ 。</p>
<p>记 $\mathrm{pre}(S)$ 为前缀集合，$\mathrm{suf}(S)$ 为后缀集合， $\mathrm{pre}’(S)$ 为严格前缀集合，$\mathrm{suf}’(S)$ 为严格后缀集合。</p>
</li>
<li><p><strong>出现位置</strong>：对于串 $t$ ，记：</p>
<p>$\mathrm{Beg}_{S}(t)$ 为 $t$ 在 $S$ 中所有出现位置的左端点集合。</p>
<p>$\mathrm{End}_{S}(t)$ 为 $t$ 在 $S$ 中所有出现位置的右端点集合。</p>
<p>对于区间集合 $L$ ，类似地记：</p>
<p>$\mathrm{Beg}(L)$ 为 $L$ 地左端点集合。</p>
<p>$\mathrm{End}(L)$ 为 $L$ 地右端点集合。</p>
</li>
<li><p><strong>字符串的拼接,幂</strong> ： 记 $st$ 。 $S\cdot t$ 为字符串 $S,t$ 顺次连接而得的串。</p>
<p>定义 ： $S^k=\overbrace{ss\ldots S}^{\text{共 k 个}}$ ，即 $S$ 重复 $k$ 次后形成的串。</p>
</li>
<li><p><strong>循环节 $\mathbf{period}$</strong>：若对于所有 $1\leq i\leq n-c$ ，均有$s_i=s_{i+c}$ ,则称 $c$ 是 $S$ 的一个循环节。</p>
<p>若 $c|n$ 则称$c$为整周期。</p>
<p>记 $\mathrm{period}(S)$ 为 $S$ 的循环节集合。</p>
</li>
<li><p><strong>Border</strong> : 若有 $S\langle i]=S[n-i+1\rangle\left(1\leq i&lt;n\right)$ （等于后缀的严格前缀） ，则称之为 $\mathrm{Border}$ ，简称为 $\mathrm{Bd}$ </p>
<p>记 $\mathrm{Bd}(S)$ 为 $S$ 的 Bd 集合。（ 注意 $S\not\in\operatorname{Bd}(S)$ ）</p>
<p>$\mathrm{Bd}$ 和 $\mathrm{period}$ 是一一对应的。其中，一个长度为 $k$ 的 $\mathrm{Bd}$ 对应一个长度为 $n-k$ 的循环节。</p>
</li>
<li>串 $S$ 的循环位移：$S$ 和 $\forall 1\le i&lt;|S|,S[i+1\rangle S\langle i]$ 所构成的字符串集合称为 $S$ 的循环位移。</li>
<li><p><strong>Lyndon Word</strong>: 若字符串 $S$ 的最小后缀是其本身，即 $S&lt;\mathrm{suf}^{\prime}(S)$ ,则称之为 $\mathrm{Lyndon Word},简称为 $\mathrm{Ly}$。</p>
<p>例：$abc,ababc$ 是 $\mathrm{Ly}$ ，而 $ba,acabc$ 不是。</p>
</li>
<li><strong>Lyndon 分解</strong> ：$L_1L_2,…,L_k$ 称为 $S$ 的 $\mathrm{Lyndon}$ 分解当且仅当：$L_i\ge L_{i+1}$ ，且 $L_{i}$ 是 $\mathrm{Ly}$ 。</li>
<li><p><strong>Runs</strong>: 三元组 $\mathbf{r}=(l,r,p)$ 是串 $S$ 的一个 $\mathrm{run}$ ,当且仅当：</p>
<ul>
<li>$S[l,r]$ 的最小循环节为 $p$ ，满足 $2p\leq\left|S[l, r]\right|=r-l+1$</li>
<li>该循环不能延伸，即 $S[l-1]\neq S[l+p-1],S[r+1]\neq S[r-p+1]$</li>
</ul>
<p>实数 $e_{\mathrm{r}}=\frac{r-l+1}p$ 被称为该 $\mathrm{run}$ 的指数记 $\mathrm{Runs}(S)$ 为 $S$ 的所有 $\mathrm{run}$ 构成的集合。$\rho_{\mathrm{run}}(n)$ 表示长度为 $n$ 的字符串中至多含有的 $\mathrm{run}$ 个数。$\sigma_{\mathrm{run}}(n)$ 表示长度为 $n$ 的字符串的 $\mathrm{run}$ 的指数和的最大值。</p>
</li>
<li>设 $sa[i]$ 表示在后缀排序中 ，排名第 $i$ 的后缀是 $S[sa[i]\rangle$ ，$rk[i]$ 表示 $S[i\rangle$ 的排名。</li>
</ul>
<p>上面的符号和定义部分使用了 command_block 博客的符号，这些符号有部分是他个人规定的，并不完全正规。</p>
<h1 id="字符串的基本性质"><a href="#字符串的基本性质" class="headerlink" title="字符串的基本性质"></a>字符串的基本性质</h1><p>字符串比较都认为虚空最小，在此基础上有两种视角，第一种：将比较的字符通过在末尾填虚空的方式，填到等长，比较。第二种是直接关于长度进行讨论。我个人喜欢第二种，至少目前是，个人感觉第一种只能用在比较简单的性质上，直观易懂，但第二种比较灵活。</p>
<p><strong>性质 1</strong> （字符串不等式的传递性）：若 $A&lt;B,B&lt;C$ ，则 $A&lt;C$ 。（换成非严格不等号一样）</p>
<p><strong>性质 2</strong> ： $A&lt;B$ 当且仅当 $CA&lt;CB$ 。（换成非严格不等号一样）</p>
<p><strong>性质 3</strong> ：若 $|A|=|B|$ ，且 $AC&lt;BD$ ，则 $A\le B$ 。</p>
<p><strong>性质 4</strong> ：若 $|A|\ge |B|$ ，$A&lt;B$ ，则 $AC&lt;B$ 。</p>
<p><strong>性质 5</strong> ：若 $A\ge B$ ，则对于所有的 $i$ 有 ：$A\langle i] \ge B\langle i]$ 。（假设 $|A|&lt;i$ ，则 $A\langle i]=A$ ，$B$ 同理）</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>两种情况讨论一下就行了：$B$ 是 $A$ 的前缀和 $B$ 不是 $A$ 的前缀（因为字符不同产生的 $&gt;$）。</p>
</div></details>
<h1 id="Lyndon-Word"><a href="#Lyndon-Word" class="headerlink" title="Lyndon Word"></a>Lyndon Word</h1><h2 id="重要的性质"><a href="#重要的性质" class="headerlink" title="重要的性质"></a>重要的性质</h2><p><strong>性质 1</strong> ： $\mathrm{Ly}$ 串 $S$ 没有 $\mathrm{Bd}$ 。</p>
<p><strong>性质 2</strong> ：一个串 $S$ 是 $\textrm{Ly}$ 当且仅当 $S$ 是 $S$ 的所有循环位移中严格唯一最小的一个。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>必要性：设 $S=AB$ ，故 $BA&gt;B&gt;AB$ ，证毕，</p>
<p>充分性：$AB<BA$ ，若 $|A|\ge |B|$ ，若 $B\notin \mathrm{pre}(A)$ ，则 $A<B$ ，则有 $AB<B$ ，否则 $A=BC$ （显然 $A≠B$ ，则有 $|A|>|B|$） ，则有 $BCB&lt;BBC$ ，又有：$CBB&lt;BCB$ ，但是根据假设有：$AB=BCB&lt;CBB$ ，矛盾。</p>
<p>若 $|A|&lt;|B|$ ，若 $A\notin\mathrm{pre}(B)$ ，同理 $AB&lt;B$ 。</p>
<p>否则设 $B=A^KC(k\ge 1)$ ，满足 $A\notin \mathrm{pre}(C)$ ，故有 $A^{k+1}C<CA^{k+1}$ ，重复上面的讨论可以证明：$C>A^{k+1}C=S$ ，若 $|C|\le |A|$ ，则有 $C&gt;A$ ，故有 $A^{k}C&gt;A^{k+1}$ ，故有 $B&gt;S$ ，否则 $|C|&gt;|A|$ ，则有 $C\langle i]&gt;A$ ，同理 $B&gt;S$ ，证毕。</p>
</div></details>
<p>推论 ：$S$ 的循环位移有严格唯一最小值当且仅当 $S$ 没有整周期。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>显然，$S$ 的循环位移同时有或没有整周期。</p>
<p>若有严格唯一最小值，设 $S’$ 为最小值，则 $S’$ 为 $\mathrm{Ly<br>}$ ，所以 $S’$ 无 $\mathrm{Bd}$ ，所以无整周期。</p>
<p>否则设 $S’$ 是其中一个最小值， $S’=AB$ ，其中 $BA$ 为另外一个最小值 ，则 $A,B$ 都是 $S’$ 的周期，故 $S’$ 有整周期 $(|A|,|B|)$ （最大公约数），证毕。</p>
<p>其实这个结论不用 Lyndong Word 也很好证明，证明 $S$ 在有整周期的情况下不可能有唯一最小值就行了。</p>
</div></details>
<p><strong>性质 3</strong> ： $\mathrm{Lyndon}$ 分解若存在，则唯一。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>设 $L_{1}L_{2}…L_{k}$ 和 $L’_{1}…L’_{m}$ 都是 $S$ 的 $\mathrm{Ly}$ 分解，不妨设 $|L_{1}|&lt;|L’_{1}|$ （否则考虑 $S’=L_{2}…L_{k}=L’_{2}…L’_{m}$）。</p>
<p>设 $t$ 为最小的满足：$L’_{1}\in \mathrm{pre}(L_{1}L_{2}…L_{t})$ ，设 $S=L_{t}\langle|L’_{1}|-\sum\limits_{i=1}^{t-1}|L_{i}|]$ ，$S\le L_{t}\le L_{1}&lt;L’_{1}$ ，但 $S&gt;L’_{1}$ ，矛盾，证毕。</p>
</div></details>
<p><strong>性质 4</strong> ：若 $A&lt;B$ ，且 $A,B$ 都是 $\mathrm{Ly}$ ，那么 $AB$ 是 $\mathrm{Ly}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>$\forall T\in \mathrm{suf}’(AB)$ ，若 $|T|&gt;|B|$ ，则有：$T\langle |T|-|B|]&gt;A$ ，则有：$T&gt;AB$ 。</p>
<p>若 $|T|\le |B|$ ，则有 $A&lt;B&lt;T$ ，证毕。</p>
</div></details>
<p><strong>性质 5</strong> ：$S$ 的 $\mathrm{Lyndon}$ 分解一定存在。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>$\forall 1\le i\le |S|,L_{i}=S_{i}$ 。</p>
<p>考虑调整，若 $L_{i}&gt;L_{i+1}$ ，则合并，直到没有为止，则为一组解，证毕。</p>
</div></details>
<p>推论：若 $L_{1}L_{2}…L_{k}=S$ ，$L_{i}$ 为 $\mathrm{Ly}$ ，设 $L’_{1}…L’_{t}$ 为 $S$ 的 $\mathrm{Lyndon}$ 分解 ，则存在 $0=a_{0}&lt;a_{1}&lt;a_{2}&lt;…&lt;a_{t}=k$ 满足：$L_{a_{i-1}+1}…L_{a_{i}}=L’_{i}$ 。</p>
<p>证明方法和性质 5 一样，在此不再赘述。</p>
<p>所以一个串 $S$ 的 $\mathrm{Lyndon}$ 分解存在且唯一。</p>
<p><strong>性质 6</strong> ：若 $S=L^kA$ 满足：$L$ 为 $\mathrm{Ly}$ ，$L^{k}\ge A$ ，则设 $L_{1}…L_{t}$ 为 $A$ 的 $\mathrm{Lyndon}$ 分解，则 $L^{k}L_{1}…L_{t}$ 为 $A$ 的 $\mathrm{Lyndon}$ 分解。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>反证法，如果 $L_{1} &gt; L$ ，那么如果 $|L_{1}|\le |L|$ ，那么有 $A&gt;L^{k}$ 矛盾。</p>
<p>否则若 $|L_{1}|&gt;L$ ，同理可得到 $L\in \mathrm{pre}(L_{1})$ （否则和上面的情况没区别），设 $L_{1}=L^{v}B$ ，$L\notin \mathrm{pre}(B)$ ，其中，根据 $L^{k}\ge A$ 以及 $L_{1}&gt;L$ ，$L$ 是个 $\mathrm{Ly}$ ，可以得到 $v&lt;k,B≠\emptyset$ 。</p>
<p>那么 $B\notin \mathrm{pre}(L)$ ，否则，不构成 $\mathrm{Ly}$ ，所以可以根据 $L_{k}\ge S$ 得到 $B&lt;L$ （由于字符不同产生的小于），所以 $B&lt;L_{1}$ ，矛盾，证毕。</p>
</div></details>
<p><strong>性质 7</strong> ：设 $i$ 是第一个 $rk_{i}&lt;rk_{1}$ 的数字，如果不存在， $i=|S|+1$ ，那么有 $L_{1}=S\langle i-1]$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>先证明 $S\langle i-1]$ 是 $\mathrm{Ly}$ ：</p>
<p>设 $1<j<i$ ，则有 $rk_{j}>rk_{1}$ ，则有 $S_{j,i-1}\ge S_{1,i-j}$ 。</p>
<p>若 $S_{j,i-1}=S_{1,i-j}$ ，则有 $rk_{i}&gt;rk_{i-j+1}&gt;rk_{1}$ ，矛盾，故 $S_{j,i-1}&gt;S_{1,i-j}$ ，故 $S_{j,i-1}&gt;S\langle i-1]$ ，证毕。</p>
<p>设 $A=S\langle i-1]$ ，$S=AB$ ，已知 $B&lt;AB$ ，若 $A&lt;B$ ，则有 $A\in\mathrm{pre}’(B)$ ，若 $S=A^{k}$ ，则显然 $L_{1}=A$ ，否则若 $S=A^{k}C$ ，即 $B=A^{k-1}C$ ，$A\notin \mathrm{pre}(C)$ ，则有 $C&lt;A&lt;A^{k}$ ，根据性质 $6$ 可以知道 $L_{1}=A$ 。</p>
<p>证毕。</p>
</div></details>
<p>这个性质可以用于在 $O(n\log{n})$ 的时间找到 $\mathrm{Lyndon}$ 分解，而且在求每个后缀的 $\mathrm{Lyndon}$ 分解的相关问题上有奇效。</p>
<p>可以用一个单调栈，从后往前跑出所有后缀的 $\mathrm{Lyndon}$ 分解。</p>
<p><strong>性质 8</strong> ：如果 $S$ 和字符 $x$ 满足 $Sx\in \mathrm{pre}(L)$ ，$L$ 是个 $\mathrm{Ly}$ ，那么 $\forall y&gt;x,Sx$ 是 $\mathrm{Ly}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>显然 ，$y&gt;S_{1}$ ，如果 $\exists 1&lt;i\le |S|:S[i\rangle y \le Sy$ ，那么 $S[i\rangle x&lt;S[i\rangle y\le Sy$ ，而且一定是因为字母比较产生的 $&lt;$ ，所以 $S[i\rangle x&lt;L$ ，矛盾。</p>
</div></details>
<p>推论：把 $L$ 改成 $L^{k}$ 仍然正确，因为在 $L^k$ 后面加上一个无限大字符后 ，得到的 $L’$ 仍然是 $\mathrm{Ly}$ 。</p>
<h2 id="Duval-算法"><a href="#Duval-算法" class="headerlink" title="Duval 算法"></a>Duval 算法</h2><p>定义 $T$ 为近似 $\mathrm{Ly}$ 当且仅当 $S=L^{k}\overline{L}$ ，其中 $\overline{L}=\mathrm{pre}’(L)$ ，$\overline{L}$ 可以为空。</p>
<p>整个算法采用增量的方式去找到 $\mathrm{Lyndon}$ 分解 。</p>
<p>假设 $S=L_{1}L_{2}…L_{k}T$ ，其中 $T$ 为近似 $\mathrm{Ly}$ ，$T=L^{t}\overline{L}$ 。（其中 $L_{i}$ 为已经确定的部分，可以不用管了）</p>
<p>假设现在加入字符 $c$ 。</p>
<ol>
<li>如果 $c=L_{|\overline{L}+1|}$ ，那么继续，扩展 $T$ 。</li>
<li>如果 $c&lt;L_{|\overline{L}+1|}$ ，那么根据上面的性质 $6$ ，可以知道 $L^{t}$ 可以扔出去了，然后剩下的部分继续处理。</li>
<li>如果 $c&gt;L_{|\overline{L}+1|}$ ，那么根据根据性质 $8$ 的推论可以知道 $Tc$ 此时是个 $\mathrm{Ly}$ ，更新 $T=L=Tc$ 。</li>
</ol>
<p>直到最后，如果 $\overline{L}=\emptyset$ ，则结束，否则 $L^t$ 扔出去，继续处理 $\overline{L}$ 。</p>
<p>下面代码中，$i=|L_{1}…L_{k}|+1,k=|L_{1}…L_{k}T|-|L|+1,j=|L_{1}…L_{k}T|+1$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;)&#123;</span><br><span class="line">    <span class="type">int</span> j = i + <span class="number">1</span>, k = i;</span><br><span class="line">    <span class="keyword">for</span>(; j &lt;= n &amp;&amp; st[k] &lt;= st[j]; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[k] &lt; st[j]) k = i;</span><br><span class="line">        <span class="keyword">else</span> k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt;= k; i += j - k) ;</span><br><span class="line">    <span class="comment">//[i,i+j-k)即为对应的Lyndon分解 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：注意到每层循环下来，$i$ 会加上 $\frac{j-i+1}{2}$ ，而内层每层循环 $j$ 会 $+1$ ，所以内层最多跑 $2n$ 次，外层每次 $i$ 至少 $+1$ ，所以至多跑 $n$ 次，所以总时间复杂度：$O(n)$ 。</p>
<p>相比起后缀数组求法，Duval 算法在求每个前缀的 $\mathrm{Lyndon}$ 分解的问题上有奇效。</p>
<p>UPD：这里补充一下所谓的已经完成的 $\mathrm{Ly}$ 的意思是什么，意思是 $\forall j\ge i$ ，$S\langle j]$ 的 $\mathrm{Lyndon}$ 分解都是 $S\langle i-1]$ 的分解拼接上 $S[i-1,j]$ 的分解，熟悉这个理解有助于后面理解求前缀最小/大后缀的做法。</p>
<h2 id="一些补充的性质"><a href="#一些补充的性质" class="headerlink" title="一些补充的性质"></a>一些补充的性质</h2><p>可以自己证证玩玩的性质。</p>
<p><strong>性质 9</strong> ：对于 $\mathrm{Ly}$ $A=BC$ ，由 $B&lt;C$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>$B&lt;BC&lt;C$</p>
</div></details>
<p><strong>性质 10</strong> ：$\mathrm{Ly}$ 串 $S$ 的任意子串 $S_{l,r}\ge S\langle r-l+1]$ ，且若 $r=|S|$ ，则改为严格不等号。</p>
<p>这个性质某种意义上很重要，它反映了 $\mathrm{Ly}$ 串的一个性质：在求字符串的最小解问题时，$\mathrm{Ly}$ 串往往作为一个整体存在。在后面的例题中我们能更加直观的看到这一点。</p>
<p><strong>性质 11</strong> ：对于 $\mathrm{Ly}$ $B$ 和另一个串 $A$ ，有 $A&lt;B\Leftrightarrow AB&lt;B$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>$\leftarrow$ ：$A&lt;AB&lt;B$ 。</p>
<p>$\rightarrow$ ：若 $A\notin \mathrm{pre}(B)$ ，则显然成立（因为 $&lt;$ 由字符不同产生，而不是长度不同）。</p>
<p>否则设 $B=AC$ ，即证明：$AAC&lt;AC$ ，即证明 $AC&lt;C$ ，由 $\mathrm{Ly}$ 定义可得，证毕。</p>
</div></details>
<p><strong>性质 12</strong> ：$A$ 是 $\mathrm{Ly}$ ，且 $|A|\ge 2$ ， 则一定存在 $S=AB,A&lt;B$ ，且 $A,B$ 均为 $\mathrm{Ly}$ 。（这可以看作上面性质 $4$ 的一个反方向）</p>
<details class="toggle" ><summary class="toggle-button" style="">证明 1</summary><div class="toggle-content"><p>先证明一个引理：如果 $S=ABC$ ，其中 $C$ 是 $\mathrm{Ly}$ ，那么 $AC$ 是 $\mathrm{Ly}$ 。</p>
<p>对于 $AC$ ，$\forall T\in \mathrm{suf}’(AC)$ ，如果 $A\notin \mathrm{pre}(T)$ ，那么由于 $T&gt;ABC$ 可以得到 $T&gt;A$ （因字符不同而产生的 $&gt;$），所以 $T&gt;AC$ ，否则有 $T=AD$ ，那么有 $D&gt;C$ ，$AD&gt;AC$ ，证毕。</p>
<p>那么设 $B$ 为 $\mathrm{suf}’(S)$ 中最长的是 $\mathrm{Ly}$ 的串，则 $S=AB$ ，$A$ 不能有 $\mathrm{Bd}$ ，否则 $B$ 可以伸长，矛盾。</p>
<p>所以 $\forall T\in \mathrm{suf}’(A)$ ，如果 $T<A$ ，则有 $TB<AB=S$ ，矛盾，所以 $T>A$ ，所以 $A$ 是 $\mathrm{Ly}$ ，证毕。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">证明 2</summary><div class="toggle-content"><p>来自 cmd 的证明。</p>
<p>考虑 $S[i\rangle$ 是最小的严格后缀。</p>
<p>那么显然 ，$S[i\rangle$ 是 $\mathrm{Ly}$ 。</p>
<p>现证明 $S\langle i-1]$ 是 $\mathrm{Ly}$ ，显然只需要证明 $S\langle i]$ 没有 $\mathrm{Bd}$ 即可。</p>
<p>假设有长度为 $k$ 的 $\mathrm{Bd}$ ，那么有：$S[1,k]=S[i-k,i-1]$ ，根据前面的定义，有 $S_{k+1}&gt;S_{i}$ 。（这里也可以用我证明中的引理，证明 $S[i-k\rangle$ 是 $\mathrm{Ly}$ ，所以 $rk[i-k]&lt;rk[i]$ ，矛盾）</p>
<p>所以 $S&gt;S_{i-k}$ ，矛盾，证毕。</p>
</div></details>
<p><strong>性质 13</strong> ：$S=L_{1}…L_{k}$ ，则 $1\le i<j\le k,L_{i}...L_{k}>L_{j}…L_{k}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>从后缀数组的角度看显然，因为排名递降。</p>
<p>但是从 $\mathrm{Lyndon}$ 角度看呢？</p>
<p>不妨假设 $L_{i}≠L_{j}$ ，否则去掉 $L_{i}$ 直接归纳，即认为 $L_{i}&gt;L_{j}$。</p>
<p>如果 $|L_{i}|\le |L_{j}|$ ，那么根据上面假设，显然成立。</p>
<p>否则假设 $t$ 为最小的数字满足： $|L_{j}L_{j+1}…L_{t}|\ge L_{i}$ ，那么有：</p>
<p>$\forall j\le v \le t-1,L_{v}\le L_{i}\langle |L_{v}|]\le L_{i}[|L_{j}…L_{v-1}|+1,|L_{j}…L_{v}|]$</p>
<p>$L_{t}\langle |L_{i}|-|L_{j}…L_{t-1}| ]\le L_{i}\langle |L_{i}|-|L_{j}…L_{t-1}|]&lt;L_{i}[|L_{j}…L_{t-1}|+1\rangle$ 。</p>
<p>若不存在 $t$ 同理，证毕。</p>
<p>这个证明就很好的反映了 $\mathrm{Lyndon}$ 串的性质。</p>
</div></details>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1-板子题"><a href="#1-板子题" class="headerlink" title="1. 板子题"></a>1. 板子题</h3><p>题目链接：<a href="https://www.luogu.com.cn/problem/P6114">https://www.luogu.com.cn/problem/P6114</a></p>
<p>题目大意：求 $\mathrm{Lyndon}$ 分解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(ss) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st);</span><br><span class="line">    n = <span class="built_in">strlen</span>(st + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;)&#123;</span><br><span class="line">        <span class="type">int</span> j = i + <span class="number">1</span>, k = i;</span><br><span class="line">        <span class="keyword">for</span>(; j &lt;= n &amp;&amp; st[k] &lt;= st[j]; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[k] &lt; st[j]) k = i;</span><br><span class="line">            <span class="keyword">else</span> k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt;= k; i += j - k) ans ^= i + j - k - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-求最小表示法"><a href="#2-求最小表示法" class="headerlink" title="2. 求最小表示法"></a>2. 求最小表示法</h3><p>求一个串的最小表示法。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>我一开始在想能不能只通过一个串的 $\mathrm{Lyndon}$ 分解得到最小表示法，后面发现不行，思考为什么，会发现原因和不能只通过单串的后缀数组得到最小表示法一样，就是循环位移字符串的不等式，不等价于后缀的不等式。</p>
<p>因此，这个题目不太能用单串的 $\mathrm{Lyndon}$ 分解来做。</p>
<p>具体做法为：求 $SS$ 的 $\mathrm{Lyndon}$ 分解，然后从 $\le |S|$ 的最后一个 $\mathrm{Ly}$ 串的开头开始就是最小表示法。（用性质 13 和 $\mathrm{Ly}$ 的性质不难证明这是对的）</p>
</div></details>
<h3 id="3-求每个前缀的最小后缀"><a href="#3-求每个前缀的最小后缀" class="headerlink" title="3. 求每个前缀的最小后缀"></a>3. 求每个前缀的最小后缀</h3><p>题目链接：<a href="https://acm.hdu.edu.cn/showproblem.php?pid=6761">https://acm.hdu.edu.cn/showproblem.php?pid=6761</a></p>
<p>题目大意：求所有前缀的字典序最小的后缀。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>首先，给你一个串，怎么求它的最小后缀，显然是最后一个 $\mathrm{Ly}$ 串。</p>
<p>但是怎么求前缀的最后一个 $\mathrm{Ly}$ 串呢？</p>
<p>假设现在在求前缀 $i$ 的答案，答案数组是 $f$ 数组（记录最小后缀长度）。</p>
<p>根据 $Duval$ 算法的性质，我们只关心这个位置近似 $\mathrm{Ly}$ $T=L^t\overline{L}$ 。</p>
<p>如果 $T=L$ ，那么答案就是 $L$ 。</p>
<p>否则注意到，这个 $T$ 的 $\mathrm{Lyndon}$ 分解是 $L^t$ 拼接上 $\overline{L}$ 的$\mathrm{Lyndon}$ 分解，也可以看作是 $L$ 拼接上 $L^{t-1}\overline{L}$ 的 $\mathrm{Lyndon}$ 分解，所以可以看作求 $L^{t-1}\overline{L}$ 的最小后缀，注意到这等于 $f[i-|L|]$ ，做完了。</p>
<p>时间复杂度：$O(n)$ 。</p>
<p>代码的 $f$ 记录的是位置，魔改了一下上面的结论。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e7</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(ss) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mnsuf</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> *mn, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;)&#123;</span><br><span class="line">        <span class="type">int</span> j = i + <span class="number">1</span>, k = i; mn[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(; j &lt;= n &amp;&amp; s[k] &lt;= s[j]; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[k] &lt; s[j]) mn[j] = k = i;</span><br><span class="line">            <span class="keyword">else</span> mn[j] = mn[k] + j - k, k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt;= k; i += j - k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> n, f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">get_char_array</span>(st);</span><br><span class="line">        n = <span class="built_in">strlen</span>(st + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">mnsuf</span>(st, f, n);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--) ans = (ans * <span class="number">1112ll</span> + f[i]) % mod;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h3 id="4-求每个前缀的最大后缀"><a href="#4-求每个前缀的最大后缀" class="headerlink" title="4. 求每个前缀的最大后缀"></a>4. 求每个前缀的最大后缀</h3><p>这个没找到题目，直接口胡了。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>怎么求出一个串的最大后缀。</p>
<p>先把所有字母的偏序关系倒过来，近似的变为最小后缀，但是虚空大小无限大而不是无限小。</p>
<p>注意到，如果 $S=L_{1}L_{2}^{t_2}…L_{k}$ ，显然答案一定是 $L_{i}…L_{k}$ 。</p>
<p>注意到对于一个字符串链 $S_{1}\le S_{2}\le S_{3}…\le S_{t}$ ，如果存在 $i$ 满足：$S_{i} &lt; S_{i+1}$（ $&lt;$ 由于字符不同产生），那么 $S_{i} &lt; S_{j} , j &gt; i$（ $&lt;$ 由于字符不同产生），也就是说，对于这个字符串链，如果我们认为虚空大小无限大，那么最小字符串应该是最小的 $S_{i}$ 满足：$\forall 1\le j&lt;i,S_{j}$ 是 $S_{j+1}$ 的前缀，而且 $S_{i}$ 不是 $S_{i+1}$ 的前缀。</p>
<p>设 $S_{i}=L_{k-i+1}…L_{k}$ ，那么答案是什么就显然了。</p>
<p>问题来了，有没有等价的、更好用的说法呢？</p>
<p>我们设 $S=L_{1}^{t_1}…L_{p}^{t_{p}}$ （把相同的 $\mathrm{Ly}$ 合并）。</p>
<p>显然，如果 $L_{i+1}^{t_{i+1}}…L_{k}^{p_{k}}$ 是 $L_{i}L_{i+1}^{t_{i+1}}…L_{k}^{p_{k}}$ 的前缀，那么 $L_{i}^{o-1}L_{i+1}^{t_{i+1}}…L_{k}^{p_{k}}$ 是 $L_{i}^{o}L_{i+1}^{t_{i+1}}…L_{k}^{p_{k}}$ 的前缀 。</p>
<p>所以只需要考虑 $L_{i+1}^{t_{i+1}}…L_{k}^{p_{k}}$ 是不是 $L_{i}L_{i+1}^{t_{i+1}}…L_{k}^{p_{k}}$ 的前缀就行了。</p>
<p>根据性质 13 的证明可以得到，$L_{i+1}^{t_{i+1}}…L_{k}^{p_{k}}$ 是 $L_{i}L_{i+1}^{t_{i+1}}…L_{k}^{p_{k}}$ 当且仅当 $L_{i+1}^{t_{i+1}}…L_{k}^{p_{k}}$ 是 $L_{i}$ 的前缀。</p>
<p>所以可以得到，答案是 $L_{i}^{t_{i}}…L_{i}^{t_{p}}$ ，其中 $i$ 是最大的满足：$L_{i}^{t_{i}}…L_{p}^{t_{p}}$ 不是 $L_{i-1}$ 前缀的数字。</p>
<p>注意到，答案等价于最后一个位置在 Duval 算法中，第一次被近似 $\mathrm{Ly}$ $T$ 覆盖时的 $T$ 。</p>
<p>原因是 Duval 算法每次实际上是一次性添加：$L_{u}^{t_{u}}$ ，所以当 $i$ 恰好在 $L_{ans}^{t_{ans}}…L_{p}^{t_{p}}$ 的左端点时，根据前面的假设可以知道，此时 $j$ 一定在 $|S|$ ，也就是最后一个位置。（这里的 $i,j$ 表示代码中的 $i,j$ ）</p>
<p>而当 $j$ 第一次到 $|S|$ 时，$T$ 对应的 $L_{u}^{t_{u}}…L_{p}^{t_{p}}$ 满足 $L_{u+1}^{t_{u+1}}…L_{p}^{t_{p}}$ 是 $L_{u}$ 的前缀，只需要证明对于 $\forall v&gt;u$ ，仍然满足这个性质就行了，一个显然的事情是，既然后面是 $L_{u}$ 的前缀，那么下一次跑的时候 $j$ 一定能跑到 $n$ ，类似跑 $L_{u}$ 的过程，归纳下去即可证明（即每次跳出内层循环的 $j$ 一定是不降的）。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">扩展</summary><div class="toggle-content"><p>其实注意到，$L_{u+1}^{t_{u+1}}…L_{p}^{t_{p}}$ 是 $L_{u}$ 的前缀 $\Leftrightarrow$ 生成 $L_{u}^{t_{u}}$ 时 $j=n$ ，根据上面的证明可以证得满足这样的 $u$ 是一个后缀，即存在 $u_{limie}$ 满足 $u\ge u_{limie}$ ，$L_{u+1}^{t_{u+1}}…L_{p}^{t_{p}}$ 是 $L_{u}$ 的前缀，如果 $u&lt;u_{limit}$ ，则不满足。</p></p>
<p>进一步的有满足 $L_{u+1}^{t_{u+1}}…L_{p}^{t_{p}}$ 是 $L_{u}L_{u+1}^{t_{u+1}}…L_{p}^{t_{p}}$ 前缀的是一个区间。</p>
<p>由于 $U$ 是 $V$ 的前缀 $\Leftrightarrow$ $AU$ 是 $AV$ 的前缀。</p>
<p>所以设 $S=L_{1}…L_{k}$ ，则存在 $i_{limit}$ ：$\forall i\ge i_{limit}$ ，$L_{i+1}…L_{k}$ 是 $L_{i}L_{i+1}…L_{k}$ 的前缀，$i&lt;i_{limit}$ 不是。</p>
<p>也就是说这样构造的字符串链的前缀关系是特殊的。</p>
<p>所以，上面的答案是 $L_{i}^{t_{i}}…L_{i}^{t_{p}}$ ，其中 $i$ 是最大的满足：$L_{i}^{t_{i}}…L_{p}^{t_{p}}$ 不是 $L_{i-1}$ 前缀的数字。</p>
<p>可以改成最小的 $i$ 满足：$L_{i+1}^{t_{i+1}}…L_{p}^{t_{p}}$ 是 $L_{i}$ 前缀的数字。</p>
</div></details>
<p>求前缀的答案的话，只需要在第一次跑到的时候更新一下就行了，时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(ss) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mxsuf</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> *mx, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;)&#123;</span><br><span class="line">        <span class="type">int</span> j = i + <span class="number">1</span>, k = i; !mx[i] ? mx[i] = i : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; j &lt;= n &amp;&amp; s[k] &lt;= s[j]; j++)&#123;</span><br><span class="line">            !mx[j] ? mx[j] = i : <span class="number">0</span>;</span><br><span class="line">            s[k] &lt; s[j] ? k = i : k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt;= k; i += j - k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, f[N];</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st);</span><br><span class="line">    n = <span class="built_in">strlen</span>(st + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">mxsuf</span>(st, f, n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cout &lt;&lt; f[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>某种无意义的占位符，防止排版垮掉。</p></div></details>
<h3 id="更多例题正在咕咕咕咕咕"><a href="#更多例题正在咕咕咕咕咕" class="headerlink" title="更多例题正在咕咕咕咕咕"></a>更多例题正在咕咕咕咕咕</h3><h1 id="Runs"><a href="#Runs" class="headerlink" title="Runs"></a>Runs</h1><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P6656">https://www.luogu.com.cn/problem/P6656</a></p>
<p><a href="https://www.luogu.com.cn/problem/P6656">https://www.luogu.com.cn/problem/P6656</a></p>
<h2 id="一个基本的求法"><a href="#一个基本的求法" class="headerlink" title="一个基本的求法"></a>一个基本的求法</h2><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>command_block 的洛谷博客 ：<a href="https://www.luogu.com/article/d4y3zqqv">https://www.luogu.com/article/d4y3zqqv</a></p>
<p>OIwiki ：<a href="https://oi-wiki.org/string/lyndon/">https://oi-wiki.org/string/lyndon/</a></p>
<p>国家集训队 2021 年论文：《胡昊 浅谈Lyndon分解》</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>Lyndon</tag>
        <tag>Runs</tag>
      </tags>
  </entry>
  <entry>
    <title>MEXimum Spanning Tree</title>
    <url>/2024/01/30/MEXimum-Spanning-Tree/</url>
    <content><![CDATA[<p>题目链接：<a href="https://qoj.ac/contest/1221/problem/6402">https://qoj.ac/contest/1221/problem/6402</a></p>
<p>题目大意：求 $mex$ 最大的生成树。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>一个显然的事情，这道题目是拟阵交，第一个拟阵无环，第二个拟阵要求每条数字的边至多一条。</p>
<p>这个时候可以二分+拟阵交，也可以从小到达考虑 $\le c$ 的边的拟阵交，因为拟阵交的算法保证了，只要给一个交集中的元素（一般默认空集），就一定可以增广出最大的元素。</p>
<p>接下来默认用从小到大考虑的方法，因为少个 $log$ 。</p>
<p>以下时间复杂度默认点数与边数同阶。</p>
<p>暴力建图的话是 $O(n^3)$ ，虽然能过，但是能不能更加优秀？</p>
<p>这个时候有几个优化方向：</p>
<ol>
<li>bitset ，在翻代码的时候看到的，虽然没看具体怎么优化的，反正是有人这么干的。</li>
<li>等到遍历到在加入边，显然，我们没必要一开始就把图建出来，而是跑到一个点再把这个点的所有出边找到，发现由于是 BFS，所以每个点至多走一次，所以这个优化只快不慢，同时注意到图拟阵那边的出边是难的，可以采用并查集优化的方式，在 $O(n^2\alpha(n))$ 的时间解决这个特殊的拟阵交问题。</li>
<li>题解说可以 $O(n^2\sqrt{n})$ ，没懂具体咋搞的，但肯定不是一开始就把图建出来。后面经过询问，似乎是说最短路的总长度有个 bound ，又说和 Hopcroft Karp 的分析类似，但 Hopcroft Karp 我没有学过，这个方法先咕了，等以后再说吧。</li>
</ol>
<p>但我写的是最暴力的三方做法，还要乘并查集的 $\alpha(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,c;</span><br><span class="line">&#125;e[N];<span class="type">int</span> pf[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Edge x,Edge y)</span></span>&#123;<span class="keyword">return</span> x.c&lt;y.c;&#125;</span><br><span class="line"><span class="type">bool</span> in[N],col[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=<span class="built_in">findfa</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mer</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x=<span class="built_in">findfa</span>(x);y=<span class="built_in">findfa</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x!=y)fa[x]=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">findfa</span>(x)==<span class="built_in">findfa</span>(y);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">uinit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y,next;</span><br><span class="line">&#125;a[M];<span class="type">int</span> len,las[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;a[++len]=&#123;y,las[x]&#125;;las[x]=len;&#125;</span><br><span class="line"><span class="type">int</span> typ[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> lim)</span></span>&#123;</span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(las+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*lim);</span><br><span class="line">    <span class="built_in">memset</span>(typ+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*lim);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lim;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!in[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">uinit</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=lim;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=j &amp;&amp; in[j])<span class="built_in">mer</span>(e[j].x,e[j].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=lim;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[j])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">pd</span>(e[j].x,e[j].y))<span class="built_in">ins</span>(i,j);</span><br><span class="line">            <span class="keyword">if</span>(e[i].c==e[j].c || !col[e[j].c])<span class="built_in">ins</span>(j,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">uinit</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lim;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i])<span class="built_in">mer</span>(e[i].x,e[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lim;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">pd</span>(e[i].x,e[i].y))typ[i]|=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!col[e[i].c])typ[i]|=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> pre[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> lim)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lim;i++)pre[i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lim;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(typ[i]&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            pre[i]=<span class="number">0</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(typ[x]&amp;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">while</span>(x)&#123;</span><br><span class="line">                col[e[x].c]^=<span class="number">1</span>;</span><br><span class="line">                in[x]^=<span class="number">1</span>;</span><br><span class="line">                x=pre[x];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=las[x];k;k=a[k].next)&#123;</span><br><span class="line">            <span class="type">int</span> y=a[k].y;</span><br><span class="line">            <span class="keyword">if</span>(pre[y]==<span class="number">-1</span>)&#123;</span><br><span class="line">                pre[y]=x;</span><br><span class="line">                q.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;e[i].x,&amp;e[i].y,&amp;e[i].c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(e+<span class="number">1</span>,e+m+<span class="number">1</span>,[](Edge x,Edge y)&#123;</span><br><span class="line">        <span class="keyword">return</span> x.c&lt;y.c;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)pf[e[i].c]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)pf[i]=<span class="built_in">max</span>(pf[i],pf[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">build</span>(pf[i]);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">solve</span>(pf[i]))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h6><p>根号做法是啥。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>拟阵</tag>
      </tags>
  </entry>
  <entry>
    <title>Moscow Pre-Finals Workshop 2020 Day 5 赛后小结</title>
    <url>/2024/08/04/Moscow-Pre-Finals-Workshop-2020-Day-5-%E8%B5%9B%E5%90%8E%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://qoj.ac/contest/1302">https://qoj.ac/contest/1302</a></p>
<p>队友开局秒 J ，后面 AC 了 L ，然后我去做 A ，搞了个结论，和队长说了一下，队长觉得很对，上去写，过了。</p>
<p>D 我开局就声称是 Runs 板子题，但是我不信真有板子题，在队长核善的邀请下还是上去写了 Runs ，然后一小时的时候 WA 了，后面发现是板子有点问题，半小时后过了。</p>
<p>队友写 G ，在两个小时的时候喜提 WA ，一直卡精度到三小时都没过，期间我搞了个 Border Series 上去把 B 过了，后面他们弃了。</p>
<p>后面和队长讨论 I ，搞了个看着很对的暴力，上去写过了。</p>
<p>后面和队友讨论 G ， 队长上去写了个高精度，在四个小时的时候过了，最后不会做 E ，遗憾离场。</p>
<p>G 我们精度差了，他们用 long double 存高精度，最后在除阶乘，我一开始声称说逐步乘精度可能会变好，队长说不会，原因精度差在回溯的减法，而在浮点数记录有效位数，除个数字不会影响有效位数，所以这是没有道理的，但是最后看题解发现题解就是这么做的，至于为什么这么做精度变好了，未知，神秘。</p>
<p>没啥错误，就是菜了。</p>
<p>正赛我肯定直接上 Runs ，但是训练赛怎样都无所谓，毕竟 Runs 确实有点大炮打蚊子的感觉，平时太过依赖科技不好，但写 Runs 也可以顺便查下板子（板子也确实错了），反正我个人认为怎样决策都对，不管他了。</p>
<p>部分题解：</p>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>首先假设每个点都选了 $Y$ ，所以现在变成要不要把 $Y$ 换成 $X$ 。</p>
<p>思考一下线性基，本质上是个线性方程组。</p>
<p>假设现在问你 $x$ 经过线性基后的最小值是多少，显然是从大到小，最高位相同就异或。</p>
<p>所以先把后手的线性基跑出来。</p>
<p>问题变成先手最大化线性基跑出来的最小值，注意到这是一个可以拆分的问题，即这是线性的。</p>
<p>所以可以先把每个可选的数字包括 $X$ 扔进去跑出最小值，然后在问这堆数字异或起来的最大值，求最大值再建个线性基就行了，时间复杂度：$O((n+m)\log{V})$</p>
<p>与题解和别人做法一致。</p>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>上 Runs 了。</p>
<p>注意到每个答案都一定在恰好一个 Runs 里，首先显然在一个 Runs 里。</p>
<p>其次考虑在两个 Runs 里，如果一个最小周期为 $p$ ，另外一个为 $q$ ，那么显然 $p+q\le len$ ，所以可以得到两个 Runs 周期相同，所以可以直接合并成一个 Runs ，矛盾，证毕。</p>
<p>那么求出 Runs 计数就行了。</p>
<p>但是这个能过洛谷的板子错了，你们有什么头猪吗？</p>
<p>不过还好错误不大，能在不会 Runs 具体过程的情况下猜出来，不然就真爆了。</p>
<p>看了题解：不是哥们，怎么优秀的拆分高中不会，上了大学还是不会啊。唐人就只会用科技解决问题，但是正解就不一样了。</p>
<p>首先，设长度为 $x$ 的极长周期串（重复至少两次）的子串为 $T_{1},…,T_{k}$ ，显然相邻两个串的交集 $&lt;x$ ，所以考虑将原串以长度 $x$ 分段。</p>
<p>那么显然，每个极长周期串至少覆盖其中一个整段，而且显然，完整覆盖其中一个整段的极长周期串至多一个，所以这个时候就已经可以对每个段用 SA 直接暴力求解所有可能的极长周期串，或者二分 + Hash。</p>
<p>但是别急，还有性质，相邻两个段如果完全一样，则一定存在同时覆盖这两个段的极长周期串，$k$ 个段同理。</p>
<p>所以综上，设极长相等的段编号为 $<a href="l\le r">l,r</a>$ ，根据上面的结论，不需要求 $(r-l+1)$ 次极长周期串，求一次就行了，因为如果存在（$l&lt;r$ 时一定存在），则覆盖 $[l,r]$ 的是同一个。而且显然，这个极长周期串覆盖 $[l,r]$ ，不覆盖 $l-1,r+1$ 。</p>
<p>但是这能带来什么进步吗？其实不能，只不过二分 + Hash 中二分的范围变小了罢了。</p>
<p>时间复杂度：$O(n\log{n})/O(n\log^2{n})$ 。</p>
<p>甚至求出所有串后，可以直接排序去重，得到的就是 Runs ，可以看成 Runs 一个很低门槛的等价替代品。</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>上 Border Series 了。</p>
<p>插入在前面可以把串翻过来，注意到翻过来后，整个串的 $Bd$ 是不会变化的，所以尝试维护 Bd 集合。</p>
<p>注意到 Bd 可以拆分成 $\log$ 段等差数列，那么你在维护的时候，直接合并相邻两段可以合并的等差数列到不能合并为止，最多只会有 $2\log$ 段，所以可以这样维护。</p>
<p>然后每添加一个字符的 Bd 集合怎样变化，手模一下就知道了。</p>
<p>时间复杂度：$O(n\log{n})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> l, r, p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;node&gt; VN;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(node x, node y)</span></span>&#123;<span class="comment">//x.l &gt; y.r</span></span><br><span class="line">	<span class="keyword">if</span>(x.l == x.r &amp;&amp; y.l == y.r) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x.l != x.r &amp;&amp; y.l != y.r &amp;&amp; x.p != y.p) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(x.l == x.r) x.p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(y.l == y.r) y.p = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> p = <span class="built_in">max</span>(x.p, y.p);</span><br><span class="line">	<span class="keyword">return</span> x.l - y.r == p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">VN <span class="title">merge</span><span class="params">(VN x)</span></span>&#123;</span><br><span class="line">	VN tmp;</span><br><span class="line">	<span class="keyword">while</span>(!x.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		node y = x.<span class="built_in">back</span>();</span><br><span class="line">		x.<span class="built_in">pop_back</span>();</span><br><span class="line">		<span class="keyword">while</span>(!x.<span class="built_in">empty</span>())&#123;</span><br><span class="line">			node z = x.<span class="built_in">back</span>();</span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">check</span>(z, y)) <span class="keyword">break</span>;</span><br><span class="line">			x.<span class="built_in">pop_back</span>();</span><br><span class="line">			y.p = z.l - y.r;</span><br><span class="line">			y.r = z.r;</span><br><span class="line">		&#125;</span><br><span class="line">		tmp.<span class="built_in">push_back</span>(y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">reverse</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">VN fail;</span><br><span class="line"><span class="type">int</span> a[N * <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> llen, rlen;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> len, <span class="type">int</span> t, <span class="type">int</span> c)</span></span>&#123; <span class="comment">//t = 0 : left</span></span><br><span class="line">	<span class="keyword">if</span>(!t) <span class="keyword">return</span> a[rlen - len] == c;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> a[llen + len] == c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	llen = n + <span class="number">1</span>;</span><br><span class="line">	rlen = n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		string s, t;</span><br><span class="line">		cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		<span class="keyword">if</span>(t[<span class="number">0</span>] == <span class="string">&#x27;d&#x27;</span>) x = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t[<span class="number">0</span>] == <span class="string">&#x27;r&#x27;</span>) x = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t[<span class="number">0</span>] == <span class="string">&#x27;m&#x27;</span>) x = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t[<span class="number">0</span>] == <span class="string">&#x27;f&#x27;</span>) x = <span class="number">3</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t[<span class="number">0</span>] == <span class="string">&#x27;s&#x27;</span> &amp;&amp; t[<span class="number">1</span>] == <span class="string">&#x27;o&#x27;</span>) x = <span class="number">4</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t[<span class="number">0</span>] == <span class="string">&#x27;l&#x27;</span>) x = <span class="number">5</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t[<span class="number">0</span>] == <span class="string">&#x27;s&#x27;</span> &amp;&amp; t[<span class="number">1</span>] == <span class="string">&#x27;i&#x27;</span>) x = <span class="number">6</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">		<span class="type">int</span> type = s[<span class="number">0</span>] == <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		VN tmp;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> [l, r, p] : fail)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">check</span>(r, type, x)) tmp.<span class="built_in">push_back</span>(&#123;r + <span class="number">1</span>, r + <span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">			<span class="keyword">if</span>(l &lt; r &amp;&amp; <span class="built_in">check</span>(l, type, x)) tmp.<span class="built_in">push_back</span>(&#123;l + <span class="number">1</span>, r - p + <span class="number">1</span>, p&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(i != <span class="number">1</span> &amp;&amp; <span class="built_in">check</span>(<span class="number">0</span>, type, x)) tmp.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">		<span class="keyword">if</span>(type == <span class="number">0</span>) a[--llen] = x;</span><br><span class="line">		<span class="keyword">else</span> a[++rlen] = x;</span><br><span class="line">		fail = <span class="built_in">merge</span>(tmp);</span><br><span class="line">		<span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> [l, r, p] : fail)&#123;</span><br><span class="line">			ans++;</span><br><span class="line">			<span class="keyword">if</span>(l &lt; r) ans += (r - l) / p;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题解做法：</p>
<p>注意到周期 $x$ 存在的时间是一段区间：$[x,?]$ ，二分 + Hash 确定这个区间就行了。</p>
<p>时间复杂度：$O(n\log{n})$ 。</p>
<p>但是我的做法用了科技，代码却意外的更短，绷不住了。</p>
<h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p>直接做 DP ，然后回溯 DP ，枚举最后一个数字是啥，然后求求答案就行了。</p>
<p>和题解一致。</p>
<h1 id="I"><a href="#I" class="headerlink" title="I"></a>I</h1><p>注意到，空集和全集一定在里头。</p>
<p>全集用所有集合取并就行了，空集用所有元素去交就行了。</p>
<p>然后注意到每个元素所在的集合和其所在的大小最小的集合一一对应。</p>
<p>显然一个元素所在的大小最小的集合是唯一决定的，而这个元素所在的集合就是所有这个集合的超集。</p>
<p>所以至多 $5$ 种本质不同的观众，考虑把全集踢掉，只有 $2^4$ 种可能性，所以 $2^{20}$ 次方枚举一下就行了。</p>
<p>check 随便怎么 check 都行，只要不是太扯就行了。</p>
<p>至于计数，注意到集合有标号，我们选定了每种观众所在的集合，所以直接计数就是不会重的。</p>
<p>至于计数吗，容斥一下就行了。</p>
<p>时间复杂度：$O(\mathrm{能过})$</p>
<p>看了题解，发现分析的有点 SB ，$\binom{2^{4}}{5}$ 确实可以看成 $2^{20}$ ，但是显然 $2^{2^{4}}$ 也就是 $2^{16}$ 是一个显然的更小的界。</p>
<p>但是那个线性递推的做法，说句实话，我没懂。</p>
<h1 id="Plan"><a href="#Plan" class="headerlink" title="Plan"></a>Plan</h1><p>补题</p>
<p>把两个字符串的题目写写代码。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>KMP 和 PAM 的可持久化</title>
    <url>/2024/07/26/KMP-%E5%92%8C-PAM-%E7%9A%84%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<p>KMP 和 PAM 的可持久化主要解决一个问题：去均摊分析。</p>
<h1 id="KMP-的可持久化"><a href="#KMP-的可持久化" class="headerlink" title="KMP 的可持久化"></a>KMP 的可持久化</h1><p>操作：</p>
<ol>
<li>插入字符</li>
<li>回溯</li>
<li>问最大周期</li>
</ol>
<p>希望能维护一个 KMP 形状的可持久化结构。</p>
<h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法 1"></a>方法 1</h2><p>为了去除时间复杂度中的均摊分析部分，类似 AC 自动机一样，如果一个前缀的某个儿子不是其下一个字符，那么记录其的失配（不知道叫不叫这个名字，反正这么个意思）。</p>
<p>所以，将每个节点的儿子数组用可持久化结构维护，同时把 fail 树的结构也给类似的可持久化一下（这个可持久化不是指用可持久化数据结构维护，是指后一个版本的 fail 树可以借用前一个版本 fail 树的一些节点，只要这些节点信息相同）。</p>
<p>所以每次插入字符只需要修改两个节点：一个原来的后缀，一个新增的后缀，同时新的 fail 树除了这两个节点以外的部分都不用动，而且原后缀在 fail 树中没有节点指向他，所以可以直接在新 fail 树上偷梁换柱，以下是一个例子：</p>
<p>![1.png]</p>
<p>时间复杂度：$O(q\log{S})$ 。</p>
<p>但是需要注意，这样子形成的失配结构和 AC 自动机有本质区别，什么意思呢？</p>
<p>如果我们按照回溯的情况，来建出一个 Trie ，然后在这个 Trie 上跑出 AC 自动机，那么这个 AC 自动机的失配和可持久化的失配是不同的。</p>
<p>例如：$ab$ 后回溯，插入 $b$ ，如果 AC 自动机，回溯后 $ab$ 会指向 $b$ ，可持久化不会。</p>
<p>这种做法的本质是在时间 Trie 上维护每个点到根的失配数组，由于不基于均摊，时间复杂度是对的，当然，既然都这样了，也可以不用可持久化的方式维护失配树组，直接开一个数组，时间复杂度是：$O(qS)$ 的。</p>
<p>如果还要维护原串信息，原串也得用可持久化线段树维护一下。</p>
<p>一点变式：</p>
<p>众所周知，字符串的数据结构往往可以在维护的时候往上跳几个 fail ，有时候会有奇效，比如 SAM 时间复杂度的证明就要看 last 的 fail 相关的信息。</p>
<p>而这里也可以，我们可以维护一个新的 $\mathrm{quick[c]}$ 数组，表达的意思是，如果这个节点失配了，那么其最长的前缀满足下一个字符是 $c$ 是哪个节点。</p>
<p>这个的意义在哪呢？它弱化了字符串的存在，认为每个节点都是一个字符串（原字符串的前缀），而 $\mathrm{quick[c]}$ 只由这个节点的字符串决定，而不由总的字符串决定，这有时候会方便思考。</p>
<p>而这种遍历在 KMP 上体现的一般不多，但是在其余数据结构例如 PAM 上体现就比较多了，因为 KMP 上每个节点的字符串和原串前缀一一对应，因此即使只看每个节点的字符串，两者关系也是藕断丝连，但是 PAM 不一样，他是从原串中抽离出所有回文串，因此这个变式就显得很有用了。</p>
<h2 id="方法-2"><a href="#方法-2" class="headerlink" title="方法 2"></a>方法 2</h2><p>KMP 的失配有一个很重要的结论：</p>
<p>如果 $x$ 在跳 $fail$ 的时候失败了，而且 $2\mathrm{len[fail[x]]}&gt;\mathrm{len[x]}$ ，那么可以直接跳到 $len[x]\%(len[x]-len[fail[x]])+(len[x]-len[fail[x]])$ ，用这个结论，再用可持久化数据结构维护一下 $fail$ 数组和原串就轻轻松松了。</p>
<p>时间复杂度：$O(q\log^2{n})$ 。</p>
<p>慢了，但是好写得多，而且原串信息也顺便维护了，所以这是 KMP 可持久化的主流写法。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><a href="https://www.luogu.com.cn/problem/P5287">https://www.luogu.com.cn/problem/P5287</a></p>
<h1 id="PAM-的可持久化"><a href="#PAM-的可持久化" class="headerlink" title="PAM 的可持久化"></a>PAM 的可持久化</h1><h2 id="PAM-的去均摊化"><a href="#PAM-的去均摊化" class="headerlink" title="PAM 的去均摊化"></a>PAM 的去均摊化</h2><p>PAM 和 KMP 不同的是，每个节点和原串关系，但不多，因为你不能说每个回文串在原串中的前一个字符和后一个字符是啥，回文串是原串中抽象的概念。</p>
<p>但是注意到，现在我们从一个 PAM 上的节点开始匹配，我们只关心两个值：这个串在现在串位置中的前一个字符 $c_1$ 和后一个字符 $c_2$ 。</p>
<p>那我们是不是要维护 $S^2$ 种结果呢？</p>
<p>不然，还是那句话，字符串的数据结构总是可以往 fail 上跳一跳，我们维护在这个节点失配后往上跳的匹配结果，注意到这时上面的回文前后缀一定在这个回文串的里面，所以只要我们知道这个回文串，下面的串所需要的他们的前一个字符我们就已知了。</p>
<p>所以，我们维护 $\mathrm{quick[c]}$ 表示这个节点失配后，后一个字符是 $c$ 的匹配结果，类似 KMP 的，可以 $O(S)$ 数组维护或者 $O(\log{S})$ 可持久化维护。</p>
<h2 id="PAM-的各种扩展"><a href="#PAM-的各种扩展" class="headerlink" title="PAM 的各种扩展"></a>PAM 的各种扩展</h2><h3 id="后面添加-删除"><a href="#后面添加-删除" class="headerlink" title="后面添加/删除"></a>后面添加/删除</h3><p>直接用去均摊化的 PAM 即可。</p>
<p>注意在每个节点维护这个节点作为最长后缀的次数，归零删除。</p>
<h3 id="Trie-上的-PAM"><a href="#Trie-上的-PAM" class="headerlink" title="Trie 上的 PAM"></a>Trie 上的 PAM</h3><p>如果不均摊化，类似 AC 自动机，时间复杂度是所有叶子节点深度和。</p>
<p>均摊化是 size ，原串信息可以在 DFS 时记录。</p>
<h3 id="可持久化-PAM"><a href="#可持久化-PAM" class="headerlink" title="可持久化 PAM"></a>可持久化 PAM</h3><p>同样的，只不过需要用可持久化数据结构维护一下原串信息。</p>
<h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><p>Trie PAM ：<a href="https://vjudge.net/problem/CodeChef-TREEPAL">https://vjudge.net/problem/CodeChef-TREEPAL</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>可持久化</tag>
        <tag>KMP</tag>
        <tag>PAM</tag>
      </tags>
  </entry>
  <entry>
    <title>Moscow International Workshops 2017 Day 4 赛后小结</title>
    <url>/2024/07/31/Moscow-International-Workshops-2017-Day-4-%E8%B5%9B%E5%90%8E%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://qoj.ac/contest/1213">https://qoj.ac/contest/1213</a></p>
<p>一开始队长秒了 B ，队友秒了 D ， 我秒了 C 。</p>
<p>然后和队长讨论 F ，这道题目让我们想起了一个之前 CF 的一个题目，猜测结论是一样的，但是不会证明，后面队长去搞别的题目，我开始思考结论是不是一样的。</p>
<p>然后发现结论真的是一样的，直接开写，过了。</p>
<p>然后忘了是 Imakf 还是队长，上机过了 L ，这时一个小时过去了。</p>
<p>然后和队长讨论 H ，队长声称了一个贪心思路，我觉得很对，后面尝试证明其做法的时候发现了更本质的东西，上机过了。 </p>
<p>Imakf 上机过了 J ，期间我和队长讨论 G ，由于注意到一个传统的一堆石子拿 $k$ 个的 NIM 游戏，总是尝试拼出 $k+1$ ，所以发现这道题目应该和 $\mod (A+B)$ 的余数有关，然后感觉剩下的部分只剩下了讨论，队长就去和 Imakf 讨论别的题，然后我讨论到两小时时过了此题，感觉其实是慢了的，没道理讨论这么久，或者说，我感觉我大部分时间是在寻找优美的讨论，而不是在讨论，真要正赛就一个劲的讨论了，估计这样虽然结果丑了点，但是速度应该会快些，毕竟寻找优美讨论这个行为在重要比赛的性价比本来就不高。</p>
<p>期间队友一直在讨论 I （后面发现他们一直在图上讨论，这其实方向错了），我看了一眼，我也没有思路，我去看了 A 题意，也没有思路，但是突然发现 I 很多时候专注于某一个集合是好的。</p>
<p>顺藤摸瓜发现应该答案 $\le$ 两个集合，这个时候提出了一个错误的原因：理论上你知道得到一个出现次数 $&gt;1$ 的数字就应该不断地操作包含其地最小地集合，然后写出如下地代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; c[N];</span><br><span class="line"><span class="type">int</span> m1[N], m2[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!m1[x]) m1[x] = y;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(y &lt; m1[x]) m2[x] = m1[x], m1[x] = y;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!m2[x]) m2[x] = y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getans</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(y != m1[x]) <span class="keyword">return</span> m1[x];</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(!m2[x]) <span class="keyword">return</span> inf;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> m2[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line"><span class="type">int</span> siz[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="type">int</span> k;</span><br><span class="line">		cin &gt;&gt; k;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++)&#123;</span><br><span class="line">			<span class="type">int</span> x;</span><br><span class="line">			cin &gt;&gt; x;</span><br><span class="line">			<span class="keyword">if</span>(!v[x]) siz[i]++;</span><br><span class="line">			v[x] = <span class="number">1</span>;</span><br><span class="line">			c[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> x : c[i])&#123;</span><br><span class="line">			<span class="built_in">push</span>(x, siz[i]);</span><br><span class="line">			v[x] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans = inf;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="type">int</span> tmp = <span class="number">0</span>, base = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> x : c[i])&#123;</span><br><span class="line">			<span class="keyword">if</span>(!m2[x]) base++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> x : c[i])&#123;</span><br><span class="line">			<span class="keyword">if</span>(!m2[x]) <span class="keyword">continue</span>;</span><br><span class="line">			tmp = <span class="built_in">max</span>(tmp, base + <span class="number">1</span> + <span class="built_in">getans</span>(x, siz[i]));</span><br><span class="line">			ans = <span class="built_in">min</span>(ans, siz[i] + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!tmp) tmp = inf;</span><br><span class="line">		ans = <span class="built_in">min</span>(ans, tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但实际上是错的，后面 Imakf 提出质疑，两个集合那个性质真的证明了吗？我思考了一下，好像真没证明，举个例子，如果我中间得到了一个需要次数更少地有效次数，显然更优的操作是去操作这个更优地数字，因此我前面地证明显然是错的。只能说急了，在没有想明白地情况下就开写了，太急了，以后打比赛能不能别那么急，想清楚了再上。（不过当时机时空着也确实闹腾，但现在看来确实更稳地打法是想好再上，我宁愿什么都不做，也不愿意犯错）</p>
<p>然后讨论着突然发现好像确实是至多两个集合，但是不太一样的是先找到最优的位置再跳，原因是如果真有一个过程有多个集合，那么直接从倒数第二个集合开始答案一定不劣，所以就做完了。</p>
<p>然后接近三个小时过了 I 。</p>
<p>这个时候和队友讨论 A ，容斥容斥不行，dp dp 不行，因此我在想能不能直接计数，突然发现好像直接在有根树上给每个连通块在最浅的 meet room 计数就能保证不重，遂上机。</p>
<p>在四个半小时的时候通过 A 。</p>
<p>最后和队友讨论 E,K ，期间队长说 E 交叉字母能互相唯一确定位置，但是无法处理不相交的情况，我当时想的是如果不相交就像区间 dp 一样合并一下就行了，但是想想就难写，最后半小时肯定写不出来，但是这里我并没告诉队友这个事情，算是小错误，但也不大，毕竟这个搞法赛后队友听了也觉得是史，当时写这个做法确实就是写不出来（更何况还是在当时没想明白的基础之上），其次就是赛后看了别人做法，发现不长，因此这个做法也没道理是正解。</p>
<p>然后 K 也没啥思路，当时觉得 dp 不了有考虑过什么指数搞法，但是也没什么思路，最终遗憾离场，虽然最后看题解发现确实是带指数的，但是显然想到方向和想到做法之间的差距还是很大的，总之菜就得多练。</p>
<p>总之我这场的错误：</p>
<ol>
<li>I 急了多了好几发罚时。</li>
<li>没有及时的和队友交流我 E 和 K 的想法。</li>
<li>开天眼和队友说 E 赛时没人过（因为赛前看到一堆 11 题队，以为都是过的 K ），导致最后重心落在 K ，但不仅天眼开错了，而且还错失了一个 11 题的机会（赛后看了 E 的代码，理论上如果全力想 E ，如果在最后 15 分钟前想出来，那还是有机会写出来的），总之以后真不能开天眼了，开天眼打比赛这种行为纯 SB 。</li>
</ol>
<p>队友问题：真不能在想不出题时玩手机吧！怒！</p>
<p>部分题解：</p>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>行列独立，check 一下。</p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>选择个数最多的字母单独作为子序列，答案是 $\frac{n^2}{9}$ ，所以只需要关心周期长度 $&lt;9$ 的。（一开始搞成 $\le 9$ 的，还在犹豫要不要写，唐完了）</p>
<p>直接枚举然后贪心匹配即可，时间复杂度：$O(3^8n)$</p>
<p>和正解一致。</p>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p>首先整个串不是回文串，答案为 $1$ 。</p>
<p>否则如果可以切成一个前缀一个后缀都不是回文串，则答案为 $2$ 。</p>
<p>思考一下上面两个都打不成的情况。</p>
<p>首先如果一个长度为 $len$ 的回文串，其有一个长度为 $len-k$ 的回文前缀，则有长度为 $k$ 的周期。</p>
<p>下面讨论不妨认为首字母是 $a$ ，剩下的依次为 $bc..$ 。</p>
<p>首先一种情况：$aaaa…aa$</p>
<p>不妨考虑字符串 $S[1…i],S[i+1…n]$ 是不是回文串。</p>
<p>如果 $S[1]$ 是，$S[1…2]$ 不是，那么 $S[1…i],S[1…i+1]$ 不可能同时是回文串，否则 $S[1…2]$ 就是回文串，又由于 $S$ 是回文串，那么 $S[i…n],S[i+1…n]$ 同理。</p>
<p>所以 $S[1…i],S[i+1…n]$ 总是随着 $i$ 的变化交替成为回文串，根据 $S$ 是回文串，$S[1…n-2]$ 是，$S[1…n-1]$ 不是可以得到这种串一定是：$ababa….a$ 。</p>
<p>类似的，直接找到第一个 $i$ ，使得 ：$S[1…i]$ 是回文串，$S[1…i+1]$ 不是，显然只要不是 $aaa..aa$ ，那么 $i$ 一定存在，而且显然 $i\ge 2$。</p>
<p>对应的，有最大的 $j=n-i+1$ 满足：$S[j…n]$ 是回文串，$S[j-1…n]$ 不是，显然 $i+1\le j-1$。</p>
<p>若 $i+1=j-1$ ，即 $S=aaa…aba…aaa$ ，那么 $S$ 显然无解。</p>
<p>否则在 $[i,j]$ 在，$S[i+1,j-1]$ 的范围内，前后缀必须反复交换回文串，也就是 $S[1…j-1]$ 是周期为 $2$ 的，如果 $i&gt;2$ ，那么 $S[1…j-1]$ 是全 $a$ 串，则对称一下，得到 $S$ 是全 $a$ 串，矛盾，而 $i=2$ 则在上面讨论过了，是 $abab…a$ 。</p>
<p>所以综上，只有三种特殊串：$aaa..aa,ababa….a,aaa…aba…aaa$ ，而这三种显然无解。</p>
<p>证毕。</p>
<p>时间复杂度：$O(n)$ 。</p>
<p>与题解一致。</p>
<h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><p>首先，如果从起点可以直接跳到终点，那么答案为 $0$ 。</p>
<p>其次，如果存在 $a[i]-a[i-1]&gt;d$ ，那么肯定会想答案为让最小 $c_{i}$ 的走过全程，然后其余直接大跳到终点。</p>
<p>不妨来证明一下：</p>
<p>将 $1,a_{1},…,a_{k},n$ 根据 $a[i]-a[i-1]&gt;d$ 切成若干段，每一段都能从开头直接小跳到结尾，不妨设有 $cnt$ 段。</p>
<p>那么除了最后一段外，每一段里面的每一个青蛙都得大跳才能跳到后面的段，所以每个青蛙的系数至少是 $1$ 。</p>
<p>其次，每一段至少有一只青蛙，所以第一段 $k$ 只青蛙，后面 $[2,cnt-1]$ 段 $\ge 1$ 只，所以系数和 $\ge k+cnt-2$ 。</p>
<p>所以显然 $cnt-1$ 的系数分配给 $c$ 最小的，其余都为 $1$ 是最优答案。</p>
<p>然后如果不存在这样的 $&gt;d$ 的 gap ，那肯定会想，那是不是每次把最远的不用大跳的点跳过来就行了呢？（队长给出的贪心）</p>
<p>这看起来很对，但是为什么呢？</p>
<p>我们不妨考虑最大化系数为 $0$ 的青蛙个数，考虑上述本质过程，是找到最大的 $t$ 满足 $a[i]-a[i-t+1]\le d$ 。</p>
<p>那么我们考虑放 $t-1$ 只青蛙全程小跳，显然每次都能让最远那只过来。</p>
<p>但是如果放 $t$ 只青蛙，考虑将 $i$ 递增并不断地把青蛙跳到 $a[i]$ ，来模拟这 $t$ 只青蛙的行进路线，在 $a[j]-a[j-t]&gt;d$ 的这个位置，会发现最远那只青蛙的位置 $\le a[j-t]$ ，而 $a[j-t+1]…a[j-1]$ 的位置都已经走过，所以无论如何最远的青蛙都不可能不借助大跳跳到 $a[j]$ 及以后，所以矛盾，证毕。</p>
<p>那现在知道至多多少只青蛙系数为 $0$ ，剩下的青蛙系数为 $1$ 自然为最优解。</p>
<p>证毕。</p>
<p>时间复杂度：$O(m+k)$</p>
<p>和题解一致。</p>
<h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p>update ：喜报，写题解的时候发现自己赛时写的做法讨论出了点小问题，但是 AC 了，乐麻了。</p>
<p>太狗屎了，还要讨论。</p>
<p>如果 $A=B$ ，做法显然，考虑剩下的情况。</p>
<p>如果存在 $min(A,B)\le a_{i}\mod {(A+B)} &lt; max(A,B)$ ，那么显然 $min(A,B)$ 取胜，不妨考虑这一堆为第一堆，无论先后手，如果 $max(A,B)$ 操作了一次这个堆，$min(A,B)$ 就操作回来，只有当其余堆都无法操作的时候，$min(A,B)$ 才会先操作这个堆，这种情况下，$min(A,B)$ 显然必胜。</p>
<p>其余情况：</p>
<p>如果 $A&lt;B$ ：</p>
<p>如果存在 $a_{i}\mod {(A+B)} \ge 2A$ ，那么先手操作这一堆能造出上面的情况。</p>
<p>否则，统计 $a_{i}\mod {(A+B)} \ge B$ 的数量，如果为奇数先手必胜，否则后手必胜。</p>
<p>原因：偶数：不妨认为是第 $1,2…,k$ 堆 $\ge B$ ，剩下的堆都满足：$a_{i}\mod {(A+B)} &lt; A$ ，$A$ 若操作了 $1,…,k$ 其中的一堆，则 $B$ 操作另外一堆，然后这两堆可以直接扔到 $a_{i}\mod {(A+B)} &lt; A$ 去，如果 $A$ 操作了别的堆，则 $B$ 操作一样的堆，最后只会剩下一堆 $&lt;A$ 的堆，卡死 $A$ 。</p>
<p>奇数：先手操作其中一堆，这一堆丢到后面，其余操作一样，虽然和上面不太一样的是，一个 $-A$ ，一个 $-B$ ，但都变成了 $&lt;A$ ，效果一样。</p>
<p>如果 $A&gt;B$ ：</p>
<p>设 $a_{i}\mod {(A+B)} \ge 2B$ 的个数为 $cnt$ 个，根据上面的前提，显然有 $\ge A$ 成立。</p>
<ol>
<li>如果 $cnt=1$ ，则直接操作这个数字，判断剩下的数字中 $a_{i}\mod {(A+B)} \ge A$ 的个数，偶数先手赢，否则后手赢。</li>
<li>如果 $cnt\ge 2$ ，后手赢。</li>
</ol>
<p>$cnt=0$ 则考察 $a_{i}\mod {(A+B)} \ge A$ 的个数，为奇数则先手赢。</p>
<p>那么剩下的情况先手是否必败呢，例如能否操作那些 $a_{i}\mod {(A+B)} &lt; B$ 的数字完成翻盘呢，思考一下，如果 $B\le (a_{i}-A)\mod {(A+B)}&lt;A$ 则后手胜，$B\le (a_{i}-A)\mod {(A+B)}$ 则后手也胜（$\ge B$ 的个数为奇数个）。</p>
<p>则只有 $&lt;B$ 才可以，但是 $-A$ 等于 $+B$ ，设 $r=a_{i}\mod {(A+B)}$ ，而 $r+B&lt;2B&lt;A+B$ ，所以 $r+B$ 就是操作后模意义下的值，显然 $r+B\ge B$ ，所以 $&lt;B$ 是不可能的，所以这种情况后手必胜。</p>
<p>做闭，时间复杂度：$O(n)$ 。</p>
<p>经过若干次修改后的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, a[N], A, B;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; A &gt;&gt; B;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">	<span class="keyword">if</span>(A == B)&#123;</span><br><span class="line">		<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cnt += a[i] / A;</span><br><span class="line">		<span class="keyword">return</span> cnt &amp; <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(A &lt; B)&#123;</span><br><span class="line">		<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">			<span class="type">int</span> res = a[i] % (A + B);</span><br><span class="line">			<span class="keyword">if</span>(res &gt;= A &amp;&amp; res &lt; B) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(res &gt;= A + A) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			cnt += (res &gt;= B);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cnt &amp; <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//A &gt; B</span></span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="type">bool</span> bk = <span class="number">0</span>, bbk = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="type">int</span> res = a[i] % (A + B);</span><br><span class="line">		<span class="keyword">if</span>(res &gt;= B &amp;&amp; res &lt; A) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(res &gt;= B + B)&#123;</span><br><span class="line">			<span class="keyword">if</span>(bk) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			bk = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cnt += (res &gt;= A);</span><br><span class="line">		<span class="keyword">if</span>(res &lt; B &amp;&amp; a[i] &gt; res &amp;&amp; (a[i] - A) % (A + B) &gt;= A) bbk = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(bk) <span class="keyword">return</span> cnt &amp; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> (cnt &amp; <span class="number">1</span>) || bbk;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">work</span>()) cout &lt;&lt; <span class="string">&quot;Zenyk\n&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Marichka\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无语了，赛后写小结把赛时代码 hack 了，what can i say ，man ！</p>
<p>感觉这样讨论好烦，去看看别人的讨论。</p>
<p>咕咕咕。。。</p>
<h1 id="I"><a href="#I" class="headerlink" title="I"></a>I</h1><p>注：</p>
<ol>
<li>后面的讨论中都认为集合的修改是及时的，即只要球被摸出后，这个集合后续都没有这个球。</li>
<li>关于我后面为什么这么思考这个问题，可以看本博客的 “关于如何思考有向图游戏上的不对称博弈问题” 。</li>
</ol>
<p>首先注意到一个事情，一个方案中的某个看起来不那么愚蠢的世界线中（即后手的某种决策会导向的结果，且后手如果存在不立即结束的决策，就一定不会选会立即结束的决策），最后选择的那个集合设置为 $S$ ，如果 $S$ 有重复的元素。</p>
<p>那么显然，答案一定 $\ge S$ 的颜色个数 $+1$ ，原因是考虑 DAG 上，后手在这个状态的答案一定不为 $0$ ，所以一开始直接操作这个集合颜色个数 $+1$ 就可以得到不劣的方案。</p>
<p>但是呢，这是否意味着我们只要有一个可以成为答案的有效颜色就可以直接操作含有这个颜色的最小集合呢？这是不一定的，因为这个有效颜色不一定是我们目标中的有效颜色，即不一定等于我们最后一步操作的集合中有的颜色，当时赛时犯了这个错误。</p>
<p>那么正确的结论是怎样子的呢？</p>
<p>注意到一个事情，在游戏结束前，每种颜色至多存在一个，这启示我们其实可以不用访问过多的集合，可以直接访问原本计划在后面访问的集合，这感性上对称于原来方案的后半部分，不同的是，手里少了一些颜色，多了一些步数。因此我们期望能在后续通过步数换取回这些颜色，如果最后能够结束，那么我们没换回的颜色说明是用来卡我们的，那我们正好节省了他们对应的步数，如果全部换回来了，说明都需要，那也不劣，但问题是有可能我们去掉前面的访问，只执行后面的决策，后可能在决策结束时没办法使游戏结束，但这依旧是一个很好的想题方向，顺着这个方向想，我们或许可以得到下面的结论（“或许” 是因为我当时是通过错误的思路和证明想到该结论的，我实际上并不知道这道题目一个正常的、自然的思考过程，这上面的思考过程是我口胡的，但我个人感觉其实也不自然）：</p>
<p>我们认为最终的决策只会询问至多两个集合：一个集合询问数字，然后找到最后一个颜色所在的颜色数最少的集合然后狂问。</p>
<p>所以答案是询问一个集合的答案和询问两个集合的答案：两个集合每次选择一个集合</p>
<p>证明就考虑对于任意一个决策，如果不是</p>
<p>没清空栈 WA 了一发，唐完了。</p>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>A 一开始还想着容斥，后面发现竟然是直接计数？？？</p>
<p>先给树定根，注意到如果 $x,y$ 可以作为 meet room ，那么 $x,y$ 的 LCA 一定能作为 meet room ，所以一定存在一个最浅的 meet room ，在这个位置计数就行了。</p>
<p>注意到需要统计距离 $x$ 为 $L$ 的点的个数，以及 $x$ 子树内距离 $x$ 距离在 $L-c&lt;d\le L$ 的点的个数，$c$ 是到父亲的距离。</p>
<p>前者点分治，后者二维数点（在 DFS 序上的二维数点）。</p>
<p>计数的话，后者必须至少选一个点，这个是简单容斥，注意根节点可能需要额外处理一下，我的处理是让根节点的 $c=L+1$ 。</p>
<p>时间复杂度：$O(n\log^2 n)$ 。</p>
<p>和题解基本一致。</p>
<h1 id="Plan"><a href="#Plan" class="headerlink" title="Plan"></a>Plan</h1><p>剩余： G 的官方题解和 I 题解/官方题解。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>Milk Candy</title>
    <url>/2024/01/31/Milk-Candy/</url>
    <content><![CDATA[<p>题目链接：<a href="https://qoj.ac/contest/1386/problem/7580">https://qoj.ac/contest/1386/problem/7580</a></p>
<p>题目大意：</p>
<p>有 $n$ 个未知数字，有 $m$ 个商人，每个商人有 $c_i$ 个的线索，每个线索有个价格，同时线索内容为 $[l,r]$ 的数字的和，你可以向每个商人买线索，但是每个商人必须恰好买 $k_i$ 个线索，问最少需要多少钱才能知道所有未知数字。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>虽然赛时队长神力秒了，但是我来编一个比较自然的思考路线：前缀和。</p>
<p>设 $s$ 为前缀和数组，所以实际上就是要知道所有 $s_i-s_0$ 。</p>
<p>考虑每个线索实际上提供了 $s_r-s_{l-1}$ ，又 $(s_a-s_b)+(s_b-s_c)=(s_a-s_c)$ ，所以实际上就是 $r$ 与 $l-1$ 连边，最后问所有点是不是与 $0$ 联通，也就是 $n+1$ 个点的生成树。</p>
<p>问题等价于 $n+1$ 个点，然后有一些边，问符合要求的最小权连通图。</p>
<ol>
<li>第一个拟阵 ，图拟阵的对偶拟阵。</li>
<li>第二个拟阵 ，每个商人去掉的线索数量不超过 $c_i-k_i$ 。</li>
</ol>
<p>带权拟阵交。</p>
<p>时间复杂度：$O((n\sum c_i)^2)$ 。</p>
<p>记得特判图一开始是不是联通的，因为如果一开始就不联通，那么 $\emptyset\notin \mathcal{I}$ ，这与拟阵交一开始默认 $\emptyset \in \mathcal{I}$ 冲突。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">2e4</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,K,ans,ned;</span><br><span class="line"><span class="type">int</span> bel[N],cnt[N],lim[N];</span><br><span class="line">PII e[N];<span class="type">int</span> pri[N];</span><br><span class="line"><span class="type">bool</span> in[N];</span><br><span class="line"><span class="keyword">namespace</span> Union&#123;</span><br><span class="line">    <span class="type">int</span> fa[N];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=<span class="built_in">findfa</span>(fa[x]);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mer</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        x=<span class="built_in">findfa</span>(x);y=<span class="built_in">findfa</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(x!=y)fa[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> mov,<span class="type">int</span> add)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==mov)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i!=add &amp;&amp; in[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">mer</span>(e[i].first,e[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">findfa</span>(i)!=<span class="built_in">findfa</span>(<span class="number">0</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Union::pd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y,next;</span><br><span class="line">&#125;a[M];<span class="type">int</span> len,las[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;a[++len]=&#123;y,las[x]&#125;;las[x]=len;&#125;</span><br><span class="line"><span class="type">int</span> val[N],typ[N];PII d[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(las+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*K);</span><br><span class="line">    <span class="built_in">memset</span>(typ+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*K);</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;<span class="type">bool</span> v[N];</span><br><span class="line"><span class="type">int</span> pre[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)d[i]=&#123;-inf,-inf&#125;;</span><br><span class="line">    <span class="built_in">assert</span>(q.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(typ[i]&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            d[i]=&#123;val[i],<span class="number">0</span>&#125;;</span><br><span class="line">            v[i]=<span class="number">1</span>;</span><br><span class="line">            pre[i]=<span class="number">0</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        v[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=las[x];k;k=a[k].next)&#123;</span><br><span class="line">            <span class="type">int</span> y=a[k].y;</span><br><span class="line">            <span class="keyword">if</span>(PII&#123;d[x].first+val[y],d[x].second<span class="number">-1</span>&#125;&gt;d[y])&#123;</span><br><span class="line">                d[y]=PII&#123;d[x].first+val[y],d[x].second<span class="number">-1</span>&#125;;</span><br><span class="line">                pre[y]=x;</span><br><span class="line">                <span class="keyword">if</span>(!v[y])&#123;</span><br><span class="line">                    v[y]=<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    PII maxval=&#123;-inf,-inf&#125;;</span><br><span class="line">    <span class="type">int</span> endpoint=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((typ[i]&amp;<span class="number">2</span>) &amp;&amp; d[i]&gt;maxval)&#123;</span><br><span class="line">            maxval=d[i];</span><br><span class="line">            endpoint=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!endpoint)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ans-=maxval.first;ned--;</span><br><span class="line">    <span class="type">int</span> now=endpoint;</span><br><span class="line">    <span class="keyword">while</span>(now)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[now])cnt[bel[now]]--;</span><br><span class="line">        <span class="keyword">else</span> cnt[bel[now]]++;</span><br><span class="line">        in[now]^=<span class="number">1</span>;</span><br><span class="line">        now=pre[now];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!in[i])val[i]=pri[i];</span><br><span class="line">        <span class="keyword">else</span> val[i]=-pri[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(in[i])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=K;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(in[j])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">pd</span>(j,i))<span class="built_in">ins</span>(i,j);</span><br><span class="line">                <span class="keyword">if</span>(cnt[bel[j]]&lt;lim[bel[j]] || bel[i]==bel[j])<span class="built_in">ins</span>(j,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">pd</span>(i,<span class="number">-1</span>))typ[i]|=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(cnt[bel[i]]&lt;lim[bel[i]])typ[i]|=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        ans=ned=K=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(cnt,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;lim[i]);</span><br><span class="line">            lim[i]=x-lim[i];</span><br><span class="line">            ned+=lim[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=x;j++)&#123;</span><br><span class="line">                ++K;bel[K]=i;in[K]=<span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> l,r;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;pri[K]);</span><br><span class="line">                l--;</span><br><span class="line">                e[K]=&#123;l,r&#125;;</span><br><span class="line">                ans+=pri[K];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">pd</span>(<span class="number">-1</span>,<span class="number">-1</span>))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="built_in">build</span>();</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="built_in">solve</span>());</span><br><span class="line">        <span class="keyword">if</span>(ned)ans=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>拟阵</tag>
      </tags>
  </entry>
  <entry>
    <title>MS1+2 shell 学习笔记/shell使用技巧</title>
    <url>/2024/12/17/MS1-2-shell-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-shell%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Missing Semester 1 和 2 的学习笔记。</p>
<ol>
<li><p>Course View + the shell : <a href="https://missing.csail.mit.edu/2020/course-shell/">https://missing.csail.mit.edu/2020/course-shell/</a></p>
</li>
<li><p>Shell Tools and Scripting : <a href="https://missing.csail.mit.edu/2020/shell-tools/">https://missing.csail.mit.edu/2020/shell-tools/</a></p>
</li>
</ol>
<p>主要讲了一些适用于 Bash（MacOS 和 Linux 的 默认shell）的知识，当然很多概念在其他 shell 中也有，不过名字可能不同。</p>
<p>笔记中不止涉及到了课程中讲的内容，还有些内容自己搜索补充了一下：</p>
<p>Bash条件等语句：<a href="https://blog.csdn.net/ceshiren_com/article/details/141930133">https://blog.csdn.net/ceshiren_com/article/details/141930133</a></p>
<p>同时也懒得开一个新的文章了，干脆把其他的奇奇怪怪的 Bash 知识也放在这里了。</p>
<h1 id="Shell-使用技巧"><a href="#Shell-使用技巧" class="headerlink" title="Shell 使用技巧"></a>Shell 使用技巧</h1><p>主要在 1. Course View + the shell 介绍，第二章也介绍了一点。</p>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><ul>
<li><code>date</code> : 日期</li>
<li><code>echo</code> : 输出后续的内容，例如：<code>echo &quot;test&quot;</code></li>
<li><code>pwd</code> : 输出 cmd 现在的工作目录。</li>
<li><p><code>cd</code> : 进入某个文件夹，<code>cd ..</code> 进入上一级文件夹（可嵌套），<code>cd HOME</code> 到当前用户主文件夹，<code>cd ~</code> 去到根目录。</p>
<p><code>cd -</code> 会让你回到上一次所在的目录，这在需要在两个目录间反复切换时很好用。</p>
</li>
<li><p><code>ls</code> : 列出当前所有文件，<code>ls dir</code> 列出文件夹里面的所有文件和文件夹(不会递归)。</p>
<p><code>ls -l</code> 会列出文件夹内更加详尽的信息，左边的字符为：第一个字符是类型：$\text{d(文件夹)/-(文件)}$，后面有三组三个字符($\text{rwx}$)，分别代表拥有者、拥有组、所有人的权限：</p>
<p>| 符号 |文件| 文件夹 |<br>|:——:|:—-:|:———:|<br>|   -  | 没有对应权限 | 没有对应权限  |<br>|   r  | 读取权限 | 读取文件列表 |<br>|   w  | 写入权限 | 修改文件列表 |<br>|  x  | 执行 | 进入文件夹的权限（需要当前和所有父文件夹的 x 权限） |$</p>
<p>注：其实文件夹的权限可以看成是，对记录文件夹中文件信息的那个文件的权限。</p>
</li>
<li><p><code>man</code>$(\text{manual})$ : 查询某个指令的用法（如果这个指令有 manual 界面的话）</p>
</li>
<li><code>mkdir</code> : 创建文件夹</li>
<li><code>mv</code> : 移动文件，<code>mv source goal</code> ，如果 <code>goal</code> 是文件夹，则会移动到里面，如果不是，则会改名。</li>
<li><code>which</code> : 返回文件的路径</li>
<li><code>chmod</code> : 给某个文件加减权限，<code>chmod +x file</code> 给 file 加可执行的权限（在下一节课写脚本的时候会用到）。</li>
<li><code>cp</code>$(\text{copy})$ : 复制文件。</li>
<li><code>cat</code>$(\text{capture})$ : 获取文件中的内容。</li>
<li><code>touch</code> : 更新文件的更改时间为当前时间，不存在则创建一个空文件。</li>
<li><code>head/tail</code> : 输出输入的开头或者结尾，<code>-nk</code> 输出 $k$ 行。</li>
<li><code>sudo/#</code>$(\text{super do})$ : 用管理员权限进行某个指令。</li>
<li><code>find</code> : 寻找该文件夹中符合条件的文件或文件夹(会递归)。</li>
<li><code>locate</code> : 通过且只能通过文件名查找文件，查找速度更快，需要用 <code>updatedb</code> 维护数据库，<a href="https://unix.stackexchange.com/questions/60205/locate-vs-find-usage-pros-and-cons-of-each-other">与 <code>find</code> 更详细的对比</a>。</li>
<li><code>tee</code> : 将标准输入既输入到文件中，也输入到标准输出中。</li>
<li><code>rm/rmdir</code> : 移除文件/空文件夹。</li>
<li><code>curl</code>：访问给定的 URL 并返回结果。</li>
<li><code>tee</code>(T型管，一个进两个出)：从输入流读取输出到输出流和文件中。</li>
<li><code>cut</code>：切割输入流得到的内容。</li>
<li><code>xdg-open</code>：用合适的程序打开一个文件。</li>
<li><code>diff</code>：比较文件的不同。</li>
<li><code>source</code>：我目前只用它来加载过脚本。</li>
<li><code>env</code>：没怎么用过，但是在 shebang 行中使用可以提高脚本兼容性。</li>
<li><code>export</code>：也没怎么用过，好像是用来导出变量之类的东西。</li>
</ul>
<h2 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h2><p>一般每个进程都有三个主要的流：</p>
<ol>
<li>标准输入流(STDIN)，用于读入。</li>
<li>标准输出流(STDOUT)，输出结果</li>
<li><p>标准错误流(STDERR)，用于输出进程发生的错误。</p>
<ul>
<li><code>&lt;</code> : 重定义标准输入流。</li>
<li><code>&gt;</code> : 重定义标准输出流，输出前会清空目标文件，不存在则创建文件。(时间在所在命令执行之前，所以在某些指令中使用可能会涉及时机问题)。</li>
<li><code>&gt;&gt;</code> : 重定义标准输出流，输出时扩展目标文件内容，不会清空，不存在则创建文件。</li>
<li><code>|</code> : 将左边的标准输出作为右边的标准输入。</li>
<li>每个进程都有三个主要的文件描述符：$0$ 标准输入，$1$ 标准输出，$2$ 标准错误，所以可以用 <code>1&gt;/&gt;</code> 来重定向标准输出，<code>2&gt;</code> 重定向标准错误流，或者使用 <code>&amp;&gt;</code> 将标准输入或输出一起重定向（也可以 <code>&gt;file 2&gt;&amp;1</code> ）。</li>
</ul>
</li>
</ol>
<h2 id="表达式扩展"><a href="#表达式扩展" class="headerlink" title="表达式扩展"></a>表达式扩展</h2><p>通配符：<code>?/*</code> 匹配一个/任意多个字符。例如：文件夹中有 <code>bar,foo1,foo23</code> ，那么 <code>rm foo?</code> 删除 <code>foo1</code> ，<code>rm foo23</code> 删除 <code>foo1,foo23</code> 。</p>
<p>大括号：<code>&#123;&#125;</code> ，里面放上可能匹配的若干模式串，例如：<code>*.&#123;png,jpg&#125;</code> 用于匹配图片。</p>
<h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>command substitution：<code>$(CMD)</code> 会执行 CMD 然后将其输出替换掉这一部分。</p>
<p>process substitution: <code>&lt;(CMD)</code> 会执行 CMD 然后将其输出放在一个临时文件，将临时文件的名字替换掉这一部分。例如：<code>diff &lt;(ls d1) &lt;(ls d2)</code> 就必须用这个替换而不能用上面的，因为上面的部分会用输出替换掉 <code>$(ls d1)</code> ，然后这条指令就变成了比较两个文件夹内所有文件里的内容，然后就偏离预期了。</p>
<p>计算表达式：使用 <code>[]/[[]]</code> ，里面放表达式即可，两者的区别似乎是后者有更多语法但兼容性更差，具体区别 <a href="https://mywiki.wooledge.org/BashFAQ/031">here</a> 。</p>
<h2 id="一些简称"><a href="#一些简称" class="headerlink" title="一些简称"></a>一些简称</h2><ul>
<li><code>$PATH</code> : 所有环境变量，环境变量是系统在寻找可执行文件时会搜索的目录。</li>
<li><code>$HOME/~</code> : 表示用户的主文件夹 <code>/home/user</code></li>
<li><code>/</code> : 表示根目录，<code>ls /</code> 进入根目录，路径前面有没有 <code>/</code> 是区分相对路径和绝对路径的标志。</li>
</ul>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul>
<li><code>/sys</code> 文件夹中会将内核参数以文件的形式展现，通过修改这些文件可以起到配置某些系统功能的作用，例如用亮度之类的。</li>
<li><ul>
<li><code>/dev/null</code> ：可以理解为电子焚烧炉，不要的东西往里面丢就行了。</li>
</ul>
</li>
<li><code>C-l</code> 会让当前行到 shell 顶部，但并不会清空 shell ，他只会在前面填充大段的空白达到类似清空的效果。</li>
<li>命令行前的 <code>$</code> 表示现在处在用户环境，<code>#</code> 表示管理员环境，使用 <code>sudo su/exit</code> 进入/退出。</li>
<li><code>;</code> 隔开可以一行写多条指令。</li>
<li>命令后加 <code>\</code> 可以另开一行，<code>&#39;</code> 可以开多行(在输入 <code>&#39;</code> 结束)，<code>;</code> 可以一行输入多个命令。</li>
</ul>
<h1 id="Bash-脚本"><a href="#Bash-脚本" class="headerlink" title="Bash 脚本"></a>Bash 脚本</h1><p>主要在 2. Shell Tools and Scripting 介绍。</p>
<p>Shell 中和在脚本中能使用的语法基本一样，这里主要介绍一般只会（不是只能）在脚本中使用的语法。</p>
<h2 id="杂项-1"><a href="#杂项-1" class="headerlink" title="杂项"></a>杂项</h2><p>变量：<code>foo=bar</code>，这样会得到一个值为字符串 <code>bar</code> 的变量 <code>foo</code>，<code>$foo</code> 引用该变量。</p>
<p>shebang 行 ：在脚本的第一行，用于标明这个脚本使用的执行程序。例如一般 Bash 脚本的 shebang 行：<code>#!/bin/bash</code> 。</p>
<p>使用 <code>env</code> 来写 shebang 行可以提高脚本兼容性，例：<code>#!/usr/bin/env python</code> ，会让程序使用 <code>env</code> 去 Path 中寻找 Python 的可执行程序作为这个脚本的执行程序。</p>
<p><code>source A</code> 会让 CMD 加载脚本 A ，这会运行其中的指令，和 <code>./A</code> 的区别在于，前者在当前环境，而后者是新开了一个环境，所以脚本中如果有 <code>cd</code> 之类的指令，前者会影响当前 shell ，后者不会，包括定义的函数和参数也是。</p>
<h2 id="条件-循环语句"><a href="#条件-循环语句" class="headerlink" title="条件/循环语句"></a>条件/循环语句</h2><p>条件语句：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ expression_1 ] &amp;&amp; [expression_2] ;</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">statements</span><br><span class="line"><span class="keyword">elif</span> [ expression_3 ] || [expression_4] ;</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">statements</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">statements</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># true/false 会一直返回对应的布尔值</span></span><br></pre></td></tr></table></figure>
<p>for循环语句：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> variable <span class="keyword">in</span> list</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#或</span></span><br><span class="line"><span class="keyword">for</span> (( expression1; expression2; expression3 )) <span class="comment">#Ex:for ((i=1; i&lt;=10; i++))</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>while循环：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> [ expression ];</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">commands;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>函数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">function_name</span></span>() &#123;</span><br><span class="line">  commands</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="特殊含义的参数"><a href="#特殊含义的参数" class="headerlink" title="特殊含义的参数"></a>特殊含义的参数</h2><ul>
<li><code>$0</code>：脚本名。</li>
<li><code>$1</code> to <code>$9</code>：给脚本的第 $i$ 个参数。</li>
<li><code>$@</code>：所有参数。</li>
<li><code>$#</code>：参数数量。</li>
<li><code>$?</code>：上一条命令的返回代码（在这个参数使用前的上一条命令，不是脚本前的）。</li>
<li><code>$$</code>：当前脚本的进程标识数(PID)。</li>
<li><code>!!</code>：上一条完整的指令，包括参数。（一种用处，在上一条指令因为权限不够执行失败时，用管理员再执行一次）</li>
<li><code>$_</code>：上一条的最后一个参数。</li>
</ul>
<h2 id="工具-扩展推荐"><a href="#工具-扩展推荐" class="headerlink" title="工具/扩展推荐"></a>工具/扩展推荐</h2><ul>
<li>shellcheck (<a href="https://github.com/koalaman/shellcheck)：检查你的">https://github.com/koalaman/shellcheck)：检查你的</a> Bash 脚本的语法错误。</li>
<li>TLDR (<a href="https://tldr.sh/)：简化版的">https://tldr.sh/)：简化版的</a> <code>man</code> ，会提供所查询指令的一些比较常用的用法。</li>
<li>fd (<a href="https://github.com/sharkdp/fd)：语法更加人性化的">https://github.com/sharkdp/fd)：语法更加人性化的</a> <code>find</code> 。</li>
<li>locate ()</li>
</ul>
<h1 id="目前进度"><a href="#目前进度" class="headerlink" title="目前进度"></a>目前进度</h1><p>第一课 note + 视频完成。</p>
<p>第二课 note 和视频都没完成。</p>
]]></content>
      <categories>
        <category>CS学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Missing Semester 学习笔记</title>
    <url>/2024/12/02/Missing-Semester-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="7-Debugging-and-Profiling"><a href="#7-Debugging-and-Profiling" class="headerlink" title="7. Debugging and Profiling"></a>7. Debugging and Profiling</h1><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul>
<li>使用颜色高亮输出，以更方便的获取信息，比如日志中使用不同颜色高亮不同严重程度的信息。</li>
<li>在大多数的 UNIX 系统，日志通常放在 <code>/var/log</code> 下。</li>
<li><code>logger</code>(shell 指令) :  可以用来记录日志，例如：<code>logger &quot;Hello&quot;</code> 可以将 <code>Hello</code> 记录在系统日志中。</li>
<li><code>time</code>(shell 指令) : 计算程序运行所花的三种时间。</li>
<li><code>strace</code>(shell 指令) : UNIX 系统上操作分为两种，用户级代码(user level code)，内核级代码(kernel level code) ，该指令可以追踪程序执行了那些系统调用。</li>
<li><code>tac</code>(shell 指令) : (<code>cat</code> 反过来写) 读取文件并从下往上输出，在 shell 可以免去翻滚看顶部的苦恼。</li>
<li><code>perf</code>(shell 指令) : 分析程序表现，比如执行了多少个 CPU 时钟等等。</li>
</ul>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>调试方式：</p>
<ul>
<li>printf debugging : 在代码中插入输出语句输出需要的信息进行调试。</li>
<li>logging : 使用日志进行调试。优点：可以定义严重性程度，并进行过滤；</li>
<li>调试器调试 : 比较大的错误不如上面两者，效率比较低，但是对于某些错误使用这个方法有奇效，比如比较短的代码发生 Runtime error。</li>
<li>静态分析工具：以源代码为输入，输出可能有问题的部分。（有英语的静态分析工具，狂喜）</li>
</ul>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>实际时间(real)：代码运行的实际时间<br>用户时间(user)：执行用户级指令所花的时间。<br>系统时间(sys)：执行内核指令所花的时间。</p>
<p>例子：</p>
<ol>
<li><code>sleep x</code> 的实际时间不是 x 秒，会有些误差，很好理解，有别的程序在占用程序资源，导致实际时间大于理论实践，且会浮动。</li>
<li><code>time curl URL</code>(URL是某个网站) 得到 $real=x,user=y,sys=z$ ，则实际本机执行命令时间为 $y+z$ ，而在等待网站响应等其他事情上花了 $x-(y+z)$ 。</li>
</ol>
<p>分析方式：</p>
<ul>
<li>printf profiling : 获取每段代码前后两个时间点，作差输出时间差得到运行时间，得到代码运行的实际时间。</li>
<li>分析器：分为跟踪分析和采样分析，跟踪分析：跟着程序一起执行，返回每个部分的时间（因此会影响程序的性能，会得到偏差的数据）。采样分析：执行一段时间终止程序，根据堆栈等信息返回程序现在的位置。</li>
</ul>
<h1 id="8-Metaprogramming"><a href="#8-Metaprogramming" class="headerlink" title="8. Metaprogramming"></a>8. Metaprogramming</h1><p>标题欺诈，实际是将软件开发流程的。</p>
<h2 id="构建系统"><a href="#构建系统" class="headerlink" title="构建系统"></a>构建系统</h2><p>为了得到一个文件，有时候会执行一系列的指令，使用某些工具可以自动化这个过程，甚至减少构建过程中的工作量，加快构建之间，比如 : <code>make</code> ，配置 $\text{makefile}$ 文件可以自动化执行指令并生成一些列你需要的文件，其会自动执行指令、寻找执行指令需要的依赖项和避免不必要的工作（比如依赖项没变，就不执行命令生成一个一样的文件）。</p>
<h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>在编写版本号时，一个可行的版本号设计是 <code>x.y.date</code> 其中 $\text{x,y}$ 是版本号，$\text{date}$ 是日期，这样的版本号有个问题，以编写函数库为例子，现在有三种更新：</p>
<ol>
<li>打补丁，补漏洞。</li>
<li>添加新的功能。</li>
<li>减少功能、重命名功能。</li>
</ol>
<p>$\text{1}$ 对依赖的影响最小，甚至如果用到的特性与补丁漏洞无关，用低版本没有任何区别，$\text{2}$ 不具有向前兼容性，旧版本无法适应高版本，$\text{3}$ 则不具有向后兼容性，依赖低版本的软件在高版本中使用。因此，如果不在版本号中对这三者加以区分，可能会使使用者十分痛苦，也就是无法根据版本号看出哪些版本可能是兼容的（兼容是十分重要的，如果每个软件都依赖一个库的特定版本，不兼容其他版本，那为了同时运行这些软件就要下很多个版本的同一个库，这显然是痛苦的）。</p>
<p>比如都是小的版本号，$\text{1.0}\to\text{1.1}$ 修改了补丁，而 $\text{1.1}\to\text{1.2}$ 增加了新的特性，可能会让使用软件的人疑惑，为啥依赖 $\text{1.1}$ 的可以依赖于 $\text{1.0}$ ，而依赖 $\text{1.2}$ 的则无法向前兼容。所以使用者很难根据版本号，推断出哪些版本是能够兼容的。</p>
<p>因此一个方法是采用 <code>x.y.z</code> ，$\text{x}$ 表示破坏向后兼容的更新，$\text{y}$ 表示破坏向前兼容的更新，$\text{z}$ 则是补丁，Python 的版本号就遵循类似的规则。</p>
<h3 id="锁定文件"><a href="#锁定文件" class="headerlink" title="锁定文件"></a>锁定文件</h3><p>在构建依赖关系的时候，锁定某个文件在某个版本或者某个状态。</p>
<p>好处：</p>
<ol>
<li>加快构建时间，不用每次构建都更新这个文件（构建系统可能会每次更新所需的依赖项）或者更新状态。</li>
<li>将软件锁定在某个状态，比如和安全有关的软件，可能因为依赖项更新所产生的安全漏洞，而导致软件的不安全。</li>
</ol>
<p>坏处：失去更新依赖项新版本的好处，比如新版本修复了一个安全漏洞等等。</p>
<h3 id="持续集成-Continuous-Integration-CI"><a href="#持续集成-Continuous-Integration-CI" class="headerlink" title="持续集成(Continuous Integration/CI)"></a>持续集成(Continuous Integration/CI)</h3><p>本质上是云构建系统，将构建系统存储在网上，对项目进行构建，持续集成可以干很多事情，一个经典的操作是将系统设置为条件触发，在触发条件后，执行一系列指令。</p>
<p>网上有很多持续集成的服务，例如 : Github Action，dependabot（一个能在依赖项更新时提醒你更新的工具，也就是说持续集成可能在项目没有发生任何改变的时候也有可能触发，总之触发条件可以各种各样，十分灵活）。</p>
<p>在将持续集成嵌入项目中时，可以设置该持续集成项目提供的徽章来表明你设置了这个服务，下面是视频中的例子。</p>
<p><img src="1.png" alt=""></p>
<p>还有一个例子是我现在就在用的 Github Pages，将用户上传的 Markdown 文件通过 Jekyll 解析为 HTML 文件并且部署在 Github 提供的子域名上形成静态网站。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>讲了些术语。</p>
<p>测试套件：程序所有测试的简称。</p>
<p>单元测试：通常是比较小的，自包含的测试，用来测试某项特定的功能</p>
<p>集成测试：测试程序不同子系统间的交互。</p>
<p>回归测试：在发现 BUG 并修复后，将测试该 BUG 的测试加入到测试中防止未来再次发生。</p>
<p>模拟(mocking)：用虚拟的方式替换掉某些部分，起到检测特定功能的目的，比如测试 SSH 进行文件拷贝的工具时，可以将 SSH 的部分改成另外一个模拟函数，正常的输入输出，让其余部分认为这一部分在正常工作，这样就可以专门测试文件拷贝的部分。</p>
<h1 id="Security-and-Cryptography"><a href="#Security-and-Cryptography" class="headerlink" title="Security and Cryptography"></a>Security and Cryptography</h1><h2 id="熵与密码"><a href="#熵与密码" class="headerlink" title="熵与密码"></a>熵与密码</h2><p>这里的熵指信息量，以 bit 为单位，计算公式为：$\log_{2}{p}$ ，其中 $p$ 表示可能性，比如投硬币只有正反两面，所以是 $\log_{2}{2}=1$ 表示 $1\text{bit}$ 的可能性。</p>
<p>而在平时设计密码的时候，根据设计密码的逻辑不同，对应的密码会有一定的熵，熵越高的密码理论上越难暴力破解，因为要尝试更多的可能性。同时给出了些数据，如果网站有一定保护，比如在密码错误若干次后会锁住一段时间之类的机制，则熵在 $40\text{bit}$ 左右就比较强了，但是如果没有，则要升到 $80\text{bit}$ 左右。</p>
<p>同时讲了些比较强的密码生成规则，比如给一个字典，然后每次随机几个单词作为密码，那就有 $\text{单词数量}^{随即次数}$ 种可能，又或者将一句话中比较像数字的字母替换成数字，然后末尾加些标点符号之类的东西。</p>
<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希函数打 OI 的再熟悉不过了，具体来说，是一个将任意输入变成固定长度输出的一个函数，具有以下性质：</p>
<ol>
<li>不可逆性，不能从输出倒退输入。</li>
<li>结果确定，同一个输入只会有一个输出。</li>
<li>抗碰撞性，很难构造具有同样输出的输入。（一般来说，根据需求，对抗碰撞性的强弱要求会有所不同，比如加密哈希函数的抗碰撞性要求会比较高）</li>
</ol>
<p><code>sha1sum</code>(shell指令)：从标准输入流读入并用 SHA1 算法输出加密结果。</p>
<p>用途：</p>
<ol>
<li>生成存储地址，例如 git ，根据内容用哈希函数生成唯一的存储地址，可想而知，这对抗碰撞性的要求很高。</li>
<li>验证文件，给文件生成哈希值，在下载时对比确定下载的就是目标文件。</li>
<li>承诺方案，在进行类似猜你心中在想哪个数字之类的事情时，可以先把所猜数字的哈希值公布，然后在结束后验证结果，当然，可以采用某些手段来防止暴力试出结果，比如在加密前加入一些显然不会干扰验证的话：5 is the answer. 之类的。</li>
<li>验证密码，数据库存储密码的哈希值，防止数据库泄露的时候直接泄露原密码，降低损失。</li>
</ol>
<h3 id="密钥生成函数-key-derivation-functions-KDFs"><a href="#密钥生成函数-key-derivation-functions-KDFs" class="headerlink" title="密钥生成函数(key derivation functions,KDFs)"></a>密钥生成函数(key derivation functions,KDFs)</h3><p>哈希函数的变种，但有个额外的特性：计算速度较慢。</p>
<p>用途：用来加密密码，来每次验证单个用户不会有明显的速度感觉，但是如果在破解的时候，涉及到大量的加密操作时，就会明显降低破解速度。</p>
<h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>主要有以下三个函数：</p>
<p>密钥生成函数(key gen)：随机或者按照某个规则生成密钥</p>
<p>加密函数：给出明文和密钥，生成密文。</p>
<p>解密函数：给出密文和密钥，生成明文。</p>
<p>如果怕忘记密钥，可以用口令生成密钥，类似密码那样，但是要考虑强度问题，可能通过暴力尝试口令尝试所有密钥，所以要类似密码那样考虑可能性的问题。</p>
<p><code>openssl</code>(shell指令)：加密解密内容，可指定算法。</p>
<p>用途：在自己保留密钥的情况下，加密自己的文件防止被查看，比如上传到不信任的公共空间或者云盘上等，或者在私底下交换了密钥后，公开和别人进行加密通信。</p>
<p>一种可能的破解方式：彩虹表，存储大量密文对应的明文，然后查询破解。</p>
<p>应对手段：撒盐，给加密过程加上一些外部的随机因素，例如，外部加入一段随机出来的固定的字符串在文件末尾参与加密，这样原信息就不会因为收录在彩虹表中而导致破解。</p>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>密钥生成函数：生成公钥和私钥。</p>
<p>加密函数：给出明文和公钥，生成密文。</p>
<p>解密函数：给出密文和私钥，生成明文。</p>
<p>好处：可以公开公钥，让别人用公钥加密，发送给持有私钥的人，可以用于加密通信。</p>
<p>用处：</p>
<ol>
<li>数字签名，签名者用私钥加密，然后公开公钥，发送密文，别人可用公钥解密验证身份，没有私钥的人无法伪造签名。</li>
<li>加密通信，只要互相公开公钥，就可以进行加密通信。</li>
<li>git也有类似的签名操作，但是我没看懂，相关的操作是 <code>tag</code> 。</li>
</ol>
<p>密钥分发(key distribution)：如何确保别人得到的是我的公钥，而不是别人的公钥。（感觉这个翻译成密钥有点奇怪，感觉应该是公钥）</p>
<p>一些方法：</p>
<ol>
<li>非网络渠道交换，比如线下交换。</li>
<li>由第三方平台的安全性保障，比如加密通信平台 Signal 的安全性就是由其服务器安全性保证。</li>
<li>社会证明，将公钥和一系列社交平台用户绑定，只要没有一次性大量平台的账号被黑，就能确保公钥的安全性，一个对应的网站叫 keybase.io 。</li>
</ol>
<p>对应的一个更加宏大的问题是</p>
<p>引导问题：通常指在没有预共享密钥和信任基础的情况下建立安全通信渠道的问题。</p>
<h2 id="混合加密技术"><a href="#混合加密技术" class="headerlink" title="混合加密技术"></a>混合加密技术</h2><p>非对称加密比较慢，但是对称加密比较快，有没有综合两者优点的方法，对应的就是混合加密技术。</p>
<p>用密钥对称加密源文件，再用非对称加密加密密钥，然后将加密后的密钥和密文发送过去，就可以综合两者的有点。</p>
<h2 id="威胁模型-Threat-Modeling"><a href="#威胁模型-Threat-Modeling" class="headerlink" title="威胁模型(Threat Modeling)"></a>威胁模型(Threat Modeling)</h2><p>课上提到，去搜了一下，大概是说：</p>
<p>在构建安全方案之前，先建立对应的问题模型，为安全设置合适的目标，比如假定现在服务器是安全的，而可能产生问题的是哪些环节，可能的攻击者是哪些，他们可能采取什么手段进行攻击等等。</p>
<h1 id="大杂烩-Potpourri"><a href="#大杂烩-Potpourri" class="headerlink" title="大杂烩(Potpourri)"></a>大杂烩(Potpourri)</h1><p>介绍了很多概念，以及一些可能会用到的计算机工具（涉及的软件可能需要自行寻找）。</p>
<h2 id="Key-mapping"><a href="#Key-mapping" class="headerlink" title="Key mapping"></a>Key mapping</h2><p>将键盘上的操作映射到一些别的操作，下面是一些具体的例子：</p>
<ol>
<li>将一个键或组合按键映射到另外一个键。</li>
<li>将一个键或组合按键映射到一个具体的计算机操作，类似快捷键那样，例如打开一个浏览器窗口或者粘贴某段具体的文本。</li>
<li>用键盘序列去映射到某个具体的操作，具体来说就是一连串的按键产生具体操作，例如 tmux 中 C-A 再 C-B 会对应着一个操作。</li>
<li>一个按键在不同状态下对应不同的操作，例如将 CapsLock 在短按状态下对应 Esc，长按状态下 Ctrl 。</li>
</ol>
<h2 id="守护进程-daemons"><a href="#守护进程-daemons" class="headerlink" title="守护进程(daemons)"></a>守护进程(daemons)</h2><p>在后台运行，在系统启动运行到系统结束，或者在某种条件下运行的进程。</p>
<p>系统中通常有个大的系统守护进程，用来管理系统中的所有守护进程，例如：Linux 中的 systemd 。</p>
<p><code>systemctl</code>(shell指令)：用来查询现在执行的所有守护进程的状态。</p>
<p>注：系统守护进程通常以 ‘d’ 结尾，例如：sshd, systemd 。</p>
<h2 id="文件系统-file-system"><a href="#文件系统-file-system" class="headerlink" title="文件系统(file system)"></a>文件系统(file system)</h2><p>通常执行一个文件操作的时候，用户层面会将操作发送到内核，然后内核先判断对应的文件处在哪个文件系统（现在的文件系统可以模块化使用，也就是可以使用多个文件系统），再根据内置的文件系统去执行相应的操作，一个坏处是，我们无法在中间插入用户操作。</p>
<p>FUSE 文件系统允许用户在文件操作时插入用户操作，所以有一些很酷的操作：</p>
<ol>
<li>在每次创建文件时发送一封邮件。</li>
<li>将每次的文件操作都链到远程服务器，这样就相当于将远程服务器作为一个本地的一个文件夹。</li>
<li>在文件操作时加密或解密对应的内容，这样在将磁盘取出置于另外一个文件系统时，看到的就是加密文件了。</li>
</ol>
<p>备份，课上提到了很多很有意思的备份观点。</p>
<ol>
<li>备份时考虑攻击者需要什么样的信息，才能将数据删除，从而采取不同的备份方式，例如：离线存储、云上存储等等。</li>
<li>一些远程服务器的数据本地可能没有备份，比如邮件，如果账号丢失，封禁等等，数据就直接丢失了，有一些工具可以储存这些东西。</li>
</ol>
<h2 id="接口-API"><a href="#接口-API" class="headerlink" title="接口(API)"></a>接口(API)</h2><p>在使用一些服务的时候，这些服务会提供一些 API ，方便我们与服务交互，获取数据或者执行操作之类的。</p>
<p>一个例子就是：有些网站可以通过访问 URL 的方式，根据 URL 中填写的参数，服务器会响应并返回结果。</p>
<p><code>curl</code>(shell执行)：访问 URL 并返回结果。</p>
<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>在涉及到需要文件名作为参数的时候，可以用 <code>-</code> 作为标准输入/输出的代称。</p>
<p>在一些指令时，我们希望某些参数不要被识别为选项或者标志，例如我们像删除名叫 -r 的文件，但 rm 会将其视为选项，一个方法是 <code>--</code> ，会让命令将之后的所有东西都不识别为选项，前面的例子就是：<code>rm -- -r</code> 。</p>
<h2 id="窗口管理器"><a href="#窗口管理器" class="headerlink" title="窗口管理器"></a>窗口管理器</h2><p>我们比较常用的是浮动窗口管理器，好处是简单易上手，有一些别的窗口管理器以效率为主。</p>
<p>例如平铺窗口管理器，会将窗口填满整个总空间，类似于 tmux 那样，可以通过快捷键快速在窗口间切换。</p>
<h2 id="虚拟专用网络-VPN"><a href="#虚拟专用网络-VPN" class="headerlink" title="虚拟专用网络(VPN)"></a>虚拟专用网络(VPN)</h2><p>一个经典的操作是，更改网络服务提供商。</p>
<p>但如果目的是安全性，这未必安全，因为只是将信任主体从网络提供商变成了 VPN 提供商而已，他们可以监视你的流量。</p>
<h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><p>一种标识文本的语言，太熟悉了。</p>
<h2 id="Hammerspoon"><a href="#Hammerspoon" class="headerlink" title="Hammerspoon"></a>Hammerspoon</h2><p>MacOS的窗口管理工具，可以与操作系统进行交互实现一些很酷的操作，其他操作系统应该有类似的功能。</p>
<p>可以通过 Lua 语言编写脚本，与显示管理、文件系统、电池等各种操作系统管理的东西交互。</p>
<p>例如：</p>
<ol>
<li>执行键盘映射。</li>
<li>用快捷键进行窗口布局。</li>
<li>在窗口创建一个小菜单，上面提供一些会执行预设好的操作的选项。</li>
<li>识别所处 Wi-Fi 环境，如果不是家中则静音防止外放。</li>
</ol>
<h2 id="Live-USB"><a href="#Live-USB" class="headerlink" title="Live USB"></a>Live USB</h2><p>电脑通常会配有一个 BIOS 系统用来在开机时启动系统，在开机时根据电脑的不同可以按不同的按键进入这个系统，来配置一些系统相关的东西，如果要在电脑上安装系统甚至多系统，应该对这个东西很熟。</p>
<p>而 Live USB 是将操作系统和软件安装在 USB 上的一个工具，电脑在插入 Live USB 后，可以在 BIOS 上选择启动 Live USB 上的操作系统，来对计算机上的文件进行操作，例如计算机安装系统失败了等等，都可以用这种方式来补救。</p>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>用软件创造一个孤立的环境运行一个独立的操作系统，在这儿操作系统上隔离的执行一些操作防止影响到主机。</p>
<p>还有一些类似思想的工具，例如 Docker ，在不安装系统的情况下，配备相应环境并运行该系统下的软件，比较轻量级。</p>
<h2 id="笔记本编程环境"><a href="#笔记本编程环境" class="headerlink" title="笔记本编程环境"></a>笔记本编程环境</h2><p>这个比较抽象，大概是说可以将编程界面变得更加交互，例如一个叫 Jupyter notebook 的编程软件，可以分段式的运行 Python 代码，逐渐的构建起程序，听老师说在机器学习中会用到？不懂。</p>
<h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><p>主要讲了如何给 github 的项目做贡献。</p>
<ol>
<li>issue ，也就是反馈 BUG 或者是问题。</li>
<li>pr(pull request) ，提供具体的代码给管理者。一般流程是将仓库克隆到本地，做出修改，提高 pr ，然后和管理者交流，管理者认同后将提交合并到主仓库。</li>
</ol>
<h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><p>C-o 跳转到上次停留的位置</p>
<p>d/{string} 搜索是个名词</p>
<p>C-i</p>
<p>:eariler</p>
<p>撤销记录</p>
]]></content>
      <categories>
        <category>CS学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>NCPC-2020 with some BAPC/UKIEPC 2020 赛后小结</title>
    <url>/2024/07/03/NCPC-2020-with-some-BAPC-UKIEPC-2020-%E8%B5%9B%E5%90%8E%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：NCPC-2020 with some BAPC/UKIEPC 2020</p>
<p>前期，B,G 队友秒了，K 不难，但是我和队友交流了一会，得出了必须写高精度的结论，上去写，写完后发现结论有点问题，下来改了又上去写，然后才过了。</p>
<p>感觉最大的问题在于结论错了一次，其余没有犯什么大的罪。</p>
<p>但是呢，在看了最短的代码，发现我实际上实现糟糕了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://qoj.ac/submission/191620</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,v,x,m,b,A[<span class="number">1</span>&lt;&lt;<span class="number">20</span>],k;</span><br><span class="line">string s,t;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;s&gt;&gt;t;</span><br><span class="line">	<span class="keyword">if</span>(s.<span class="built_in">size</span>()&lt;t.<span class="built_in">size</span>())</span><br><span class="line">		<span class="built_in">swap</span>(s,t);</span><br><span class="line">	<span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>()),<span class="built_in">reverse</span>(t.<span class="built_in">begin</span>(),t.<span class="built_in">end</span>()),n=s.<span class="built_in">size</span>(),s=<span class="string">&#x27; &#x27;</span>+s,t=<span class="string">&#x27; &#x27;</span>+t+<span class="built_in">string</span>(n-t.<span class="built_in">size</span>(),<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		x+=s[i]-<span class="string">&#x27;0&#x27;</span>+t[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(x&gt;<span class="number">9</span>)</span><br><span class="line">			m=i;</span><br><span class="line">		x/=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		<span class="keyword">if</span>(s[i]&gt;t[i])</span><br><span class="line">			v=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(s[i]&lt;t[i])</span><br><span class="line">			v=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(!v)</span><br><span class="line">		<span class="built_in">swap</span>(s,t);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		A[i]=(b-s[i]+<span class="string">&#x27;0&#x27;</span>)%<span class="number">10</span>;</span><br><span class="line">		<span class="keyword">if</span>(A[i]&lt;<span class="number">0</span>)</span><br><span class="line">			b=<span class="number">-1</span>,A[i]+=<span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		<span class="keyword">if</span>(A[i])</span><br><span class="line">			k=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=k;i;i--)</span><br><span class="line">		cout&lt;&lt;A[i]; </span><br><span class="line">	<span class="keyword">if</span>(!k)</span><br><span class="line">		cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到就是找到最大的符合条件的 $k$ ，然后求出：$10^{k}-(a\mod 10^k)$ ，或者是 $b$ ，而这个位置我们是用 $a,b$ 分别与 $a+b$ 比较去找的，但实际上这个位置就是 $a+b$ 最后一次发生进位的位置。</p>
<p>为啥呢，设 $a=a_n…a_5a_4a_3a_2a_1a_0,b=b_n…b_5b_4b_3b_2b_1b_0$ ，从低位到高位。</p>
<p>如果第 $i$ 位进位了，说明 $a_{i}…a_{0}+b_{i}…b_{0}\ge 10^{i+1}$ ，所以操作的时候不让 $a$ 或者 $b$ 在第 $i$ 位进位，$a+b$ 就一定会在第 $i$ 位进位，所以直接操作 $a,b$ 中的一个让其进位就行了，而且由于 $a_{i}…a_{0}+b_{i}…b_{0}\ge 10^{i+1}$ ，所以另外一个不会退位，所以这一定是合法的，因此这是最优的，就做完了。</p>
<p>但你要说这是我们策略上的问题吗？我觉得不是，只是我们菜了。</p>
<p>C,D 队友秒了，但是这个时候队长上 I 了，我觉得比赛时可以炸，但是中期开炸我觉得很不合理，队长记大过一次，虽然最后过了，但是这个决策确实浪费了很多时间。</p>
<p>反正我觉得很多时候卡题了不如直接跳，逻辑是什么呢？首先红了以后效率会降低，其次可能会错失一些其余机会，比如某个题你很擅长，在干完其余事后头脑清醒了，再回来调试或许效率会更高点。</p>
<p>或者这么说，我个人认为，激进一点就是直接跳，赌跳的收益会比调的收益高，稳健点就调试，都已经会了，只要做法假了，期望的调的时间不会很长，当然，至于两种策略谁激进谁稳健，最终都要根据实际情况来定，不能一概而论。</p>
<p> J 板子，抄了个板子过了。</p>
<p> F 队长神力，将前面的犯罪都弥补了，E 队友神力，队长还秒了个 H 。</p>
<p>那 fw 的我在干嘛呢？我在构造 L ，然后提出一个做法假一个做法，在最后都没有过。</p>
<p>最后来看，总体上而言，过不了 A,L 是实力问题，大的决策问题只有队长的 I 。</p>
<p>但实际上呢？我前期啥事没干，后期构造了半个比赛。</p>
<p>首先，我认为那个构造时间长还没做出来是实力问题，但是前期我其实在偷偷犯罪，我看到 A 的第一眼，我就觉得这是道好题，就很想把他做出来，在想了半天后，发现其不是 dp 而是模拟后，就已经意识到最后的代码可能很难写了。</p>
<p>后面的大部分时间，我一直都在想 A 怎么快速的判断一个方案是合法的，到我开始拿起 L 的时候都没搞出来。</p>
<p>最后在赛后做出来 A 后回头来看，A 或许不难，但也绝对没有这么简单，更别提我当时方向错了，这道题目得先猜出答案再做，而我当时一直在想怎么快速判断一个方案是合法的。</p>
<p>首先，榜上大部分情况下就是可以反映实际的难度，我深刻检讨，或许是在之前的比赛做出来了几道少人的题目，让我以为我在某些题目特别擅长，超过了我自己的平均水平，导致这场比赛直接莽 A 了，但结合所以比赛来看，前面几场就是意外，实际比赛中基本不会发生这种情况，就得一步一个脚印。</p>
<p>其次，我当时还有点私心，我觉得这个题目非常的好，很想自己做出来，但 ACM 是个团队比赛，除非你有超人的能力，否则纯凭个人力量是没法打出好的名次的，团队赛要注重的是配合，如果我那么想独立做题，就应该平时自己多加训，而不是赛时直接去莽题。深刻检讨我自己，希望以后不要在比赛时犯这种错误，多和队友合作交流。</p>
<p>再回头来看 A ，我当时实际上并没有发现答案的一个下界，也没有发现答案就是下界，也没有想出快速模拟的方法，而是一直在想只知道每个区间操作了多少次能否快速判断，这很 ATcoder ，ATcoder 中很多 1000 的题目就是这么做的，所以赛时我没有做出来。</p>
<p>回头来看，这道题目实际就是找下界，证明是下界，然后模拟，如果要快点，就用数据结构加速模拟。不是特别难，是能做的题目，但是我当时的思维就限制在 ATcoder 类型的题目上面，导致根本没有想到，这启示我要多开阔思维，不要把思维局限在某一类方法上。</p>
<p>还记得 NOI D1T2 我就是因为这个原因寄掉的，希望未来不会出现重蹈覆辙的情况，ATcoder 上的题目终究只是一类题目，不能代表所有题目，要想思维开阔要广刷题，多刷题，不能只刷 ATcoder 的题目，我也不能呆在舒适圈里，要多去做些别的题库的题，感受不一样的风格，这样才能变强。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>NCPC 2020 L. Languages</title>
    <url>/2024/07/01/NCPC-2020-L-Languages/</url>
    <content><![CDATA[<p>题目链接：<a href="https://qoj.ac/contest/531/problem/886">https://qoj.ac/contest/531/problem/886</a></p>
<p>题目大意：给你一个矩阵，每个位置为 $1/2$ ，分别表示恰有一种颜色，和 $\ge 2$ 种颜色。</p>
<p>要求给出三种颜色的染色方案，满足符合上面的矩形，且单个染色是联通的。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>说来话长，特判掉没有 $2$ ，$n=1$ 和 $m=1$ 的情况。</p>
<p>然后假设每行都有一个 $2$ ，那么两种颜色就够了，奇偶行分别主要染不同的颜色，次要染不同的颜色。（表示 $1/2$ 分别染什么颜色，$1$ 染主要颜色 ，$2$ 主要次要都染）</p>
<p>假设有一个行没有 $2$ ，很自然的想把这一行作为枢纽，用来连接所有的 $0$ ，然后上面主要为 $1$ ，下面主要为 $2$ 。</p>
<p>具体来说，不妨只看单侧，即假设这一行为最后一行：</p>
<p>一种自然的想法是，如果这一列有 $2$ ，那么整一列主要染 $0$ ，次要染 $1$ ，但是这样如果相邻列都有 $2$ ，$1$ 就不连通了，因此会想这种情况下就让下一列主要染 $1$ ，次要染 $0$ 就行了。</p>
<p>综上得到做法，若某列有 $2$ ，先把这一列全部先染个 $0$ ，同时如果下一列相邻格子也有 $2$ ，就把这个格子也染成 $2$ ，然后跳过下一列，染完后，如果一个格子为 $2$ 或者没染过色，就染 $1$ ，对两边分别做一次就行了。</p>
<p>时间复杂度：$O(nm)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">	cin &gt;&gt; ss;</span><br><span class="line">	<span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(ss) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> type;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> a[N][N], tmp[N][N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">bool</span> be[<span class="number">3</span>][N][N];</span><br><span class="line"><span class="type">bool</span> vr[N], vc[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	vector&lt;PII&gt; seg;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= m; l++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[<span class="number">1</span>][l] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="type">int</span> r = l;</span><br><span class="line">		<span class="keyword">while</span>(r &lt; m &amp;&amp; a[<span class="number">1</span>][r + <span class="number">1</span>] == <span class="number">2</span>) r++;</span><br><span class="line">		seg.<span class="built_in">push_back</span>(&#123;l, r&#125;);</span><br><span class="line">		l = r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(seg.<span class="built_in">size</span>() &gt;= <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = seg[<span class="number">0</span>].first; j &lt;= seg[<span class="number">0</span>].second; j++) be[<span class="number">2</span>][<span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(seg.<span class="built_in">size</span>() == <span class="number">1</span>) t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= seg[t].second; j++) be[<span class="number">0</span>][<span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = seg[t].first; j &lt;= m; j++) be[<span class="number">1</span>][<span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">putone</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="type">bool</span> bk = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i][j] == <span class="number">2</span>)&#123;be[t][i][j] = <span class="number">1</span>; bk = <span class="number">1</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(bk) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">putone</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i][j] == <span class="number">2</span>) be[<span class="number">0</span>][i][j] = be[<span class="number">1</span>][i][j] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> be[i &amp; <span class="number">1</span>][i][j] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">auto</span> f)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) tmp[j][i] = f[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) f[i][j] = tmp[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sta[N], top;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="type">bool</span> b2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="built_in">get_char_array</span>(st);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">			a[i][j] = st[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">			<span class="keyword">if</span>(a[i][j] == <span class="number">2</span>)&#123;</span><br><span class="line">				vr[i] = vc[j] = <span class="number">1</span>;</span><br><span class="line">				b2 = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!b2)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n * m &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) be[<span class="built_in">min</span>(cnt, <span class="number">2</span>)][i][j] = <span class="number">1</span>, cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">work1</span>();</span><br><span class="line">	<span class="keyword">if</span>(m == <span class="number">1</span>)&#123;</span><br><span class="line">		type = <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">rotate</span>(a);</span><br><span class="line">		<span class="built_in">swap</span>(n, m);</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">work1</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> posi = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vr[i])&#123;posi = i; <span class="keyword">break</span>;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!posi) <span class="keyword">return</span> <span class="built_in">work2</span>();</span><br><span class="line">    <span class="keyword">if</span>(posi == <span class="number">1</span>) <span class="built_in">putone</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(posi == n) <span class="built_in">putone</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) be[<span class="number">0</span>][posi][j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">        <span class="type">bool</span> bk = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; posi; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j] == <span class="number">2</span>) bk = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bk)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; posi; i++)&#123;</span><br><span class="line">                be[<span class="number">0</span>][i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; m &amp;&amp; a[i][j + <span class="number">1</span>] == <span class="number">2</span>) be[<span class="number">0</span>][i][j + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">        <span class="type">bool</span> bk = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = posi + <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j] == <span class="number">2</span>) bk = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bk)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = posi + <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">                be[<span class="number">0</span>][i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; m &amp;&amp; a[i][j + <span class="number">1</span>] == <span class="number">2</span>) be[<span class="number">0</span>][i][j + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j] == <span class="number">2</span> || !be[<span class="number">0</span>][i][j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; posi) be[<span class="number">1</span>][i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> be[<span class="number">2</span>][i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">solve</span>()) cout &lt;&lt; <span class="string">&quot;impossible\n&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(type)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">2</span>; t++) <span class="built_in">rotate</span>(be[t]);</span><br><span class="line">			<span class="built_in">swap</span>(n, m);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">2</span>; t++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">					<span class="keyword">if</span>(be[t][i][j]) st[j] = t + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">					<span class="keyword">else</span> st[j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				cout &lt;&lt; st + <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方做法</summary><div class="toggle-content"><p>蚌埠住了，我太菜了，看到第一句话的那一刻起，我感觉赛时构造了一两个小时还没构造出来的我像个小丑一样，构造题真难啊。</p>
<p>注意到，如果我们能给这个矩阵划分成三个独立的连通块，且满足每个点四联通附近都有一个别的连通块的点，那么就显然做完了。</p>
<p>以下是一种可能的方案：</p>
<p><img src="1.png" alt=""></p>
<p>在 $n,m$ 小的时候这种方案可能用不了，特判一下就行了，在此不再赘述。（<del>其实是因为我没细想</del>，因为我觉得最关键的就是上面那句话，以及一种可能的方案，在完成这些后，后面的细节处理就只是时间问题了）</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>O(n)-O(1)四毛子RMQ</title>
    <url>/2025/02/03/O-n-O-1-%E5%9B%9B%E6%AF%9B%E5%AD%90RMQ/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>你知道我这个算法在哪里学的吗？</p>
<p>在CSP2021-S 初赛上学的，太TM的离谱了。</p>
<p>这里大概讲一下算法，实现细节看代码，有些细节我可能会在代码后讲，代码之前的讲解只是让你大致的了解一下这个算法而已，因此有点简略，见谅，不过也不难理解，看代码应该也能懂。</p>
<p>前置知识：</p>
<p>笛卡尔树（本文会略微教一点基础的，但是有了解总是是好的）</p>
<h1 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h1><p> $n$ 个数字， $m$ 个查询，查询为 $[l,r]$ 的最大值，即 $RMQ$ 问题，可以在线，但不支持修改，这个黑科技的复杂度是 $O(n+m)$ 的。</p>
<h1 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h1><h2 id="利用笛卡尔树将RMQ转成LCA问题"><a href="#利用笛卡尔树将RMQ转成LCA问题" class="headerlink" title="利用笛卡尔树将RMQ转成LCA问题"></a>利用笛卡尔树将RMQ转成LCA问题</h2><p>首先我们得了解笛卡尔树是个什么东西，这里不展开讲，就将概念，笛卡尔树是个二叉堆，由于这里求最大值，所以设定为大根，同时这颗树也是按下表为 $key$ 的平衡树，即中序遍历为原数组，根据数组，我们可以 $O(n)$ 建出树。</p>
<p><img src="1.jpg" alt=""></p>
<p>（图片侵权会在通知后自删，为找到出处）</p>
<p>当然，上面的是小根堆的例子，换成大根堆就是我们这次要用的。</p>
<p>不难发现，求 $[l,r]$ 的 $RMQ$ 问题变成了 $LCA$ 问题了，只要求到 $l,r$ 在树上的 $LCA$ ，然后将 $LCA$ 的值输出即可，具体为什么就不再细讲了。</p>
<h2 id="LCA转01RMQ"><a href="#LCA转01RMQ" class="headerlink" title="LCA转01RMQ"></a>LCA转01RMQ</h2><p>也许有人会问，01RMQ是什么，其实就是 $RMQ$ 中相邻两个位置的值的差值的绝对值固定为 $1$ ，就叫01RMQ，因此，我们可以把 $LCA$ 转换成以 $dep$ 为关键字，以欧拉环游序为数组的01RMQ问题了（当然，这里的01RMQ是求区间最小值了）。</p>
<p>（在 $CSP2021S$ 初赛中的算法讲解中使用的是欧拉环游序，当然我觉得DFS序也不是不行，应该可以，没有实际打过代码试验过）</p>
<p>DFS序：在DFS到一个点时，将这个点加入数组中。</p>
<p>欧拉换有序：在DFS到一个点以及在其访问完一个儿子回溯后，都将这个点加入数组中。</p>
<p>当然，具体哪个是否可行，其实都不重要，重要的是下面这个。<del>其实上面讲了这么多在初赛两句话概括过去了，当然，懂的自然都懂</del></p>
<h2 id="O-n-01RMQ"><a href="#O-n-01RMQ" class="headerlink" title="O(n) 01RMQ"></a>O(n) 01RMQ</h2><p>这个算法最精彩的无异于01RMQ的处理了，十分的优秀。</p>
<p>采用的方法是分块（看完后也许你就会感叹分块的魅力了），块长选择 $t=\left \lceil \frac{\log{n}}{2} \right \rceil$ 。</p>
<p>然后分块，首先块内的最大值先处理一下，时间复杂度是 $O(n)$ ，然后块与块之间用 $ST$ 表解决，时间复杂度： $\frac{n}{t}*\log{\frac{n}{t}}≤2n$。</p>
<p>然后就是块内的处理了，由于左右值最多差 $1$ 或者 $-1$ ，即差分数组可以视作一个 $01$ 串，再加上块长不大，那么直接暴力枚举差分数组即可。这里需要注意一个事情，我们这里暴力枚举不用每个块都枚举一遍，只需要暴力枚举 $2^{t-1}$ 种情况即可，然后跑出每个块对应的二进制即可。</p>
<p>初赛时代码的复杂度是：$2^{t-1}<em>t≤\sqrt{n}</em>\log{n}≤n$，但是我比较疑惑的是二进制枚举部分采用 $DFS$ 可以到达 $2^{t-1}$ 的复杂度，那么这样是不是块长可以直接采取 $\left \lceil \log{n} \right \rceil$ 。（当然，没具体实现过，口胡一下）</p>
<p>当然，我这里认为 RMQ 只要相邻两个位置的值是两个固定的数（即二进制），那么就可以采取这种 01RMQ 的做法。</p>
<p>这里，就讲完了这个算法。</p>
<p>时间复杂度：$O(n+m)$</p>
<p>空间复杂度：$O(n)$</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="CSP-S-代码"><a href="#CSP-S-代码" class="headerlink" title="CSP-S 代码"></a>CSP-S 代码</h2><p>待补</p>
<h2 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h2><p>待补</p>
<h2 id="作者的代码"><a href="#作者的代码" class="headerlink" title="作者的代码"></a>作者的代码</h2><p>待补</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>科技</tag>
      </tags>
  </entry>
  <entry>
    <title>Parity</title>
    <url>/2025/02/03/Parity/</url>
    <content><![CDATA[<h1 id="Parity"><a href="#Parity" class="headerlink" title="Parity"></a>Parity</h1><p><a href="https://acm.timus.ru/problem.aspx?space=1&amp;num=1003">1003. Parity @ Timus Online Judge</a></p>
<p>一个 $01$ 序列。</p>
<p>大意就是给你一些区间的奇偶性，然后你要找到最早在哪个区间出了问题。</p>
<p>这个题目首先要把区间改成左闭右开，然后离散化一下，最后用带权并查集维护一下就行了，关于奇偶性的转移全部用带权并查集维护即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 510000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> l[N],r[N],type[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> *x;<span class="type">int</span> val;</span><br><span class="line">&#125;a[N];<span class="type">int</span> top;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span></span>&#123;<span class="keyword">return</span> x.val&lt;y.val;&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> fa[N],val[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==fa[x])<span class="keyword">return</span> x;</span><br><span class="line">	<span class="type">int</span> y=<span class="built_in">findfa</span>(fa[x]);val[x]^=val[fa[x]];fa[x]=y;</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">mer</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;y)x^=y^=x^=y;<span class="comment">//其实这句加不加无所谓，但是更方便理解</span></span><br><span class="line">	fa[y]=x;val[y]=type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> st[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)!=EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">		n++;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">		top=<span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> ans=m+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l[i],&amp;r[i]);r[i]++;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>((l[i]&lt;<span class="number">1</span> || r[i]&gt;n || l[i]&gt;r[i]) &amp;&amp; ans==m+<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				ans=i;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(st[<span class="number">1</span>]==<span class="string">&#x27;e&#x27;</span>)type[i]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> type[i]=<span class="number">1</span>;</span><br><span class="line">			a[++top].x=&amp;l[i];a[top].val=l[i];</span><br><span class="line">			a[++top].x=&amp;r[i];a[top].val=r[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ans!=m+<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(a+<span class="number">1</span>,a+top+<span class="number">1</span>,cmp);</span><br><span class="line">		<span class="keyword">if</span>(top&gt;=<span class="number">1</span>)(*a[<span class="number">1</span>].x)=<span class="number">1</span>;<span class="comment">//注意可能m=0的情况 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=top;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i].val==a[i<span class="number">-1</span>].val)(*a[i].x)=(*a[i<span class="number">-1</span>].x);</span><br><span class="line">			<span class="keyword">else</span> (*a[i].x)=(*a[i<span class="number">-1</span>].x)+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(top&gt;=<span class="number">1</span>)n=(*a[top].x);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fa[i]=i,val[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> tx=<span class="built_in">findfa</span>(l[i]),ty=<span class="built_in">findfa</span>(r[i]);</span><br><span class="line">			<span class="keyword">if</span>(tx==ty)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>((val[l[i]]^val[r[i]])!=type[i])</span><br><span class="line">				&#123;</span><br><span class="line">					ans=i;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">mer</span>(tx,ty,val[l[i]]^val[r[i]]^type[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然会做，但是我一直在冥思苦想为什么正确，比如：$[1,3],[3,4]$ 虽然并查集上无关，但都包含 $3$ ，总归有点关系，且在并查集上，只有当左闭右开区间有个端点重合时，在并查集上才有关联，但是有没有可能一坨区间有些端点重合，有些不重合，然后解出了并查集不能处理出奇偶性区间的奇偶性。（简单来说就是我找不到一种合适的解释或者较为严谨的证明去解释这个并查集做法，因为区间之间的关联性错综复杂）</p>
<p>但是后来翻资料发现了一种合适的解释：</p>
<p>其实可以对数组进行异或前缀和 $f$ ，那么对于区间 $[a,b)$ ，我们就能得到 $f[a]$ 和 $f[b]$ 的关系，仔细想想 $(a,b)$ 之间的 $c$ 的 $f$ 会不会受到 $a,b$ 的影响呢？事实上并不会，因为 $f[c]$ 不管取什么，最后只要从后往前再做一遍前缀和就可以得到原数组（即原数组存在与否与 $f[c]$ 取值无关），即 $f[c]$ 的取值与 $f[a],f[b]$ 无关。</p>
<p>类似的，即使 $f[c]$ 与 $f[d]$ 有关系，这个关系与 $a,b$ 也没有关系，因为 $f[c]$ 的取值与 $f[a],f[b]$ 无关。</p>
<p>总的来讲，这样问题就不是一个区间了，而是只涉及到了点的关系，就非常好考虑了。（区间的错综复杂考虑起来真的好恶心QAQ）</p>
<p>综上，在做 $01$ 异或型区间问题的时候，前缀和可以帮助我们把区间问题变成点值问题来考虑，思考难度就下降不少了。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>NAC 2020 D. All Kill</title>
    <url>/2024/07/26/NAC-2020-D-All-Kill/</url>
    <content><![CDATA[<p>题目链接：<a href="https://qoj.ac/contest/474/problem/3164">https://qoj.ac/contest/474/problem/3164</a></p>
<p>题目大意：两个人在参加比赛，一个想题一个写题，比赛时间总长为 $t$，有 $n$ 道题目，每道题目有需要写的时间，想题人想出每道题目的时间都是 $[0,t)$ 中均匀随机的整数，写题人每分钟会选择编号最小的没写完的题目写一分钟。</p>
<p>问最后 AK 而且每道题目写的时间是一个连续段的概率是多少。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>看了题解，感觉自己唐完了。</p>
<p>显然的，问题可以转换成在从小到大摆问题，当问题在 $x$ 时刻想出来后，会找到这个位置往后的第一个空位置放置其写代码的区间，放不下就是不合法。</p>
<p>接下来，一个显然的想法是，先考虑 $n=t$ 的情况，即全部都是 $1$ 的情况，在这种特殊的情况下，我们不需要担心区间是否放得下，所以问题等价于要求在时间 $i$ 内想出来的题目不少于 $i$ 道。</p>
<p>需要注意到，这个问题可以类似于转换为在一个 $n+1$ 的环上进行上述放区间的过程，不过两者的数量转换有个比例。</p>
<p>具体来说，我们可以将原问题再变换一下：在 $t+1$ 个时间区间上摆区间，但是不可能在第 $0$ 时刻想出题，即 $[0,1]$ 始终不被占据，然后将头和尾连起来，形成一个环，这对应一个环方案，旋转一下，对应 $t+1$ 个的不同的链方案。</p>
<p>这种对应可不可逆呢？注意到，由于 $n=t$ ，所以进行上述操作后，环上恰好有一个空位，而假设这个空位就是刚刚说的开头，断链得到的链方案就是能对应到它的方案。</p>
<p>所以环上的数量除 $n+1$ 就是答案了。</p>
<p>尝试推广这个结论，在原问题上，一样的，在链方案前面加一个空格，拼接，旋转，对应得到 $t+1$ 个不同的链方案（不同说明没有重边），为了更加形象的说明，可以认为建立了方案数 $<em>(t+1)$ 条边，现在尝试通过环方案构造出相同的边集，可以发现，从每个空格断开后，环方案都可以得到一个不同的合法的链方案，可以证明，这样找到了所有的边，即我们以边的数量为桥梁证明了： $\mathrm{链方案}</em>(t+1)=\mathrm{环方案}*(t+1-\sum\limits_{x})$ 。</p>
<p>上述思考过程一个可能的心路历程是：我们想要找到的方案是前面想题多后面想题少的方案，而不想找的是前少后多的，这两种方案之间具有一定的对称性，或许有助于启发我们想到在环上重新考虑这个问题，但是如果直接拼成环，一个直接的问题就是，我们无法从环断成链，不知道从哪断，因此在开头添加一个无法占据的空格作为标识。不过感觉这个解释也有点牵强。</p>
<p>然后就可以开始考虑计算环的方案。</p>
<p>考虑一个经典的组合问题，如果不是在环上选好想出题目的时间后找到后面第一个空位，而是在原地直接尝试放区间，即如果在环上不相交的放下这些区间，那么答案是显然的：$(t+1)A^{n-1}_(t+1-\sum\limit_{i=1}^{n}(x_{i}-1))$ 。</p>
<p>考虑这玩意的组合意义，就是我们认为每个区间的 $x_{i}-1$ 的空间不是其占据得到的，而是其扩展得到的，也就是在放下的那一刻，瞬间在其后面生成这么多的空间，最后总空间为 $t+1$ ，现在稍稍改一下题目，因此也只需要稍稍改一下式子即可。</p>
<p>答案就是：$(t+1)\prod_{limits}_{i=2}^{n}(t+1-\sum\limits_{j=i+1}(x_{j}-1))$ 。</p>
<p>然后就做完了，时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function">LL <span class="title">ksm</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">    LL ans = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ans = ans * x % mod;</span><br><span class="line">        x = x * x % mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">LL fc[N], nfc[N]; </span><br><span class="line"><span class="type">int</span> n, t, a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; t;</span><br><span class="line">    t++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        t -= a[i] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans = t - n;</span><br><span class="line">    t += a[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        ans = ans * t % mod;</span><br><span class="line">        t += a[i] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说来也搞笑，第二部分的结论过于自然和优美，以至于我在复盘我的思考过程时，发现过程全错，但是结果是对的，乐麻了。</p>
<p>看了题解，后半部分计数的思路和题解基本一致。</p>
<p>非常好的一道计数题，太优美了。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>NAIPC 2016 赛后总结</title>
    <url>/2025/02/04/NAIPC-2016-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/gym/101002">https://codeforces.com/gym/101002</a></p>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>trick 题。</p>
<p>简单来说，去计算和全选最大的方案的差值可以换成另外一个问题。</p>
<p>例如：</p>
<p>$p&lt;q$ ，你现在计算与选最大的方案的差值，问题变为：</p>
<p>$p-q,0$ 选择，不难发现，问题可以转化为所选择的商店中所有商品的权值和。</p>
<p>唯一还需要考虑的问题就是两个商店必须要有一个被选择，这个问题可以在 meet in middle 中强制指定对面必须选择某些商店。</p>
<p>然后 meet in middle + 高维前缀和一下就做完了。</p>
<p>时间复杂度：$O(2^{\frac{m}{2}}*(\frac{m}{2})^2)$</p>
<p>这题我是没有做出来的。</p>
<details class="toggle" ><summary class="toggle-button" style="">启示</summary><div class="toggle-content"><p>对于一些题目，变换一下参考系有时候是可以转化问题的。</p>
<p>例如本题：一开始选择不同的价格本质上是将 $0$ 做参考系的，求与 $0$ 的差值。</p>
<p>但是如果变换参考系，变为全选最大的价格的方案代价，求与其的差值，这样就把选商品的问题变成了求被选中的商店中所有商品的权值之和，规避了一步选择。</p>
<p>问题就从先选商店再选商品变成选商店求和，问题大幅度简化，然后就可做了。</p>
<p>会发现如果不转化问题直接 meet in middle 基本没有办法解决需要进行两步选择的问题，所以这就体现了转化问题的重要性。</p>
<p><del>这不是显然吗，有些问题你不转化成其他问题不就是没法做吗？什么废话文学。</del></p>
</div></details>
<p>值得一提的是，由于限制非常松，我们机房分别以随机化、暴力剪枝过了，所以很多时候不会做不要紧，冲一发暴力剪枝再说。</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>一个感觉非常正确的事情：这道题目应该是道模拟题，模拟出来的长度应该就是最小长度。</p>
<p>其次显然长度最多是 $24000$ ，所以直接暴力模拟就行了，不过模拟方式的优秀程度会决定你写代码的时间，我们这边有的队十分钟就写完了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 4100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 31000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fep(i,x,y) for(int i=x;i&lt;=y;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> feq(i,x,y) for(int i=x;i&gt;=y;i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[N],b[N],sum[N],n;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> sta[N],top,cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;<span class="built_in">fep</span>(i,<span class="number">1</span>,cnt+cnt)sum[i]=sum[i<span class="number">-1</span>]+a[i];&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getlen</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)x/=<span class="number">10</span>,y++;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> ss[M];<span class="type">int</span> tot;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);n=<span class="built_in">strlen</span>(st+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i]==<span class="string">&#x27;(&#x27;</span>)sta[++top]=++cnt,b[(cnt+cnt<span class="number">-1</span>)]=cnt+cnt,a[cnt+cnt<span class="number">-1</span>]=a[cnt+cnt]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> x=sta[top--];</span><br><span class="line">            b[x+x]=cnt+cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> bk=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(bk)&#123;</span><br><span class="line">        bk=<span class="number">0</span>;<span class="built_in">init</span>();</span><br><span class="line">        <span class="built_in">fep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">            <span class="type">int</span> x=sum[b[i]];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">getlen</span>(x)!=a[i]<span class="number">-1</span>)&#123;</span><br><span class="line">                a[i]=<span class="built_in">getlen</span>(x)+<span class="number">1</span>;bk=<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// break;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fep(i,1,n)printf(&quot;%d %d\n&quot;,sum[i],b[i]);</span></span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="type">int</span> x=sum[b[i]];</span><br><span class="line">        <span class="type">int</span> len=<span class="built_in">getlen</span>(x),now=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">fep</span>(j,<span class="number">2</span>,len)now*=<span class="number">10</span>;</span><br><span class="line">        <span class="built_in">fep</span>(j,<span class="number">1</span>,len)ss[++tot]=x/now+<span class="string">&#x27;0&#x27;</span>,x%=now,now/=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>)ss[++tot]=<span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> ss[++tot]=<span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,ss+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>队友写了。</p>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>分数规划+树上背包。</p>
<p>时间复杂度：$O(n^2\log V)$</p>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>FFT。</p>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p>队友写了。</p>
<h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p>两种情况分别做一下，第一种情况处理中点，Hash一下，第二种情况类似，两点中垂线 Hash 一下，注意归一化的问题。</p>
<p>比较麻烦的点是有的点在对称中心（好处理）和对称轴（不好处理）。</p>
<p>直接 $n^3$ 可以 AC 。</p>
<p>但是队友有更加优秀的做法：</p>
<p>平面中等腰三角形个数的级别为 $O(n^{2.137})$ 。</p>
<p>参考[HNOI 2019] 鱼 的题解：<a href="https://www.luogu.com.cn/blog/zhoutb2333/solution-p5286">https://www.luogu.com.cn/blog/zhoutb2333/solution-p5286</a></p>
<p>证明在这：<a href="https://link.springer.com/article/10.1007/s003730200063">https://link.springer.com/article/10.1007/s003730200063</a></p>
<p>然后就可以知道一个点如果在对称轴会落在哪条对称轴了。</p>
<p>找等腰三角形也很简单，每个点求一遍与其余点的距离，排序，显然只有有两个点到达某个点的距离相等时才可能且一定构成等腰三角形，这一部分是 $O(n^2\log{n}+n^{2.137})$ 。</p>
<p>总的时间复杂度也是：$O(n^2\log{n}+n^{2.137})$ 。</p>
<h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><p>首先，一个很显然的事情，可以类似单调队列求分组背包的做法做。</p>
<p>唯一的问题是随着同一个 $k$ 的放置，越放价值越小，但是可以发现存在决策单调，然后就做完了。</p>
<p>决策单调性：</p>
<p>如果对于 $i$ ，从 $j$ 转移优于 $k(k&lt;j)$ ，那么对于 $i+1$ ，从 $j$ 转移也优于从 $k$ 转移。</p>
<p>时间复杂度：$O(ks\log{k})$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">扩展</summary><div class="toggle-content"><p><a href="https://codeforces.com/gym/101064/problem/L">https://codeforces.com/gym/101064/problem/L</a></p>
<p><a href="https://www.zhihu.com/question/26547156/answer/1181239468">https://www.zhihu.com/question/26547156/answer/1181239468</a></p>
<p>类似的题目，只不过变成了完全背包。</p>
<p>做法非常的巧妙。</p>
<p>简单来说，你总是可以把背包拆成两个部分：$f(S)=f(X)+f(S-X)$ ，且一定可以找到一种分法使得： $||X|-|S-X||\le W$ ，所以为了得到容量 $V$ 的背包，你可以跑出 $[\frac{V-W}{2},\frac{V-W}{2}]$ 的背包，然后合并出来。</p>
<p>为此，你还可以不断向下分，跑出：$[\frac{\frac{V-W}{2}-W}{2},\frac{\frac{V+W}{2}+W}{2}]$ 的答案，不断往下，可以证明 $W$ 的系数一直都是 $&lt;1$ 的，所以时间复杂度：$O(W^2\log{V})$ 。</p>
</div></details>
<h1 id="I"><a href="#I" class="headerlink" title="I"></a>I</h1><p> SB 题，调和级数随便做。</p>
<h1 id="J"><a href="#J" class="headerlink" title="J"></a>J</h1><details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>四个方向处理出每个格子的最晚到达时间，然后找一下最大最小值就做完了。</p>
<p>时间复杂度：$O(wh\log{n}+n)$。</p>
<p>也可以做到：$O(wh(\alpha(w)+\alpha(h))+n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fep(i,x,y) for(int i=x;i&lt;=y;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> feq(i,x,y) for(int i=x;i&gt;=y;i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,<span class="type">int</span>&gt; PLI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findtype</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(st[<span class="number">1</span>]==<span class="string">&#x27;u&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(st[<span class="number">1</span>]==<span class="string">&#x27;r&#x27;</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(st[<span class="number">1</span>]==<span class="string">&#x27;d&#x27;</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">PII <span class="title">dooper</span><span class="params">(PII x,<span class="type">int</span> type,<span class="type">int</span> dis)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">make_pair</span>(x.first+dx[type]*dis,x.second+dy[type]*dis);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dis</span><span class="params">(PII x,PII y)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">abs</span>(x.first-y.first)+<span class="built_in">abs</span>(x.second-y.second);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> H,W,n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a[N];</span><br><span class="line">vector&lt;LL&gt; fir[N],las[N];</span><br><span class="line">vector&lt;vector&lt;PLI&gt; &gt; fuck[N];</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ope</span>&#123;</span><br><span class="line">    PII st,ed;<span class="type">int</span> type;</span><br><span class="line">    <span class="type">int</span> len;LL fir;</span><br><span class="line">&#125;op[N];</span><br><span class="line">priority_queue&lt;PLI,vector&lt;PLI&gt;,greater&lt;PLI&gt; &gt;nt1;<span class="comment">//small</span></span><br><span class="line">priority_queue&lt;PLI&gt;nt2;<span class="comment">//big</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">nextype</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y,<span class="type">int</span> type)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> bk=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!type)&#123;x--;<span class="keyword">if</span>(!x)x=H,y++,bk=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">1</span>)&#123;y++;<span class="keyword">if</span>(y==W+<span class="number">1</span>)x++,y=<span class="number">1</span>,bk=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">2</span>)&#123;x++;<span class="keyword">if</span>(x==H+<span class="number">1</span>)y++,x=<span class="number">1</span>,bk=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;y--;<span class="keyword">if</span>(!y)x++,y=W,bk=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">return</span> bk;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,LL z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!fir[x][y])fir[x][y]=las[x][y]=z;</span><br><span class="line">    <span class="keyword">else</span> fir[x][y]=<span class="built_in">min</span>(fir[x][y],z),las[x][y]=<span class="built_in">max</span>(las[x][y],z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(PII x,PLI y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="built_in">dis</span>(x,op[y.second].st);</span><br><span class="line">    <span class="keyword">return</span> len&lt;=op[y.second].len<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> nowtype)</span></span>&#123;</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,H)&#123;</span><br><span class="line">        <span class="built_in">fep</span>(j,<span class="number">1</span>,W)fuck[i][j].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(op[i].type==nowtype)fuck[op[i].st.first][op[i].st.second].<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(op[i].fir,i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> nowx=<span class="number">1</span>,nowy=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!nowtype)nowx=H;</span><br><span class="line">    <span class="keyword">if</span>(nowtype==<span class="number">3</span>)nowy=W;</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,H*W)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:fuck[nowx][nowy])&#123;nt1.<span class="built_in">push</span>(x);nt2.<span class="built_in">push</span>(x);&#125;</span><br><span class="line">        <span class="keyword">while</span>(!nt1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            PLI x=nt1.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">check</span>(<span class="built_in">make_pair</span>(nowx,nowy),x))nt1.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">upd</span>(nowx,nowy,x.first+<span class="built_in">dis</span>(<span class="built_in">make_pair</span>(nowx,nowy),op[x.second].st));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!nt2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            PLI x=nt2.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">check</span>(<span class="built_in">make_pair</span>(nowx,nowy),x))nt2.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">upd</span>(nowx,nowy,x.first+<span class="built_in">dis</span>(<span class="built_in">make_pair</span>(nowx,nowy),op[x.second].st));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">nextype</span>(nowx,nowy,nowtype)==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!nt1.<span class="built_in">empty</span>())nt1.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">while</span>(!nt2.<span class="built_in">empty</span>())nt2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;H,&amp;W,&amp;n);</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">0</span>,H)a[i].<span class="built_in">resize</span>(W+<span class="number">10</span>),fir[i].<span class="built_in">resize</span>(W+<span class="number">10</span>),las[i].<span class="built_in">resize</span>(W+<span class="number">10</span>),fuck[i].<span class="built_in">resize</span>(W+<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,H)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">fep</span>(j,<span class="number">1</span>,W)a[i][j]=(st[j]==<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PII now=<span class="built_in">make_pair</span>(H,<span class="number">1</span>);LL fnow=<span class="number">1</span>;</span><br><span class="line">    fir[H][<span class="number">1</span>]=las[H][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);<span class="type">int</span> len;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;len);</span><br><span class="line">        op[i].len=len;op[i].type=<span class="built_in">findtype</span>();op[i].fir=fnow+<span class="number">1</span>;</span><br><span class="line">        op[i].st=<span class="built_in">dooper</span>(now,op[i].type,<span class="number">1</span>);op[i].ed=<span class="built_in">dooper</span>(now,op[i].type,len);</span><br><span class="line">        now=op[i].ed;fnow+=len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fep</span>(t,<span class="number">0</span>,<span class="number">3</span>)<span class="built_in">solve</span>(t);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fep(i,1,n)&#123;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d %d:%d %d:%d %d\n&quot;,op[i].st.first,op[i].st.second,op[i].ed.first,op[i].ed.second,op[i].len,op[i].type);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// fep(i,1,H)&#123;</span></span><br><span class="line">    <span class="comment">//     fep(j,1,W)printf(&quot;%lld &quot;,fir[i][j]);</span></span><br><span class="line">    <span class="comment">//     printf(&quot;\n&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    LL ans1=<span class="number">-1</span>,ans2=<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,H)&#123;</span><br><span class="line">        <span class="built_in">fep</span>(j,<span class="number">1</span>,W)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j] &amp;&amp; !las[i][j])&#123;<span class="built_in">printf</span>(<span class="string">&quot;-1 -1\n&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(!las[i][j])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans1==<span class="number">-1</span> || las[i][j]+<span class="number">1</span>&gt;ans1)ans1=las[i][j]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!a[i][j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans2==<span class="number">-1</span> || las[i][j]&lt;ans2)ans2=las[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans1==<span class="number">-1</span>)ans1=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ans2==<span class="number">-1</span>)ans2=fnow+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ans1&gt;ans2)&#123;<span class="built_in">printf</span>(<span class="string">&quot;-1 -1\n&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>,ans1<span class="number">-1</span>,ans2<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">别的队伍</summary><div class="toggle-content"><p>先利用差分+前缀和求出跑过的路径长度。（$&gt;0$ 表示跑过了）</p>
<p>二分加检验，直接倒着跑白点，类似上面的方法求出被白点覆盖且跑过的路径长度，检验一下是否相同。</p>
<p>时间复杂度：$O(hw(\log{n}+log{h}+\log{w}))$ 。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">只考虑求最早时间的 O(n) 做法</summary><div class="toggle-content"><p>利用二维前缀和能够求出任意区域的红点数量，然后倒着跑，直到跑到红点为止，跑到红点的时间就是墨水干的时间。</p>
</div></details>
<h1 id="K"><a href="#K" class="headerlink" title="K"></a>K</h1><p>woc ，为什么这么 SB 的题目我想了这么久！</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>先点分治，每个点处理到根的路径长度，这样每个点有个权值 $(A,B)$ ，然后两个点的贡献为：$A_1*A_2+B_1+B_2$ ，注意到路径有重边无所谓，权值只会增大，所以不会统计进答案里。</p>
<p>直接跑出整个树的凸包然后在凸包上找答案就行了，为此，我才用的是凸包+李超线段树。</p>
<p>时间复杂度：$O(n\log{n}\log{p})$ 。</p>
<p>我做的久的原因：没有注意到重边无所谓的性质，一直在想子树间相互的贡献怎么统计，一直没有想出来，直到发现重边无所谓的性质就秒了。</p>
<p>不过就算没有注意到这个性质也有的做：边分治，边分治可以保证把图变成大小接近的两个部分，然后就可以统计相互之间的贡献了，时间复杂度是一样的，同样也可以利用下面的优化优化到 $O(n\log{n})$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 210000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 410000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NN 6100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fep(i,x,y) for(int i=x;i&lt;=y;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> feq(i,x,y) for(int i=x;i&gt;=y;i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,LL&gt; PLL;</span><br><span class="line">LL <span class="keyword">operator</span>*(PLL x,PLL y)&#123;<span class="keyword">return</span> x.first*y.first+x.second+y.second;&#125;</span><br><span class="line">LL <span class="keyword">operator</span>*(PLL x,LL y)&#123;<span class="keyword">return</span> x.first*y+x.second;&#125;</span><br><span class="line"><span class="type">int</span> V=<span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> lc,rc;</span><br><span class="line">    PLL val;<span class="type">int</span> mid;</span><br><span class="line">&#125;tr[NN];<span class="type">int</span> len,rot;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">(<span class="type">int</span> mid)</span></span>&#123;<span class="type">int</span> x=++len;tr[x].lc=tr[x].rc=<span class="number">0</span>;tr[x].mid=mid;tr[x].val=<span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="number">0</span>);<span class="keyword">return</span> len;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> l,<span class="type">int</span> r,PLL val)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!x)&#123;x=<span class="built_in">newnode</span>(mid);tr[x].val=val;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].val*mid&gt;val*mid)<span class="built_in">swap</span>(tr[x].val,val);</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(val.first&gt;tr[x].val.first)<span class="built_in">pushdown</span>(tr[x].lc,l,mid,val);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">pushdown</span>(tr[x].rc,mid+<span class="number">1</span>,r,val);</span><br><span class="line">&#125;</span><br><span class="line">LL now;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(LL x,LL &amp;y)</span></span>&#123;<span class="keyword">if</span>(!y || x&lt;y)y=x;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findans</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!x)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">upd</span>(tr[x].val*(LL)id,now);</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(id&lt;=mid)<span class="built_in">findans</span>(tr[x].lc,l,mid,id);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">findans</span>(tr[x].rc,mid+<span class="number">1</span>,r,id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> y,next;LL c;</span><br><span class="line">&#125;a[M];<span class="type">int</span> cnt,last[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,LL c)</span></span>&#123;cnt++;a[cnt].y=y;a[cnt].c=c;a[cnt].next=last[x];last[x]=cnt;&#125;</span><br><span class="line"><span class="type">int</span> siz[N],msiz;<span class="type">bool</span> v[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    siz[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=last[x];k;k=a[k].next)&#123;</span><br><span class="line">        <span class="type">int</span> y=a[k].y;<span class="keyword">if</span>(y==fa || v[y])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(y,x);</span><br><span class="line">        siz[x]+=siz[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> rt,maxsiz[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    maxsiz[x]=msiz-siz[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=last[x];k;k=a[k].next)&#123;</span><br><span class="line">        <span class="type">int</span> y=a[k].y;<span class="keyword">if</span>(y==fa || v[y])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(y,x);</span><br><span class="line">        <span class="keyword">if</span>(siz[y]&gt;maxsiz[x])maxsiz[x]=siz[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!rt || maxsiz[x]&lt;maxsiz[rt])rt=x;</span><br><span class="line">&#125;</span><br><span class="line">LL dep[N],zjj[N],zans[N];<span class="type">int</span> sta[N],top;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs3</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="built_in">pushdown</span>(rot,<span class="number">1</span>,V,<span class="built_in">make_pair</span>(zjj[x],dep[x]));sta[++top]=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=last[x];k;k=a[k].next)&#123;</span><br><span class="line">        <span class="type">int</span> y=a[k].y;<span class="keyword">if</span>(y==fa || v[y])<span class="keyword">continue</span>;</span><br><span class="line">        dep[y]=dep[x]+a[k].c;<span class="built_in">dfs3</span>(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    len=rot=top=<span class="number">0</span>;</span><br><span class="line">    dep[x]=<span class="number">0</span>;<span class="built_in">dfs3</span>(x,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,top)&#123;</span><br><span class="line">        <span class="type">int</span> y=sta[i];now=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">findans</span>(rot,<span class="number">1</span>,V,zjj[y]);</span><br><span class="line">        <span class="built_in">upd</span>(now+dep[y],zans[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    v[x]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    rt=<span class="number">0</span>;<span class="built_in">dfs1</span>(x,<span class="number">0</span>);msiz=siz[x];</span><br><span class="line">    <span class="built_in">dfs2</span>(x,<span class="number">0</span>);x=rt;</span><br><span class="line">    <span class="built_in">work</span>(x);</span><br><span class="line">    <span class="comment">// printf(&quot;%d\n&quot;,x);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=last[x];k;k=a[k].next)&#123;</span><br><span class="line">        <span class="type">int</span> y=a[k].y;<span class="keyword">if</span>(!v[y])<span class="built_in">solve</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,n)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;zjj[i]);</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">2</span>,n)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;LL c;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;x,&amp;y,&amp;c);</span><br><span class="line">        <span class="built_in">ins</span>(x,y,c);<span class="built_in">ins</span>(y,x,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>);</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="comment">// printf(&quot;%lld\n&quot;,zans[i]);</span></span><br><span class="line">        ans+=zans[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，注意到一个事情，每个点的斜率实际上一开始就是给定的，所以只要你愿意，在外面排好序，然后采用精妙的实现，可以做到 $O(n\log{n})$ 的时间复杂度。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>OCPC Winter 2023 D9 赛后总结</title>
    <url>/2025/02/03/OCPC-Winter-2023-D9-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><a href="https://codeforces.com/gym/104334">https://codeforces.com/gym/104334</a></p>
<p>我对这场比赛的评价是，逆天。</p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>做法并不是很困难，但是想不到就很操蛋了。</p>
<p>简单来说，就是 <img src="1.png" alt="sample"></p>
<p>简单来说，把三种类型的操作记为 A,B,C 。</p>
<p>做法就是：</p>
<p>显然，每一个操作要么不操作，要么操作一次，因为操作的先后顺序并不影响结果。</p>
<p>又不难发现，只要枚举 $A_1,A_2,B_1$ 就足以得到所有的 A,B,C，枚举一下就行了。</p>
<p>又不难发现，实际上，我们可以任意指定两种操作全部翻转，不会使三角形发生变化，所以我们实际上可以认为 $A_1,B_1=0$ ，枚举 $A_2$ 就行了。</p>
<p>时空复杂度：$O(n^2)$</p>
<p>可以做到时间复杂度：$O(n)$ 。</p>
<p>做题时的历程：</p>
<p>队友1：“这道题目本质就是给你 $3n$ 个元，$\frac{n(n+1)}{2}$ 个方程组，让你判断是否有解，有可能是存在某种方法缩减方程的规模，或者是可以证明某些方程就是没有用的，或者是某些方程起决定性的因素。”</p>
<p>此时我想：“从这个角度想感觉有点困难，很少从方程组的角度去思考问题。”</p>
<p>然后我就自顾自的去乱搞了。</p>
<p>于是就想了个贼奇怪的写法，首先此时我发现了 $A_1,B_1=0$ 的情况，又发现根据一些情况可以解出奇数位置的值。</p>
<p>队友1：“你这不就是解方程消元的过程吗？”</p>
<p>我：“好像很有道理的样子。😂”</p>
<p>接着我又发现，根据已知的确定的奇数位置的权值，我可以确定 $A,B$ 中偶数位置的相同与否，</p>
<p>只要指定了 $A_2$ 貌似就可以搞出绝大多数的位置，其余位置貌似也可以陆续确定下来了。</p>
<p>队友1：“那你为什么不一开始就枚举 $A_2$ 呢？这样还省了偶数时并查集判断相同与不同的部分。还有，有个队很快就 AC 了这道题目，以我对他们的了解，应该存在更加简单的做法。我觉得应该可以一行一行扫下来，具体我就不清楚了。”</p>
<p>于是又思考了一会，思考我的做法中其实需要枚举的元只有 $A_2$ ，这样全局的权值都能确定了。</p>
<p>这时我闪过了一个念头，就是队友1讲的，或许奇数部分都不需要去写，直接枚举 $A_2$ 就可以得到所有操作的权值！</p>
<p>然后就知道怎么做了。</p>
<p>所以实际上题解的不难发现并不适用于我 QAQ ，队友1说的对啊。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fep(i,x,y) for(int i=x;i&lt;=y;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> feq(i,x,y) for(int i=x;i&gt;=y;i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> st[N][N];</span><br><span class="line"><span class="type">int</span> n,a[N],b[N],c[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gettype</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> st[x][y]-<span class="string">&#x27;0&#x27;</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    c[<span class="number">1</span>]=<span class="built_in">gettype</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    c[<span class="number">2</span>]=<span class="built_in">gettype</span>(<span class="number">2</span>,<span class="number">1</span>)^b[<span class="number">1</span>]^a[<span class="number">2</span>];</span><br><span class="line">    b[<span class="number">2</span>]=<span class="built_in">gettype</span>(<span class="number">2</span>,<span class="number">2</span>)^c[<span class="number">2</span>]^a[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">3</span>,n)c[i]=<span class="built_in">gettype</span>(i,<span class="number">2</span>)^a[i<span class="number">-1</span>]^b[<span class="number">2</span>],a[i]=<span class="built_in">gettype</span>(i,<span class="number">1</span>)^b[<span class="number">1</span>]^c[i],b[i]=<span class="built_in">gettype</span>(i,i)^c[i]^a[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">fep</span>(j,<span class="number">1</span>,i)&#123;</span><br><span class="line">            <span class="type">int</span> x=i-j+<span class="number">1</span>,y=j;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">gettype</span>(i,j)!=a[x]^b[y]^c[i])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,n)<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st[i]+<span class="number">1</span>);</span><br><span class="line">    a[<span class="number">2</span>]=<span class="number">0</span>;<span class="keyword">if</span>(<span class="built_in">solve</span>())&#123;<span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    a[<span class="number">2</span>]=<span class="number">1</span>;<span class="keyword">if</span>(<span class="built_in">solve</span>())&#123;<span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>实际上在很早的时候就发现这道题目实际搜索的情况数应该很少，实际的贡献应该是由类似这种情况贡献的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 111  111</span><br><span class="line">2221 2121</span><br><span class="line">2111 2121</span><br><span class="line">222  222</span><br></pre></td></tr></table></figure>
<p>但是因为此时 G 更有情况就去做 G 了。</p>
<p>结果做 D 的队友 WA 了，跟我说了一遍他的思路，我突然觉得我能写出比他更短的代码，而且更他清晰，最后二十分钟上机重写，结果暴 WA ，在过了 15 分钟后 AC 了。</p>
<p>悲。</p>
<p>实际上，这道题目比我想象中要难一点，我刚开始的想法没错是没错，但是用到的判断方式是更加巧妙的，我觉得虽然刚开始我的大方向是没有问题的，但是交给我来开这道题目我却不一定能想到这一个判断方法，也就是交给我来开这道题目我是不一定能做出来的，膜拜队友1，Orz。</p>
<p>我的做法是这样子的：</p>
<p>省流：贪心放，能放就放，能产生贡献的只有深度嵌合的两个 piece 所产生的 *2 的影响，而这种情况所占据的格子是一样的，所以贪心放是正确的，至于数量，贪心的过程中统计一下深度嵌合的情况就行了。</p>
<p>顺序遍历整个矩形，观察是否以这个位置作为左上角放下一个 piece 。</p>
<p>不难发现，无论一个 piece 是什么方向，四个角永远都是被占据的，所以我们在判断能够放下一个 piece 但是无法确定方向时，就直接占据四个角，能确定方向就直接放下去。</p>
<p>对于不能确定方向的 piece ，我们需要在四个角标记好这个角属于哪个 piece ，用于后面使用。</p>
<p>然后，就是大型的分类讨论了，这里可以直接看代码。</p>
<p>时空复杂度：$O(nm)$ 。</p>
<p>空间复杂度可以做到 $O(m)$ 。</p>
<p>至于证明，很简单，遵循以下的格式就行了：</p>
<p>归纳法，证明前 i 步满足以下的要求（注：这里说的在一个位置放下 piece 指的是这个 piece 的左上角在这个位置）：</p>
<ol>
<li>已经放下的 piece 一定合法（没确定方向则任意指定一个方向，同时没有确定方向的 piece 在四个边界的中间的位置一定没有被占用）。</li>
<li>在存在合法方案的情况下，合法方案在我们已经搜索过的区域会跟我们做出类似的选择：<ol>
<li>如果一个位置有 piece ，那么合法方案也有。</li>
<li>如果一个位置没有 piece ，那么合法方案也没有。</li>
<li>如果一个 piece 确定了方向，那么合法方案对应的 piece 一般也是该方向，除了上面举的例子和类似的例子，这种情况下合法方案一定是例子中两种方法的一种。</li>
<li>任意一个 piece 所在的 $3*3$ 矩阵如果被包含在搜索过的区域，那他一定已经确定了方向。</li>
</ol>
</li>
</ol>
<p>归纳法证明就行了。</p>
<p>最后就是判断是否有未被占用的格子。</p>
<p>显然，如果存在合法方案，那么所有的 piece 都必须被确定了，反证法：如果合法方案和这种放置方法类似，那么合法方案无法填满格子，矛盾，证毕。</p>
<p>对于不存在合法情况，如果最后有未确定方向的 piece ，那么一定有未被占用的格子，如果没有，又填满了格子，又放置是合法的，那么显然矛盾，存在合法情况。</p>
<p>然后就做完了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NN 1100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fep(i,x,y) for(int i=x;i&lt;=y;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> feq(i,x,y) for(int i=x;i&gt;=y;i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line">PII b[NN];<span class="type">int</span> cnt;</span><br><span class="line"><span class="type">int</span> a[N][N],bel[N][N];</span><br><span class="line"><span class="type">int</span> n,m;LL ans=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[x+<span class="number">2</span>][y] || a[x][y+<span class="number">2</span>] || a[x+<span class="number">2</span>][y+<span class="number">2</span>])<span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">fep</span>(j,<span class="number">0</span>,<span class="number">2</span>)sum+=a[x+i][y+j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum&gt;=<span class="number">3</span>)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>((sum==<span class="number">2</span> &amp;&amp; !a[x+<span class="number">1</span>][y+<span class="number">1</span>]) || (sum==<span class="number">2</span> &amp;&amp; a[x+<span class="number">1</span>][y+<span class="number">1</span>] &amp;&amp; bel[x+<span class="number">1</span>][y+<span class="number">1</span>]))<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(!sum || (sum==<span class="number">1</span> &amp;&amp; a[x+<span class="number">1</span>][y+<span class="number">1</span>] &amp;&amp; !bel[x+<span class="number">1</span>][y+<span class="number">1</span>]))&#123;</span><br><span class="line">        cnt++;b[cnt]=<span class="built_in">make_pair</span>(x,y);</span><br><span class="line">        <span class="built_in">fep</span>(i,<span class="number">0</span>,<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">fep</span>(j,<span class="number">0</span>,<span class="number">1</span>)a[x+i*<span class="number">2</span>][y+j*<span class="number">2</span>]=<span class="number">1</span>;<span class="comment">//bel[x+i*2][y+j*2]=cnt;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fep</span>(i,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">fep</span>(j,<span class="number">0</span>,<span class="number">2</span>)bel[x+i][y+j]=cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sum==<span class="number">1</span> &amp;&amp; a[x+<span class="number">1</span>][y+<span class="number">1</span>] &amp;&amp; bel[x+<span class="number">1</span>][y+<span class="number">1</span>])&#123;</span><br><span class="line">        ans=ans*<span class="number">2</span>%mod;</span><br><span class="line">        <span class="type">int</span> xx=b[bel[x+<span class="number">1</span>][y+<span class="number">1</span>]].first,yy=b[bel[x+<span class="number">1</span>][y+<span class="number">1</span>]].second;</span><br><span class="line">        <span class="built_in">fep</span>(i,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">fep</span>(j,<span class="number">0</span>,<span class="number">2</span>)a[xx+i][yy+j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fep</span>(i,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">fep</span>(j,<span class="number">0</span>,<span class="number">2</span>)a[x+i][y+j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sum==<span class="number">1</span>)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sum==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bel[x][y+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="type">int</span> xx=b[bel[x][y+<span class="number">1</span>]].first,yy=b[bel[x][y+<span class="number">1</span>]].second;</span><br><span class="line">            <span class="built_in">fep</span>(i,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">fep</span>(j,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!(i==<span class="number">1</span> &amp;&amp; j==<span class="number">1</span>))a[xx+i][yy+j]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(bel[x+<span class="number">1</span>][y])&#123;</span><br><span class="line">            <span class="type">int</span> xx=b[bel[x+<span class="number">1</span>][y]].first,yy=b[bel[x+<span class="number">1</span>][y]].second;</span><br><span class="line">            <span class="built_in">fep</span>(i,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="built_in">fep</span>(j,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!(i==<span class="number">1</span> &amp;&amp; j==<span class="number">1</span>))a[xx+i][yy+j]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fep</span>(i,<span class="number">0</span>,<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">fep</span>(j,<span class="number">0</span>,<span class="number">2</span>)a[x+i][y+j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">fep</span>(j,<span class="number">1</span>,m)a[i][j]=st[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,n<span class="number">-2</span>)&#123;</span><br><span class="line">        <span class="built_in">fep</span>(j,<span class="number">1</span>,m<span class="number">-2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!a[i][j])<span class="built_in">pd</span>(i,j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">1</span>,n)&#123;</span><br><span class="line">        <span class="built_in">fep</span>(j,<span class="number">1</span>,m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!a[i][j])&#123;<span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>神仙队友 1 直接爆艹，因为他发现如果一个点在圆凸包内，那么必然不存在一条直线使得圆凸包在直线一侧，而点在包外存在，所以直接判断一个这个点是否能以一个小于180度的视角透视看到整个圆凸包。</p>
<p>只要求一下角度就行了。</p>
<p><img src="2.png" alt="sample"></p>
<h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p>和队友2合力做出来了。</p>
<p>这道题目一开始是队友2负责的，他发现只要对任意两列拉满限制就可以得到最严格的限制，于是开写，但是他没发现题目还有 -1 的情况。</p>
<p>后面 WA 了两发才发现，这时我 A 了 C 开始来帮他，发现其实有可能满足限制的字符串可能不只输入给出的那些。</p>
<p>然后就开始了漫长的讨论<del>沉默寡言的队友加话痨的我</del>：</p>
<p>我：“2-set计数？”</p>
<p>队友2：“咋整。”</p>
<p>我：“不会。”</p>
<p>…</p>
<p>我：“可能是先这样再那样。”</p>
<p>队友2：“emmmm。”</p>
<p>我：“woc，不对啊，怎么可能这么难，不可做啊，不应该是直接算出所有的可能性啊，这应该不可以计数啊，DAG 上怎么记啊，我觉得我们只要判断可能性是不是大于 $n+1$ 就行了啊。”</p>
<p>这时我突然醒悟了，对哦，只要判断是不是大于 $n+1$ 不就行了，这不是随便搞，只要能够在 $O(m)$ 的时间内处理一种可能性不就随便搞了。</p>
<p>然后就是我占用了队伍一半的机时写这道题目，最后竟然强连通都写错的精彩故事，怒交10发罚时，竟然还有两个认识的队伍同样的题目罚时比我们高，乐。</p>
<p>至于怎么 $O(m)$ 时间处理一种情况，很简单，首先，本题中如果一个位置全 $0$ 或者全 $1$ 显然可以直接在图中删去，因为其无法对决定其他位置起到任何的帮助，例如限制是要么你 $1$ 要么他 $0$ ，这个限制显然一点用都没有，而因为其一直是 $1$ ，我们也不可能给出你是 $0$ ，他是 ? 的限制，所以对于这种位置删去即可。</p>
<p>那么就不存在自己连向自己另一个状态的边了，而这个 2-set 又一定有解，存在两个相反的 DAG ，只考虑一个 DAG ，显然，只要点集 $S$ 满足以下要求，那么其就对应一个合法解：</p>
<p>$x$ 在 DAG 上能到 $y$，且 $x$ 属于 $S$ ，那么 $y$ 也属于 $S$ 。</p>
<p>然后就是枚举这样的点集了，直接 DFS 。</p>
<p>假设所有点一开始都在点集中。（一开始都不在也是一样的）</p>
<p>按照拓扑排序进行搜索（主要是为了缩减时间复杂度和判重，记得是要在缩点后的图跑，否则可能会 TLE ）：对于一个点，如果能到达他的点都被删了，那么他可以被删，每删除一个点，就能产生一个新的点集。</p>
<p>然后就 DFS 一个位置一个位置判断，直到 DFS 完或者发现出现了一种输入中没有的点集就退出，至于判断两个点集是否相同，可以 Hash 或者 01Trie 。</p>
<p>时空复杂度：$O(m(n+m)+\frac{nm^2}{w})$ 。</p>
<p>PS：但是常数巨大，跑了 3712ms ，差点超时，不过也有可能是我写的太丑导致的，毕竟赛场上赶时间，写丑一点很正常，能过就行<del>不能过另说</del>。</p>
<p>UPD：啊，$nm^2$ 跑的过去？比我短，还比我快？啊？做法为 DFS 每次尝试暴力加入一个点，然后将其能到达的点全部加入进去，跑出一种可能性最坏可能把所有边都跑一遍，所以是 $nm^2$ 的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NN 4100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 16100000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fep(i,x,y) for(int i=x;i&lt;=y;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> feq(i,x,y) for(int i=x;i&gt;=y;i--)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; VI;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">int</span> n, m,b[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Hash</span>&#123;</span><br><span class="line">    LL A,mod,fc[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(LL x,LL y)</span></span>&#123;</span><br><span class="line">        A=x;mod=y;</span><br><span class="line">        fc[<span class="number">0</span>]=<span class="number">1</span>;<span class="built_in">fep</span>(i,<span class="number">1</span>,m)fc[i]=fc[i<span class="number">-1</span>]*A%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;h0;</span><br><span class="line"><span class="type">int</span> cntnow=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">namespace</span> ZJJ&#123;</span><br><span class="line">    set&lt;LL&gt; shit;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fa[NN];<span class="type">bool</span> v[NN];<span class="comment">/*delete*/</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;<span class="built_in">fep</span>(i,<span class="number">0</span>,m+m<span class="number">-1</span>)fa[i]=i;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[x]==x)<span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> fa[x]=<span class="built_in">findfa</span>(fa[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mer</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;x=<span class="built_in">findfa</span>(x);y=<span class="built_in">findfa</span>(y);fa[x]=y;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">        <span class="type">int</span> y,next;</span><br><span class="line">    &#125;a[M];<span class="type">int</span> len,last[NN],in[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;len++;a[len].y=y;a[len].next=last[x];last[x]=len;<span class="built_in">mer</span>(y,x);&#125;</span><br><span class="line">    <span class="type">int</span> list[N],tail;</span><br><span class="line">    <span class="type">int</span> dfn[NN],low[NN],sta[NN],top,cnt,ti,belong[NN];</span><br><span class="line">    VI fmem[NN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        low[x]=dfn[x]=++ti;sta[++top]=x;list[++tail]=x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=last[x];k;k=a[k].next)&#123;</span><br><span class="line">            <span class="type">int</span> y=a[k].y;</span><br><span class="line">            <span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">                <span class="built_in">dfs1</span>(y);low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!belong[y])low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dfn[x]==low[x])&#123;</span><br><span class="line">            cnt++;belong[x]=cnt;fmem[cnt].<span class="built_in">clear</span>();in[cnt]=<span class="number">0</span>;fmem[cnt].<span class="built_in">push_back</span>(x);</span><br><span class="line">            <span class="keyword">while</span>(sta[top]!=x)belong[sta[top--]]=cnt,fmem[cnt].<span class="built_in">push_back</span>(sta[top+<span class="number">1</span>]);</span><br><span class="line">            top--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> del[NN],edg[N][N];</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LL sum=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fep</span>(i,<span class="number">1</span>,tail)((!del[list[i]] &amp;&amp; list[i]&gt;=m) || (del[list[i]] &amp;&amp; list[i]&lt;m))?sum=(sum+h0.fc[list[i]%m])%h0.mod:<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// printf(&quot;%lld\n&quot;,sum);</span></span><br><span class="line">        <span class="keyword">return</span> shit.<span class="built_in">find</span>(sum)!=shit.<span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> dep)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dep)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!in[dep])&#123;</span><br><span class="line">            <span class="comment">// if(dep==2)printf(&quot;%d\n&quot;,in[1]);</span></span><br><span class="line">            <span class="built_in">fep</span>(i,<span class="number">1</span>,dep<span class="number">-1</span>)in[i]-=edg[dep][i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x:fmem[dep])del[x]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">check</span>())<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs2</span>(dep<span class="number">-1</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x:fmem[dep])del[x]=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">fep</span>(i,<span class="number">1</span>,dep<span class="number">-1</span>)in[i]+=edg[dep][i];</span><br><span class="line">            <span class="comment">// if(dep==2)printf(&quot;%d\n&quot;,in[1]);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs2</span>(dep<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> stt)</span></span>&#123;</span><br><span class="line">        <span class="comment">// printf(&quot;OK\n&quot;);</span></span><br><span class="line">        stt=<span class="built_in">findfa</span>(stt);tail=<span class="number">0</span>;shit.<span class="built_in">clear</span>();</span><br><span class="line">        cnt=top=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fep</span>(i,<span class="number">0</span>,m+m<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">findfa</span>(i)==stt &amp;&amp; !dfn[i])<span class="built_in">dfs1</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fep</span>(i,<span class="number">1</span>,cnt)<span class="built_in">memset</span>(edg[i]+<span class="number">1</span>,<span class="number">0</span>,cnt);</span><br><span class="line">        <span class="built_in">fep</span>(i,<span class="number">1</span>,cnt)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x:fmem[i])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=last[x];k;k=a[k].next)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(belong[x]!=belong[a[k].y])edg[belong[x]][belong[a[k].y]]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fep(i,1,cnt)&#123;</span></span><br><span class="line">        <span class="comment">//     fep(j,1,cnt)printf(&quot;%d &quot;,edg[i][j]);</span></span><br><span class="line">        <span class="comment">//     printf(&quot;\n&quot;);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="built_in">fep</span>(i,<span class="number">1</span>,cnt)&#123;</span><br><span class="line">            <span class="built_in">fep</span>(j,<span class="number">1</span>,cnt)in[i]+=edg[j][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fep</span>(i,<span class="number">1</span>,tail)&#123;</span><br><span class="line">            <span class="type">int</span> x=list[i]%m;</span><br><span class="line">            v[x]=v[x+m]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fep</span>(i,<span class="number">0</span>,n<span class="number">-1</span>)&#123;</span><br><span class="line">            LL pre=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">fep</span>(j,<span class="number">1</span>,tail)&#123;</span><br><span class="line">                <span class="type">int</span> x=list[j]%m;</span><br><span class="line">                pre=(pre+b[i][x]*h0.fc[x])%h0.mod;</span><br><span class="line">            &#125;</span><br><span class="line">            shit.<span class="built_in">insert</span>(pre);</span><br><span class="line">            <span class="comment">// printf(&quot;%lld\n&quot;,pre);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printf(&quot;%d\n&quot;,check());</span></span><br><span class="line">        <span class="comment">// fep(i,1,tail)printf(&quot;%d &quot;,list[i]);</span></span><br><span class="line">        <span class="comment">// printf(&quot;\n&quot;);</span></span><br><span class="line">        <span class="comment">// printf(&quot;OK\n&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">check</span>() || !<span class="built_in">dfs2</span>(cnt))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        cntnow*=shit.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// printf(&quot;OK %d\n&quot;,tail);</span></span><br><span class="line">        <span class="keyword">return</span> n%cntnow==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">std::bitset &lt;2000&gt; h1[<span class="number">2005</span>], h2[<span class="number">2005</span>], cs;</span><br><span class="line"><span class="type">int</span> vis[<span class="number">2005</span>];</span><br><span class="line"><span class="type">char</span> s[<span class="number">2005</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y, type;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector &lt;node&gt; ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> type)</span></span>&#123;</span><br><span class="line">    ans.<span class="built_in">push_back</span>((node)&#123;x, y, type&#125;);</span><br><span class="line">    <span class="keyword">if</span>(x==y)ZJJ::v[x]=ZJJ::v[x+m]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ZJJ::v[x] || ZJJ::v[y])<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(type==<span class="number">1</span>)ZJJ::<span class="built_in">ins</span>(x+m,y),ZJJ::<span class="built_in">ins</span>(y+m,x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">3</span>)ZJJ::<span class="built_in">ins</span>(x+m,y+m),ZJJ::<span class="built_in">ins</span>(y,x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">2</span>)ZJJ::<span class="built_in">ins</span>(x,y),ZJJ::<span class="built_in">ins</span>(y+m,x+m);</span><br><span class="line">        <span class="keyword">else</span> ZJJ::<span class="built_in">ins</span>(x,y+m),ZJJ::<span class="built_in">ins</span>(y,x+m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ZJJ::<span class="built_in">init</span>();h0.<span class="built_in">init</span>(<span class="number">2</span>,<span class="number">10000000000000061ll</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:ans)<span class="built_in">ins</span>(x.x,x.y,x.type);</span><br><span class="line">    <span class="built_in">fep</span>(i,<span class="number">0</span>,m<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ZJJ::v[i] &amp;&amp; !ZJJ::<span class="built_in">solve</span>(i))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cntnow==n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">            <span class="keyword">if</span>(s[j] == <span class="string">&#x27;1&#x27;</span>) b[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> b[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">            h1[j][i] = b[i][j],</span><br><span class="line">            h2[j][i] = b[i][j] ^ <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(h1[i].<span class="built_in">count</span>() == n) <span class="built_in">f</span>(i, i, <span class="number">4</span>), vis[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(h2[i].<span class="built_in">count</span>() == n) <span class="built_in">f</span>(i, i, <span class="number">1</span>), vis[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; m; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[i] || vis[j]) <span class="keyword">continue</span>;</span><br><span class="line">            cs = h1[i] ^ h1[j];</span><br><span class="line">            <span class="keyword">if</span>(cs.<span class="built_in">count</span>() == n)&#123;</span><br><span class="line">                <span class="built_in">f</span>(i, j, <span class="number">1</span>), <span class="built_in">f</span>(i, j, <span class="number">4</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cs = h1[i] | h1[j];</span><br><span class="line">            <span class="keyword">if</span>(cs.<span class="built_in">count</span>() == n) <span class="built_in">f</span>(i, j, <span class="number">4</span>);</span><br><span class="line">            cs = h1[i] | h2[j];</span><br><span class="line">            <span class="keyword">if</span>(cs.<span class="built_in">count</span>() == n) <span class="built_in">f</span>(i, j, <span class="number">2</span>);</span><br><span class="line">            cs = h2[i] | h1[j];</span><br><span class="line">            <span class="keyword">if</span>(cs.<span class="built_in">count</span>() == n) <span class="built_in">f</span>(i, j, <span class="number">3</span>);</span><br><span class="line">            cs = h2[i] | h2[j];</span><br><span class="line">            <span class="keyword">if</span>(cs.<span class="built_in">count</span>() == n) <span class="built_in">f</span>(i, j, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">solve</span>())&#123;<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="type">int</span>)ans.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v : ans) <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, v.x, v.y, v.type);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>Petrozavodsk Summer 2022 Day 2 赛后小结</title>
    <url>/2024/08/08/Petrozavodsk-Summer-2022-Day-2-%E8%B5%9B%E5%90%8E%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://qoj.ac/contest/1009">https://qoj.ac/contest/1009</a></p>
<p>开局我看了 C ，但是感觉没有好写的写法，润了，感觉是签到，相信队友（主要当时在吃早餐，会了也写不了，但其实这个时候应该和队友说一下，还是太过相信队友了，虽然队友确实值得信任）。</p>
<p>后面队长看了，说 SB 题，写了，虽然后面听说他一开始的做法烦了，后面改成好写的在 15 min 一发过了。</p>
<p>F 和队友讨论，是 SB 题，上去写，过了。</p>
<p>K 我声称结论是异或和等于 $0$ ，和队友说了结论的证明，队友觉得没问题，但我不会计数，伟大的队长说是莫队，我一听，很对，然后上去写，WA 了，后面想了想证明，假麻了，我应该知道队友大部分时候是没认真听证明的。</p>
<p>接着队友非常给力的过了 J,G ，此时一个小时。</p>
<p>然后和队友接着讨论 K ，注意到三堆石头一定有解，四堆和 $-1$ 异或有关，这个时候就非常疑惑了。</p>
<p>三堆石头一定有解说明不是像 NIM 游戏那样纯粹的算式判定，但四堆石头的结论否定了这一点。</p>
<p>于是我们猜测跟奇偶性有关，但是我这个时候非常唐氏的搞了个 $5$ 堆先手无法直接操作到 $4$ 堆的例子，然后说这是不对的。</p>
<p>于是队友上去写了个暴力，发现 $5$ 堆没有反例，我发现反例我少考虑了个情况，于是觉得结论应该是对的，遂上机，过了。此时一个小时四十分钟，进入坐牢时间。</p>
<p>然后队长开 B ，我开 L ，Imakf 上机写 A ，Imakf 声称是讨论 + 插值。</p>
<p>然后一路写 + 调到三个小时才过，期间我和他讨论，但貌似是倒忙，因为我的声称是让他换题，原因是：为什么能插值，我们不知道，你讨论全了没，我们不知道，那没有写对的道理，况且有几道看上去能做的题目，所以我想让他下来做其他可做题。</p>
<p>最后过了，上 A 就是正确的，但是没过吗，也没有错，错在我帮不上忙，毕竟平时这种事是队长和他干的，我对这种题目一点想法都没有，为什么是插值不知道，为什么讨论全了不知道，Imakf 伟大，无需多言。</p>
<p>期间我 L 声称了一个做法，然后上去写，三个半小时 RE 了，发现做法又假了，后面下去吃饭，发现可以流，上去写在四个小时四十分钟过了。</p>
<p>Imakf 非常厉害的在四个小时 20 分钟的时候过了 E 。、</p>
<p>赛后 Imakf 声称 L 一看就可以流，但是他没说，这就是他的问题了，如果是假的，吹牛逼该罚，如果是真的，不说，该罚。</p>
<p>最后队长上机 B ，可惜因为我们队的唐氏儿本场比赛从头演到尾吃掉队长机时，导致队长最后遗憾离场。</p>
<p>细数这场我的罪孽，K,L 假做法吃掉大量机时，以后上机前麻烦认真想想自己的做法，不要假了，假了就炸了。</p>
<p>部分题解：</p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>只要不出现一个数字出现 $n$ 次就可以，做法是把所有出现过的数字轮换一下填入。</p>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p>显然 $x,k-x$ 处于一个等价类，相邻两个数字是等价类就可以删。</p>
<p>则做法为能删就删，</p>
<h1 id="K"><a href="#K" class="headerlink" title="K"></a>K</h1><p>判断方法为：奇数先手必胜，偶数则所有数字 $-1$ 异或起来不为 $0$ 则必胜。</p>
<p>证明：</p>
<p>不妨考虑归纳，首先一堆是对的，现在假设 $k-1$ 堆是对的。</p>
<p>假设 $k$ 是偶数，那么显然是对的，因为谁先变成 $k-1$ 谁输，故是 $a_{i}-1$ 的 NIM 游戏，谁最先操作最后一个谁输。</p>
<p>假设 $k$ 是奇数，考虑先把所有数字减 $1$ ，即现在 $a_{i}\ge 0$ ，设异或起来为 $x$。</p>
<p>我们不妨证明以下两个情况的其中一个一定会发生：</p>
<ol>
<li>我们能找到 $i≠j$ ，满足：$min(a_{i},a_{j})\le x\bigoplus a_{i}\bigoplus a_{j}\le a_{i}+a_{j}$ 。</li>
<li>我们能找到 $i$ ，满足：$a_{i}\bigoplus x=0$ 。</li>
</ol>
<p>首先有几个性质：</p>
<ol>
<li>$x\bigoplus y\le x+y$ </li>
<li>若 $y$ 的二进制最高位在 $x$ 中为 $0$ ，则 $x\bigoplus y \ge x$ ，如果为 $1$ ，则 $x\bigoplus y \le x$</li>
</ol>
<p>然后讨论一下：</p>
<ol>
<li>$x=0$ ，随便取一个数字 $a_{i}$ ，否则取在 $x$ 最高位为 $1$ 的 $a_{i}$ ，简而言之，我们希望：$x\bigoplus a_{i} \le a_{i}$ 。</li>
<li>然后若 $x\bigoplus a_{i}=0$ ，则符合情况 $2$ ，否则找到在 $x\bigoplus a_{i}$ 最高位为 $0$ 的 $a_{j}(j≠i)$ ，故有：$x\bigoplus a_{i}\bigoplus a_{j} \le x\bigoplus a_{i} + a_{j} \le a_{i} + a_{j}$ ，同时有 $x\bigoplus a_{i}\bigoplus a_{j}\ge a_{j}$ ，综上，满足情况 $1$ 。</li>
</ol>
<p>证毕。</p>
<p>显然这两个条件满足其中一个都可以直接导出 $k-1$ 的先手必败态，所以先手必胜，证毕。</p>
<p>思考过程就是手玩，发现 $3,4$ 堆的必胜条件后，去猜结论，然后证明出来就对了。<del>虽然我们压根没证明，写暴力发现 5 堆也是对的就直接写了</del></p>
<p>$3$ 堆必胜的证明还是挺简单的，就是拿出最大的堆，留下剩下两堆差值的石头，然后和最小的堆合并，就可以剩下两个大小一样的堆，这样先手就必胜了。</p>
<p>在得到这个结论之后，莫队一下就做完了，时间复杂度：$O(n\sqrt{m})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> V = <span class="number">2e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> l, r, id;</span><br><span class="line">&#125;op[N];</span><br><span class="line"><span class="type">int</span> a[N], n, q;</span><br><span class="line"><span class="type">int</span> be[N];</span><br><span class="line"><span class="type">int</span> cnt[V][<span class="number">2</span>], zcnt[<span class="number">2</span>];</span><br><span class="line">LL ans = <span class="number">0ll</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">	zcnt[t]++;</span><br><span class="line">	ans += cnt[x][t];</span><br><span class="line">	cnt[x][t]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">	zcnt[t]--;</span><br><span class="line">	cnt[x][t]--;</span><br><span class="line">	ans -= cnt[x][t];</span><br><span class="line">&#125;</span><br><span class="line">LL zans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">		a[i]--;</span><br><span class="line">		a[i] ^= a[i - <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		be[i] = i / B + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">		cin &gt;&gt; op[i].l &gt;&gt; op[i].r;</span><br><span class="line">		op[i].l--;</span><br><span class="line">		op[i].id = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(op + <span class="number">1</span>, op + q + <span class="number">1</span>, [](node x, node y)&#123;</span><br><span class="line">		<span class="keyword">return</span> be[x.l] == be[y.l] ? x.r &lt; y.r : x.l &lt; y.l;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">		<span class="keyword">auto</span> [ll, rr, id] = op[i];</span><br><span class="line">		<span class="keyword">while</span>(r &lt; rr)&#123;</span><br><span class="line">			r++;</span><br><span class="line">			<span class="built_in">ins</span>(a[r], r &amp; <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(l &gt; ll)&#123;</span><br><span class="line">			l--;</span><br><span class="line">			<span class="built_in">ins</span>(a[l], l &amp; <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(r &gt; rr)&#123;</span><br><span class="line">			<span class="built_in">del</span>(a[r], r &amp; <span class="number">1</span>);</span><br><span class="line">			r--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(l &lt; ll)&#123;</span><br><span class="line">			<span class="built_in">del</span>(a[l], l &amp; <span class="number">1</span>);</span><br><span class="line">			l++;</span><br><span class="line">		&#125;</span><br><span class="line">		zans[id] = <span class="number">1ll</span> * (rr - ll + <span class="number">1</span>) * (rr - ll) / <span class="number">2</span> - ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++) cout &lt;&lt; zans[i] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="L"><a href="#L" class="headerlink" title="L"></a>L</h1><p>显然，必要条件是最大边和最小边在一个边双上。</p>
<p>所以不妨猜测边双上的最大差值就是答案。</p>
<p>但是怎么证明这个事情呢？</p>
<p>边双有个很好的性质：割掉一条边不会影响连通性，那么什么东西和连通性有关呢？就是最小割。</p>
<p>这么考虑这个问题：</p>
<p>现在指定两条边，怎么确定性的构造一个环经过这两条边呢？考虑把这两条边删掉，以这两天边的两个端点分别作为起终点，只需要证明这个图的割 $&gt; 1$ 就行了，一个比较有疑惑性的事情是，我们其实已经删掉了两条边，所以会不会不满足割的性质，但由于我们求最小割实际上考虑的是这四个点之间的连通性，所以其实等价于没有删除。</p>
<p>证明：我们假设被割的边是 $(x,y)$ ，显然 $x,y$ 不会是网络流图中的 $st,ed$ ，考虑边双中这个边被割掉后，这四个点一定有两个点不依赖于这两条边联通，所以网络流上仍然是联通的，矛盾，证毕。</p>
<p>具体来说，设一条边为 $(l_1,l_2),(r_1,r_2)$ ，求 $l_{1},l_{2}$ 到 $r_{1},r_{2}$ 的最近点对，显然 $(l_1,l_2),(r_1,r_2)$ 不会在这条路径上，否则与最近点对矛盾。</p>
<p>然后跑网络流就行了。</p>
<p>时间复杂度：$O(n)$ 。</p>
<p>至于退流，由于边权为 $1$ ，所以直接退就是对的吗？</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>PAM 学习笔记</title>
    <url>/2024/07/26/PAM-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="PAM-入门"><a href="#PAM-入门" class="headerlink" title="PAM 入门"></a>PAM 入门</h1><h1 id="前后端插入"><a href="#前后端插入" class="headerlink" title="前后端插入"></a>前后端插入</h1><p>题目链接：<a href="https://vjudge.net/problem/HDU-5421">https://vjudge.net/problem/HDU-5421</a></p>
<p>注意到回文后缀也是回文前缀，所以大体上没有变化。</p>
<p>只是要维护最长回文前缀和后缀，当最长回文前/后缀等于原串时，记得更新另外一个。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> len[N], fail[N], go[N][<span class="number">26</span>], llast, rlast, pam_cnt;</span><br><span class="line"><span class="type">int</span> dep[N];</span><br><span class="line">LL ans;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[N * <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> lenl, lenr, n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clgo</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="built_in">memset</span>(go[x], <span class="number">0</span>, <span class="built_in">sizeof</span>(go[x]));&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fail[<span class="number">0</span>] = pam_cnt = <span class="number">1</span>;</span><br><span class="line">    len[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">    llast = rlast = <span class="number">0</span>;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">clgo</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">clgo</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getLfail</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(lenl + len[p] + <span class="number">1</span> &gt; lenr || s[lenl + len[p] + <span class="number">1</span>] != s[lenl]) p = fail[p];</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRfail</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(lenr - len[p] - <span class="number">1</span> &lt; lenl || s[lenr - len[p] - <span class="number">1</span>] != s[lenr]) p = fail[p];</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">extend</span><span class="params">(<span class="type">int</span> type)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p, c, *last;</span><br><span class="line">    <span class="keyword">if</span>(type == <span class="number">0</span>) p = <span class="built_in">getLfail</span>(llast), c = s[lenl] - <span class="string">&#x27;a&#x27;</span>, last = &amp;llast;</span><br><span class="line">    <span class="keyword">else</span> p = <span class="built_in">getRfail</span>(rlast), c = s[lenr] - <span class="string">&#x27;a&#x27;</span>, last = &amp;rlast;</span><br><span class="line">    <span class="keyword">if</span>(!go[p][c])&#123;</span><br><span class="line">        <span class="type">int</span> q = ++pam_cnt, now = p;</span><br><span class="line">        <span class="built_in">clgo</span>(q);</span><br><span class="line">        len[q] = len[p] + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">0</span>) p = <span class="built_in">getLfail</span>(fail[p]);</span><br><span class="line">        <span class="keyword">else</span> p = <span class="built_in">getRfail</span>(fail[p]);</span><br><span class="line">        fail[q] =  go[p][c];</span><br><span class="line">        go[now][c] = q;</span><br><span class="line">        dep[q] = dep[fail[q]] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(lenr - lenl + <span class="number">1</span> == len[q]) llast = rlast = q;</span><br><span class="line">        <span class="keyword">else</span> *last = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> *last = go[p][c];</span><br><span class="line">    ans += dep[*last];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)&#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        lenl = n + <span class="number">1</span>;</span><br><span class="line">        lenr = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> type;</span><br><span class="line">            cin &gt;&gt; type;</span><br><span class="line">            <span class="keyword">if</span>(type &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">                string x; cin &gt;&gt; x;</span><br><span class="line">                <span class="keyword">if</span>(type == <span class="number">1</span>) s[--lenl] = x[<span class="number">0</span>], <span class="built_in">extend</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span> s[++lenr] = x[<span class="number">0</span>], <span class="built_in">extend</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">3</span>) cout &lt;&lt; pam_cnt - <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>今天突然意识到一个很严重的问题，双端插入回文串的时间复杂度为啥对呢？原因是最长回文前后缀相等的那个特判，如果不加分析，会破坏均摊分析，所以现在来分析一下双端插入回文串的时间复杂度：</p>
<p>不妨认为插入到后面，插入后左边的最长回文前缀为 $L$ ，右边为 $R$ ，显然 $L$ 是 $R$ 的最长回文真前缀，否则与插入前 $L$ 是最长回文前缀矛盾，所以在回文树上，$L$ 和 $R$ 的深度差恰好为 $1$ ，所以这个操作只会让势能增加 $1$ ，不会破坏均摊分析。</p>
<p>证毕。</p>
<h1 id="去均摊化"><a href="#去均摊化" class="headerlink" title="去均摊化"></a>去均摊化</h1><p>可以用于解决后端插入/删除 、 Trie 上 PAM 、可持久化 PAM 的问题。</p>
<p>详情请见 KMP 和 PAM 的可持久化。</p>
<p>在此不再赘述。</p>
<h1 id="前后端插入-删除"><a href="#前后端插入-删除" class="headerlink" title="前后端插入/删除"></a>前后端插入/删除</h1><p>PS ：同样可以用同样的方法可持久化。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>PAM</tag>
      </tags>
  </entry>
  <entry>
    <title>OI 常见的语法坑</title>
    <url>/2025/02/03/OI-%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AF%AD%E6%B3%95%E5%9D%91/</url>
    <content><![CDATA[<h1 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h1><h2 id="严格弱序比较"><a href="#严格弱序比较" class="headerlink" title="严格弱序比较"></a>严格弱序比较</h2><p>现在，有两个元， $a,b$ ，如果对于比较函数 $cmp(a,b)$ ，能以下格式函数表示出 $a,b$ 三种比较关系则为严格弱序比较：</p>
<p>$cmp(a,b)=1$ 则 $a&lt;b$  </p>
<p>$cmp(b,a)=1$ 则 $a&gt;b$</p>
<p>$!cmp(a,b)$ 且 $!cmp(b,a)$ 则 $a=b$</p>
<p>（这样说可能不太严谨）</p>
<p>可以发现，$a&lt;b$ 可以成立，但是如果 $a≤b$ 便不成立，那么这个就不叫严格弱序排序。</p>
<p>为什么提这个东西呢？</p>
<p> $sort$ 里面的 $cmp$ 函数必须要满足严格弱序比较。</p>
<p>如果不满足的话，那么在 $sort$ 的内部就会发生越界错误，然后就RE了QAQ（调了我贼久QAQ）。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/llz62378/article/details/88937139?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-7.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-7.control">STL 深入理解 sort 函数 和 严格弱序比较_李白-2017的博客-CSDN博客</a></p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Petrozavodsk Winter 2017 Day 1 赛后小结</title>
    <url>/2024/07/30/Petrozavodsk-Winter-2017-Day-1-%E8%B5%9B%E5%90%8E%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://qoj.ac/contest/1362">https://qoj.ac/contest/1362</a></p>
<p>队长怎么这么喜欢赤石，找这种场。</p>
<p>队友秒了 I ，我秒了 L 。</p>
<p>队长秒了 B ，队长一开始声称了一个 $m^2*26$ 的做法，后面队长发现短序列不用子序列自动机，直接推就是 $O(m^2)$ 的，我去写，过了。</p>
<p>队长上机连过 F,A 。</p>
<p>队友跟我说了他们 K 的做法，直接把相同长度的放一起处理，然后把原串的这个长度的子串扔进 Hash map 里，时间复杂度：$O(L(\sqrt{L}+26))$ ，我觉得很对啊，而且模糊匹配一个字符怎么可能有低于根号的做法，我就直接上了。</p>
<p>第一发 WA ，此时时间一小时。</p>
<p>然后我开始写对拍，半个小时后写完对拍开拍（ Py 不熟练是这样子的）。</p>
<p>期间队友搞出了 C 。</p>
<p>后面发现是因为爆 long long 了，具体来说，正确写法是：<code>(__int128_t)x*y</code> ，而我写成了：<code>(__int128_t)(x*y)</code> ，不熟练运算优先级导致的。</p>
<p>后 T 了，最快结束的时候卡常卡过去了，赛后才知道正解是 log 的，错怪出题人了。</p>
<p>卡常手法包括：手动写 Hash map ，根据插入元素的个数决定清空方式（最后加了这个，卡过去了），等等一系列比较小的细节。</p>
<p>总之，在两个小时换了 Hash map T 了后，就暂时先放弃了此题。</p>
<p>在队长卡常的时候，我和队友聊了 J ，感觉是把前缀建个节点，后缀建个节点，连成二分图，找一个类似四元环的东西，但因为是二分图，所以可以直接认为就是找四元环，但是是根号的，我觉得过不了。</p>
<p>后面队友上去写 H ，和队长聊 D ，队长一语道破天机，只有 $64^3*2$ 种状态，所以转移就行了，但是我觉得太难写了，写不出来，遂去思考怎么写 J 。</p>
<p>队友接近三小时的时候过 H 了，询问队友怎么找四元环，以及为啥复杂度是对的，期间队友因为我执着于为啥复杂度是根号的固执和愚蠢怒发冲冠，在队友的耐心轰入下终于明白为啥是根号，赞成队友说的这是特殊图，跑不满的观点，开写。</p>
<p>这里我问复杂度这个行为对不对呢？如果真是重大比赛，其实只需要问队友这个复杂度是不是不是严格的，特殊图是不是不会跑满这个问题，得到肯定答复后直接把做法当黑盒用就可以开写了，不能浪费机时，也不能浪费思考时间，但是不是的话问一下还是可以的。</p>
<p>三个小时过去了，收获第一发 WA ，半个小时后发现原来是某个地方点数搞错了，改了过了。</p>
<p>具体来说，我一开始以为点数是 $n+n$ ，在一次调试后发现点数应该是总长乘 $2$ ，改了，但只改了一部分。</p>
<p>所以建议以后这种基本变量的更改得用 Ctrl F 把所有这种地方全改了，防止遗漏，还是习惯不好导致的。</p>
<p>期间队长上 D ，我和队友讨论，Imakf 突然发现 G 其实就是个循环卷积，但因为我对这题并不熟悉，而且系数之类的也没想明白，我并不愿意上机此题，最后和队友决定，我把多项式部分抄了，队友在机下想好系数再上。</p>
<p>不得不说尚菲杨的多项式板子真好用啊，最后抄完发现错了，后来发现是快速幂写错了，唐完了。</p>
<p>最后 Imakf 上机，在 04:18:05 收获第一发 WA ，下机，我突然发现 $nm^2$ 爆 998244353 了，所以换了个模数接着上，结果还是 WA ，我们突然意识到这发草率了（虽然但是，我感觉最后一个小时的送怎么样都不算唐，除非有罚时跟着很紧的情况，否则过了血赚，不过 20 罚时罢了），因为系数是近似随机的，所以超过 998244353 还是有难度的。</p>
<p>最后发现是 Imakf 最后没取模，唐完了，四个半小时过了。</p>
<p>最后队长激情写 D ，最后十分钟写完，但拼尽全力也无法在比赛结束前调试出来。</p>
<p>部分题解：</p>
<h1 id="L"><a href="#L" class="headerlink" title="L"></a>L</h1><p>显然从大到小，否则交换更优。</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>设 $f[x][y]$ 表示短序列前 $x$ 和匹配了 $y$ 个在长序列中的最小的位置是多少。</p>
<p>时间复杂度：$O(26n+m^2)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> st[N];</span><br><span class="line">	cin &gt;&gt; st;</span><br><span class="line">	<span class="built_in">memcpy</span>(s + <span class="number">1</span>, st, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(st) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> nxt[N][<span class="number">26</span>], las[<span class="number">26</span>];</span><br><span class="line"><span class="type">char</span> s1[N], s2[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dp[M][M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="built_in">get_char_array</span>(s1);</span><br><span class="line">		<span class="built_in">get_char_array</span>(s2);</span><br><span class="line">		n = <span class="built_in">strlen</span>(s1 + <span class="number">1</span>);</span><br><span class="line">		m = <span class="built_in">strlen</span>(s2 + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) las[i] = n + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) nxt[i][j] = las[j];</span><br><span class="line">			las[s1[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) nxt[<span class="number">0</span>][i] = las[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) dp[i][j] = n + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)&#123;</span><br><span class="line">				dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">				<span class="keyword">if</span>(j &amp;&amp; dp[i - <span class="number">1</span>][j - <span class="number">1</span>] != n + <span class="number">1</span>) dp[i][j] = <span class="built_in">min</span>(dp[i][j], nxt[dp[i - <span class="number">1</span>][j - <span class="number">1</span>]][s2[i] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = m; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(dp[m][i] != n + <span class="number">1</span>)&#123;</span><br><span class="line">				cout &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="K"><a href="#K" class="headerlink" title="K"></a>K</h1><p>我们的做法：</p>
<p>根据长度将询问串分组，把主串的子串丢进 Hash map 中，然后询问串一个个改，一个个问。</p>
<p>时间复杂度：$O(L(\sqrt{L}+26))$ 。</p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>不妨把同编号的点看成一个区域，然后 $(x,y)$ 的格子看成是 $x,y$ 区域的连边，则这是个 $n$ 个点的平面完全图，所以 $n&gt;5$ 时无解，玩出小范围就行了。</p>
<h1 id="J"><a href="#J" class="headerlink" title="J"></a>J</h1><p>前缀当成点，后缀当成点，连边，则等价于找这样的结构：</p>
<p><img src="1.png" alt=""></p>
<p>注意到这是二分图，等价于找四元环。</p>
<p>四元环怎么找，按照深度从大到小排序，给每条边定向。</p>
<p>每次搜索每个点，然后遍历其出边，这里要求只到排名大于他的点，再遍历出边的出边打标记，遇到已经打过标记的点就返回结果，找到了个四元环，这样的时间复杂度是多少呢？</p>
<p>度数 $d\le \sqrt{m}$ 的点至多被找 $\sqrt{m}$ 次，所以贡献为：$d*\sqrt{m}$ ，所以总共不超过 $m\sqrt{m}$ 次。</p>
<p>$d&gt;\sqrt{m}$ ，则能到达其的点至多 $\frac{m}{d}$ 次，所以其的贡献为 $m$ ，这样的点至多 $\sqrt{m}$ 个，所以贡献不超过 $O(m\sqrt{m})$ 。</p>
<p>所以总时间复杂度是 $O(m\sqrt{m})$ 的。</p>
<p>这是个特殊的图，所以跑的不慢。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">__int128_t</span> IT;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">991234123412334719</span>, B = <span class="number">323</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN = N * <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> n, zlen;</span><br><span class="line">string s[N];</span><br><span class="line">vector&lt;LL&gt; hl[N], hr[N];</span><br><span class="line">map&lt;LL, <span class="type">int</span>&gt; id[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> icnt[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> y, next;</span><br><span class="line">	<span class="type">int</span> id;</span><br><span class="line">&#125;a[NN]; <span class="type">int</span> len, las[NN], du[NN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins_</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> c)</span></span>&#123;a[++len] = &#123;y, las[x], c&#125;; las[x] = len;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="built_in">ins_</span>(x, y, c);</span><br><span class="line">	<span class="built_in">ins_</span>(y, x, c);</span><br><span class="line">	du[x]++;</span><br><span class="line">	du[y]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getid</span><span class="params">(LL x, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> tmp = id[t].<span class="built_in">find</span>(x);</span><br><span class="line">	<span class="keyword">if</span>(tmp == id[t].<span class="built_in">end</span>())&#123;</span><br><span class="line">		id[t][x] = ++icnt[t];</span><br><span class="line">		<span class="keyword">return</span> icnt[t];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">return</span> (*tmp).second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ord[NN], rk[NN], pre1[NN], pre2[NN], pre3[NN];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getans</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= icnt[<span class="number">1</span>]; i++)&#123;</span><br><span class="line">		<span class="type">int</span> x = ord[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k1 = las[x]; k1; k1 = a[k1].next)&#123;</span><br><span class="line">			<span class="type">int</span> y = a[k1].y;</span><br><span class="line">			<span class="keyword">if</span>(rk[y] &lt; rk[x]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k2 = las[y]; k2; k2 = a[k2].next)&#123;</span><br><span class="line">				<span class="type">int</span> z = a[k2].y;</span><br><span class="line">				<span class="keyword">if</span>(z == x || pre3[z] == y) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span>(pre1[z])&#123;</span><br><span class="line">					ans = &#123;pre1[z], pre2[z], a[k2].id, a[k1].id&#125;;</span><br><span class="line">					<span class="keyword">if</span>(x &gt; zlen) <span class="built_in">rotate</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">begin</span>() + <span class="number">1</span>, ans.<span class="built_in">end</span>());</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				pre1[z] = a[k1].id;</span><br><span class="line">				pre2[z] = a[k2].id;</span><br><span class="line">				pre3[z] = y;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k1 = las[x]; k1; k1 = a[k1].next)&#123;</span><br><span class="line">			<span class="type">int</span> y = a[k1].y;</span><br><span class="line">			<span class="keyword">if</span>(rk[y] &lt; rk[x]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k2 = las[y]; k2; k2 = a[k2].next)&#123;</span><br><span class="line">				<span class="type">int</span> z = a[k2].y;</span><br><span class="line">				pre1[z] = pre2[z] = pre3[z] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		icnt[<span class="number">0</span>] = icnt[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">			cin &gt;&gt; s[i];</span><br><span class="line">			icnt[<span class="number">1</span>] += s[i].<span class="built_in">length</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		zlen = icnt[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">			hl[i].<span class="built_in">resize</span>(s[i].<span class="built_in">length</span>() + <span class="number">1</span>);</span><br><span class="line">			hr[i].<span class="built_in">resize</span>(s[i].<span class="built_in">length</span>() + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s[i].<span class="built_in">length</span>(); j++) hl[i][j] = ((IT) hl[i][j - <span class="number">1</span>] * B + s[i][j - <span class="number">1</span>]) % mod;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = s[i].<span class="built_in">length</span>() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) hr[i][j] = ((IT) hr[i][j + <span class="number">1</span>] * B + s[i][j]) % mod;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; s[i].<span class="built_in">length</span>(); j++)&#123;</span><br><span class="line">				<span class="type">int</span> l = <span class="built_in">getid</span>(hl[i][j], <span class="number">0</span>);</span><br><span class="line">				<span class="type">int</span> r = <span class="built_in">getid</span>(hr[i][j], <span class="number">1</span>);</span><br><span class="line">				<span class="built_in">ins</span>(l, r, i);</span><br><span class="line">				<span class="comment">// ins(r, l, i);</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= icnt[<span class="number">1</span>]; i++) ord[i] = i;</span><br><span class="line">		<span class="built_in">sort</span>(ord + <span class="number">1</span>, ord + icnt[<span class="number">1</span>] + <span class="number">1</span>, [](<span class="type">int</span> x, <span class="type">int</span> y)&#123;<span class="keyword">return</span> du[x] &gt; du[y];&#125;);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= icnt[<span class="number">1</span>]; i++) rk[ord[i]] = i;</span><br><span class="line">		ans.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">getans</span>()) cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">			cout &lt;&lt; s[ans[<span class="number">0</span>]] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s[ans[<span class="number">2</span>]] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">			cout &lt;&lt; s[ans[<span class="number">1</span>]] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s[ans[<span class="number">3</span>]] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ans.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">			hl[i].<span class="built_in">clear</span>();</span><br><span class="line">			hr[i].<span class="built_in">clear</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">1</span>; t++)&#123;</span><br><span class="line">			map&lt;LL, <span class="type">int</span>&gt; tmp;</span><br><span class="line">			<span class="built_in">swap</span>(tmp, id[t]);</span><br><span class="line">		&#125;</span><br><span class="line">		len = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= icnt[<span class="number">1</span>]; i++) las[i] = du[i] = pre1[i] = pre2[i] = pre3[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p>注意到贡献是个类似循环卷积的东西，即：$(2x-1)^{n}$ ，其中系数 $\mod m$ ，关于 $x^{n}$ 循环。</p>
<p>其中 $x$ 表示 $i+x$ 的贡献系数。</p>
<p>由于循环卷积可以看成先不循环，算完结果以后再循环算一下结果，则根据卷积的结合律可以得到循环卷积也有结合律，所以可以快速幂。</p>
<p>时间复杂度：$O(n\log{n}\log{t})$ 。</p>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>注意到状态不超过 $64^3*2$ ，同时可以注意到一个性质，任何一种先手状态都存在将死局面，这个时候怎么转移都行了。</p>
<p>队长写了度数转移。</p>
<p>后面队长声称没看到题面写的答案写的 50 步以内，所以可以直接迭代 50 步，会更加好写。</p>
<p>但我感觉无论怎样，这道题目都很难写，史味浓浓啊。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>Pick Your Own Nim</title>
    <url>/2024/01/31/Pick-Your-Own-Nim/</url>
    <content><![CDATA[<p>题目链接：<a href="https://codeforces.com/gym/102156/problem/D">https://codeforces.com/gym/102156/problem/D</a></p>
<p>题目大意：</p>
<p>给你 $n$ 个数字，再给你 $m$ 组数字，你要在每一组里面选一个数字，使得选出来的数字和那 $n$ 个数字，关于异或运算线性无关，如果可以，给一组方案。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>有限大小的线性空间本身就是拟阵，这样就很显然了。</p>
<ol>
<li>拟阵 $1$ 是线性无关。（算上那 $n$ 个数字）</li>
<li>拟阵 $2$ 是每组数字至多一个。</li>
</ol>
<p>时间复杂度：$O(60^2\sum\limits k_i)$ 。</p>
<p>记得特判一开始的 $n$ 个数字是否线性无关，否则还是老生常谈的问题：$\emptyset\notin \mathcal{I}$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N1=<span class="number">65</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N2=<span class="number">5e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">6e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m,K;</span><br><span class="line">LL va[N2];<span class="type">int</span> bel[N2];</span><br><span class="line"><span class="type">bool</span> col[N1],in[N2];</span><br><span class="line"></span><br><span class="line">LL sta[N1];</span><br><span class="line"><span class="type">int</span> pos[N1],top;</span><br><span class="line">LL lin[N1],fac[N1];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">add</span><span class="params">(LL x,<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    LL now=(<span class="number">1ll</span>&lt;&lt;(id<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">59</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!lin[i])&#123;</span><br><span class="line">                lin[i]=x;</span><br><span class="line">                fac[i]=now;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> x^=lin[i],now^=fac[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">build_liner</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(lin,<span class="number">0</span>,<span class="built_in">sizeof</span>(lin));</span><br><span class="line">    <span class="built_in">memset</span>(fac,<span class="number">0</span>,<span class="built_in">sizeof</span>(fac));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">add</span>(sta[i],i))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">findfac</span><span class="params">(LL x)</span></span>&#123;</span><br><span class="line">    LL now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">59</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!lin[i])<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> x^=lin[i],now^=fac[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y,next;</span><br><span class="line">&#125;a[M];<span class="type">int</span> len,las[N2];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;a[++len]=&#123;y,las[x]&#125;;las[x]=len;&#125;</span><br><span class="line"><span class="type">int</span> typ[N2];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getliner</span><span class="params">()</span></span>&#123;</span><br><span class="line">    top=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i])sta[++top]=va[i],pos[top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">build_liner</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(las+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*K);</span><br><span class="line">    <span class="built_in">memset</span>(typ+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*K);</span><br><span class="line">    <span class="built_in">getliner</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> now=n+<span class="number">1</span>,i=pos[now];now&lt;=top;now++,i=pos[now])&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=K;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[j])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(bel[i]==bel[j] || !col[bel[j]])<span class="built_in">ins</span>(j,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i])<span class="keyword">continue</span>;</span><br><span class="line">        LL x=<span class="built_in">findfac</span>(va[i]);</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">-1</span>)&#123;</span><br><span class="line">            typ[i]|=<span class="number">1</span>;</span><br><span class="line">            x=(<span class="number">1ll</span>&lt;&lt;top)<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> now=n+<span class="number">1</span>;now&lt;=top;now++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((x&gt;&gt;(now<span class="number">-1</span>))&amp;<span class="number">1</span>)<span class="built_in">ins</span>(pos[now],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!col[bel[i]])typ[i]|=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> pre[N2];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)pre[i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(typ[i]&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            pre[i]=<span class="number">0</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(typ[x]&amp;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">while</span>(x)&#123;</span><br><span class="line">                col[bel[x]]^=<span class="number">1</span>;</span><br><span class="line">                in[x]^=<span class="number">1</span>;</span><br><span class="line">                x=pre[x];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=las[x];k;k=a[k].next)&#123;</span><br><span class="line">            <span class="type">int</span> y=a[k].y;</span><br><span class="line">            <span class="keyword">if</span>(pre[y]==<span class="number">-1</span>)&#123;</span><br><span class="line">                pre[y]=x;</span><br><span class="line">                q.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);top=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;sta[i]);</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">build_liner</span>())&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> cnt;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;cnt);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++)&#123;</span><br><span class="line">            ++K;bel[K]=i;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;va[K]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">build</span>();</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">solve</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=K;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i])<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,va[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>Petrozavodsk Winter 2016 Day 3 赛后小结</title>
    <url>/2024/07/29/Petrozavodsk-Winter-2016-Day-3-%E8%B5%9B%E5%90%8E%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://qoj.ac/contest/1350">https://qoj.ac/contest/1350</a></p>
<p>怎么队长这么喜欢霓虹景的比赛。</p>
<p>开局队长秒 E ，我和队友看了 J ，发现 Purfer 板子题，上机写 WA 了一发，原因：没判数量为 $0$ 的情况，因为可能不存在一棵树有这样子的度数。</p>
<p>后面队长给队友说了一个 L ，说这是个边际距离简单题，然后上机下机 balabala ，最后留下名言：以后这种贪心题应该想好了再上机，没想好就上有点唐了。</p>
<p>期间我和队长聊起 B ，然后交流了一下，大概做法是二分 + 并查集，还有个曼哈顿距离 $\ge D$ 的经典 trick ，拆成四种式子分别加，只会算少不会算多，队长说他搞一下，我先去看了 M ，M 是个构造，因为我是构造苦手，而且队长好像搞 B 搞晕了，就和他交换了题目。</p>
<p>后面发现 B 的四种情况的两两连边，只需要考虑至少有一方为最大值的情况就行了，上机结果 T 了，后面发现是一个全新的错误：</p>
<p>二分如果 $r$ 的量级为 $2<em>10^{9}$ ，那么有可能在算 $mid$ 的时候 $2</em>10^{9}+2*10^{9}$ 爆 int ，所以应该写成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">mid = l + (r - l) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>学到了学到了。<del>结果这一场的后面又犯了一个这样的错误</del></p>
<p>B AC 后，L 也 AC 了，我在看 C ，感觉是疑似背包的东西，这时队长声称，I 是 CF div2 D 的 SB 题，跟我讲了一遍做法，我当时觉得并不好写，而且手里还有 C ，拒绝上机的，队长遂找到 Imakf ，和其交流，Imakf 也觉得好写，遂上机。</p>
<p>这时一个小时过去了。</p>
<p>然后我和队长交流 C ，我声称背包大小只有 $±2V$ ，队长认同了，也许？然后因为没有机时，我去看 D 了，感觉 D 是一个 dp 就能完成，注意到匹配不能唯一决定的情况当且仅当两个序列后面的一段都是相同的，当某个串跳出这一段的时候，就又能唯一确定匹配了，而这一段的匹配数量是一个折线法就能完成的事，需要枚举没跳出这一段的长度，因此时间复杂度是 ：$O(n^2+\mathrm{极长相等的一段的长度的平方和})$ ，注意到后者也是至多 $O(n^2)$ 的，所以可以 AC 。（说起来特别唐的是，复杂度我其实算错了，按照我当时的想法，复杂度应该是 $O(n^2+\mathrm{极长相等的一段的长度的和})$ ，但我当时其实少计算某个部分的复杂度，所以真正正确的复杂度还是 $O(n^2+\mathrm{极长相等的一段的长度的平方和})$ 的，只能说恰好负负得正了，运气真好）</p>
<p>然后 Imakf 感觉 I 有点细节，下来交流，我上机把 C，D 写了，但是这里我犯了一个错误，就是应该我在 AC 了 C 的时候，应该让队友上机，而不应该连续上机。</p>
<p>一个简单的情形，如果队里两个人手里都有 $2$ 个题，那么应该是一人轮流上一个题，原因是：</p>
<ol>
<li>首先保证一个人不会在机上红温。</li>
<li>其次保证每个人在一个比较长的时间段都有在机下的时间，能够保证每个题目每个人都能给出他的观察，防止出现能给出关键观察的人在机上的情况。</li>
<li>同时如果一个人在机上写错了什么东西，打印下来看，另外一个人可以直接上机，不会浪费机时，如果一个人先上完了所有的题，那么后一个人一旦在机上遇到错误，需要下机的时候，队伍里没有人手里有题，机时就会空缺，这是十分严重的问题。</li>
</ol>
<p>总之这里确实犯了一个决策上的错误，只能说当时手感火辣，当了机霸。</p>
<p>在我写 C,D 的期间，队友们讨论出了 H 。</p>
<p> Imakf 上机写了一下 I ，第一发 RE ，此时两小时，半个小时后过了，感觉这题确实难写，队长说好写只能说队长太牛了，不过我确实不太会写代码。</p>
<p> Imakf 搞 I 的期间我想了想 H ，发现好像是简单容斥 dp ，两点半的时候上机过了，还犯了个错误，我以为回到原点是四个方向的步数一样，实际上是四个方向两两步数一样，只能说唐了。</p>
<p>队长上机写 H ，我和 Imakf 开始讨论 G ，我们得出结论，这道题目是史，也有可能是我们做法不太行，反正是容斥 + 讨论 + 拉格朗日插值。</p>
<p>三个小时，队长过 H ，接下来半个小时，我思考怎么写 G ，队友们讨论 A ，三个半小时过了。</p>
<p>最后一个半小时我没有写出 G ，队友没做出 M ，爆。</p>
<p>感觉比较大的问题就是连续上机，其余没啥大问题。</p>
<h1 id="J"><a href="#J" class="headerlink" title="J"></a>J</h1><p>不会做的建议认真学习 Prufer 序列。</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>先二分 $D$ 。</p>
<p>显然只有四种情况：$±x±y$ ，讨论 $x+y$ 和 $-x-y$ 的情况。</p>
<p>先从大到小排序，注意到有下面这张图成立，所以只用关心和最大值有关的连边。</p>
<p><img src="2.png" alt=""></p>
<p>时间复杂度：$O(n\log{n})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">findfa</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">mer</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	x = <span class="built_in">findfa</span>(x);</span><br><span class="line">	y = <span class="built_in">findfa</span>(y);</span><br><span class="line">	<span class="keyword">if</span>(x != y) fa[x] = y;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> val, id;</span><br><span class="line">&#125;a[<span class="number">4</span>][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> D)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i] = i;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++)&#123;</span><br><span class="line">		<span class="type">int</span> j = <span class="number">3</span> ^ i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i][<span class="number">1</span>].val + a[j][k].val &gt;= D) cnt += <span class="built_in">mer</span>(a[i][<span class="number">1</span>].id, a[j][k].id);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt == n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="type">int</span> x, y;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		a[<span class="number">0</span>][i] = &#123;x + y, i&#125;;</span><br><span class="line">		a[<span class="number">1</span>][i] = &#123;x - y, i&#125;;</span><br><span class="line">		a[<span class="number">2</span>][i] = &#123;- x + y, i&#125;;</span><br><span class="line">		a[<span class="number">3</span>][i] = &#123;- x - y, i&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++)&#123;</span><br><span class="line">		<span class="built_in">sort</span>(a[i] + <span class="number">1</span>, a[i] + n + <span class="number">1</span>, [](node x, node y)&#123;<span class="keyword">return</span> x.val &gt; y.val;&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">2e9</span>, mid, ans = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">		mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid + <span class="number">1</span>, ans = mid;</span><br><span class="line">		<span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>首先，注意到初始点在 $x$ ，则跳跃若干次后的坐标形如：</p>
<script type="math/tex; mode=display">2(\sum\limits_{i=1}^{k}a_{b_{i}}*(-1)^{i-1})+x*(-1)^{k}</script><p>前面部分是可以类似背包一样跑的，或者说类似同余最短路那样跑，具体来说，以 $k$ 的奇偶性和 $\sum\limits_{i=1}^{k}a_{b_{i}}*(-1)^{i-1}$ 的数值跑宽搜。</p>
<p>现在有一个关键，这个宽搜的大小多大，直觉告诉我是 $±2V$ ，这样时间复杂度是：$O(nV)$ 的。</p>
<p>后面证明了。</p>
<p>具体来说，我们证明，若终点的绝对值 $\le V$ ，则一定存在一个顺序使得 $\forall 1\le j\le k,|\sum\limits_{i=1}^{j}a_{b_{i}}*(-1)^{i-1}|\le 2V$ ：</p>
<p>证明方法为设现在的值为 $x$ 。</p>
<p>设正贡献的数组为 ：$a_{1}\le a_{2}\le …\le a_{k}$</p>
<p>设负贡献的数组为 ：$b_{1}\le b_{2}\le …\le b_{k}$</p>
<p>不妨设 $x\ge 0$ ：</p>
<p>则如果 $a_{1}-b_{k}\ge 0$ ，则 $a_{i}-b_{i}\ge 0$ ，则 $x\le$ 目标，所以过程中 $\le 2V$ 。</p>
<p>如果 $a_{1}-b_{k}&lt;0$ ，则进行这样子的操作，操作完后 $-V\le x’\le x$ ，证毕。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> V = <span class="number">1e4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B = <span class="number">2</span> * V;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L = <span class="number">4</span> * V;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXV = L + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> d[<span class="number">2</span>][MAXV];</span><br><span class="line"><span class="type">int</span> n, q, a[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> mid, <span class="type">int</span> r)</span></span>&#123;<span class="keyword">return</span> l &lt;= mid &amp;&amp; mid &lt;= r;&#125;</span><br><span class="line">queue&lt;PII&gt; p;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= L; i++) d[<span class="number">0</span>][i] = d[<span class="number">1</span>][i] = INF;</span><br><span class="line">	d[<span class="number">0</span>][B] = <span class="number">0</span>;</span><br><span class="line">	p.<span class="built_in">push</span>(&#123;<span class="number">0</span>, B&#125;);</span><br><span class="line">	<span class="keyword">while</span>(!p.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="keyword">auto</span> [t, v] = p.<span class="built_in">front</span>();</span><br><span class="line">		<span class="type">int</span> val = d[t][v];</span><br><span class="line">		p.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">			<span class="type">int</span> nv = a[i] - (v - B) + B;</span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">pd</span>(<span class="number">0</span>, nv, L)) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(d[t ^ <span class="number">1</span>][nv] == INF)&#123;</span><br><span class="line">				d[t ^ <span class="number">1</span>][nv] = val + <span class="number">1</span>;</span><br><span class="line">				p.<span class="built_in">push</span>(&#123;t ^ <span class="number">1</span>, nv&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cin &gt;&gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">		<span class="type">int</span> s, t;</span><br><span class="line">		cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">		<span class="keyword">if</span>((s &amp; <span class="number">1</span>) != (t &amp; <span class="number">1</span>))&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> ans = <span class="built_in">min</span>(d[<span class="number">0</span>][(t - s) / <span class="number">2</span> + B], d[<span class="number">1</span>][(t + s) / <span class="number">2</span> + B]);</span><br><span class="line">		<span class="keyword">if</span>(ans == INF) ans = <span class="number">-1</span>;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>注意到一个事情，假如我给你一个方案，什么时候会有多个选择。</p>
<p>不妨设前 $t$ 个字母一定能够唯一确定，意思是存在唯一的 $i$ 和 $j$ 满足第一个数组前 $i$ 个和第二个数组前 $j$ 个能够合并出这个数组前 $t$ 个数字。</p>
<p>思考一下转移，如果 $a[i+1]≠b[j+1]$ ，那么 $t$ 可以直接 $+1$ 。</p>
<p>否则设 $len$ 为后面的最长相等连续段，注意到 $len$ 之后的字符是不同的，因此下一次能够唯一确定的时间在 $a[i+len+1],b[j+len+1]$ 中出现其中一个，而在这之前的匹配注意都存在多种的选择，其中直接将 $i,j$ 之后的匹配交换就是一种新的选择，因此我们选择直接记录这一段的方案，然后直接转移到 $i+len+1$ 或者 $j+len+1$ 的位置。</p>
<p>好了，大体思路有了，设计方程和转移：</p>
<p>$f[i][j]$ 表示有多少个长度为 $i+j$ 的数组能够唯一确定，且对应的 $i,j$ 就是下标中的 $i,j$ 的方案数。</p>
<p>转移就是如果后面的最长相等连续段是 $0$ ，则直接转移，否则转移到 $i+len+1$ ，枚举 $j$ 的位置或者反过来。</p>
<p>则时间复杂度为 ：$O(n^2+\mathrm{极长相等的一段的长度的平方和})$ ，注意到极长的相等子串的长度和为 $n$ ，具体来说，肯定是第一个数组的一个切割，以是否在第二个数组中连续为指标，所以平方和 $\le n^2$ ，所以总时间复杂度为 ：$O(n^2)$ ，做闭。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line">LL dp[N][N], fc[N * <span class="number">2</span>], nfc[N * <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x &lt; y || y &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0ll</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> fc[x] * nfc[y] % mod * nfc[x - y] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">calc_</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">C</span>(x, (x + y) / <span class="number">2</span>);&#125;</span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">calc_</span>(x, y) - <span class="built_in">calc_</span>(x, - <span class="number">2</span> - y) + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(LL &amp;x, LL y)</span></span>&#123;x = (x + y) % mod;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	nfc[<span class="number">0</span>] = nfc[<span class="number">1</span>] = fc[<span class="number">0</span>] = fc[<span class="number">1</span>] = <span class="number">1ll</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n + n; i++) nfc[i] = (mod - mod / i) * nfc[mod % i] % mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n + n; i++) fc[i] = fc[i - <span class="number">1</span>] * i % mod, nfc[i] = nfc[i - <span class="number">1</span>] * nfc[i] % mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; b[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = n; j &gt;= <span class="number">1</span>; j--)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i] == b[j]) f[i][j] = f[i + <span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1ll</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!dp[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(!f[i + <span class="number">1</span>][j + <span class="number">1</span>])&#123;</span><br><span class="line">				<span class="keyword">if</span>(i != n) <span class="built_in">upd</span>(dp[i + <span class="number">1</span>][j], dp[i][j]);</span><br><span class="line">				<span class="keyword">if</span>(j != n) <span class="built_in">upd</span>(dp[i][j + <span class="number">1</span>], dp[i][j]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(i == j &amp;&amp; f[i + <span class="number">1</span>][j + <span class="number">1</span>] == n - i)&#123;</span><br><span class="line">					<span class="built_in">upd</span>(dp[n][n], <span class="built_in">calc</span>(f[i + <span class="number">1</span>][j + <span class="number">1</span>] * <span class="number">2</span>, <span class="number">0</span>) * dp[i][j]);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(f[i + <span class="number">1</span>][j + <span class="number">1</span>] != n - i)&#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= f[i + <span class="number">1</span>][j + <span class="number">1</span>]; k++)&#123;</span><br><span class="line">						<span class="built_in">upd</span>(dp[i + f[i + <span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">1</span>][j + k], <span class="built_in">calc</span>(f[i + <span class="number">1</span>][j + <span class="number">1</span>] + k, f[i + <span class="number">1</span>][j + <span class="number">1</span>] - k) * dp[i][j]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(f[i + <span class="number">1</span>][j + <span class="number">1</span>] != n - j)&#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= f[i + <span class="number">1</span>][j + <span class="number">1</span>]; k++)&#123;</span><br><span class="line">						<span class="built_in">upd</span>(dp[i + k][j + f[i + <span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">1</span>], <span class="built_in">calc</span>(f[i + <span class="number">1</span>][j + <span class="number">1</span>] + k, f[i + <span class="number">1</span>][j + <span class="number">1</span>] - k) * dp[i][j]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; dp[n][n] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><p>感觉是简单容斥，不知道为什么刚上手没有思路，还要想一会才发现是简单容斥。</p>
<p>设 $f[n]$ 表示 $n$ 步的答案，$g[n]$ 表示从原点出发，$n$ 步以后第一次回到原点的方案数。</p>
<p>考虑 $f[n+1]-f[n]$ ，如果不考虑去重，增量是 $4^{n+1}$ （路径个数），但是问题是有些路径可能以前到过这个格子，所以枚举上一次到达这个格子的时间 $i$ ，那么下一次重复经过格子的时间为 $n+1$ 的路径个数为：$4^{i}*g[n+1-i]$ ，减去即可，因为枚举的是恰好上一次，而不是之前的所有次数，所以恰好把所有重复贡献减掉，就是答案。</p>
<p>时间复杂度：$O(n^2)$ 。</p>
<h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p>我们的做法是尝试枚举最终在数轴上有几段，现在先解决两段的情况：</p>
<p>注意到如果我们认为 $1,2$ 合并成一段，$3,4$ 合并成一段，那么不妨把前者的长度设为 $x$ 坐标，后者长度视为 $y$ 坐标，那么对应的可能长度在平面上是个矩形。</p>
<p>那么枚举所有可能的组合，就得到了一堆矩形，现在就只需要统计这些矩形所覆盖的区域的贡献，其中 $(x,y)$ 的贡献为：</p>
<ol>
<li>$x+y+1&gt;n$ ，则贡献为 $0$ 。</li>
<li>否则为 $\binom{n-x-y+1}{2}$ 。</li>
</ol>
<p>不妨考虑用子集容斥处理，因此我们只要能在接近 $O(1)$ 的时间算出一个矩形的贡献就行了。</p>
<p>由于 $x+y+1&gt;n$ 的时候贡献为 $0$ ，因此不能直接二元的多项式插值，因此不妨考虑这样计数，枚举 $x+y$ ，注意到 $x+y$ 相等的时候组合数是同一个，考虑用组合数 <em> 个数的方式计数，相当于用 $x+y=t$ 的线扫过整个矩形，然后 $x+y=t$ 的贡献为：$\binom{n-t+1}{2}</em>\mathrm{线经过的矩形格子数}$ 。</p>
<p>注意到个数可以分为三段：个数不断 $+1$ ，个数恒定，个数 $-1$ ，分为三段，每一段的答案都是个关于这一段的长度的四次函数，可以拉格朗插值求得。</p>
<p>经过计算，这里可能的组合数量上界为 $20$ 个，所以可以直接容斥。</p>
<p>一段和四段都是简单的，问题在于三段，三段可能有 $36$ 种组合，而且立方体计数很麻烦，爆。</p>
<p>但是注意到在三维中只有一维有范围，那么计数问题解决了，其次，不妨把有范围的称为这个组合的方向，同方向的组合之间只有两种关系：不交和相等，因此去重后，四个以上的组合的立方体的交集一定为空，所以就可以容斥了。</p>
<p>然后就做完了，写起来非常的史。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, LL&gt; PLL;</span><br><span class="line"><span class="keyword">typedef</span> array&lt;PLL, 2&gt; AP2;</span><br><span class="line"><span class="keyword">typedef</span> array&lt;PLL, 3&gt; AP3;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">15</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> T = <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> S = <span class="number">1e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function">LL <span class="title">ksm</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">	LL ans = <span class="number">1ll</span>;</span><br><span class="line">	<span class="keyword">while</span>(y)&#123;</span><br><span class="line">		<span class="keyword">if</span>(y &amp; <span class="number">1</span>) ans = ans * x % mod;</span><br><span class="line">		x = x * x % mod;</span><br><span class="line">		y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">LL nfc[B + <span class="number">5</span>], fc[B + <span class="number">5</span>];</span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>(x &gt;= y &amp;&amp; y &gt;= <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">assert</span>(y &lt;= B);</span><br><span class="line">	LL ans = <span class="number">1ll</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; y; i++) ans = ans * (x - i) % mod;</span><br><span class="line">	<span class="keyword">return</span> ans * nfc[y] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">ni</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	LL type = <span class="number">1ll</span>;</span><br><span class="line">	<span class="keyword">if</span>(x &lt; <span class="number">0</span>) type = mod - <span class="number">1</span>, x = -x;</span><br><span class="line">	<span class="built_in">assert</span>(x &lt;= B);</span><br><span class="line">	<span class="keyword">if</span>(x &lt;= <span class="number">1</span>) <span class="keyword">return</span> type;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> nfc[x] * fc[x - <span class="number">1</span>] % mod * type % mod;</span><br><span class="line">&#125;</span><br><span class="line">LL divv[T + <span class="number">5</span>], fl[T + <span class="number">5</span>], fr[T + <span class="number">5</span>];</span><br><span class="line"><span class="function">LL <span class="title">calc1</span><span class="params">(<span class="type">const</span> vector&lt;LL&gt; &amp;pos, <span class="type">int</span> x)</span></span>&#123; <span class="comment">// x = 0/1/.../T</span></span><br><span class="line">	<span class="built_in">assert</span>(pos.<span class="built_in">size</span>() == T &amp;&amp; x &gt;= T);</span><br><span class="line">	fl[<span class="number">0</span>] = <span class="number">1ll</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; T; i++) fl[i + <span class="number">1</span>] = fl[i] * (x - i + mod) % mod;</span><br><span class="line">	fr[T - <span class="number">1</span>] = <span class="number">1ll</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = T - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) fr[i - <span class="number">1</span>] = fr[i] * (x - i + mod) % mod;</span><br><span class="line">	LL ans = <span class="number">0ll</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; T; i++)&#123;</span><br><span class="line">		ans = (ans + fl[i] * fr[i] % mod * pos[i] % mod * divv[i]) % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	nfc[<span class="number">0</span>] = nfc[<span class="number">1</span>] = fc[<span class="number">0</span>] = fc[<span class="number">1</span>] = <span class="number">1ll</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= B; i++) nfc[i] = (mod - mod / i) * nfc[mod % i] % mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= B; i++) fc[i] = fc[i - <span class="number">1</span>] * i % mod, nfc[i] = nfc[i - <span class="number">1</span>] * nfc[i] % mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; T; i++)&#123;</span><br><span class="line">		divv[i] = <span class="number">1ll</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; T; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">			divv[i] = divv[i] * <span class="built_in">ni</span>(i - j) % mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, K, a[N];</span><br><span class="line"><span class="function">LL <span class="title">calc2</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> l, <span class="type">int</span> t, <span class="type">int</span> c, <span class="type">int</span> len)</span></span>&#123; <span class="comment">//[0,len-1]</span></span><br><span class="line">	LL sum = <span class="number">0</span>;</span><br><span class="line">	vector&lt;LL&gt; pos;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; T &amp;&amp; i &lt; len; i++)&#123;</span><br><span class="line">		sum = (sum + <span class="built_in">C</span>(n - base - i, c) * (l + t * i) % mod + mod) % mod;</span><br><span class="line">		<span class="keyword">if</span>(len &gt; T) pos.<span class="built_in">push_back</span>(sum);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(len &gt; T) <span class="keyword">return</span> <span class="built_in">calc1</span>(pos, len - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> D2&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> D = <span class="number">2</span>;</span><br><span class="line">	AP2 sta[S];</span><br><span class="line">	<span class="type">int</span> top;</span><br><span class="line">	<span class="function">LL <span class="title">solve</span><span class="params">(AP2 x)</span></span>&#123; <span class="comment">// n - 1 &gt;= x + y</span></span><br><span class="line">		<span class="built_in">sort</span>(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), [](PLL xx, PLL yy)&#123;<span class="keyword">return</span> xx.second - xx.first &lt; yy.second - yy.first;&#125;);</span><br><span class="line">		LL tmp = <span class="number">0ll</span>;</span><br><span class="line">		&#123;<span class="comment">//up</span></span><br><span class="line">			LL l = x[<span class="number">0</span>].first + x[<span class="number">1</span>].first, r = <span class="built_in">min</span>(x[<span class="number">0</span>].second + x[<span class="number">1</span>].first - <span class="number">1</span>, (n - <span class="number">1</span>) * <span class="number">1ll</span>);</span><br><span class="line">			<span class="keyword">if</span>(l &lt;= r) tmp = (tmp + <span class="built_in">calc2</span>(l - <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">			<span class="number">1</span>, <span class="number">2</span>, r - l + <span class="number">1</span>)) % mod;</span><br><span class="line">		&#125;</span><br><span class="line">		&#123;<span class="comment">//maintain</span></span><br><span class="line">			LL l = x[<span class="number">0</span>].second + x[<span class="number">1</span>].first, r = <span class="built_in">min</span>(x[<span class="number">0</span>].first + x[<span class="number">1</span>].second, (n - <span class="number">1</span>) * <span class="number">1ll</span>);</span><br><span class="line">			<span class="keyword">if</span>(l &lt;= r) tmp = (tmp + <span class="built_in">calc2</span>(l - <span class="number">1</span>, x[<span class="number">0</span>].second - x[<span class="number">0</span>].first + <span class="number">1</span>,</span><br><span class="line">			<span class="number">0</span>, <span class="number">2</span>, r - l + <span class="number">1</span>)) % mod;</span><br><span class="line">		&#125;</span><br><span class="line">		&#123;<span class="comment">//down</span></span><br><span class="line">			LL l = x[<span class="number">0</span>].first + x[<span class="number">1</span>].second + <span class="number">1</span>, r = <span class="built_in">min</span>(x[<span class="number">0</span>].second + x[<span class="number">1</span>].second, (n - <span class="number">1</span>) * <span class="number">1ll</span>);</span><br><span class="line">			<span class="keyword">if</span>(l &lt;= r) tmp = (tmp + <span class="built_in">calc2</span>(l - <span class="number">1</span>, x[<span class="number">0</span>].second - x[<span class="number">0</span>].first,</span><br><span class="line">			<span class="number">-1</span>, <span class="number">2</span>, r - l + <span class="number">1</span>)) % mod;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(AP2 x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= top; i++)&#123;</span><br><span class="line">			<span class="type">bool</span> bk = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; D; j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(x[j] != sta[i][j])&#123; bk = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(bk) <span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		sta[++top] = x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">dfs</span><span class="params">(<span class="type">int</span> dep, AP2 val, LL type, <span class="type">bool</span> bk)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; D; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(val[i].second &lt; val[i].first) <span class="keyword">return</span> <span class="number">0ll</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(dep == top + <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(bk) <span class="keyword">return</span> <span class="number">0ll</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">solve</span>(val) * type % mod;</span><br><span class="line">		&#125;</span><br><span class="line">		LL tmp = <span class="number">0ll</span>;</span><br><span class="line">		tmp = <span class="built_in">dfs</span>(dep + <span class="number">1</span>, val, type, bk);</span><br><span class="line">		<span class="keyword">if</span>(bk) val = sta[dep];</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; D; i++)&#123;</span><br><span class="line">				val[i].first = <span class="built_in">max</span>(val[i].first, sta[dep][i].first);</span><br><span class="line">				val[i].second = <span class="built_in">min</span>(val[i].second, sta[dep][i].second);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		tmp = (tmp + <span class="built_in">dfs</span>(dep + <span class="number">1</span>, val, mod - type, <span class="number">0</span>)) % mod;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> D3&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> D = <span class="number">3</span>;</span><br><span class="line">	AP3 sta[S];</span><br><span class="line">	<span class="type">int</span> top;</span><br><span class="line">	<span class="function">LL <span class="title">solve</span><span class="params">(AP3 x)</span></span>&#123;</span><br><span class="line">		<span class="built_in">sort</span>(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), [](PLL xx, PLL yy)&#123;<span class="keyword">return</span> xx.second - xx.first &gt; yy.second - yy.first;&#125;);</span><br><span class="line">		<span class="built_in">assert</span>(x[<span class="number">1</span>].second == x[<span class="number">1</span>].first);</span><br><span class="line">		<span class="comment">// n + 1 - x - y - z &gt;= D</span></span><br><span class="line">		x[<span class="number">0</span>].second = <span class="built_in">min</span>(x[<span class="number">0</span>].second, n + <span class="number">1</span> - D - x[<span class="number">1</span>].first - x[<span class="number">2</span>].first);</span><br><span class="line">		<span class="keyword">if</span>(x[<span class="number">0</span>].second &lt; x[<span class="number">0</span>].first) <span class="keyword">return</span> <span class="number">0ll</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">calc2</span>(x[<span class="number">0</span>].first + x[<span class="number">1</span>].first + x[<span class="number">2</span>].first - <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, x[<span class="number">0</span>].second - x[<span class="number">0</span>].first + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(AP3 x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= top; i++)&#123;</span><br><span class="line">			<span class="type">bool</span> bk = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; D; j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(x[j] != sta[i][j])&#123; bk = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(bk) <span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		sta[++top] = x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">dfs</span><span class="params">(<span class="type">int</span> dep, AP3 val, LL type, <span class="type">bool</span> bk)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; D; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(val[i].second &lt; val[i].first) <span class="keyword">return</span> <span class="number">0ll</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(dep == top + <span class="number">1</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(bk) <span class="keyword">return</span> <span class="number">0ll</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">solve</span>(val) * type % mod;</span><br><span class="line">		&#125;</span><br><span class="line">		LL tmp = <span class="number">0ll</span>;</span><br><span class="line">		tmp = <span class="built_in">dfs</span>(dep + <span class="number">1</span>, val, type, bk);</span><br><span class="line">		<span class="keyword">if</span>(bk) val = sta[dep];</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; D; i++)&#123;</span><br><span class="line">				val[i].first = <span class="built_in">max</span>(val[i].first, sta[dep][i].first);</span><br><span class="line">				val[i].second = <span class="built_in">min</span>(val[i].second, sta[dep][i].second);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		tmp = (tmp + <span class="built_in">dfs</span>(dep + <span class="number">1</span>, val, mod - type, <span class="number">0</span>)) % mod;</span><br><span class="line">		<span class="keyword">return</span> tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(AP3 s, <span class="type">int</span> dep)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep == K + <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!s[<span class="number">0</span>].first || !s[<span class="number">1</span>].first) <span class="keyword">return</span> ;</span><br><span class="line">		<span class="keyword">if</span>(!s[<span class="number">2</span>].first) D2::<span class="built_in">push</span>(&#123;s[<span class="number">0</span>], s[<span class="number">1</span>]&#125;);</span><br><span class="line">		<span class="keyword">else</span> D3::<span class="built_in">push</span>(&#123;s[<span class="number">0</span>], s[<span class="number">1</span>], s[<span class="number">2</span>]&#125;);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++)&#123;</span><br><span class="line">		AP3 tmp = s;</span><br><span class="line">		tmp[i].first = <span class="built_in">max</span>(tmp[i].first, a[dep] * <span class="number">1ll</span>);</span><br><span class="line">		tmp[i].second += a[dep];</span><br><span class="line">		<span class="built_in">dfs</span>(tmp, dep + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="comment">// vector&lt;LL&gt; tmp;</span></span><br><span class="line">	<span class="comment">// for(int i = 0; i &lt; T; i++) tmp.push_back(i*i);</span></span><br><span class="line">	<span class="comment">// cout &lt;&lt; calc(tmp, 9) &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">	cin &gt;&gt; n &gt;&gt; K;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= K; i++) cin &gt;&gt; a[i];</span><br><span class="line">	<span class="built_in">sort</span>(a + <span class="number">1</span>, a + K + <span class="number">1</span>);</span><br><span class="line">	LL ans = <span class="number">0ll</span>;</span><br><span class="line">	&#123;</span><br><span class="line">		LL l = a[K], r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= K; i++) r += a[i];</span><br><span class="line">		r = <span class="built_in">min</span>(n * <span class="number">1ll</span>, r);</span><br><span class="line">		ans = <span class="built_in">calc2</span>(l - <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, r - l + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(K == <span class="number">4</span>)&#123;</span><br><span class="line">		LL tmp = <span class="number">0ll</span>, sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= K; i++) sum += a[i];</span><br><span class="line">		<span class="keyword">if</span>(sum + K - <span class="number">1</span> &lt;= n) tmp = <span class="built_in">C</span>(n - sum + <span class="number">1</span>, <span class="number">4</span>) * fc[K] % mod;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= K; l++)&#123;</span><br><span class="line">			<span class="type">int</span> r = l;</span><br><span class="line">			<span class="keyword">while</span>(r &lt; K &amp;&amp; a[l] == a[r + <span class="number">1</span>]) r++;</span><br><span class="line">			tmp = tmp * nfc[r - l + <span class="number">1</span>] % mod;</span><br><span class="line">			l = r;</span><br><span class="line">		&#125;</span><br><span class="line">		ans = (ans + tmp) % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(&#123;PLL&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, PLL&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, PLL&#123;<span class="number">0</span>, <span class="number">0</span>&#125;&#125;, <span class="number">1</span>);</span><br><span class="line">	ans = (ans + D2::<span class="built_in">dfs</span>(<span class="number">1</span>, &#123;&#125;, mod - <span class="number">1</span>, <span class="number">1</span>)) % mod;</span><br><span class="line">	ans = (ans + D3::<span class="built_in">dfs</span>(<span class="number">1</span>, &#123;&#125;, mod - <span class="number">1</span>, <span class="number">1</span>)) % mod;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说起来一个很唐的事情，这场前面二分 $l+r$ 爆了一次 int ，而这里在 D2 里面计算 $l$ 的时候有个加法，那里也爆了一次 int ，悲 。</p>
<p>事实证明蠢人是有可能在同一个坑跌倒第二次的，悲。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>Petrozavodsk Winter 2021 Day 1 赛后小结</title>
    <url>/2024/08/01/Petrozavodsk-Winter-2021-Day-1-%E8%B5%9B%E5%90%8E%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://qoj.ac/contest/529">https://qoj.ac/contest/529</a></p>
<p>F 队长秒了，I 是个幽默题，队长以为是线性题，给了个结论，然后我瞪了半天，发现结论不对，然后发现时限 20s ，直接调和级数过了，幽默，太幽默了。</p>
<p>然后队长写几何：B 题。</p>
<p>和 Imakf 讨论 C ，发现叶子一定会选，但是还有讨论，什么环上有几个没有叶子的节点等等。</p>
<p>但这里我其实犯了罪，我在其实讨论快结束的时候就去看别的题了，主要原因其实是：最后我参与讨论，讨论完了我可能要写这道题目，基环树一看就很不好写，所以我润了。</p>
<p>但是讨论到最后我还是总结了一下 Imakf 的讨论，然后 Imakf 要上这个题，这个时候我发现题目很难读，然后又看 Imakf 要上这个难写的题目（我也明白这个是怎么讨论的），突然心生忏悔，前面我为了逃避，将写题的任务推给了 Imakf ，这不是双标是什么！于是我让 Imakf 去看题，我去写这个题（说到底心生忏悔是你的谎言，看不懂题才是真正原因）。</p>
<p>但总之，以后无论如何都不能因为不想写题而不参与讨论，快打 WF 还搞这种小心眼，窝里斗，是非常不好的事情，必须牢记！</p>
<p>而后一个小时 WA 了一发，在 3 分钟后过了，原因是少了一个讨论：当环上有两个相邻的无叶子节点时，可以选择两个环上的点。</p>
<p>然后和 Imakf 讨论 K ，在会做后上机，一个半小时开 WA ，15 分钟后过掉。</p>
<p>原因：</p>
<ol>
<li>向上取整写成向下取整。</li>
<li>应该在原数组二分而不是前缀和数组。</li>
</ol>
<p>两个小时队友过 K 。半个小时后队友过 G ，我看 E ，发现是 SB 题。</p>
<p>期间队长和我在和别人聊天，记大过。</p>
<p>然后我上 E ，期间因为公式写错，WA 了三发，然后又因为 1e9 * 10 爆了 int ，WA 了一发，总计四发，警钟长鸣。</p>
<p>三个小时过了。</p>
<p>队友写 J ，我和队长讨论 D ，其实没有讨论，队长直接把 D 秒了，然后我处理做法细节。</p>
<p>四个小时队友 J TLE 了，我上去写 D ，四个半小时，D,J 都过了。</p>
<p>最后战 A 失败，遗憾离场。</p>
<p>我犯的错误：</p>
<ol>
<li>因为不想写题而不参与讨论。</li>
<li>比赛时和别人聊天。</li>
<li>E 不推好公式就上机。</li>
<li>没有听队长 A 的吹逼，以为边际距离和贪心没有关系，于是忽略队长讲的话，但是没想到是重要观察，导致我在最后半小时处于完全无用的状态。</li>
</ol>
<p>队长的错误：</p>
<ol>
<li>比赛时和别人聊天。</li>
<li>玩手机。</li>
</ol>
<p>Imakf 的错误：</p>
<ol>
<li>多开，但是声称是为了弥补今天队友聊天所损失的时间，因此可以理解，不算大的错误。</li>
</ol>
<p>部分题解：</p>
<h1 id="I"><a href="#I" class="headerlink" title="I"></a>I</h1><p>枚举一下因子，时间复杂度：$O(V\log^2{V})$</p>
<p>但是能不能优化呢？能，考虑优化掉 gcd 的时间。</p>
<p>设 $x$ 是 $y$ 的因子，且 $z=x\bigoplus y &lt; y$ ，那么考虑什么时候：</p>
<script type="math/tex; mode=display">gcd(y,z)=x</script><p>首先，$x$ 整除 $y-z$ 是必要条件，而 $y-z\le x$ 且等号成立当且仅当 $y$ 的二进制完全覆盖 $x$ ，故必要条件是 $y-z=x$ ，注意到这也是充分的。</p>
<p>所以我们得到一个充要条件：$y-z=x$ 。</p>
<p>当然，同时注意到因为 $y-z\le x$ ，故 $gcd(y,z)\le x$ ，所以显然 $x$ 整除于 $z$ 也是一个充要条件。</p>
<p>用哪个都行，时间复杂度：$O(V\log{V})$</p>
<p>跟题解差不多。</p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>首先把基环树想象成一堆树，然后把根用环连起来。</p>
<p>那么如果一个点被选了，显然往叶子走不劣，不能往叶子走则子树里面有别的被选点，故其祖先及环上其他树一定没有被选，这个时候把这个点往环上移动更优。</p>
<p>综上，一定存在一个最优方案，使得选择的点要么在叶子，要么在环上。</p>
<p>严谨证明就：先选择环上有点的最优方案，没有就任选一个最优方案，根据上述讨论，这样选择后一定可以把不在环上的点拖到叶子上去，就证完了。</p>
<p>然后如果一个环上的节点被选了，若其所在的树有除了他以外的节点，一定可以不选他，选择其所在树的所有叶子，不劣，所以环上选择的点都是所在树大小 $=1$ 的点。</p>
<p>下面为了方便，将不在环上的叶子节点才叫叶子节点。</p>
<p>于是我们不妨猜测，直接选所有叶子节点就是最优的，不妨讨论环上有多少个节点被选了，显然 $\le 3$。</p>
<ol>
<li>$3$ 个节点，显然不能选任何叶子节点，显然有叶子节点一定可以踢掉环上一个叶子节点且不劣。</li>
<li>$2$ 个节点，显然环上由这两个节点切成的两部分不能同时选叶子节点，故如果两边都有叶子节点，显然再从环上踢掉一个节点更优，如果两边不是同时有叶子，显然可以选择所有的叶子。</li>
<li>$0/1$ 个节点，显然可以选择所有的叶子节点。</li>
</ol>
<p>综上，选择所有叶子节点，然后讨论一下环上可以再选多少个节点就行了。</p>
<p>时间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> y, next;</span><br><span class="line">&#125;a[N * <span class="number">2</span>]; <span class="type">int</span> len, last[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;a[++len] = &#123;y, last[x]&#125;; last[x] = len;&#125;</span><br><span class="line"><span class="type">int</span> v[N], sta[N], top;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">	v[x] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k = last[x]; k; k = a[k].next)&#123;</span><br><span class="line">		<span class="type">int</span> y = a[k].y;</span><br><span class="line">		<span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(!v[y])&#123;</span><br><span class="line">			<span class="type">int</span> z = <span class="built_in">dfs1</span>(y, x);</span><br><span class="line">			<span class="keyword">if</span>(z)&#123;</span><br><span class="line">				<span class="keyword">if</span>(z &gt; <span class="number">0</span>)&#123;</span><br><span class="line">					sta[++top] = x;</span><br><span class="line">					<span class="keyword">if</span>(z == x) z = <span class="number">-1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> z;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(v[y] == <span class="number">1</span>)&#123;</span><br><span class="line">			sta[top = <span class="number">1</span>] = x;</span><br><span class="line">			<span class="keyword">return</span> y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	v[x] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> leaf[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="type">bool</span> bk = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k = last[x]; k; k = a[k].next)&#123;</span><br><span class="line">		<span class="type">int</span> y = a[k].y;</span><br><span class="line">		<span class="keyword">if</span>(y == fa || v[y]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs2</span>(y, x);</span><br><span class="line">		bk = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!bk) leaf[x] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">			<span class="type">int</span> x, y;</span><br><span class="line">			cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">			<span class="built_in">ins</span>(x, y);</span><br><span class="line">			<span class="built_in">ins</span>(y, x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">assert</span>(<span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>) == <span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= top; i++) v[sta[i]] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= top; i++) <span class="built_in">dfs2</span>(sta[i], <span class="number">0</span>);</span><br><span class="line">		<span class="type">int</span> cnt = <span class="number">0</span>, cnt2 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!v[i] &amp;&amp; leaf[i]) cnt++;</span><br><span class="line">			<span class="keyword">if</span>(v[i] &amp;&amp; leaf[i]) cnt2++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> add = <span class="number">0</span>;</span><br><span class="line">		sta[top + <span class="number">1</span>] = sta[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= top; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(leaf[sta[i]] &amp;&amp; leaf[sta[i + <span class="number">1</span>]]) add = <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(leaf[sta[i]]) add = <span class="built_in">max</span>(add, <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		cnt += <span class="built_in">max</span>(add, <span class="number">3</span> - (top - cnt2));</span><br><span class="line">		cout &lt;&lt; cnt &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		len = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) last[i] = v[i] = leaf[i] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="M"><a href="#M" class="headerlink" title="M"></a>M</h1><p>Imakf 告诉我个性质，找最大值是一定是一个连续段，原因是固定最大值，把小值移动上来一定不劣。</p>
<p>那么固定右端点，左端点可以二分。</p>
<p>而且长度本身显然可以二分，扔掉最小值显然不劣。</p>
<p>现在问题是怎么确定一个数字会不会被选。</p>
<p>注意到包含某个数字的方案一定也是要么是一个连续段，要么除了他是个连续段，所以直接枚举最大值，对于最大值而言，最小值能是的数值也能二分，用前缀和处理一下就行了。</p>
<p>时间复杂度：$O(n\log{V})$</p>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>不是怎么开始推式子了：</p>
<script type="math/tex; mode=display">\begin{align*}
&v_{y}t-\frac{g}{2}t^2\\
=&\frac{v_{y}x}{v_{x}}-\frac{g}{2v_{x}^2}x^2\\
=&x\tan{a}-\frac{gx^2}{2v^2}(\tan^2{a}+1)
\end{align*}</script><p>这不解个方程就行了？</p>
<p>不知道出这道题目的目的是啥。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">double</span> LD;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> C, n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		cin &gt;&gt; C;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		LD l = <span class="number">0</span>, r = <span class="number">1e18</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">			LD x, y;</span><br><span class="line">			cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">			LD a = <span class="number">10</span> * x, b = - <span class="number">2.0</span> * C * C, c = <span class="number">10</span> * x + y / x * <span class="number">2</span> * C * C;</span><br><span class="line">			LD delta = b * b - <span class="number">4</span> * a * c;</span><br><span class="line">			<span class="built_in">assert</span>(delta &gt;= <span class="number">0</span>);</span><br><span class="line">			LD ll = (- b - <span class="built_in">sqrt</span>(delta)) / (a + a), rr = (- b + <span class="built_in">sqrt</span>(delta)) / (a + a);</span><br><span class="line">			<span class="built_in">assert</span>(ll &lt;= rr &amp;&amp; rr &lt;= <span class="number">1e18</span>);</span><br><span class="line">			l = <span class="built_in">max</span>(l, ll);</span><br><span class="line">			r = <span class="built_in">min</span>(r, rr);</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">3</span>) &lt;&lt; (l + r) / <span class="number">2</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>显然任何一个最优方案都不会改变强连通内部的边，证明：考虑一个方案，然后把其中一个强连通内的边还原，对于 $x\to y$ 的路径而言，找到第一个和最后一个在这个强连通上的点，将中间的部分换成现在的路径，显然仍然联通，把所有强连通还原即可。</p>
<p>首先强连通缩点，然后把拓扑序搞出来，$a_{1},…,a_{m}$，。</p>
<p>考虑最后一个块 $a_{m}$，其一定会改变一条和前面的连边，考虑改完以后会怎样。</p>
<ol>
<li>如果连向的不是 $a_{m-1}$ ，或者两者的大小有一个不为 $1$ ，改完这条边后这一段变成一个强连通块，变成一个全新的问题。</li>
<li>如果连向的是 $a_{m-1}$ ，且两者的大小都为 $1$ ，则有 $a_{m-1},a_{m}$ 调换顺序，接着考虑 $a_{m-1}$ ，显然改变一条向前的连边，而且一定不会是和 $a_{m}$ 的（不会改变一条边两次），而显然这条边能让这一段变成一个强连通块，和上面一样，是一个新的问题。</li>
</ol>
<p>显然，到一个局面下，一定是前缀和原问题一样，后缀缩成一个强连通块，按照上述过程接着考虑这个全新的问题，注意到这是一个 dp ，可以转移，做完了。</p>
<p>时间复杂度：$O(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> y, next;</span><br><span class="line">&#125;a[N * N]; <span class="type">int</span> len, last[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;a[++len] = &#123;y, last[x]&#125;; last[x] = len;&#125;</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], ti;</span><br><span class="line"><span class="type">int</span> sta[N], top;</span><br><span class="line"><span class="type">int</span> belong[N], tot;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; point[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	dfn[x] = low[x] = ++ti;</span><br><span class="line">	sta[++top] = x;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k = last[x]; k; k = a[k].next)&#123;</span><br><span class="line">		<span class="type">int</span> y = a[k].y;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(a[k].y);</span><br><span class="line">			low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(!belong[y]) low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(dfn[x] == low[x])&#123;</span><br><span class="line">		++tot;</span><br><span class="line">		belong[x] = tot;</span><br><span class="line">		point[tot].<span class="built_in">push_back</span>(x);</span><br><span class="line">		<span class="keyword">while</span>(sta[top] != x) belong[sta[top]] = tot, point[tot].<span class="built_in">push_back</span>(sta[top--]);</span><br><span class="line">		top--;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, v[N][N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> val, x, y;</span><br><span class="line">&#125;d[N][N], nxt[N];</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (Edge x, Edge y)&#123;<span class="keyword">return</span> x.val &lt; y.val;&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &gt; (Edge x, Edge y)&#123;<span class="keyword">return</span> x.val &gt; y.val;&#125;</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line">pair&lt;<span class="type">int</span>, Edge&gt; pre[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">			cin &gt;&gt; v[i][j];</span><br><span class="line">			<span class="keyword">if</span>(v[i][j]) <span class="built_in">ins</span>(i, j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[i]) <span class="built_in">dfs</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= tot; j++) d[i][j].val = <span class="number">2e9</span> + <span class="number">1</span>;</span><br><span class="line">		dp[i] = <span class="number">2e9</span> + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">			d[belong[j]][belong[i]] = <span class="built_in">min</span>(Edge&#123;v[i][j], i, j&#125;, d[belong[j]][belong[i]]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(tot &gt;= <span class="number">2</span> &amp;&amp; point[<span class="number">1</span>].<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; point[<span class="number">2</span>].<span class="built_in">size</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= tot; i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">1ll</span> * d[<span class="number">1</span>][<span class="number">2</span>].val + d[<span class="number">2</span>][i].val &lt; <span class="number">1ll</span> * d[<span class="number">1</span>][i].val) d[<span class="number">1</span>][i] = Edge&#123;d[<span class="number">1</span>][<span class="number">2</span>].val + d[<span class="number">2</span>][i].val, d[<span class="number">2</span>][i].x, d[<span class="number">2</span>][i].y&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= tot; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(i == <span class="number">1</span>) nxt[j] = d[i][j];</span><br><span class="line">			<span class="keyword">else</span> nxt[j] = <span class="built_in">min</span>(nxt[j], d[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span> + (i == <span class="number">1</span> &amp;&amp; point[<span class="number">1</span>].<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; point[<span class="number">2</span>].<span class="built_in">size</span>() == <span class="number">1</span>); j &lt;= tot; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="number">1ll</span> * dp[j] &gt; <span class="number">1ll</span> * dp[i] + nxt[j].val)&#123;</span><br><span class="line">				dp[j] = dp[i] + nxt[j].val;</span><br><span class="line">				pre[j] = &#123;i, nxt[j]&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">assert</span>(dp[tot] != <span class="number">2e9</span> + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">work</span>()) cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(tot == <span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;YES\n0 0\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">			vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; ans;</span><br><span class="line">			<span class="type">int</span> now = tot;</span><br><span class="line">			<span class="keyword">while</span>(now &gt; <span class="number">1</span>)&#123;</span><br><span class="line">				<span class="keyword">auto</span> [state, use] = pre[now];</span><br><span class="line">				<span class="keyword">auto</span> [val, x, y] = use;</span><br><span class="line">				ans.<span class="built_in">push_back</span>(&#123;x, y&#125;);</span><br><span class="line">				now = state;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(belong[ans.<span class="built_in">back</span>().second] == <span class="number">2</span>) ans.<span class="built_in">push_back</span>(&#123;point[<span class="number">2</span>][<span class="number">0</span>], point[<span class="number">1</span>][<span class="number">0</span>]&#125;);</span><br><span class="line">			cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; dp[tot] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> [x, y] : ans) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dfn[i] = low[i] = belong[i] = last[i] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) point[i].<span class="built_in">clear</span>();</span><br><span class="line">		len = tot = ti = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">assert</span>(!top);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>还没补。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>Public Round 4赛后总结</title>
    <url>/2025/02/03/Public-Round-4%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>在家打的，打的不是很专心，因此结果也没有多好。</p>
<p>赛后做了一下 C 题，难，但是的确没有以往的难，确实感觉整体难度略简单于往年的 NOI D1 。</p>
<p>出的很好，下次继续出QMQ。</p>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>发现决策单调性直接上分治了QAQ。</p>
<p>题解的凸包做法是真的神仙，确实没有想到QAQ。</p>
<p>都怪分治惯坏我了QAQ。</p>
<p>双指针法和凸包还能这么用，长见识了QAQ。</p>
<p>时间复杂度：$O(n\log{n})$</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>维护一下最小值次小值最大值次大值的位置下标即可。</p>
<p>1操作使用次数：2</p>
<p>2操作使用次数：2n-5</p>
<p>时间复杂度：$O(n)$</p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p><del>暂时还不会QAQ。</del></p>
<p>现在会了。</p>
<p>时间复杂度往大了算很大，但是常数足够小，最后 2ms 通过，这句话为什么这么熟悉？没错，我的做法是数位 DP ，辣个经常出现常数小跑不满这句话的算法。</p>
<p>首先，这道题目用到的 trick 是一个经典 trick 的加强版，有这么一个经典的 trick ，$x$ 的数位和和 $x$ 关于 $9$ 同余，而这道题目的 trick 更强，是 $x$ 从低位到高位每隔 $k$ 个数字划段，然后加起来得到类数位和，这个和与 $x$ 关于 $10^k-1$ 同余 。</p>
<p>所以我们只要求出第 $n$ 个模 $10^k-1$ 等于 $0$ 且十进制表示不包含 $9$ 的数字即可。（注意：为了下面方便讲解以及方便代码好写， $0$ 也算是合法的）</p>
<p>到此为止，这道题目最关键的第一步已经讲完了，但是还有至关重要的第二步QAQ。</p>
<p>显然，我们不可能直接维护模 $10^k-1$ 的值，这个太大，我们维护不了，因此考虑用上面的 $trick$ 分段维护，那么最多会分多少段呢？</p>
<p>可以发现，有 $t$ 段的时候 ，去掉模的限制，合法的数字个数有：$9^{k<em>t}$ ，但是如果加上模的限制呢？我们能不能用最后一段专门来修正模数来让模数等于 $0$ 呢？不行，可以发现还差一点点，因此要用两段，根据计算，如果 $(t-2)</em>k≥19$ 就 100% 能得到结果，因此我们就得到了段数的数量级。</p>
<p>接着考虑，现在就是要求有多少个加起来模 $10^k-1$ 等于 $0$ 的数字，可以发现，由于段数不多，因此，所得到的最终结果也是有限个的，最多 $t+1$ 个（包括 $0$ ，其实可以更小，但是懒得想了），直接暴力枚举结果是哪个即可，现在就不用维护余数了，变成维护和了，难度就小了很多了，直接所有段从低位到高位数位DP转移枚举一下就行了，然后就能在能接受的复杂度内解决个数问题了。</p>
<p>解决个数问题后，直接从高位到低位枚举每一位是啥就行了。</p>
<p>时间复杂度：$O(玄学)$ ，实际表现：$O(神奇)$ 。（其实应该可以算出具体复杂度，但是我懒，保守估计一下上界应该在两亿，是完全能过的，除非常数大，但是常数小）</p>
<p>很有趣的一道数位 DP 题。</p>
<p>还是想了我挺久的，赛时如果有其他题就不要硬啃这道题目了。</p>
<p>很有趣的比赛，下次如果没有意外的话还打QMQ。</p>
<p> PR4 还是保持了以往 PR 一样的高质量，感谢组织方给我们 Oier 带来了多场高质量的比赛，感谢。</p>
<p><del>但是TM难是真的难，艹，让我又一次意识到了自己的实力不足QAQ</del></p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>Rainbow Graph</title>
    <url>/2024/01/31/Rainbow-Graph/</url>
    <content><![CDATA[<p>题目链接：<a href="https://open.kattis.com/problems/rainbowgraph">https://open.kattis.com/problems/rainbowgraph</a></p>
<p>题目大意：</p>
<p>一张无向图，每条边有红绿蓝三种颜色，请选一个最小权值和的边集，使得：不看红色边图是联通的，不看蓝色边图也是联通的。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>两个对偶拟阵一交就做完了，需要注意的是，带权拟阵交每次增广出来的集合，都是与他同大小的权值和最大的集合，所以一遍带权拟阵交就能处理出所有的答案。</p>
<p>记得特判图一开始是不是联通的，因为如果一开始就不联通，那么 $\emptyset\notin \mathcal{I}$ ，这与拟阵交一开始默认 $\emptyset \in \mathcal{I}$ 冲突。</p>
<p>时间复杂度：$O(m^4)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e2</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">2e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,m,zans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,c,typ;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="type">bool</span> in[N];</span><br><span class="line"><span class="keyword">namespace</span> Union&#123;</span><br><span class="line">    <span class="type">int</span> fa[N];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x]==x?x:fa[x]=<span class="built_in">findfa</span>(fa[x]);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mer</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        x=<span class="built_in">findfa</span>(x);y=<span class="built_in">findfa</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(x!=y)fa[x]=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> ban,<span class="type">int</span> mov,<span class="type">int</span> add)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(e[i].typ==ban || i==mov)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i!=add &amp;&amp; in[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">mer</span>(e[i].x,e[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">findfa</span>(i)!=<span class="built_in">findfa</span>(<span class="number">1</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Union::pd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y,next;</span><br><span class="line">&#125;a[M];<span class="type">int</span> len,las[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;a[++len]=&#123;y,las[x]&#125;;las[x]=len;&#125;</span><br><span class="line"><span class="type">int</span> pri[N],typ[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(las+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*m);</span><br><span class="line">    <span class="built_in">memset</span>(typ+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(in[j])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">0</span>,j,i))<span class="built_in">ins</span>(i,j);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">2</span>,j,i))<span class="built_in">ins</span>(j,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">0</span>,i,<span class="number">-1</span>))typ[i]|=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">2</span>,i,<span class="number">-1</span>))typ[i]|=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!in[i])pri[i]=e[i].c;</span><br><span class="line">        <span class="keyword">else</span> pri[i]=-e[i].c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> pre[N];PII d[N];</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(q.<span class="built_in">empty</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)d[i]=&#123;-inf,-inf&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(typ[i]&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            v[i]=<span class="number">1</span>;</span><br><span class="line">            d[i]=&#123;pri[i],<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        v[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=las[x];k;k=a[k].next)&#123;</span><br><span class="line">            <span class="type">int</span> y=a[k].y;</span><br><span class="line">            <span class="keyword">if</span>(PII&#123;d[x].first+pri[y],d[x].second<span class="number">-1</span>&#125;&gt;d[y])&#123;</span><br><span class="line">                d[y]=PII&#123;d[x].first+pri[y],d[x].second<span class="number">-1</span>&#125;;</span><br><span class="line">                pre[y]=x;</span><br><span class="line">                <span class="keyword">if</span>(!v[y])&#123;</span><br><span class="line">                    v[y]=<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    PII maxval=&#123;-inf,-inf&#125;;<span class="type">int</span> mp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((typ[i]&amp;<span class="number">2</span>) &amp;&amp; d[i]&gt;maxval)&#123;</span><br><span class="line">            maxval=d[i];</span><br><span class="line">            mp=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!mp)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    zans-=maxval.first;</span><br><span class="line">    <span class="type">int</span> now=mp;</span><br><span class="line">    <span class="keyword">while</span>(now)&#123;</span><br><span class="line">        in[now]^=<span class="number">1</span>;</span><br><span class="line">        now=pre[now];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> ss[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,w,t;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%s&quot;</span>,&amp;x,&amp;y,&amp;w,ss+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ss[<span class="number">1</span>]==<span class="string">&#x27;R&#x27;</span>)t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ss[<span class="number">1</span>]==<span class="string">&#x27;G&#x27;</span>)t=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t=<span class="number">2</span>;</span><br><span class="line">        e[i]=&#123;x,y,w,t&#125;;</span><br><span class="line">        zans+=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)ans[i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pd</span>(<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>) &amp;&amp; <span class="built_in">pd</span>(<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-1</span>))&#123;</span><br><span class="line">        ans[m]=zans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=m<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">            <span class="built_in">build</span>();</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">solve</span>())<span class="keyword">break</span>;</span><br><span class="line">            ans[i]=zans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>拟阵</tag>
      </tags>
  </entry>
  <entry>
    <title>Prüfer序列学习笔记</title>
    <url>/2024/02/02/Prufer%E5%BA%8F%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p> Prüfer 序列是真好用啊。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>对于一棵 $n(n\ge 2)$ 个点的树，每次我们选择一个编号最小的叶子节点删掉，然后将其相邻节点的编号加入到序列中，直到剩下两个点为止，这样构成的序列，就叫这棵树的 Prüfer 序列。</p>
<h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><p>Prüfer 序列构建了一个有标号无根树到序列的双射，后面会讲如何通过另方求另一方。</p>
<p>而且任意一个值域为 $n$ 长度为 $n-2$ 的序列都对应了一棵生成树，这让 Prüfer 序列在解决无根树相关的计数问题非常好用。</p>
<p>从度数的角度看 Prüfer 序列，可以发现，Prüfer 序列中的点实际上表现的是度数 $-1$ 的过程。</p>
<p>例如 ：Prüfer 序列是 $1,2,3$ ，那么表示在删除第一个叶子时，$1$ 号点度数减 $1$ ，接下来同理。</p>
<p>最后，所有度数为 $1$ 的点被删除，只剩下了 $n$ 和另外一个度数为 $1$ 的点。</p>
<p>综上，我们可以得到下面这个结论。</p>
<p><strong>结论 1</strong> ：每个点在 Prüfer 序列中的出现次数为度数$-1$ 。</p>
<h1 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h1><h2 id="无根树转-Prufer-序列"><a href="#无根树转-Prufer-序列" class="headerlink" title="无根树转 Prüfer 序列"></a>无根树转 Prüfer 序列</h2><p>从小到大搜索每一个点，直到 Prüfer 序列中已经有 $n-2$ 个数字，设搜索到 $p$ 号点：</p>
<ol>
<li>假如 $p$ 号点不是叶子，继续搜。</li>
<li>假如 $p$ 号点是叶子，删除，如果新增了一个叶子节点且编号小于 $p$ ，显然这个叶子节点编号最小，接着删，直到删了 $n-2$ 个点或者编号 $&gt;p$ 。</li>
</ol>
<p>时间复杂度：$O(n)$ 。</p>
<h2 id="Prufer-序列转无根树"><a href="#Prufer-序列转无根树" class="headerlink" title="Prüfer 序列转无根树"></a>Prüfer 序列转无根树</h2><p>首先，根据 Prüfer 序列可以算出每个点的度数，然后按照 Prüfer 序列，每次取出编号最小的叶子节点和 Prüfer 序列当前位置连边，然后给 Prüfer 序列当前位置度数 $-1$ ，不断重复，直到最后，就只会剩两个度数为 $1$ 的节点，连起来即可。</p>
<p>时间复杂度：$O(n\log{n})$ 。</p>
<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol>
<li>$n$ 个点的有标号无根树有多少个：$n^{n-2}$ 个。</li>
<li>假设每个点的度数已知，设为 $d_i$ ，求满足这个度数限制的有标号无根树的数量：$\binom{n-2}{d_1-1,d_2-1,…,d_n-1}$ 。</li>
<li><p>Cayley 公式：给定 $m(m\ge 2)$ 个连通块，每个连通块的大小是 $s_i$ ，且 $\sum\limits_{i=1}^m=n$ ，那么用 $m-1$ 条边把这 $m$ 个联通块联通起来的方案数为 $(\prod\limits_{i=1}^m s_i)n^{m-2}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>证明 1 ：考虑 $m$ 个点的树的 $Prüfer$ 序列，不妨设为 $p$ 序列，由于 $Prüfer$ 序列实际上代表了一种连边方式，所以我们只需要计算 $n-1$ 条边能够有多少种连法就行了，那么对于这个 $Prüfer$ 序列能够代表的方案数，通过计算为：$(\prod_{i=1}^m s_i)<em>(\prod_{i=1}^{m-2} s_{p_i})$ 。又 Prüfer 序列 $m-2$ 个位置都可以填 $1-m$ ，所以显然，总方案数为 $(\prod\limits_{i=1}^m s_i)</em>n^{m-2}$ 。</p>
<p>证明 2 ：代数证明（来自oiwiki）</p>
<p>考虑每个连通块的度数为 $d_i$ ，显然，只要 $d_i&gt;0,\sum\limits_{i=1}^md_i=2m-2$ ，就能算是一个合法的度数序列。</p>
<p>所以这样子的方案数为：$\binom{m-2}{d_1-1,d_2-1,…,d_m-1}\prod{s_i^{d_i}}$ 。</p>
<p>由多元二项式定理：$(x_1+x_2+…+x_p)^k=\sum\limits_{a_1,a_2,…,a_p\ge 0,a_1+a_2+…+a_p=k}\binom{k}{a_1,a_2,…,a_p}\prod\limits_{i=1}^px_i^{a_i}$ 。</p>
<p>那么 $\sum\limits_{d_i&gt;0,d_1+…+d_m=2m-2}\binom{m-2}{d_1-1,d_2-1,…,d_m-1}\prod\limits_{i=1}^m{s_i^{d_i}}$ ，令 $e_i=d_i-1$ 可以得到：$\sum\limits_{e_i\ge 0,e_1+…+e_m=m-2}\binom{m-2}{e_1,e_2,…,e_m}\prod\limits_{i=1}^m{s_i^{e_i+1}}=n^{m-2}\prod\limits_{i=1}^ms_i$</p>
<p>证毕。</p>
</div></details></li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>Prüfer序列</tag>
      </tags>
  </entry>
  <entry>
    <title>Petrozavodsk Winter 2022 Day 5 赛后小结</title>
    <url>/2024/08/05/Petrozavodsk-Winter-2022-Day-5-%E8%B5%9B%E5%90%8E%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://qoj.ac/contest/823">https://qoj.ac/contest/823</a></p>
<p>开局我把 B 秒了，但是唐氏操作一直到半小时后才 AC ，期间队友先把 C 秒了，期间队友非常厉害的把 K 秒了。</p>
<p>我把 G 秒了，但是这个时候队长说你怎么老是按删除键，于是把删除键给我抠了，然后我龟速打字，最终一个小时过了 G 。</p>
<p>但是我确实太经常的按删除键，这个确实要改。</p>
<p>队长构造出了 E ，上去写过了，此时一个半小时。</p>
<p>我看了下 I ，感觉好像不难，上去写了个线段树过了。</p>
<p>接下来进入很长的挂机时间。Imakf 搞 J ，我搞 H ，队长搞 D ，在两个多小时的时候，我放弃了 H ，和 Imakf 讨论 J ，然后 Imakf 甩给我一个很怪的式子，但是后面讨论着讨论着 Imakf 发现自己列错式子了，这道题目和 Gem Island 很像，其中一个性质一模一样，Imakf 非常幽默的把这个性质搞错了，然后 Imakf 上去写，我去想 H，后面在 2:40 的时候，Imakf WA 了第一发。</p>
<p>后面 Imakf WA了好几发，但计数题是这样子的，一遍写对就还好，否则就折磨了，不知道式子哪里错了。</p>
<p>期间和他讨论了好几次，式子改了好几遍，代码也改了好几次，最后终于在四个小时的时候过了此题，计数题是这样子的。</p>
<p>期间，我在 Imakf 写 J 的时候，H 搞了好久，最终发现是数学系老师上课讲了无数遍的性质，但是我们队有唐氏儿与此题大战一个小时都没注意到，甚至注意到后还不会做，总算在半个小时后注意到自己的铸币操作，在四个小时的时候过了 H 。</p>
<p>然后队长上 D ，我和 Imakf 讨论 A ，但最后得出 A 不会做或者写不了的结论，队长也没有冲出 D ，最后遗憾离场。</p>
<p>部分题解：</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>注意到前缀和在模 $3$ 的剩余系下只有三种取值，不妨设 $0,1,2$ 的个数分别为 $a,b,c$ ，其中 $0$ 不算最开头，所以 $a+b+c=n$ 。</p>
<p>那么个数就为：$\binom{a+1}{2}+\binom{b}{2}+\binom{c}{2}$ 。</p>
<p>在知道 $a,b,c$ 后，显然最优答案的前缀和数组就是：$a$ 个 $0$ ，$b$ 个 $1$ ，$c$ 个 $2$ 排列。</p>
<p>所以枚举一下 $a$ ，然后 $b,c$ 用二次方程解一下就行了。</p>
<p>但是期间式子列错了，而且 $\Delta$ 和 $\sqrt{\Delta}$ 用混了，WA 了两发，唐完了。</p>
<p>与题解一致。</p>
<h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p>注意到对于某个特定的 $k$ 可以容斥解决，那么要一次性算出所有的 $k$ 就直接 NTT 就行了。</p>
<p>具体来说：高位前缀和+容斥+NTT 即可，时间复杂度：$O(2^n*n)$</p>
<p>与题解一致。</p>
<h1 id="I"><a href="#I" class="headerlink" title="I"></a>I</h1><p>注意到不妨设 $x$ 的限制是 $\ge y$ ，那么就给 $cnt[y]+1$ ，那么答案合法当且仅当 $\forall j,\sum\limits_{i=1}^{j}cnt[i]\ge j$ 。</p>
<p>首先先把所有数字的最大限制和次大限制找到，然后遍历所有限制，把这个限制拿掉，然后把以这个限制为最大限制的数字改成次大限制，看是否合法，显然总复杂度是 ：$O(n\log{n}+m)$ 的，当然，求最大限制的部分用了 set 来求，所以总时间复杂度是：$O(n\log{n}+(n+m)\log{m})$</p>
<p>与题解一致。</p>
<h1 id="J"><a href="#J" class="headerlink" title="J"></a>J</h1><p>有一个性质和 Gem Island 的一个性质一样。</p>
<p>不妨考虑第 $i$ 个细菌增殖了 $a_{i}$ 次，共增殖了 $r$ 次的概率：</p>
<script type="math/tex; mode=display">\begin{align*}
&\frac{(n-1)!\prod\limits_{i=1}^{n}a_{i}!}{(n+r-1)!}*\binom{r}{a_1,...,a_{n}}\\
=&\frac{(n-1)!r!}{(n+r-1)!}
\end{align*}</script><p>即只要知道了每个细菌增殖的次数，则概率是固定的。</p>
<p>在知道这个性质后，注意到最大的段只有一个，不妨考虑枚举最大段。</p>
<p>式子为：</p>
<script type="math/tex; mode=display">\sum\limits_{r=1}^{k}\frac{(n-1)!r!}{(n+r-1)!}\sum\limits_{M=\left\lfloor \frac{n+r}{2}
\right\rfloor+1}^{r+1}(2M-n-r)\binom{r-(M-1)+n-2}{n-2}</script><p>其中要算类似这种东西：</p>
<script type="math/tex; mode=display">\sum\limits_{i=j}^{k}\binom{i}{j}/\sum\limits_{i=j}^{k}(i-j+1)\binom{i}{j}</script><p>对应于杨辉三角形上的一列，这一列的系数要么全是 $1$ 要么是等差数列。</p>
<p><img src="1.png" alt=""></p>
<p>全 $1$ 是一个经典问题，直接杨辉三角形上合一合就行了。</p>
<p>问题是等差数列，注意到等差数列可以看成是同一条竖线上长度逐渐递增的线，所以跑到下一列的时候恰好是系数全为 $1$ 的问题，所以直接跳到下两列就行了。</p>
<p>同样的方式可以用来处理系数是 $k$ 阶等差数列的问题，当然，这个问题用不到。</p>
<p>当然也能代数推导，Imakf 给了种代数推导的方式：$\sum\limits_{i=j}^{k}(i+1)\binom{i}{j}=\frac{1}{j+1}\sum\limits_{i=j}^k\binom{i+1}{j+1}$</p>
<p>当然，其实本质是一样的，但是从两个角度看也可以收获不同的东西。</p>
<p>剩下部分计数一下就行了。</p>
<p>与题解一致。</p>
<h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><p>非常乐的一道题目。</p>
<p>首先一个性质，我们可以证明所有贡献和其实等于 $\sum\prod\limits_{i=1}^{q}a_{i}$ 。</p>
<p>原因是，设 $S_{i}$ 为固定 $1\le b_{1}&lt;b_{2}&lt;…&lt;b_{i}\le q$ ，$S_{i}=\sum\prod\limits_{j=1}^{i}a_{b_{j}}$ ，显然 $S_{i}$ 的值不会根据 $b$ 的选取而改变，原因是一个幸运票 shuffle 一下还是幸运票。</p>
<p>然后贡献和等于：$\sum\limits_{i=0}^{n}S_i * T_{n-i}+(2^{q}-1)S_{i}$ ，其中 $T_{i}$ 表示 $\prod\limits_{i=1}^{q}(x+i)$ 中 $x^{i}$ 的系数。</p>
<p>这非常有意思啊，因为可以证明 $q$ 是素数的时候，$\prod\limits_{i=1}^{q}(x+i)=x^{q}-x$ ，而这个的证明就是初等数论课上讲了一万遍的东西。</p>
<p>显然 ${q-1}$ 次多项式的根至多 $q-1$ 个，所以指定过 $q$ 个点的首一多项式只有一个，就是 $x^{q}-x$ 。</p>
<p>那么整理一下式子就可以得到：$\sum\prod\limits_{i=1}^{q}a_{i}$ 。</p>
<p>好了，知道这个结论问题就简单了。</p>
<p>现在任意给你个方案，设相同的数字出现次数分别为 ：$c_{1},c_{2},…,c_{t},\sum c_{i}=q$ ，那么其贡献 $\binom{q}{c_{1},…,c_{t}}$ ，显然当 $t&gt;1$ 时，这玩意被 $q$ 整除。</p>
<p>所以 $t=1,c_{1}=q$ 。</p>
<p>验证一下就行了。</p>
<p>时间复杂度：$O(n\log{q})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="function">LL <span class="title">ksm</span><span class="params">(LL x, LL y, LL mod)</span></span>&#123;</span><br><span class="line">	LL ans = <span class="number">1ll</span>;</span><br><span class="line">	<span class="keyword">while</span>(y)&#123;</span><br><span class="line">		<span class="keyword">if</span>(y &amp; <span class="number">1</span>) ans = ans * x % mod;</span><br><span class="line">		x = x * x % mod;</span><br><span class="line">		y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">LL n, s, q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; s &gt;&gt; q;</span><br><span class="line">	LL ans = <span class="number">0ll</span>;</span><br><span class="line">	<span class="keyword">for</span>(LL i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		LL tmp = <span class="built_in">ksm</span>(i, q, n) + i * q;</span><br><span class="line">		tmp %= n;</span><br><span class="line">		<span class="keyword">if</span>(tmp == s)&#123;</span><br><span class="line">			ans = (ans + i) % q;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Plan"><a href="#Plan" class="headerlink" title="Plan"></a>Plan</h1><p>看懂 H 的题解，并且给出组合意义的 $x^q-x$ 的证法。</p>
<p>写 D 的题解。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>SCOI2016 美味</title>
    <url>/2025/02/05/SCOI2016-%E7%BE%8E%E5%91%B3/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p><a href="https://loj.ac/problem/2016">题目链接</a></p>
<h1 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h1><p>一个很新鲜的 idea，由于直接建 01trie 没法支持修改，不妨考虑另类做法：</p>
<p>枚举答案 $\mathrm{xor}$ $b$（即枚举 $x_{i}+a_{j}$）的二进制每一位是 $0$ 还是 $1$ ，即对于最高位第 $t$ 位，如果我想要这一位是 $0$（因为 $b$ 的这一位是 $1$ ），那么就判断 $[l,r]$ 区间是否有 $[0,2^{t}-1]$ 的数字，后面的位类似。</p>
<p>至于判断区间是否存在某个区间的数字，直接用动态开点线段树搞就行了。</p>
<p>时间复杂度：$O(n\log^2{\mathrm{V}})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  N  210000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  NN  4100000</span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>  l,r,c<span class="comment">/*数字个数*/</span>;</span><br><span class="line">&#125;tr[NN];<span class="type">int</span>  len,rt[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">updata</span><span class="params">(<span class="type">int</span>  x)</span></span>&#123;tr[x].c+=tr[tr[x].l].c+tr[tr[x].r].c;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">link</span><span class="params">(<span class="type">int</span>  &amp;x,<span class="type">int</span>  l,<span class="type">int</span>  r,<span class="type">int</span>  k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x)x=++len;</span><br><span class="line">	tr[x].c++;</span><br><span class="line">	<span class="keyword">if</span>(l==r)<span class="keyword">return</span>  ;</span><br><span class="line">	<span class="type">int</span>  mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(k&lt;=mid)<span class="built_in">link</span>(tr[x].l,l,mid,k);</span><br><span class="line">	<span class="keyword">else</span>  <span class="built_in">link</span>(tr[x].r,mid+<span class="number">1</span>,r,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">mer</span><span class="params">(<span class="type">int</span>  &amp;x,<span class="type">int</span>  y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x  ||  !y)&#123;x=x+y;<span class="keyword">return</span>  ;&#125;</span><br><span class="line">	tr[x].c+=tr[y].c;</span><br><span class="line">	<span class="built_in">mer</span>(tr[x].l,tr[y].l);<span class="built_in">mer</span>(tr[x].r,tr[y].r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span>  <span class="title">query</span><span class="params">(<span class="type">int</span>  x,<span class="type">int</span>  y,<span class="type">int</span>  l,<span class="type">int</span>  r,<span class="type">int</span>  ll,<span class="type">int</span>  rr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tr[x].c==tr[y].c)<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span>  <span class="keyword">if</span>(l==ll  &amp;&amp;  r==rr)<span class="keyword">return</span>  tr[x].c-tr[y].c&gt;<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span>  mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(rr&lt;=mid)<span class="keyword">return</span>  <span class="built_in">query</span>(tr[x].l,tr[y].l,l,mid,ll,rr);</span><br><span class="line">	<span class="keyword">else</span>  <span class="keyword">if</span>(mid&lt;ll)<span class="keyword">return</span>  <span class="built_in">query</span>(tr[x].r,tr[y].r,mid+<span class="number">1</span>,r,ll,rr);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">query</span>(tr[x].l,tr[y].l,l,mid,ll,mid))<span class="keyword">return</span>  <span class="built_in">query</span>(tr[x].r,tr[y].r,mid+<span class="number">1</span>,r,mid+<span class="number">1</span>,rr);</span><br><span class="line">		<span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>  n,m,limit=<span class="number">262143</span>;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span>  x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">		<span class="built_in">link</span>(rt[i],<span class="number">0</span>,limit,x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">2</span>;i&lt;=n;i++)<span class="built_in">mer</span>(rt[i],rt[i<span class="number">-1</span>]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span>  b,x,l,r;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;b,&amp;x,&amp;l,&amp;r);</span><br><span class="line">		<span class="type">int</span>  ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  j=<span class="number">17</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span>  ll=ans,rr=ans;</span><br><span class="line">			<span class="keyword">if</span>(b&amp;(<span class="number">1</span>&lt;&lt;j))rr+=(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>;<span class="comment">//有</span></span><br><span class="line">			<span class="keyword">else</span>  ll+=(<span class="number">1</span>&lt;&lt;j),rr+=(<span class="number">1</span>&lt;&lt;(j+<span class="number">1</span>))<span class="number">-1</span>;<span class="comment">//没有 </span></span><br><span class="line">			ll-=x;rr-=x;</span><br><span class="line">			<span class="type">int</span>  shit;</span><br><span class="line">			<span class="keyword">if</span>(ll&lt;<span class="number">0</span>  &amp;&amp;  rr&lt;<span class="number">0</span>)shit=<span class="number">0</span>;<span class="comment">//完全不行</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(ll&lt;<span class="number">0</span>)ll=<span class="number">0</span>;</span><br><span class="line">				shit=<span class="built_in">query</span>(rt[r],rt[l<span class="number">-1</span>],<span class="number">0</span>,limit,ll,rr);</span><br><span class="line">			&#125;</span><br><span class="line">			ans|=(b&amp;(<span class="number">1</span>&lt;&lt;j))^(shit&lt;&lt;j); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans^b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>SEERC 2020 赛后小结</title>
    <url>/2024/08/04/SEERC-2020-%E8%B5%9B%E5%90%8E%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://qoj.ac/contest/636">https://qoj.ac/contest/636</a></p>
<p>开局过 E ，和队友讨论 B ，讨论着讨论着队长听到直接秒了，我上去写过了，队友秒了 M，F，期间我和剩下的队友讨论 L ，看到有人 9 min 过 L ，我们以为是贪心，贪了半天，后面队友去做别的题，我无可奈何，搞了个 $log^2$ 做法遗憾上机，一个小时的时候过了此题。</p>
<p>队友们秒了 I ，然后 Imakf 上去写，但是突然牢起来了，期间我会做了 A 和 H ，队长会做了 D ，会一半的 G ，我上去过了 A,H 后，两个小时到了，去看处于水火之中的 Imakf ，队长上 D 。</p>
<p>讨论一番，发现他 DP 状态设的不好，后面又讨论了一下 DP 转移，发现我其实也考虑漏了，但综合起来对很多，后面 Imakf 上去改 I ，两个半小时过 D,I 。</p>
<p>后面和队长讨论 J ，一开始觉得他在放屁，不知道他在说什么，再加上队长能说会道，妙语连珠，一下子输出观点给我输出懵逼了，差点红温，出去冷静了一下，当时以为他的圆交圆只能是圆这个性质只能用来求交，没什么用。但是在半个小时后手模了一下，发现之前没有参透队长话语之精髓，突然发现其实这个性质就已经做完此题。队长伟大，无需多言。</p>
<p>后面又想了半个小时怎么写，后面上机半小时过了，此时四个小时。</p>
<p>首先我在知道完所有性质还玩了一个小时，确实菜了，这个不用洗，下次必须快一点，我觉得半小时都算慢了。</p>
<p>其次说句实话，我其实有点烦队长的沟通方式，在我还没熟悉题目，听懂他前面想法的时候，后面的话就跟过来了，然后队长反应比较快，有新想法又喜欢 “哦” 吸引注意然后继续输出，我又恰好反应比较慢，给他这么一整，整一段话经常听完没法思考，听着听着就容易红温，红温了就容易懒得鸟他，而且他在说勾八话的时候也是有的，这个时候不能思考被迫听他放屁就比较痛苦了。</p>
<p>但是呢，这需要改吗？我觉得其实不需要，首先我的反应比较慢所以这种沟通有点史，Imakf 跟他沟通就比较融洽；其次如果让队长说慢一点，万一他一停下来就宕机了就不好了，不如就让他先把观点输出完，毕竟虽然口胡很多，但也有不少次直接把题目秒了的情况在；再其次，虽然队长说的话我当时无法思考，但后面大抵都是能懂的，后面没懂的时候大部分是因为他确实在放屁，所以也无所谓；最后就是我红温不仅是因为沟通方式的问题，我本身沟通久了容易红，以及当我渴望自己做出这道题目但是直接被队友爆出了一堆性质的时候我也会红温，所以我红温不仅是沟通的问题，也有我的问题在，这也是我需要改的事情。</p>
<p>综上，没必要去强行改变和队长的沟通方式，在此之前，我觉得我需要先去解决我容易红的问题，以及意识到这是个团队游戏，虽然我觉得后一条非常困难，毕竟打比赛的目的中但凡有奔着证明自己实力的成分去，就不可避免会在队友 C 而自己徒劳无功的时候感到难受，毕竟一场下来只能起到写代码的作用那真是闹麻了，总之这里有个度，我觉得有个度正常，但是我可能这个度有点超乎常理了，确实应该调得正常一点，这样和队友的配合才会更好，更何况我打比赛的核心目的是为了打钱。</p>
<p>接着复盘，后面我一直在想 K ，队长爆了一个关键的性质考虑 $\frac{d}{3}$ ，但是我没鸟他，虽然鸟了也没啥用，因为我们全队没有一个人意识到容斥可以逐位确定答案，以至于所有人都没有想容斥，虽然最后容斥确实难，但是连容斥都没想过就直接遗憾离场确实有点搞了。<del>而且说句实话，我其实之前好像见过甚至用过这个容斥，想一个小时容斥真有机会想出来吧</del></p>
<p>但是队友非常给力啊，搞了一个小时 C 搞出来打表做法。</p>
<p>最后几分钟过了，极限！</p>
<p>赛时队友写了一半的 G 在赛后过了，队友伟大，无需多言。</p>
<p>我这场的问题：</p>
<ol>
<li>其实应该在过了 A 后就去询问一下 Imakf 的情况，毕竟 Imakf 因为这种问题牢了一个半小时直接让其可能能产生贡献的机会少了很多，虽然确认应该相信队友能解决问题，但是询问一下也是应该的，毕竟这个询问一下情况也不会花很多时间，相反，如果让 Imakf 多一个小时想题我们这把可能打的更好。</li>
<li>队长报完了 J 的性质我还想了一小时，这真是脑子有问题吧。</li>
</ol>
<p>部分题解：</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>注意到几个操作分别对应逆序对数 $-1/-2$ 。</p>
<p>猜一下只要逆序对数 $\ge 2$ ，就一定存在 $110,100,1010$ 四种情况中的一种，所以对应 NIM 游戏中的 $-1,-2$ ，所以答案就是会不会被 $3$ 整除。</p>
<p>事实上也不难证明，你讨论一下 $1$ 在 $0$ 中的放置位置就行了。</p>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><h1 id="L"><a href="#L" class="headerlink" title="L"></a>L</h1><p>二分加贪心。</p>
<p>首先注意到这个答案显然是可以二分的。</p>
<p>然后在二分答案后，我们不妨根据 $m,p$ 分别排一次序，然后我们尝试维护用到的数字在 $m$ 排序后的数组是哪个前缀，和 $p$ 排序后的数组是哪个前缀（不是所有数字）。</p>
<p>原因是显然，我们可以把数组分为三类，偷的，不干的，资助的，注意到不干的里面所有的 $m\le$ 偷的 $m$ ，对资助的 $p$ 也是。</p>
<p>所以偷的和资助的一部分数字理应构成 $m$ 数组的一个前缀 ，$p$ 也是。</p>
<p>所以枚举一下 $m$ 的前缀，然后 $p$ 用双指针扫一下就行了。</p>
<p>至于每个人是偷还是资助，可以注意到是根据 $m+p$ 排序，所以用两个 set 维护一下就行了。</p>
<p>时间复杂度：$O(n\log^2n)$ 。</p>
<p>RE 了一发，因为有个地方写的纯错。</p>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>不难，注意到差分一下，每个位置的贡献是 $-1/0/1$ ，所以选择每个数字的贡献是后缀和。</p>
<p>不妨考虑全部选 $-1$ ，这样就是每个数字选 $1,2$ ，保证前缀和 $\ge 0$ ，且总和得是 $0/1$ ，那么就堆处理一下就行了。</p>
<p>时间复杂度：$O(n\log{n})$ 。</p>
<h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><p>注意到假设最终相等的这个数字为 $x$ ，统计其二进制位数为 $c$ ，二进制位数 $&gt;c$ 的一定在 $and$ 里头 ，$&lt;c$ 在 $or$ 里头。</p>
<p>注意到这个性质，讨论一下就行了，很好写。</p>
<p>别的队注意到的性质比较差，注意到 $x\ge x\And y$ ，$or$ 反之，所以一定是 $<x$ 的在 $or$ 里头，$>x$ 在 $and$ 里头，然后注意到排序后前缀的 $or$ 至多变化 $\log{V}$ 次，后缀同理。</p>
<p>所以每层合并写个归并排序合并。</p>
<p>时间复杂度都是：$O(n\log{n}\log{V})$</p>
<h1 id="I"><a href="#I" class="headerlink" title="I"></a>I</h1><p>注意到只有 $1,2$ 能向上跳，所以答案一定为至多两个下降序列拼接起来，所以用 $dp$ 维护一下就行了，转移是调和级数的。</p>
<p>$f[i]$ 表示有两个接头，一个在 $i$ ，一个在 $i+1$ 。</p>
<p>其中转移的时候只考虑 $i+1$ 的跳跃。</p>
<p>防止出现：$4\to 2,3\to 1$ 的情况的时候算重。</p>
<p>反正就是差不多这样的 $dp$ ，具体状态还有转移可能还有点小区别，但反正大差不差了。</p>
<p>时间复杂度：$O(n\log{n})$ 。</p>
<h1 id="J"><a href="#J" class="headerlink" title="J"></a>J</h1><p>唐完了。</p>
<p>队长都已经报出做法了还不会做。</p>
<p>首先什么是树上的一个圆，考虑每条边也算是有效单位（即还要算每条边要百分之多少是在点集里的），所有树上距离 $x\le d$ 的点构成的点集是个圆。</p>
<p>现在证明，树上两个圆的交集还是圆：</p>
<p>大概就是讨论一下圆的位置，然后选一下两点的连线，连线上交集的中心就是新的圆心。</p>
<p><img src="1.png" alt=""></p>
<p>上面是一种情况。</p>
<p>所以最终可行的连通块还是一个圆。</p>
<p>考虑手模一下这个过程，由于给定的圆都非常地好，圆心都落在顶点上，而且边界也都落在点上。</p>
<p>所以最终可以证明，最终的圆心一定在顶点或者边中间，边界一定是顶点。</p>
<p>所以就可以得到做法了。</p>
<p>而且这道题目性质还要好，每个点都有一个圆，所以可以证明答案一定是从最小值点或者两个最小值点的中心向外辐射。</p>
<p>随便写写算算概率就行了，时间复杂度：$O(n\log{n})$ 。</p>
<p>概率还有个性质：显然一个点的概率要么是 $0$ ，要么 $\ge \frac{1}{2}$ ，因为显然如果他能选，那么在一个没选他的方案里选他也是合法方案。所以概率 $\ge \frac{1}{2}$ 。</p>
<p>当然，这道题目甚至性质还要强一点，保证了合法，所以还有一个证明圆的方法。</p>
<p>就是随便找一个可行方案，这个可行方案中选的点构成一个虚树，树上有个结论，所有点到虚树直径两端的距离是最远的，而且一定经过虚树的重心（这个重心是可以在边上的），而因为合法，这个距离一定等于 $d$ ，所以得到距离重心 $\le r$ （虚树半径）的点都一定是可以选的，又由于每个点都有限制，所以两个端点一定分别有以他们为最远点的限制，所以可以得到 $&gt;r$ 一定是不能选的。</p>
<p>证毕。</p>
<h1 id="Plan"><a href="#Plan" class="headerlink" title="Plan"></a>Plan</h1><ol>
<li>补一下题解</li>
<li>看一下题解</li>
<li>思考一下 K |B|+1 的性质，看能不能出题。</li>
<li>看一下洛谷的题解。</li>
<li>找一下之前 CF 的某道题，我似乎在某道题目中使用过 K 的容斥做法，看看是不是一样的（提供自己一点情绪价值）。</li>
<li>做一下 F</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>SCOI2016 围棋</title>
    <url>/2025/02/05/SCOI2016-%E5%9B%B4%E6%A3%8B/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p><a href="https://www.luogu.com.cn/problem/P3290">题目链接</a></p>
<h1 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h1><p>首先你得先轮廓线DP（不一定得会插头DP，但这两玩意好像没差）</p>
<p>题解部分照搬：<a href="https://www.luogu.com.cn/blog/duyi/solution-p3290，讲的挺好的。">https://www.luogu.com.cn/blog/duyi/solution-p3290，讲的挺好的。</a></p>
<p>先做补集转化。把“至少有一次匹配”，转化为求“禁止出现匹配”。然后用$3^{nm}$减去禁止出现匹配的方案数，就是答案了。</p>
<p>考虑轮廓线DP。</p>
<p>设 $dp[i][j][mask][k][l]$ 表示考虑到了第 $i$ 行、第 $j$ 列这个位置。$mask$ 是一个状压，表示当前轮廓线哪些位置可以与模板的第一行完全匹配。由于 $1…c−1$ 这些列显然不可能完全匹配，所以 $mask$ 只需要记录 $m-c+1$ 个二进制位。$k$ 表示第 $i$ 行 $1…j$ 位最多能匹配到模板串第一行的哪个位置，$l$ 表示第 $i$ 行 $1…j$ 位最多能匹配到模板串第二行的哪个位置。</p>
<p>显然，当 $l=c$ 且 $mask$ 的第一个二进制位（也就是代表了 $i,j$ 正上方的位置）为 $1$ 时，就会出现一次和模板串的完整匹配，因此这种转移是不合法的。否则，其他情况下我们都可以转移。新的 $k,l$ 可以用 $KMP$ 求出。新的 $mask$ 相比原来的 $mask$ 要去掉第一位，然后新加入一位：若 $k=c$ 则新加入的位为 $1$，否则为 $0$ 。</p>
<p>DP 数组的前两维可以滚动使用，这样优化了空间。</p>
<p>注意，在 DP 完一整行后，要把所有方案数，累加到 $dp[i][j][mask][0][0]$ 上：因为下一行又要重新开始匹配了。</p>
<p>时间复杂度：$O(nm2^{m-c+1}c^2)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">long</span>  <span class="type">long</span>  LL;</span><br><span class="line"><span class="type">const</span>  LL  mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  LL  <span class="title">ksm</span><span class="params">(LL  x,<span class="type">int</span>  y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL  ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(y)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>  ans;</span><br><span class="line">&#125;</span><br><span class="line">LL  dp[<span class="number">2</span>][<span class="number">4100</span>][<span class="number">10</span>][<span class="number">10</span>];<span class="comment">//滚动数组</span></span><br><span class="line"><span class="type">int</span>  kmp[<span class="number">2</span>][<span class="number">10</span>],a[<span class="number">2</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span>  st[<span class="number">2</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span>  n,m,q,c;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">int</span>  <span class="title">get</span><span class="params">(<span class="type">int</span>  k,<span class="type">int</span>  x)</span></span>&#123;<span class="keyword">return</span>  (k&amp;(<span class="number">1</span>&lt;&lt;(x-c)))&gt;<span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">change</span><span class="params">(<span class="type">int</span>  &amp;k,<span class="type">int</span>  x,<span class="type">int</span>  val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(k&amp;(<span class="number">1</span>&lt;&lt;(x<span class="number">-1</span>)))k^=(<span class="number">1</span>&lt;&lt;(x<span class="number">-1</span>));</span><br><span class="line">	k|=(val&lt;&lt;(x<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;c,&amp;q);</span><br><span class="line">	<span class="type">int</span>  limit=(<span class="number">1</span>&lt;&lt;(m-c+<span class="number">1</span>))<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  t=<span class="number">1</span>;t&lt;=q;t++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">0</span>;i&lt;=<span class="number">1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st[i]+<span class="number">1</span>);</span><br><span class="line">			kmp[i][<span class="number">0</span>]=<span class="number">-1</span>;a[i][<span class="number">0</span>]=a[i][c+<span class="number">1</span>]=<span class="number">-1</span>;</span><br><span class="line">			<span class="type">int</span>  k=<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span>  j=<span class="number">1</span>;j&lt;=c;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				a[i][j]=(st[i][j]==<span class="string">&#x27;W&#x27;</span>?<span class="number">1</span>:(st[i][j]==<span class="string">&#x27;B&#x27;</span>?<span class="number">2</span>:<span class="number">0</span>));</span><br><span class="line">				<span class="keyword">while</span>(k!=<span class="number">-1</span>  &amp;&amp;  st[i][k+<span class="number">1</span>]!=st[i][j])k=kmp[i][k];</span><br><span class="line">				kmp[i][j]=++k;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span>  now=<span class="number">0</span>,pre=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">memset</span>(dp[now],<span class="number">0</span>,<span class="built_in">sizeof</span>(dp[now]));</span><br><span class="line">		dp[now][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//初始化为1 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span>  j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				now^=<span class="number">1</span>;pre^=<span class="number">1</span>;</span><br><span class="line">				<span class="built_in">memset</span>(dp[now],<span class="number">0</span>,<span class="built_in">sizeof</span>(dp[now]));</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span>  k=<span class="number">0</span>;k&lt;=limit;k++)<span class="comment">//之前的状态 </span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span>  q=<span class="number">0</span>;q&lt;=c  &amp;&amp;  q&lt;j;q++)<span class="comment">//第零行 </span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">for</span>(<span class="type">int</span>  p=<span class="number">0</span>;p&lt;=c  &amp;&amp;  p&lt;j;p++)<span class="comment">//第一行 </span></span><br><span class="line">						&#123;</span><br><span class="line">							<span class="keyword">if</span>(!dp[pre][k][q][p])<span class="keyword">continue</span>;</span><br><span class="line">							<span class="keyword">for</span>(<span class="type">int</span>  o=<span class="number">0</span>;o&lt;=<span class="number">2</span>;o++)</span><br><span class="line">							&#123;</span><br><span class="line">								<span class="type">int</span>  qq=q,pp=p;</span><br><span class="line">								<span class="keyword">while</span>(qq!=<span class="number">-1</span>  &amp;&amp;  a[<span class="number">0</span>][qq+<span class="number">1</span>]!=o)qq=kmp[<span class="number">0</span>][qq];</span><br><span class="line">								<span class="keyword">while</span>(pp!=<span class="number">-1</span>  &amp;&amp;  a[<span class="number">1</span>][pp+<span class="number">1</span>]!=o)pp=kmp[<span class="number">1</span>][pp];</span><br><span class="line">								qq++;pp++;</span><br><span class="line">								<span class="keyword">if</span>(pp==c  &amp;&amp;  <span class="built_in">get</span>(k,j)==<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">								<span class="type">int</span>  kk=k;</span><br><span class="line">								<span class="keyword">if</span>(j&gt;=c)<span class="built_in">change</span>(kk,j-c+<span class="number">1</span>,qq==c);</span><br><span class="line">								dp[now][kk][qq][pp]=(dp[now][kk][qq][pp]+dp[pre][k][q][p])%mod;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			now^=<span class="number">1</span>;pre^=<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">memset</span>(dp[now],<span class="number">0</span>,<span class="built_in">sizeof</span>(dp[now]));</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span>  k=<span class="number">0</span>;k&lt;=limit;k++)<span class="comment">//之前的状态 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span>  q=<span class="number">0</span>;q&lt;=c;q++)<span class="comment">//第零行 </span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span>(<span class="type">int</span>  p=<span class="number">0</span>;p&lt;=c;p++)dp[now][k][<span class="number">0</span>][<span class="number">0</span>]=(dp[now][k][<span class="number">0</span>][<span class="number">0</span>]+dp[pre][k][q][p])%mod;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		LL  ans=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  k=<span class="number">0</span>;k&lt;=limit;k++)ans=(ans+dp[now][k][<span class="number">0</span>][<span class="number">0</span>])%mod;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(<span class="built_in">ksm</span>(<span class="number">3</span>,n*m)-ans+mod)%mod);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这道题目好难，完全不会QAQ</p>
<p>但是感悟也不是没有，其实轮廓线 DP 有的时候可以优化方格图上某些状压，当状压难以转移，或者可以转移但时间较大时不妨考虑轮廓线 DP 。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>轮廓线dp</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>SDOI2009 学校食堂</title>
    <url>/2025/02/05/SDOI2009-%E5%AD%A6%E6%A0%A1%E9%A3%9F%E5%A0%82/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>题目链接：<a href="https://www.luogu.com.cn/problem/P2157">https://www.luogu.com.cn/problem/P2157</a>  </p>
<h1 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h1><p>$ f[i][j][k] $ 表示第 $ i $ 个数字，$ j $ 表示最后一个数字在 $ j+k $ 的位置，然后 $ k $ 用二进制表示后面的情况，对于 $ f[i][j][k] $，设 $ x $ 为包括他以内往后 $ b[i]+1 $ 位第一个没有做菜的位置，然后用 $ f[i][j][k] $ 贡献给 $ f[x] $ 即可。  </p>
<p>当然，需要提前处理每个位置的哪些二进制合法。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&amp;-x;&#125;</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">10</span>][<span class="number">260</span>]<span class="comment">/*表示这个位置自己优先搞到了*/</span>;</span><br><span class="line"><span class="type">int</span> n,m,a[N],b[N];</span><br><span class="line"><span class="type">bool</span> he[N][<span class="number">260</span>]<span class="comment">/*表示这个学生哪个二进制是非常合法的*/</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">mymin</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&lt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">mymax</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k,<span class="type">int</span> limit<span class="comment">/*表示限制后面几位*/</span>,<span class="type">int</span> id)</span><span class="comment">//用来处理合法情况</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	he[id][k]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x&gt;limit)<span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">dfs</span>(x+<span class="number">1</span>,k,<span class="built_in">mymin</span>(limit,b[id+x]+x),id);</span><br><span class="line">	<span class="built_in">dfs</span>(x+<span class="number">1</span>,k^(<span class="number">1</span>&lt;&lt;x),limit,id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">find2</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==<span class="number">1</span>?<span class="number">0</span>:(x==<span class="number">2</span>?<span class="number">1</span>:(x==<span class="number">4</span>?<span class="number">2</span>:(x==<span class="number">8</span>?<span class="number">3</span>:(x==<span class="number">16</span>?<span class="number">4</span>:(x==<span class="number">32</span>?<span class="number">5</span>:(x==<span class="number">64</span>?<span class="number">6</span>:(x==<span class="number">128</span>?<span class="number">7</span>:<span class="number">8</span>)))))));&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cost</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> (x|y)-(x&amp;y);&#125;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k,<span class="type">int</span> pre<span class="comment">/*前面那个数组*/</span>,<span class="type">int</span> co)</span><span class="comment">//贡献情况</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==n+<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ans=<span class="built_in">mymin</span>(ans,co);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> shit=(<span class="number">1</span>&lt;&lt;(b[x]+<span class="number">1</span>))<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> ed=shit^k;ed;ed=ed^<span class="built_in">lowbit</span>(ed))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> y=<span class="built_in">find2</span>(<span class="built_in">lowbit</span>(ed));</span><br><span class="line">		<span class="keyword">if</span>(!he[x][k^(<span class="number">1</span>&lt;&lt;y)])<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(f[x][y][k^(<span class="number">1</span>&lt;&lt;y)]==<span class="number">-1</span> || co+<span class="built_in">cost</span>(a[x+y],pre)&lt;f[x][y][k^(<span class="number">1</span>&lt;&lt;y)])f[x][y][k^(<span class="number">1</span>&lt;&lt;y)]=co+<span class="built_in">cost</span>(a[x+y],pre);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">		<span class="built_in">memset</span>(he,<span class="number">0</span>,<span class="built_in">sizeof</span>(he));</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);ans=<span class="number">999999999</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i],&amp;b[i]);</span><br><span class="line">			b[i]=<span class="built_in">mymin</span>(b[i],n-i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,i);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=b[<span class="number">1</span>];i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(he[<span class="number">1</span>][<span class="number">1</span>&lt;&lt;i])f[<span class="number">1</span>][i][<span class="number">1</span>&lt;&lt;i]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> ed=(<span class="number">1</span>&lt;&lt;(b[i]+<span class="number">1</span>))<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=ed;k++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(!he[i][k])<span class="keyword">continue</span>;</span><br><span class="line">				<span class="type">int</span> cnm=<span class="built_in">find2</span>(<span class="built_in">lowbit</span>(((<span class="number">1</span>&lt;&lt;(b[i]+<span class="number">2</span>))<span class="number">-1</span>)^k));</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> t=k;t;t=t^<span class="built_in">lowbit</span>(t))</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">int</span> j=<span class="built_in">find2</span>(<span class="built_in">lowbit</span>(t));</span><br><span class="line">					<span class="keyword">if</span>(f[i][j][k]!=<span class="number">-1</span>)<span class="built_in">solve</span>(cnm+i,k&gt;&gt;cnm,a[i+j],f[i][j][k]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Strange Keyboard</title>
    <url>/2024/02/11/Strange-Keyboard/</url>
    <content><![CDATA[<p>题目链接：Strange Keyboard</p>
<p>题目大意：$Q$ 组数据，给 $n$ 个串 $S_i$ 和一个 $K$ ，还有一个空串和目标串 $T$ ，你可以对空串依次做下面两个操作的其中一个，问最少几步变成目标串。</p>
<ol>
<li>如果串长 $\ge K$ ，就删除最后 $K$ 个字符。</li>
<li>在串尾加入 $n$ 个串的其中一个。</li>
</ol>
<p>数据范围：$Q\le 100$ ，所有数据的 $\sum |S_i|\le 10^6$ ，所有数据的 $\sum |K|\le 5000$ ，$K\le 5000$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>循序渐进的考虑这道题目怎么做：</p>
<p>考虑一种特殊情况：$T=aaa…$ ，然后只有一个串是 $abc…$ 的结构（首字母为 $a$ ，后面全都不是 $a$ ），然后其余一堆没有 $a$ 的垃圾串，那么这显然引导我们先要解决一个同余最短路的问题，即需要至少多少次数能够消掉一个长度为 $len$ 的后缀？</p>
<p>注意到，在这个问题中，我们并不关心字符串的内容是什么，我们只关心长度，不同的长度只有至多 $O(\sqrt{\sum |S_i|})$ 种。</p>
<p>设 $f_i$ 表示需要最少多少次才能让字符串恰好有 $i$ 个字符，$f_0=0$ ，这个时候发现，跑同余最短路会超时，多个 log ，怎么办呢？</p>
<p>如果你足够聪慧，就会发现，导致出现权值从而让我们不得不跑最短路的原因是我们直接做了取余操作，事实上，我们根本没必要一次性把取余操作做完，详细的说就是：</p>
<script type="math/tex; mode=display">
\begin{align*}
    f_{i-K}&=\min(f_{i-K},f_{i}+1),i\ge K\\
    f_{i+a_j}&=\min(f_{i+a_j},f_{i}+1),i<K\\
\end{align*}</script><p>这样，权值就都是 $1$ 了，直接跑 $BFS$ 即可。</p>
<p>当然，我不够聪慧，我的解决方法是直接开值域个队列，不难证明 $f$ 的最大值不超过 $\max(S_i)+K$ 。</p>
<p>上述两种方法的时空复杂度都一样，单组数据下：</p>
<p>时间复杂度：$O(max(S_i)+K\sqrt{\sum |S_i|})$</p>
<p>空间复杂度：$O(\sum |S_i|+K)$</p>
<p>后面就简单了，考虑一个事情，假如我们现在已经填了 $T$ 的一个前缀，然后现在我们要填一个字符串，并且要删掉字符串的一个后缀，那么代价可以很方便的用 $f$ 计算。</p>
<p>设 $dp[i]$ 表示填下 $T$ 的长度为 $i$ 的前缀的最小操作次数。</p>
<p>那么 $dp[i]\to dp[j]$ 的转移就是所有前缀能对上 $T[i+1\to j]$ 的 $S$ 串的转移代价的最小值，这里有个匹配前缀的要求，显然用 Trie 就行了。</p>
<p>因此这道题目就做完了：先同余最短路算 $f$ ，然后建 $Trie$ ，最后 $dp$ 转移即可。</p>
<p>单组数据下：</p>
<p>时间复杂度：$O(26\sum S_i+K\sqrt{\sum |S_i|}+T^2)$</p>
<p>空间复杂度：$O(26\sum S_i+K+T)$</p>
<p>虽然有 $100$ 组数据，但是算一下发现这个复杂度已经足以通过此题。（注意 $S$ 是所有数据的长度总和不超过 $10^6$ ，不是单组数据的）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL inf=<span class="number">1e15</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5e3</span>+<span class="number">105</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">5e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n,K;</span><br><span class="line">string ss[N];<span class="type">char</span> st[N];</span><br><span class="line"><span class="type">bool</span> v[N];<span class="type">int</span> stk[N],top;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!v[x])stk[++top]=x;</span><br><span class="line">    v[x]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="function">LL <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y=x%K;</span><br><span class="line">    <span class="keyword">if</span>(!y)<span class="keyword">return</span> x/K;</span><br><span class="line">    <span class="keyword">if</span>(!h[K-y])<span class="keyword">return</span> inf;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> h[K-y]+x/K;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    h[<span class="number">0</span>]=<span class="number">1</span>;q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=K)&#123;</span><br><span class="line">            <span class="type">int</span> y=x-K;</span><br><span class="line">            <span class="keyword">if</span>(!h[y])&#123;</span><br><span class="line">                h[y]=h[x]+<span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;i++)&#123;</span><br><span class="line">                <span class="type">int</span> y=x+stk[i];</span><br><span class="line">                <span class="keyword">if</span>(!h[y])&#123;</span><br><span class="line">                    h[y]=h[x]+<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">26</span>];LL val;</span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> x)&#123;<span class="keyword">return</span> a[x];&#125;</span><br><span class="line">&#125;tr[N];<span class="type">int</span> tcnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cl</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(tr[x].a,<span class="number">0</span>,<span class="built_in">sizeof</span>(tr[x].a));</span><br><span class="line">    tr[x].val=inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mxlen=<span class="number">0</span>;</span><br><span class="line">    top=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        v[ss[i].<span class="built_in">length</span>()]=<span class="number">0</span>;</span><br><span class="line">        mxlen=<span class="built_in">max</span>(mxlen,(<span class="type">int</span>)ss[i].<span class="built_in">length</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    mxlen+=K;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*mxlen);</span><br><span class="line"></span><br><span class="line">    tcnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cl</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(string &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=s[i<span class="number">-1</span>]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!tr[now][x])&#123;</span><br><span class="line">            tr[now][x]=++tcnt;</span><br><span class="line">            <span class="built_in">cl</span>(tcnt);</span><br><span class="line">        &#125;</span><br><span class="line">        now=tr[now][x];</span><br><span class="line">        tr[now].val=<span class="built_in">min</span>(tr[now].val,<span class="built_in">calc</span>(len-i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL dp[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;K);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">            ss[i]=st+<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">add</span>(ss[i].<span class="built_in">length</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">bfs</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">add</span>(ss[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> m=<span class="built_in">strlen</span>(st+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)dp[i]=inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">                now=tr[now][st[j]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                <span class="keyword">if</span>(!now)<span class="keyword">break</span>;</span><br><span class="line">                dp[j]=<span class="built_in">min</span>(dp[j],dp[i]+tr[now].val+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(dp[m]&lt;=inf);</span><br><span class="line">        <span class="keyword">if</span>(dp[m]==inf)dp[m]=<span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dp[m]);</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>Trie</tag>
        <tag>字符串</tag>
        <tag>同余最短路</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>The 2nd Ucup Stage 2: SPb M. Hardcore String Counting</title>
    <url>/2024/05/30/The-2nd-Ucup-Stage-2-SPb-M-Hardcore-String-Counting/</url>
    <content><![CDATA[<p>题目链接：<a href="https://contest.ucup.ac/contest/1356/problem/7187">https://contest.ucup.ac/contest/1356/problem/7187</a></p>
<p>题目大意：给一个长度为 $n$ 的字符串 $S$，问有多少个长度为 $m$ 的字符串满足所有真前缀没有子串等于 $S$ ，但整个串有。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法 + 反思</summary><div class="toggle-content"><p>看复杂度，应该是 $n\log$ 之类的东西，不大可能在 AC 自动机上跑，因此比较有可能的就是列一个线性递推式，然后常系数齐次线性递推。</p>
<p>我当时想到这一步了，可惜并没有列出线性递推式。</p>
<p>我当时的思路是，设 $g(m)$ 表示长度为 $m$ 的字符串且没有子串等于 $S$ ，然后在 $g(m-1)$ 放一个字符，容斥减去 $g(m-n)$ ，但 $g(m-n)$ 不一定满足前 $m-1$ 前缀没有子串等于 $S$ ，所以还得容斥，当时我的思路就是接着找 border ，不断下去，但是发现这个过程好想是无穷的。</p>
<p>例如 $S=aa$ 时，则按照这个思路可以得到：$g(m)=26g(m-1)-\sum\limits_{i=2}^{m}(-1)^ig(m-i)$ 。</p>
<p>下面的代码可以验证：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">LL f1[N][<span class="number">2</span>], f2[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    f1[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        f1[i][<span class="number">0</span>] = (f1[i - <span class="number">1</span>][<span class="number">0</span>] + f1[i - <span class="number">1</span>][<span class="number">1</span>]) * <span class="number">25ll</span> % mod;</span><br><span class="line">        f1[i][<span class="number">1</span>] = f1[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        cout &lt;&lt; (f1[i][<span class="number">0</span>] + f1[i][<span class="number">1</span>]) % mod &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    f2[<span class="number">0</span>] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        f2[i] = f2[i - <span class="number">1</span>] * <span class="number">26</span> % mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>, type = <span class="number">-1ll</span>; j &lt;= i; j++, type = -type) f2[i] = (f2[i] + f2[i - j] * type + mod) % mod; </span><br><span class="line">        cout &lt;&lt; f2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后我就觉得这个思路是错的，虽然上面的 $g(m)$ 可以加上 $g(m-1)$ ，这样就可以变成有限项求和，但是这只是针对 $S=aa$ 的情况，对于更加一般的情况，就不一定能这么干了，而且我也想不太明白一般情况下 $g$ 的递推式。（这个思路我感觉确实比较绕，比较难想）</p>
<p>但是如果换个角度来看：我们设 $f(m)$ 就表示答案，显然：$f(m)=26g(m-1)-g(m)$ ，上面的式子中，我们需要容斥掉不一定满足前 $m-1$ 前缀没有子串等于 $S$ 但是前 $m-n$ 的前缀满足的字符串，显然这就是 $\sum\limits_{Border}f(m-n+Border)$ 。</p>
<p>所以这显然就是 $\sum\limits_{Border}26g(m-n+Border-1)-g(m-n+Border)$ ，那么就得到了有限项的递推式。</p>
<p>然后直接加速一下，就可以在 $O(n\log{n}\log{k})$ 的时间解决这个问题了。</p>
<p>反思一下我为什么没做出来：我没找到有限项递推 ≠ 没有，我找到无限项递推 ≠ 没有有限项。</p>
<p>再回头看我那个思考方向，我不认为能想出来，从结果来看，有限项的递推式中一堆 $26$ ，因此可以知道那个无穷递推式的结果肯定很难看，更别说要看出怎样线性组合可以把那个无穷递推式变成有限项，反正我不认为那个角度可以想出来。</p>
<p>所以当推不出递推式的时候，先别着急的认为不存在递推式，或许换个方式去推就能很快推出来了。虽然做题的时候，做不出来换个方向考虑是正常的，但对于这种不同的推式子方法难度天差地别的方向，多换不同的方法推式子也是必要的。同理，组合题也是。</p>
<h6 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h6><p>代码？博主不会多项式算法，咕了，以后会了再回来补上。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>字符串</tag>
        <tag>常系数齐次线性递推</tag>
      </tags>
  </entry>
  <entry>
    <title>The 2nd Universal Cup Semifinals L. Slay the Spire</title>
    <url>/2024/07/06/The-2nd-Universal-Cup-Semifinals-L-Slay-the-Spire/</url>
    <content><![CDATA[<p>题目链接：<a href="https://contest.ucup.ac/contest/1708/problem/8824">https://contest.ucup.ac/contest/1708/problem/8824</a></p>
<p>题目大意：给你 $n$ 张卡，卡的效果为将你变成 $c_i$ 状态，同时如果之前你处于 $a_{i}$ 状态，那么你对敌人造成 $b_{i}$ 点攻击，还有 $k$ 瓶药，效果是直接变成 $x_{i}$ 状态，然后给你初始状态，问你能造成的最大伤害。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然卡牌和药全用完最优，然后我们可以变成，构建一条欧拉路径，使得权值和最大，权值定义为，能把卡片效果用出来的边，即如果一张卡牌是 $x\to y$ ，而我们也确实让这张卡牌这么干了。</p>
<p>又可以注意到，我们可以把终点和起点连起来，变成欧拉回路，即我们添加一瓶能到初始状态的药，然后要求最终回到初始状态，这两个问题显然是等价的。</p>
<p>这样，每个点的总入度是知道的，现在问题在于，我们能保留多少张卡牌的效果。</p>
<p>一个显然的事情是：一个点有多少入度，我们就会保留等量的从大到小的以这个点为起始点的卡牌。</p>
<p>但有一个问题，这样不一定连通。</p>
<p>我们不妨统计选的边所贡献的入度和出度，显然一个点的出度小于等于这个点的总入度。</p>
<p>可以发现，这个选法有效当且仅当，将单向边当成双向边后，一个连通块的总入度和 $&gt;$ 出度和。</p>
<p>思考一下什么时候等于，一个连通块的出度和等于入度和，入度 $\le$ 总入度，即总入度等于入度，所以这个连通块中所选择的边就是这个连通块所有的入边，即这个连通块没有块外的边连进来，同时因为入度等于总入读等于出度，所以这个连通块还是个欧拉图（单向边的情况下）。</p>
<p>现在要尝试花最小的代价使得其合法化，不妨猜一下，要么删除一条边，或者删除一条边，加入一条同起点的连向块外的边。</p>
<p>首先这一定是合法的，由于原来是欧拉图，所以一定强连通，所以连通块内仍连通，同时连通块的入度和等于总入度和等价于其中每个点都等于，而删除或者替换都会使原连通块不满足后者，所以新的连通块一定不满足。</p>
<p>问题是这为什么是最优的呢？</p>
<p>首先如果一开始没有孤立的团，那么显然是对的，假设有，假设有 $k$ 个，将点集分成 $k+1$ 部分，$X_1,X_2,…,X_{k+1}$ ，其中最后一个为补集。</p>
<p>尝试用局部最优的方法证明上面的那种选法就是上界，考虑每个集合中的点选出边，显然都会优先选最优的，但是任何方案都不可能包含 $X_{i}(i\le m)$ 的最优选法，所以每个方案至多包含 $X_{i}$ 的次优方案，所以每个方案的权值和 $\le$ $X_{1},…,X_{k}$ 的次优方案和 $X_{k+1}$ 的最优方案，而这个上界是能达到的，也就是上面那个东西，证毕。</p>
<p>时间复杂度：$O((n+k)\log{n+k}+m\log_{m})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, K, st, in[N];</span><br><span class="line">vector&lt;PII&gt; e[N];</span><br><span class="line"><span class="type">int</span> fa[N], inc[N], outc[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">findfa</span>(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mer</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x = <span class="built_in">findfa</span>(x);</span><br><span class="line">    y = <span class="built_in">findfa</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x != y)&#123;</span><br><span class="line">        fa[x] = y;</span><br><span class="line">        inc[y] += inc[x];</span><br><span class="line">        outc[y] += outc[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; u[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="built_in">sizeof</span>(in));</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m &gt;&gt; K &gt;&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) e[i].<span class="built_in">clear</span>(), u[i].<span class="built_in">clear</span>();</span><br><span class="line">        in[st]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> x, c, y;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; c &gt;&gt; y;</span><br><span class="line">            e[x].<span class="built_in">push_back</span>(&#123;c, y&#125;);</span><br><span class="line">            in[y]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= K; i++)&#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            in[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            fa[i] = i;</span><br><span class="line">            inc[i] = in[i];</span><br><span class="line">            outc[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LL ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="built_in">sort</span>(e[i].<span class="built_in">begin</span>(), e[i].<span class="built_in">end</span>(), [](PII x, PII y)&#123;<span class="keyword">return</span> x.first &gt; y.first;&#125;);</span><br><span class="line">            <span class="type">int</span> cnt = in[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> [c, y] : e[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(!cnt) <span class="keyword">break</span>;</span><br><span class="line">                cnt--;</span><br><span class="line">                ans += c;</span><br><span class="line">                <span class="built_in">mer</span>(i, y);</span><br><span class="line">                outc[<span class="built_in">findfa</span>(i)]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) u[<span class="built_in">findfa</span>(i)].<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fa[i] == i &amp;&amp; inc[i] == outc[i] &amp;&amp; inc[i])&#123;</span><br><span class="line">                <span class="type">int</span> tmp = <span class="number">1e9</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> x : u[i])&#123;</span><br><span class="line">                    <span class="built_in">assert</span>(in[x]);</span><br><span class="line">                    <span class="keyword">if</span>(e[x].<span class="built_in">size</span>() &gt; in[x]) tmp = <span class="built_in">min</span>(tmp, e[x][in[x] - <span class="number">1</span>].first - e[x][in[x]].first);</span><br><span class="line">                    <span class="keyword">else</span> tmp = <span class="built_in">min</span>(e[x].<span class="built_in">back</span>().first, tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                ans -= tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以为什么才开到 $5000$ ，这么能诈骗，要是 $200000$ 我赛时就做这题了。</p>
<p>和官方题解基本一致，不过我是从保留的角度考虑的，题解是从删除的角度考虑的，本质是一样的。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>SHOI2015 零件组装机</title>
    <url>/2025/02/05/SHOI2015-%E9%9B%B6%E4%BB%B6%E7%BB%84%E8%A3%85%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>[SHOI2015]零件组装机：<a href="https://www.luogu.com.cn/problem/P4386">https://www.luogu.com.cn/problem/P4386</a>  </p>
<h1 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h1><p><del>同机房大佬想性质想了很久，我从树的思想搞很快搞出来了</del>  </p>
<p>言归正传，这道题目从树的思路想是比较简单的，关键是建树。  </p>
<p>现在讲讲建树：对于一条边，默认是从编号大的连向编号小的有向边。  </p>
<p>那么，设 $x$ 连向的编号最大的点为 $y$，那么 $x,y$ 是什么关系？  </p>
<p>我们规定一个联通块的根为这个联通块编号最小的点（不难发现联通块的编号是连续的），那么 $x,y$ 的关系其实就是以 $x$ 为根的联通块与 $[y,x-1]$ 的联通块合并。  </p>
<p>这样，我们就只需要根据 $x,y$ 建出一棵树，从下往上合并，每次合并检验一下即可。  </p>
<p>需要注意的是：如果存在重边和自环直接无解。  </p>
<p>当然还有一个性质：合法图的边的是在 $O(n)$ 级别的。（同机房大佬找到的）  </p>
<p>时间复杂度：$O((n+m)\log{m})$  </p>
<p>用桶排加内存池以及其余细节便可以优化到 $O(n+m)$。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 110000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; fuck[N];</span><br><span class="line"><span class="type">int</span> cnt,now;<span class="comment">//合法边的数量 </span></span><br><span class="line"><span class="type">int</span> fa[N],siz[N];</span><br><span class="line"><span class="type">int</span> id[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> siz[x]&lt;siz[y];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> l1,<span class="type">int</span> r1,<span class="type">int</span> l2,<span class="type">int</span> r2)</span><span class="comment">//检验吧[l2,r2]合并到[l1,r1]是否合法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=r1-l1+<span class="number">1</span>,m=r2-l2+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(n&gt;m)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x=l1+i%n,y=l2+i;</span><br><span class="line">		set&lt;<span class="type">int</span>&gt;::iterator z=fuck[y].<span class="built_in">find</span>(x);</span><br><span class="line">		<span class="keyword">if</span>(z==fuck[y].<span class="built_in">end</span>())<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		now++;</span><br><span class="line">		fuck[y].<span class="built_in">erase</span>(z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)</span><br><span class="line">	&#123;</span><br><span class="line">		now=cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fuck[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="type">bool</span> bk=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> x,y;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">			<span class="keyword">if</span>(x&lt;y)x^=y^=x^=y;</span><br><span class="line">			<span class="keyword">if</span>(bk)<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(x==y)&#123;bk=<span class="number">1</span>;<span class="keyword">continue</span>;&#125;</span><br><span class="line">			set&lt;<span class="type">int</span>&gt;::iterator shit=fuck[x].<span class="built_in">find</span>(y);</span><br><span class="line">			<span class="keyword">if</span>(shit==fuck[x].<span class="built_in">end</span>())<span class="comment">//重边无解</span></span><br><span class="line">			&#123;</span><br><span class="line">				fuck[x].<span class="built_in">insert</span>(y);</span><br><span class="line">				cnt++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> bk=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)id[i]=i;</span><br><span class="line">		siz[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			siz[i]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(!fuck[i].<span class="built_in">size</span>())<span class="comment">//无边无解</span></span><br><span class="line">			&#123;</span><br><span class="line">				bk=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			set&lt;<span class="type">int</span>&gt;::iterator x=fuck[i].<span class="built_in">end</span>();</span><br><span class="line">			x--;fa[i]=*x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(bk==<span class="number">1</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)siz[fa[i]]+=siz[i];</span><br><span class="line">		<span class="built_in">sort</span>(id,id+n,cmp);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> x=id[i],y=fa[x];</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">check</span>(y,x<span class="number">-1</span>,x,x+siz[x]<span class="number">-1</span>))<span class="comment">//此次合并不合法</span></span><br><span class="line">			&#123;</span><br><span class="line">				bk=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(bk==<span class="number">1</span> || now!=cnt)&#123;<span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>The 3rd Ucup Stage 25 赛后总结</title>
    <url>/2025/02/10/The-3rd-Ucup-Stage-25-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>对应比赛：The 2024 ICPC Asia Hangzhou Regional Contest</p>
<p>比赛链接：<a href="https://qoj.ac/contest/1893">https://qoj.ac/contest/1893</a></p>
<p>总结：我打的一坨。</p>
<p>开局队友神勇，过了 A,K ，一开始 M 很快意识到一层层搜，只要有解，时间复杂度是 $O(n\log{V})$ 的，无解中途退出就行了，但是不知道怎么处理限制，然后去问队长，队长也不知道，但后面发现可以是 $n*240$ ，其中 $240$ 是 $10^9$ 最多的因子个数，遂流汗，这么出题的。不过这时便初见端倪。</p>
<p>后面队友在写 F ，队长告诉我 H 做法，我再看了 E ，在队友过 F 后我去把这两题写了。</p>
<p>后面开 B ，觉得并不是一个简单题，丢给了数据结构大师。队长告诉了我 J 的大致做法（埋下伏笔），我去写 J 。中途听到 Imakf 说 B 不是线段树就行了吗，虽然浅浅意识到正解应该不是简单的线段树，但是因为在机上，我就什么都没说了，如果在机下的话还是应该和他讨论一下，数据结构题假掉比较麻烦，后面也确实假了一次。</p>
<p>然后伏笔暴雷了，我 J 一开始不想写 $2^m<em>m$ 的状压，就是喜欢复杂度小的做法，所以写的 DFS ，但是好巧不巧的是，这个做法有一个细节想错了，所以是不对的，在写了对拍后，终于在 2:30 意识到问题所在，但因为需要加的部分和原先代码的相性相当差，于是在修正代码的时候就有一种强烈的赤石感，而且由于修正部分有一个高维前缀和，所以最后复杂度还是 $O(2^m</em>m)$，唐完了。所以以后这种题目如果有复杂度大但能过，而且更加好写的做法还是写这种，别为了那一点复杂度专门写个 DFS 恶心自己，大不了 T 了再换，还能顺便攻击一下出题人。如果 DFS 的做法写久了，就只能攻击自己了，而且攻击者大概率不止自己一个人。</p>
<p>终于，1:30 开写，在 3:00 AC，成功将队伍拖向深渊。</p>
<p>然后期间队友会了 B,I ，开写，先过了 I ，队友上去写 B ，在队友写 B 的时候，队长告诉了我 D 的题意和 G 的做法。</p>
<p>我在想了一会 D 后，没什么具象的做法。在队友过了 B 后，我感到大事不妙，G 这坨屎大概得是我吃了。怀着对石的天然厌恶，而且也确实没想好怎么写，我战战兢兢的问了句这个谁写，队长给出了充足的理由让我去写：你已经想了会 D ，没有想出什么东西，所以先让 Imakf 想想。</p>
<p>于是我开了这坨屎。不出所料，卡的我精神恍惚，最终花了一个半小时过了，队友 D 也卡的精神恍惚，无法战胜。</p>
<h1 id="M"><a href="#M" class="headerlink" title="M"></a>M</h1><details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>首先看最小的数字，答案加上最小的数字肯定是其余数字与最小数字差值的最大公约数的因子。</p>
<p>然后每个最小的数字将序列分成若干段，每一段接着做，这样会得到 $n$ 个限制，而且可以知道的是，如果有解，则每个分支的深度至多为 $\log{n}$ ，而 $10^9$ 的因子个数至多为 $240$ ，所以只需要把第一个限制的所有可能答案找到，后面不断 check 就行了。</p>
<p>时间复杂度：$O(n(\log{n}+\log{V}+240)+\sqrt{V})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> !x ? y : <span class="built_in">gcd</span>(y % x, x);&#125;</span><br><span class="line"><span class="type">int</span> n, k, a[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; f; <span class="type">bool</span> type = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= k &amp;&amp; x &gt;= <span class="number">1</span>) f.<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(type &amp;&amp; f.<span class="built_in">empty</span>()) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">// debug(&quot;%d %d : \n&quot;, l, r);</span></span><br><span class="line">    <span class="comment">// debug(&quot;type = %d\n&quot;, type);</span></span><br><span class="line">    <span class="comment">// for(auto x : f) debug(&quot;%d &quot;, x);</span></span><br><span class="line">    <span class="comment">// debug(&quot;\n&quot;);</span></span><br><span class="line">    <span class="type">int</span> minval = <span class="number">1e9</span> + <span class="number">1</span>, d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i++)&#123;</span><br><span class="line">        minval = <span class="built_in">min</span>(minval, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; pos; pos.<span class="built_in">push_back</span>(l - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i++)&#123;</span><br><span class="line">        d = <span class="built_in">gcd</span>(d, a[i] - minval);</span><br><span class="line">        <span class="keyword">if</span>(a[i] == minval) pos.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// debug(&quot;d = %d minval = %d\n&quot;, d, minval);</span></span><br><span class="line">    pos.<span class="built_in">push_back</span>(r + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!d) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!type)&#123;</span><br><span class="line">            type = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= d; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(d % i == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">push</span>(i - minval);</span><br><span class="line">                    <span class="keyword">if</span>(i * i != d) <span class="built_in">push</span>(d / i - minval);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">push</span>(d - minval);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">            <span class="built_in">swap</span>(tmp, f);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x : tmp)&#123;</span><br><span class="line">                <span class="keyword">if</span>(d % (minval + x) == <span class="number">0</span>) <span class="built_in">push</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; pos.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="built_in">solve</span>(pos[i - <span class="number">1</span>] + <span class="number">1</span>, pos[i] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        type = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">swap</span>(tmp, f);</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">        <span class="built_in">solve</span>(<span class="number">1</span>, n);</span><br><span class="line">        <span class="keyword">if</span>(!type)&#123;</span><br><span class="line">            cout &lt;&lt; k &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">1ll</span> * k * (k + <span class="number">1</span>) / <span class="number">2</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            LL ans = <span class="number">0ll</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> x : f) ans += x;</span><br><span class="line">            cout &lt;&lt; f.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="M-1"><a href="#M-1" class="headerlink" title="M"></a>M</h1><details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>由于所有人都是往上走的，不妨假设有人要到最高层，那么答案就是运输距离加上 $f$ 层往上没有被覆盖的层数。</p>
<p>这显然是下界，而构造也很简单，先不断的往上走，走到最高层，然后按照 $r$ 从大到小排序，一个个人运输就行了。</p>
<p>时间复杂度：$O(n\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, f;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r, id;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; f;</span><br><span class="line">    LL ans = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i].l &gt;&gt; a[i].r;</span><br><span class="line">        ans += a[i].r - a[i].l;</span><br><span class="line">        a[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, [](node x, node y)&#123;<span class="keyword">return</span> x.l &lt; y.l;&#125;);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sol, tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].r &gt; f) sol.<span class="built_in">push_back</span>(a[i].id);</span><br><span class="line">        <span class="keyword">else</span> tmp.<span class="built_in">push_back</span>(a[i].id);</span><br><span class="line">        ans += <span class="built_in">max</span>(<span class="number">0</span>, a[i].l - f);</span><br><span class="line">        f = <span class="built_in">max</span>(a[i].r, f);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : sol) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">reverse</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : tmp) cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">work</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>讨论一下就行了，如果最长链只有一条，全挂在最长链顶端，否则，最短链得 $\le$ 最长链链长 $-2$ ，否则显然无解。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, k, a[N];</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cout &lt;&lt; p[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        vector&lt;PII&gt; e;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++)&#123;</span><br><span class="line">            <span class="type">int</span> l, r;</span><br><span class="line">            cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = l + <span class="number">1</span>; j &lt;= r; j++) p[j] = j - <span class="number">1</span>;</span><br><span class="line">            e.<span class="built_in">push_back</span>(&#123;r - l + <span class="number">1</span>, l&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(e.<span class="built_in">begin</span>(), e.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(e.<span class="built_in">begin</span>(), e.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(e.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; e[<span class="number">0</span>].first == e[<span class="number">1</span>].first)&#123;</span><br><span class="line">            <span class="keyword">if</span>(e[<span class="number">0</span>].first - e.<span class="built_in">back</span>().first &lt;= <span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;IMPOSSIBLE\n&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> [len, rt] : e)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(len &gt;= e[<span class="number">0</span>].first - <span class="number">1</span>) p[rt] = e[<span class="number">0</span>].second;</span><br><span class="line">                    <span class="keyword">else</span> p[rt] = e[<span class="number">0</span>].second + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p[e[<span class="number">0</span>].second] = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">print</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> [len, rt] : e) p[rt] = e[<span class="number">0</span>].second;</span><br><span class="line">            p[e[<span class="number">0</span>].second] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">print</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="J"><a href="#J" class="headerlink" title="J"></a>J</h1><p>tag：状压dp</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>考虑左边每种数字是否出现，有 $2^{m}$ 种。</p>
<p>考虑一组限制 $(a,b)$ ，如果左边没有 $a$ ，就会要求左边有 $b$ ，右边有 $a$ ，反之亦然，但是这样的限制不足以合法，因为注意到如果左边有 $a,b$ ，对右边没有限制，或者说有一个很难处理的限制：$a,b$ 至少出现一个。但是其实 $a,b$ 至少出现一个的限制无论左边是什么，右边都有这个限制，因此先用状压 dp 先处理出右边所有的合法情况，在用高维前缀和统计贡献就行了。</p>
<p>时间复杂度：$O(m2^m)$ 。</p>
</div></details>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>tag：线段树</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>首先如果拆位了，那么基本上都会被卡到 $O(n\log{n}\log{V})$ 。</p>
<p>所以要压位，状压处理。一个关键是，我们其实只要知道被删除的位置是哪个，处理出剩下的 and 和是简单的。</p>
<p>又发现，只要处理出是哪个 bit 恰好缺一个，则处理出被删除的位置是哪个是显然的，到这就呼之欲出了。</p>
<p>就是维护三个状态，删除了 $0$ / $1$ / $\ge 2$ 个的 bit ，然后合并是简单的，随便维护一下就行了。</p>
<p>时间复杂度：$O(n\log{n}+n\log{V})$ 。</p>
<p>看了下，队友也是这个思路。</p>
</div></details>
<h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p>tag：基环树</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>做法队友提出的，写起来挺石的。</p>
<p>大体思路就是，先处理出从环上一点出发每个颜色的答案，存在一个 set 里面，然后每次新增一个点，对应颜色见到第 $k$ 次的位置会向前移动，移动到哪个位置是好处理的，然后撤销也是好撤销的，然后就做完了。</p>
<p>时间复杂度：$O(n\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(...) fprintf(stderr, __VA_ARGS__)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, <span class="type">int</span>&gt; PLI;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[N], t[N], n, k;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; son[N]; <span class="type">int</span> v[N];</span><br><span class="line"><span class="type">int</span> col[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; cpos[N]; <span class="type">int</span> pre[N], pos[N], clen;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dis</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="comment">//x -&gt; y</span></span><br><span class="line">    <span class="keyword">if</span>(y &lt;= x) y += clen;</span><br><span class="line">    <span class="keyword">return</span> y - x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PLI rep[N];</span><br><span class="line">set&lt;PLI&gt; s;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; peo;</span><br><span class="line">vector&lt;PLI&gt; stk[N];</span><br><span class="line"><span class="type">int</span> cop[N], dep[N];<span class="comment">//下面的坐标</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; cc[N];</span><br><span class="line"></span><br><span class="line">LL ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> type)</span></span>&#123;</span><br><span class="line">    peo.<span class="built_in">push_back</span>(x);</span><br><span class="line">    cc[t[x]].<span class="built_in">push_back</span>(x);</span><br><span class="line">    cop[x] = cc[t[x]].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!rep[t[x]].second)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cop[x] == k - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> y = cc[t[x]][<span class="number">0</span>];</span><br><span class="line">            s.<span class="built_in">insert</span>(rep[t[x]] = &#123;<span class="number">1ll</span> * dep[y], y&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> [ti, y] = rep[t[x]];</span><br><span class="line">        stk[t[x]].<span class="built_in">push_back</span>(rep[t[x]]);</span><br><span class="line">        <span class="keyword">if</span>(ti &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ti - <span class="built_in">dis</span>(pos[pre[y]], pos[y]) &gt;= <span class="number">0</span>) s.<span class="built_in">insert</span>(rep[t[x]] = &#123;ti - <span class="built_in">dis</span>(pos[pre[y]], pos[y]), pre[y]&#125;);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> z = cc[t[x]][<span class="number">0</span>];</span><br><span class="line">                <span class="comment">// assert(false);</span></span><br><span class="line">                s.<span class="built_in">insert</span>(rep[t[x]] = &#123;<span class="number">1ll</span> * dep[z], z&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> z = cc[t[x]][cop[y] + <span class="number">1</span>];</span><br><span class="line">            s.<span class="built_in">insert</span>(rep[t[x]] = &#123;<span class="number">1ll</span> * dep[z], z&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y : son[x])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[y] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">        dep[y] = dep[x] - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// debug(&quot;ans[%d] = %d\n&quot;, x, (*s.begin()).second);</span></span><br><span class="line">    <span class="built_in">assert</span>(!s.<span class="built_in">empty</span>());</span><br><span class="line">    ans += <span class="number">1ll</span> * x * t[(*s.<span class="built_in">begin</span>()).second];</span><br><span class="line">    <span class="keyword">if</span>(!type)&#123;</span><br><span class="line">        cc[t[x]].<span class="built_in">pop_back</span>();</span><br><span class="line">        s.<span class="built_in">erase</span>(rep[t[x]]);</span><br><span class="line">        rep[t[x]] = &#123;<span class="number">0ll</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(!stk[t[x]].<span class="built_in">empty</span>())&#123;</span><br><span class="line">            s.<span class="built_in">insert</span>(rep[t[x]] = stk[t[x]].<span class="built_in">back</span>());</span><br><span class="line">            stk[t[x]].<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!v[rt])&#123;</span><br><span class="line">        v[rt] = <span class="number">1</span>;</span><br><span class="line">        rt = a[rt];</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; cir;</span><br><span class="line">    <span class="keyword">while</span>(v[rt] != <span class="number">2</span>)&#123;</span><br><span class="line">        v[rt] = <span class="number">2</span>;</span><br><span class="line">        cir.<span class="built_in">push_back</span>(rt);</span><br><span class="line">        pos[rt] = cir.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        cpos[t[rt]].<span class="built_in">push_back</span>(rt);</span><br><span class="line">        rt = a[rt];</span><br><span class="line">    &#125;</span><br><span class="line">    clen = cir.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; cir.<span class="built_in">size</span>() * <span class="number">2</span>; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x = cir[i % cir.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="keyword">if</span>(col[t[x]] &amp;&amp; !pre[x]) pre[x] = col[t[x]];</span><br><span class="line">        col[t[x]] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// debug(&quot;circle : &quot;);</span></span><br><span class="line">    <span class="comment">// for(auto x : cir) debug(&quot;%d &quot;, x);</span></span><br><span class="line">    <span class="comment">// debug(&quot;\n&quot;);</span></span><br><span class="line">    <span class="comment">// for(int i = 0; i &lt; clen; i++) debug(&quot;pre[%d] = %d\n&quot;, cir[i], pre[cir[i]]);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : cir)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == cpos[t[x]][<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="type">int</span> y = (k - <span class="number">1</span>) % cpos[t[x]].<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">int</span> T = (k - <span class="number">1</span>) / cpos[t[x]].<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">int</span> z = cpos[t[x]][y];</span><br><span class="line">            s.<span class="built_in">insert</span>(rep[t[x]] = &#123;<span class="number">1ll</span> * T * clen + pos[z], z&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int j = 1; j &lt;= n; j++)&#123;</span></span><br><span class="line">    <span class="comment">//     if(rep[j].second) debug(&quot;col = %d time = %lld pos = %d\n&quot;, j, rep[j].first, rep[j].second);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = clen - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="comment">// debug(&quot;rt = %d : \n&quot;, cir[i]);</span></span><br><span class="line">        <span class="comment">// for(int j = 1; j &lt;= n; j++)&#123;</span></span><br><span class="line">        <span class="comment">//     if(rep[j].second) debug(&quot;col = %d time = %lld pos = %d\n&quot;, j, rep[j].first, rep[j].second);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        dep[cir[i]] = i - clen;</span><br><span class="line">        <span class="built_in">dfs</span>(cir[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : peo)&#123;</span><br><span class="line">        col[t[x]] = <span class="number">0</span>;</span><br><span class="line">        cpos[t[x]].<span class="built_in">clear</span>();</span><br><span class="line">        rep[t[x]] = &#123;<span class="number">0ll</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        stk[t[x]].<span class="built_in">clear</span>();</span><br><span class="line">        cop[x] = dep[x] = <span class="number">0</span>;</span><br><span class="line">        cc[t[x]].<span class="built_in">clear</span>();</span><br><span class="line">        v[x] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    peo.<span class="built_in">clear</span>(); s.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="comment">// cin.sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">// cin.tie(0);</span></span><br><span class="line">    <span class="type">int</span> T; cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; t[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            son[a[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!v[i]) <span class="built_in">solve</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            son[i].<span class="built_in">clear</span>();</span><br><span class="line">            v[i] = pre[i] = pos[i] = cop[i] = dep[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>tag：Lyndon</p>
<details class="toggle" ><summary class="toggle-button" style="">做法一</summary><div class="toggle-content"><p>注：字符串的严格不等号为去掉前缀的情况。</p>
<p>首先对串进行 Lyndon 分解，现在证明，Lyndon 串一定一起出现在一个串中。</p>
<p>先证明一个引理：</p>
<p><details class="toggle" ><summary class="toggle-button" style="">一个 Lyndon 串的答案就是其本身</summary><div class="toggle-content"><p>递归证明，先假设更短的 Lyndon 串是对的，现在可以知道，一个 Lyndon 串可以写成 $AA…AA’$ 的形式，其中 $A’$ 是 $A$ 的一个前缀加上一个大字母，$A,A’$ 是 Lyndon 串 。</p></p>
<p><p>所以 $A,A’$ 如果拆成两个串，一定会有一个串严格大于原本的串，用这个可以证明所有 $A$ 或者 $A’$ 都应该完整存在，否则一定不优，进而证明这个 Lyndon 串自身就是最好的串。</p><br>&lt;/div&gt;&lt;/details&gt;</p>
<p><p>在证明完这个后，就可以证明以下定理：</p></p>
<p><details class="toggle" style="border: 1px solid T$ ，对于一个 Lyndon 串 $L$，要将其拆分成两个子序列加入到 $S"><summary class="toggle-button" style="background-color: T$ ，对于一个 Lyndon 串 $L$，要将其拆分成两个子序列加入到 $S;color: T$ 末尾使得字典序大的尽可能小，则 Lyndon 串一定完整存在于串中，无论后面还有什么字符串。">现在已经有个串 $S</summary><div class="toggle-content"><p>设 $L=AA…AA’$，后续的串为 $P$ 。根据归纳，可以知道每个 $A$ 和 $A’$ 都是完整放置的，注意这里的归纳比较神秘，$S,T$ 是可以变的，但因为还是有限归纳，所以正确性显然。</p></p>
<p><p>然后，如果 $S=T$ 或者 $S,T$ 之间已经有严格的大小关系，则显然正确，所以不妨设 $T$ 是 $S$ 的真前缀，或者不妨设 $T$ 为空串。</p></p>
<p><p>现在讨论为啥是 $AA…AA’$ 放置。</p></p>
<p><p>如果 $A’$ 放置在 $S$ 后面，则显然 $S$ 后面直接放置 $L+P$，答案显然更小，所以反例只可能是 A’ 在另一边。</p></p>
<p><p>所以讨论 $A’$ 放在 $T$ 后面且有 $A$ 放在 $S$ 的情况，不妨设新的串为 $S’,T’$，设 $T’’=S+L$ 。</p></p>
<p><p>如果 $S$ 严格大于 $T’’$ ，又显然 $max(S’,T’)\ge S$ ，只需要把 $P$ 放置在 $T’’$ 后面就得到更优答案。</p></p>
<p><p>如果 $T’’$ 是 $S$ 前缀，则有 $T’$ 严格大于 $S,T’’$ ，所以也显然不优。</p></p>
<p><p>如果 $T’’&gt;S$ ，则显然 $max(T’’+P,S)=T’’+P&lt;T’&lt;=max(S’,T’)$ ，所以也显然不优。</p></p>
<p><p>综上，$L$ 一定完整存在。</p></p>
<p><p>证毕。</p><br>&lt;/div&gt;&lt;/details&gt;</p>
<p><p>有了这个结论，就知道 Lyndon 分解中每个 Lyndon 串完整存在，那做法就显然了，设 $L_{i}$ 为第 $i$ 个 Lyndon 串。</p></p>
<p><p>将 $L_{2i-1}$ 加入到答案中，如果 $L_{2i-1}=L_{2i}$ 则增大 $i$ 并继续，否则停下来。</p></p>
<p><p>至于原因，就是 Lyndon 分解后的串可以根据大小当成单个字符来对待，对于一个非递增的序列，答案是显然的。</p></p>
<p><p>时间复杂度：$O(n)$ 。</p></p>
<p><p>从上面的证明，可以看到 Lyndon 串有相当良好的递归性质，如果当思考字符串问题的时候，发现这个字符串的答案有一种近似递归的结构，就可以考虑一下答案的结构是不是和 Lyndon 分解有关，血的教训。</p><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, a[N], b[N];</span><br><span class="line"><span class="type">int</span> *ls[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; lyn;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y : x) ans.<span class="built_in">push_back</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        ans.<span class="built_in">clear</span>(); lyn.<span class="built_in">clear</span>();</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            ls[i] = &amp;a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(ls + <span class="number">1</span>, ls + n + <span class="number">1</span>, [](<span class="type">int</span> *x, <span class="type">int</span> *y)&#123;<span class="built_in">return</span> (*x) &lt; (*y);&#125;);</span><br><span class="line">        <span class="type">int</span> pre = m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((*ls[i]) != pre) pre = (*ls[i]), m++, b[m] = pre;</span><br><span class="line">            (*ls[i]) = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= n)&#123;</span><br><span class="line">            <span class="type">int</span> j = i + <span class="number">1</span>, k = i;</span><br><span class="line">            <span class="keyword">while</span>(j &lt;= n &amp;&amp; a[k] &lt;= a[j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(a[k] &lt; a[j]) k = i;</span><br><span class="line">                <span class="keyword">else</span> k++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i &lt;= k)&#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> t = i; t &lt; i + j - k; t++) tmp.<span class="built_in">push_back</span>(a[t]);</span><br><span class="line">                lyn.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                i += j - k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//[i,i+j-k)即为对应的Lyndon分解 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(auto v : lyn)&#123;</span></span><br><span class="line">        <span class="comment">//     for(auto x : v) cout &lt;&lt; x &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="built_in">reverse</span>(lyn.<span class="built_in">begin</span>(), lyn.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span>(!lyn.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(lyn.<span class="built_in">size</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">add</span>(lyn.<span class="built_in">back</span>());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> x = lyn.<span class="built_in">back</span>(); lyn.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">auto</span> y = lyn.<span class="built_in">back</span>(); lyn.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="built_in">add</span>(x);</span><br><span class="line">            <span class="keyword">if</span>(x != y) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x : ans) cout &lt;&lt; b[x] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>The 3rd Ucup Stage 2: E. Pattern Search II</title>
    <url>/2024/06/27/The-3rd-Ucup-Stage-2-E-Pattern-Search-II/</url>
    <content><![CDATA[<p>题目链接：<a href="https://contest.ucup.ac/contest/1699/problem/8521">https://contest.ucup.ac/contest/1699/problem/8521</a></p>
<p>题目大意：略。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>很有意思的 dp ，如果一开始想对了方向就会很简单，但是一旦一开始想错了方向，就会花很多时间了。</p>
<p>$fl[i][j]/fr[i][j]$ 表示的是从 $S_{i}$ 左边往右边/右边往左边匹配 $T$ 的从 $j$ 开始的前缀/后缀能匹配都多少，如果能完整匹配就记录所需的最短长度。</p>
<p>转移是显然的，记录答案的时候需要注意，由于 $fl,fr$ 只能记录 $S$ 前缀或者后缀的最小值，而如果我们想要知道 $S$ 内部的答案，就需要枚举。</p>
<p>注意到若答案在 $S_i$ 内部，我们先把 $S_i$ 用 $S_{i-1},S_{i-2}$ 表示，答案要么还在里面，要么横跨两个串，即不断下去，答案一定可以跨过：$S_{i}S_{j}(|i-j|\le 1)$ ，或者答案的长度为 $1$ 。</p>
<p>但问题来了，我们要枚举 $i$ 到什么地步为止？</p>
<p>我们设 $t$ 表示最小的 $t$ 满足 $S_{t}\ge 3n$ （不难证明，不会有连续三个 $a$ ，连续两个 $b$，所以当 $S_{t}\ge 3n$ 时，$T$ 一定是其子序列）</p>
<p>因此如果把字符串表示成 $S_{t},S_{t+1}$ 的组合，答案一定不会跨过三个字符串，所以 $i\le t+1$ 就行了。</p>
<p>时间复杂度：$O(n\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L = <span class="number">40</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">strlen</span>(ss) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// left to right</span></span><br><span class="line"><span class="comment">// right to left</span></span><br><span class="line"><span class="type">int</span> dp[L][<span class="number">2</span>][N];<span class="comment">//&gt;=0 num &lt;0 len</span></span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> n, f[L];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st);</span><br><span class="line">    n = <span class="built_in">strlen</span>(st + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span> &amp;&amp; st[<span class="number">1</span>] == <span class="string">&#x27;a&#x27;</span> &amp;&amp; st[<span class="number">2</span>] == <span class="string">&#x27;b&#x27;</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    只要第一次满足匹配的 t &gt;= 3 就可以在下面求出答案，所以对 t=0,1,2 特判。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i] == <span class="string">&#x27;a&#x27;</span>) dp[<span class="number">1</span>][<span class="number">0</span>][i] = dp[<span class="number">1</span>][<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(st[i] == <span class="string">&#x27;b&#x27;</span>) dp[<span class="number">0</span>][<span class="number">0</span>][i] = dp[<span class="number">0</span>][<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt;= <span class="number">1</span>; t++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i + dp[t][<span class="number">0</span>][i] == n + <span class="number">1</span>) dp[t][<span class="number">0</span>][i] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i - dp[t][<span class="number">1</span>][i] == <span class="number">0</span>) dp[t][<span class="number">1</span>][i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">2</span>; ; t++)&#123;</span><br><span class="line">        f[t] = f[t - <span class="number">1</span>] + f[t - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[t - <span class="number">1</span>][<span class="number">0</span>][i] &lt; <span class="number">0</span>) dp[t][<span class="number">0</span>][i] = dp[t - <span class="number">1</span>][<span class="number">0</span>][i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> j = i + dp[t - <span class="number">1</span>][<span class="number">0</span>][i];</span><br><span class="line">                <span class="keyword">if</span>(dp[t - <span class="number">2</span>][<span class="number">0</span>][j] &lt; <span class="number">0</span>) dp[t][<span class="number">0</span>][i] = dp[t - <span class="number">2</span>][<span class="number">0</span>][j] - f[t - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[t][<span class="number">0</span>][i] = dp[t - <span class="number">2</span>][<span class="number">0</span>][j] + dp[t - <span class="number">1</span>][<span class="number">0</span>][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[t - <span class="number">2</span>][<span class="number">1</span>][i] &lt; <span class="number">0</span>) dp[t][<span class="number">1</span>][i] = dp[t - <span class="number">2</span>][<span class="number">1</span>][i];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> j = i - dp[t - <span class="number">2</span>][<span class="number">1</span>][i];</span><br><span class="line">                <span class="keyword">if</span>(dp[t - <span class="number">1</span>][<span class="number">1</span>][j] &lt; <span class="number">0</span>) dp[t][<span class="number">1</span>][i] = dp[t - <span class="number">1</span>][<span class="number">1</span>][j] - f[t - <span class="number">2</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[t][<span class="number">1</span>][i] = dp[t - <span class="number">1</span>][<span class="number">1</span>][j] + dp[t - <span class="number">2</span>][<span class="number">1</span>][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[t][<span class="number">1</span>][i] &lt; <span class="number">0</span> &amp;&amp; dp[t - <span class="number">1</span>][<span class="number">0</span>][i + <span class="number">1</span>] &lt; <span class="number">0</span>) ans = <span class="built_in">max</span>(ans, dp[t][<span class="number">1</span>][i] + dp[t - <span class="number">1</span>][<span class="number">0</span>][i + <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(dp[t][<span class="number">1</span>][i] &lt; <span class="number">0</span> &amp;&amp; dp[t][<span class="number">0</span>][i + <span class="number">1</span>] &lt; <span class="number">0</span>) ans = <span class="built_in">max</span>(ans, dp[t][<span class="number">1</span>][i] + dp[t][<span class="number">0</span>][i + <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(dp[t - <span class="number">1</span>][<span class="number">1</span>][i] &lt; <span class="number">0</span> &amp;&amp; dp[t][<span class="number">0</span>][i + <span class="number">1</span>] &lt; <span class="number">0</span>) ans = <span class="built_in">max</span>(ans, dp[t - <span class="number">1</span>][<span class="number">1</span>][i] + dp[t][<span class="number">0</span>][i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f[t - <span class="number">1</span>] &gt;= n * <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="built_in">assert</span>(dp[t - <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>] &lt; <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; -ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><details class="toggle" ><summary class="toggle-button" style="">当时想题时记录的一些性质</summary><div class="toggle-content"><p>注意放 $a(0)$ 还是 $b(1)$ 可以用下面的方法生成：</p></p>
<p>初始有个全 $0$ 的串，每次在最左边放 $1$ ，然后没有相邻两个 $1$ ，就删掉向右边进 $1$ ，即每个 $1$ 分别表示：$1,2,3,5,…$ 。</p>
<p>然后第一个是 $0/1$ 代表了是放 $a$ 还是 $b$ 。</p>
<ol>
<li><p>1…. 后面一定是 b。</p>
</li>
<li><p>不会有aaa…. ，与下面同理，1… 的结构在两次 aa 后一定会生成</p>
</li>
<li><p>不会有连续三个 aa ：</p>
</li>
</ol>
<p>0100000000….   b<br>0010000000….   a<br>1010000000….   a<br>0001000000….   b<br>1001000000….   a<br>0101000000….   b</p>
<p>0000100000….   b<br>0000100000….   a<br>1000100000….   a<br>0100100000….   b<br>0010100000….   a<br>1010100000….   a<br>0000010000….   b<br>1000010000….   a<br>0100010000….   b</p>
<p>0101010000….   b<br>0000001000….   a<br>1000001000….   a<br>0100001000….   b<br>0010001000….   a<br>1010001000….   a<br>0001001000….   b<br>1000001000….   a<br>0100001000….   b</p>
<p>逻辑，当 001 这种结构生成的时候，接下来一定会是：abab 的形式。</p>
<p>而这种结构两次一定会生成成功。</p>
<ol>
<li><p>不会有连续三个 ab ，同样的逻辑，当 01 生成时，接下来一定是：aa，同理一定会生成。</p>
</li>
<li><p>综上，任何一个前缀在两次经过后一定会生成。</p>
</li>
<li><p>一定不会有连续两个 ab ，逻辑：研究 babab 的结构，发现一开始必须是 001 ，矛盾。</p>
</li>
</ol>
</div></details>
<p>感觉这个 $dp$ 非常的有意思，用 $dp$ 来完成了匹配，感觉以前没有见过。</p>
<p>和官方做法基本一致，在此不再赘述。</p></div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>The 3rd Ucup Stage 29 赛后总结</title>
    <url>/2025/02/09/The-3rd-Ucup-Stage-29-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接：<a href="https://qoj.ac/contest/1913">https://qoj.ac/contest/1913</a></p>
<p>这场比赛的签到感觉没啥问题，也许？如果说英语水平算问题的话，那我确实读题太慢了，最需要训练的人是你呀。而且某人在队长说完之后还 WA 了一发 C 确实有点铸币了。</p>
<p>然后后面就陆陆续续的做各种题，队友在牢 B ，我发现 C 是 SB 就开写了。</p>
<p>然后等 C 过了后，队友因为有事离开，队长开始赤队友没做完的石，开始重复对吗？对的。真对吗？好像是对的的话<del>就在我庆幸牢的不是我的时候，一个小时后回旋镖击中了我</del>。</p>
<p>接着发现 G 也是 SB 后接着写，过了 G 以后开 D ，感觉也不难，就直接开了。一个小时过了 D ，一个半小时过了 B 。</p>
<p>写完 D 后开 E ，其实 E 如果逐步推进结论就会发现结论挺显然的，但是我一开始结论猜偏了，猜了一个等价但是繁琐很多的命题，等到后面代码写到一半了才发现了更加简单的命题，虽然实现上没变化，但是从繁琐的结论开始想实现方式还是花了不少时间，半年没打熟练度下降好快<del>果然最该训练的人是你呀</del>。</p>
<p>正常情况下这个时候应该要找队长反馈情况了，毕竟赛时知道结论后，想怎么写想了这么久有点抽象了，但是队长在牢 B ，悲，果然队伍还是要有人统领全局。（感觉我确实代码实现能力不太行，赛时如果不知道怎么写还是应该及时问队友，总之不会问队友就行了，队友总能解决的）</p>
<p>然后慢悠悠的写 E ，两个小时过了，不得不说，现在写代码速度也好慢，在学会 vim 后会快一点吗？不过制约我打字速度的真不是因为铸币脑子吗？</p>
<p>然后就是讨论 J ，虽然很不想写这坨屎，但是数据结构大师不在，显然只能我吃了，前面写个扫描线，后面的部分还好可以用树状数组 + DFS 序避免树链剖分，但依旧写了一个小时，在 2:40 的时候调完扫描线，因为线段树建树时没有给左右儿子赋值的幽默错误，甚至队长还感叹一句：“我还以为你写完了，原来才刚建完树”。中大半小时写完是什么怪物啊。</p>
<p>然后就是讨论 F ，说句实话，一开始就知道是半在线 NTT 了，不过一直不相信罢了，我是真不信会有人放一道裸半在线 NTT 在赛场啊。</p>
<p>然后因为各种原因，不信是半在线 NTT ，所以在想有没有可能有别的做法；然后主观上不太想写多项式，一直拖着；然后一开始的 dp 转移式我以为是 4 个半在线 NTT；最后有个除法，万一写完后分母是 0 就 see you again 了。虽然在正赛上肯定得写，就算是分母可能为 0 也得写，赛场上想不出正解不是大事，没 AC 才是大事。</p>
<p>拖拉到一个小时，队长可能也看出来我怠工了，拉我去讨论他的 M ，可惜我并不会圆反演，在提出了几个观点后就接着想 F 去了。</p>
<p>然后拖拉到最后四十分钟，终于准备写了，队友也复活了，队友去处理队长的 M ，我在具体写 dp 式子。（是的，我前面的转移式都仅仅是存在于脑子里面，细节什么的都还没想）</p>
<p>然后不喜欢动笔的习惯发力了，因为做题长时间不动笔，导致遇到这种需要动笔写转移式的题就猪脑过载，写了一半发现可以变成两个半在线 NTT ，然后接着搁那列式，思考这个转化的组合意义（我的习惯，思考明白组合意义能让我对这个转移式的正确性更有把握一点），然后过载着过载着就只剩下十分钟了，然后来不及写，直接暴寄，最后一看做法是半在线 NTT ，真放板在比赛里面啊，不是。</p>
<p>不过过载半小时没写出 dp 转移式也是真神人了，确实需要练习吧。怎么练习呢？平时做 dp 题之前能不能把 dp 转移式先在纸上写出来，然后争取一遍写对啊。</p>
<p>队友的 M 大战了许久之后没过，赛后发现不用圆反演，遂小丑。我感觉我在这道题目的问题就是我只是在听他们的做法，我并没有自己想想有没有别的简单搞法，方便最后如果过不去的话，能给队友提供多一些乱搞的选择，不过鉴于那时队友做法成型，我手里也有 F ，其实这个行为的优先级并不高。不过正赛肯定要这么干了，因为最后一小时肯定先保队长这个已经写完的题，F 肯定就丢掉了，不存在我手里还有 F 的说法。</p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>tag：博弈</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>注意到每个人接触到的数字的奇偶性相同，又注意到奇数只会被接触奇数的人删除就知道做法了，接下来就只需要讨论了。</p>
<p>怎么注意到的？我也想知道，队长做出来的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="type">int</span> type = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((r - l + <span class="number">1</span>) &amp; <span class="number">1</span>) type = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">2</span> * l &lt;= r) type = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> type = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>((r - l + <span class="number">1</span>) &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">2</span> * (l + <span class="number">1</span>) &lt;= r) type = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> type = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> type = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(type != <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(!type) cout &lt;&lt; <span class="string">&quot;Alice\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Bob\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p>tag：二分</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>二分答案，然后每个线段能匹配的是一段前驱或者后继，随便贪心的匹配一下就行了。</p>
<p>时间复杂度：$O(n\log{V}\log{n})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">LL a[N], b[N], c[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(LL val)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; l;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            LL pos = <span class="built_in">floor</span>((<span class="number">1.0L</span> * val - b[i]) / a[i]);</span><br><span class="line">            <span class="type">int</span> p = <span class="built_in">upper_bound</span>(c + <span class="number">1</span>, c + n + <span class="number">1</span>, pos) - c - <span class="number">1</span>;</span><br><span class="line">            l.<span class="built_in">push_back</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            LL pos = <span class="built_in">ceil</span>((<span class="number">1.0L</span> * val - b[i]) / a[i]);</span><br><span class="line">            <span class="type">int</span> p = <span class="built_in">lower_bound</span>(c + <span class="number">1</span>, c + n + <span class="number">1</span>, pos) - c;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; pos &lt;&lt; &quot; &quot; &lt;&lt; p &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">            r.<span class="built_in">push_back</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b[i] &gt;= val)&#123;</span><br><span class="line">            l.<span class="built_in">push_back</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(r.<span class="built_in">begin</span>(), r.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(r.<span class="built_in">begin</span>(), r.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> cntl = <span class="number">0</span>, cntr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : l)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cntl &lt; x) cntl++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x : r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n - cntr + <span class="number">1</span> &gt; x) cntr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cntl + cntr &gt;= (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    cin.<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> T; cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; b[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; c[i];</span><br><span class="line">        <span class="built_in">sort</span>(c + <span class="number">1</span>, c + n + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; pd(114614) &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">        LL l = <span class="number">-2e18</span>, r = <span class="number">2e18</span>, mid, ans = <span class="number">-3e18</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">pd</span>(mid)) l = mid + <span class="number">1</span>, ans = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>WA 了一发，踩了一点小坑。</p>
<p>可以看到，难点在于无法拿走最后两堆的石头，所以如何将这两堆石头移出来是很关键的问题。</p>
<p>首先注意到一个事情是一个几乎连续的 $1$ 序列可以展开或者收起，即变成 10101… 或者 1111… 。</p>
<p>同时也可以中间的先拿完然后接着收起，即：1111… 变成 1011… 变成 111… 。</p>
<p>所以可以知道第一个结论，如果最后两个位置所在的几乎连续的 1 序列能够将其拉出最后两个位置，就一定可以，即左端点 $\le n-4$ ，同理，如果最后两个位置只有一个 $1$ 就是 $\le n-3$ 。</p>
<p>注意，这里所在的几乎连续的 1 序列是看展开后能不能接到一起，例如下面就是一个 1 序列：1110001 。</p>
<p>然后显然如果最后两个位置有石子且左端点在 $\ge n-2$ 的位置则显然无解。</p>
<p>则关键要讨论最后两堆都有石头且左端点 $=n-3$ 的情况，即：</p>
<p>1011 和 1111 。</p>
<p>1011 ：先操作 1 位置再操作 2 再操作 1，这样局面是 1110 且第 $2$ 堆为偶数，不断操作就可以变成 1010 ，可行。</p>
<p>1111 ：先操作掉第 2 堆石头，所以可行。</p>
<p>所以实际实际上是 $\le n-3$ 就可行。</p>
<p>时间复杂度：$O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(ss) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">get_char_array</span>(st);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(st[n] == <span class="string">&#x27;1&#x27;</span>) cnt++;</span><br><span class="line">    <span class="keyword">if</span>(st[n - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) cnt++;</span><br><span class="line">    <span class="keyword">if</span>(!cnt) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> f = n + <span class="number">1</span>, c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        c++;</span><br><span class="line">        <span class="keyword">if</span>(st[i] == <span class="string">&#x27;1&#x27;</span>) c -= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(c &lt;= <span class="number">0</span>) f = i, c = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f &lt;= n - <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">work</span>()) cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>这种所有环的题优先关注 DFS 树上只包含一条非树边的环，不妨记这些环为特殊环。</p>
<p>首先所有特殊环的长度一定要一样，其次，可以想到，必要条件是相交的两个特殊环得到的一个环的长度也得一样。</p>
<p>所以可以得到特殊环的交一定得是环长一半，即 $\frac{len}{2}$。</p>
<p>而特殊环在树上只有 $len-1$ 的长度，故如果一个特殊环和两个特殊环有交，可以得到有交部分一定相交，进而可以得到相交部分是同一部分。</p>
<p>进而可以得到充要条件：特殊环等长，相交的特殊环相交于同一部分且相交部分为 $\frac{len}{2}$ 。</p>
<p>实现上，可以发现，如果得到环的相交部分，是通过在 DFS 树上每个点处以合并的方式处理的话，则只需要关心每个环最浅的节点的深度是多少。</p>
<p>所以每个点只需要维护子树到祖先的简单环中每个环最浅节点的深度，而且类似于上面结论的证明可以得到不同的深度不会超过 $2$ 个。</p>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y, next;</span><br><span class="line">&#125;a[N * <span class="number">2</span>]; <span class="type">int</span> cnt, las[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;a[++cnt] = &#123;y, las[x]&#125;; las[x] = cnt;&#125;</span><br><span class="line"><span class="type">int</span> n, m, len;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; pa[N], son[N];</span><br><span class="line"><span class="type">int</span> dep[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">findcir</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = las[x]; k; k = a[k].next)&#123;</span><br><span class="line">        <span class="type">int</span> y = a[k].y;</span><br><span class="line">        <span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!dep[y])&#123;</span><br><span class="line">            dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">            son[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">findcir</span>(y, x)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(dep[y] &lt; dep[x])&#123;</span><br><span class="line">            <span class="type">int</span> tmp = dep[x] - dep[y] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!len) len = tmp;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(len != tmp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            pa[x].<span class="built_in">push_back</span>(dep[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">itc</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy, <span class="type">int</span> dt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(len &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">assert</span>(dx &lt; dt &amp;&amp; dy &lt; dt);</span><br><span class="line">    <span class="keyword">return</span> dt - <span class="built_in">max</span>(dx, dy) == len / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y : son[x])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">check</span>(y)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d1 : pa[x])&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> d2 : pa[y])&#123;</span><br><span class="line">                <span class="comment">// cerr &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; d1 &lt;&lt; &quot; &quot; &lt;&lt; d2 &lt;&lt; &quot; &quot; &lt;&lt; dep[x] &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">itc</span>(d1, d2, dep[x])) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d : pa[y]) pa[x].<span class="built_in">push_back</span>(d);</span><br><span class="line">        <span class="built_in">sort</span>(pa[x].<span class="built_in">begin</span>(), pa[x].<span class="built_in">end</span>());</span><br><span class="line">        pa[x].<span class="built_in">erase</span>(<span class="built_in">unique</span>(pa[x].<span class="built_in">begin</span>(), pa[x].<span class="built_in">end</span>()), pa[x].<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">assert</span>(pa[x].<span class="built_in">size</span>() &lt;= <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!pa[x].<span class="built_in">empty</span>() &amp;&amp; dep[x] == pa[x].<span class="built_in">back</span>() + <span class="number">1</span>) pa[x].<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="built_in">ins</span>(x, y);</span><br><span class="line">        <span class="built_in">ins</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    dep[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">findcir</span>(<span class="number">1</span>, <span class="number">0</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!len) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">assert</span>(pa[i].<span class="built_in">size</span>() &lt;= <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">check</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cerr &lt;&lt; i &lt;&lt; <span class="string">&quot; : \n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> d : pa[i]) cerr &lt;&lt; d &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cnt = len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        las[i] = dep[i] = <span class="number">0</span>;</span><br><span class="line">        pa[i].<span class="built_in">clear</span>();</span><br><span class="line">        son[i].<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">work</span>()) cout &lt;&lt; <span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">        <span class="comment">// print();</span></span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在比赛时得到的结论要多一句：且两个环间相交的部分之间不会产生不相等且相交的关系，但实际上多想一下就知道这句话是多于的，根据 $\frac{len}{2}+\frac{len}{2}&gt;len-1$ 可以知道，如果这个特殊环有两个不同的相交部分，则这两个部分一定相交。会多这一句话是真有点糖了，好久不训练导致的<del>虽然可能以前也这么糖</del>。</p>
</div></details>
<h1 id="J"><a href="#J" class="headerlink" title="J"></a>J</h1><p>tag：扫描线，线段树</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>首先前面部分建树，我用的扫描线，后面部分维护虚树大小，怎么写都行，可以树剖，可以线段树维护虚数形态啥的，但是这里介绍一个维护虚数的技巧。</p>
<p>对于一堆点，其虚树大小（包括链上的点，不止有 LCA） ，可以按照 DFS 序排序，然后相邻两个点的距离和就是虚树大小的两倍 $-2$ ，而这里类似，只不过相邻两个点之间对答案不是简单的和的贡献，可以看成对深度的区间加的操作，用线段树维护一下就行了。</p>
<p>时间复杂度：$O(n\log{n})$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SN = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> n, q, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; son[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span>&#123;</span><br><span class="line">    <span class="type">int</span> xl, xr, yl, yr;</span><br><span class="line">&#125;a[N]; <span class="type">int</span> *ls[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">namespace</span> Tree&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Query</span>&#123;</span><br><span class="line">        <span class="type">int</span> l, r, pos, type;</span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;Query&gt; q;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">        <span class="type">int</span> lc, rc;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    &#125;tr[N * <span class="number">4</span>]; <span class="type">int</span> cnt;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bt</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> x = ++cnt;</span><br><span class="line">        tr[x].stk.<span class="built_in">clear</span>();</span><br><span class="line">        tr[x].lc = tr[x].rc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            tr[x].lc = <span class="built_in">bt</span>(l, mid);</span><br><span class="line">            tr[x].rc = <span class="built_in">bt</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ll, <span class="type">int</span> rr, <span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rr &lt; l || ll &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ll &lt;= l &amp;&amp; r &lt;= rr)&#123;</span><br><span class="line">            <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(!tr[x].stk.<span class="built_in">empty</span>()) ans = tr[x].stk.<span class="built_in">back</span>();</span><br><span class="line">            tr[x].stk.<span class="built_in">push_back</span>(id);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> al = <span class="built_in">add</span>(tr[x].lc, l, mid, ll, rr, id);</span><br><span class="line">        <span class="type">int</span> ar = <span class="built_in">add</span>(tr[x].rc, mid + <span class="number">1</span>, r, ll, rr, id);</span><br><span class="line">        <span class="built_in">assert</span>(!al || !ar || al == ar);</span><br><span class="line">        <span class="keyword">if</span>(!al &amp;&amp; !ar &amp;&amp; !tr[x].stk.<span class="built_in">empty</span>()) al = tr[x].stk.<span class="built_in">back</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(al, ar);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ll, <span class="type">int</span> rr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rr &lt; l || ll &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(ll &lt;= l &amp;&amp; r &lt;= rr)&#123;</span><br><span class="line">            <span class="built_in">assert</span>(!tr[x].stk.<span class="built_in">empty</span>());</span><br><span class="line">            <span class="type">int</span> ans = tr[x].stk.<span class="built_in">back</span>();</span><br><span class="line">            tr[x].stk.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> al = <span class="built_in">del</span>(tr[x].lc, l, mid, ll, rr);</span><br><span class="line">        <span class="type">int</span> ar = <span class="built_in">del</span>(tr[x].rc, mid + <span class="number">1</span>, r, ll, rr);</span><br><span class="line">        <span class="built_in">assert</span>(!al || !ar || al == ar);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(al, ar);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            q.<span class="built_in">push_back</span>(&#123;a[i].yl, a[i].yr, a[i].xl, i&#125;);</span><br><span class="line">            q.<span class="built_in">push_back</span>(&#123;a[i].yl, a[i].yr, a[i].xr, -i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(q.<span class="built_in">begin</span>(), q.<span class="built_in">end</span>(), [](Query x, Query y)&#123;<span class="keyword">return</span> x.pos &lt; y.pos;&#125;);</span><br><span class="line">        <span class="built_in">bt</span>(<span class="number">1</span>, m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [l, r, p, t] : q)&#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; &quot; &quot; &lt;&lt; p &lt;&lt; &quot; &quot; &lt;&lt; t &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">            <span class="comment">// for(int i = 1; i &lt;= cnt; i++)&#123;</span></span><br><span class="line">            <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot; :&quot;;</span></span><br><span class="line">            <span class="comment">//     for(auto x : tr[i].stk) cout &lt;&lt; &quot; &quot; &lt;&lt; x;</span></span><br><span class="line">            <span class="comment">//     cout &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="keyword">if</span>(t &gt; <span class="number">0</span>) son[<span class="built_in">add</span>(<span class="number">1</span>, <span class="number">1</span>, m, l, r, t)].<span class="built_in">push_back</span>(t);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">del</span>(<span class="number">1</span>, <span class="number">1</span>, m, l, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Segment&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">        LL bst[N];</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(x &lt;= n)&#123;</span><br><span class="line">                bst[x] += k;</span><br><span class="line">                x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">LL <span class="title">findans</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">            x = <span class="built_in">min</span>(x, n);</span><br><span class="line">            LL ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x)&#123;</span><br><span class="line">                ans += bst[x];</span><br><span class="line">                x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;ti, t1;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        ti.<span class="built_in">change</span>(x, <span class="number">1ll</span> * x * k);</span><br><span class="line">        t1.<span class="built_in">change</span>(x, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findans</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1ll</span> * (x + <span class="number">1</span>) * t1.<span class="built_in">findans</span>(x) - ti.<span class="built_in">findans</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modif</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    Segment::<span class="built_in">change</span>(l, k);</span><br><span class="line">    Segment::<span class="built_in">change</span>(r + <span class="number">1</span>, -k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dep[N], dfn[N], stk[N], ti;</span><br><span class="line"><span class="type">int</span> fa[N][SN];</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    dfn[x] = ++ti; stk[ti] = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; SN; i++) fa[x][i] = fa[fa[x][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y : son[x])&#123;</span><br><span class="line">        dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">        fa[y][<span class="number">0</span>] = x;</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findlca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &gt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = SN - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="number">1</span> &lt;&lt; i) &lt;= dep[y] - dep[x]) y = fa[y][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = SN - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> state[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifpath</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> lca = <span class="built_in">findlca</span>(x, y);</span><br><span class="line">    <span class="built_in">modif</span>(dep[lca] + <span class="number">1</span>, dep[x], val);</span><br><span class="line">    <span class="built_in">modif</span>(dep[lca] + <span class="number">1</span>, dep[y], val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i].xl &gt;&gt; a[i].yl &gt;&gt; a[i].xr &gt;&gt; a[i].yr;</span><br><span class="line">        ls[i * <span class="number">2</span> - <span class="number">1</span>] = &amp;a[i].yl;</span><br><span class="line">        ls[i * <span class="number">2</span>] = &amp;a[i].yr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(ls + <span class="number">1</span>, ls + n * <span class="number">2</span> + <span class="number">1</span>, [](<span class="type">int</span> *x, <span class="type">int</span> *y)&#123;<span class="built_in">return</span> (*x) &lt; (*y);&#125;);</span><br><span class="line">    <span class="type">int</span> pre = (*ls[<span class="number">1</span>]) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((*ls[i]) != pre) pre = (*ls[i]), m++;</span><br><span class="line">        (*ls[i]) = m;</span><br><span class="line">    &#125;</span><br><span class="line">    Tree::<span class="built_in">build</span>();</span><br><span class="line">    <span class="comment">// for(int i = 0; i &lt;= n; i++)&#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot; : &quot;;</span></span><br><span class="line">    <span class="comment">//     for(auto x : son[i]) cout &lt;&lt; x &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(ti == n + <span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="number">1</span>); s.<span class="built_in">insert</span>(n + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123; </span><br><span class="line">        <span class="type">char</span> tmp[<span class="number">10</span>]; <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; tmp &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span>(tmp[<span class="number">0</span>] == <span class="string">&#x27;^&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> prev = stk[*(--s.<span class="built_in">lower_bound</span>(dfn[x]))];</span><br><span class="line">            <span class="type">int</span> nexv = stk[*(s.<span class="built_in">upper_bound</span>(dfn[x]))];</span><br><span class="line">            <span class="type">int</span> val = <span class="number">-1</span>; <span class="keyword">if</span>(state[x]) val = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">modifpath</span>(prev, nexv, val);</span><br><span class="line">            <span class="built_in">modifpath</span>(prev, x, -val);</span><br><span class="line">            <span class="built_in">modifpath</span>(nexv, x, -val);</span><br><span class="line">            <span class="keyword">if</span>(!state[x]) s.<span class="built_in">insert</span>(dfn[x]);</span><br><span class="line">            <span class="keyword">else</span> s.<span class="built_in">erase</span>(dfn[x]);</span><br><span class="line">            state[x] ^= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> ans = Segment::<span class="built_in">findans</span>(x + <span class="number">1</span>) - Segment::<span class="built_in">findans</span>(x);</span><br><span class="line">            <span class="built_in">assert</span>(ans % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">            cout &lt;&lt; ans / <span class="number">2</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p>tag：NTT</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>就半在线卷积啊，很典的板子。</p>
<p>设 $f[i]$ 表示长度为 $i$ 不能分段的排列有多少个，$g[i]$ 表示长度为 $i$ 的段如果不能分段，就 shuffle ，可以分段就分段的答案（差不多定义，但是有些细节），然后转移就行了，两次半在线。</p>
<p>时间复杂度：$O(n\log^2{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">int</span>&gt; poly;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function">LL <span class="title">ksm</span><span class="params">(LL x, LL y)</span></span>&#123;</span><br><span class="line">    LL ans = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ans = ans * x % mod;</span><br><span class="line">        x = x * x % mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">poly omega[<span class="number">25</span>]; <span class="comment">// 单位根</span></span><br><span class="line"><span class="comment">// n 是 DFT 的最大长度，例如如果最多有两个长为 m 的多项式相乘，</span></span><br><span class="line"><span class="comment">// 或者求逆的长度为 m，那么 n 需要 &gt;= 2m</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ntt_init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="comment">// n = 2^k</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">2</span>, d = <span class="number">0</span>; k &lt;= n; k *= <span class="number">2</span>, d++) &#123;</span><br><span class="line">		omega[d].<span class="built_in">resize</span>(k + <span class="number">1</span>);</span><br><span class="line">		<span class="type">int</span> wn = <span class="built_in">ksm</span>(<span class="number">3</span>, (mod - <span class="number">1</span>) / k), tmp = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123; omega[d][i] = tmp;</span><br><span class="line">			tmp = (LL)tmp * wn % mod; &#125; &#125; &#125;</span><br><span class="line"><span class="comment">// 传入的数必须是 [0, p) 范围内，不能有负的</span></span><br><span class="line"><span class="comment">// 否则把 d == 16 改成 d % 8 == 0 之类，多取几次模</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ntt</span><span class="params">(<span class="type">int</span> *c, <span class="type">int</span> n, <span class="type">int</span> tp)</span> </span>&#123;</span><br><span class="line">	<span class="type">static</span> ULL a[N];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) a[i] = c[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="type">int</span> k = n; <span class="keyword">do</span> j ^= (k &gt;&gt;= <span class="number">1</span>); <span class="keyword">while</span> (j &lt; k);</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(a[i], a[j]); &#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>, d = <span class="number">0</span>; k &lt; n; k *= <span class="number">2</span>, d++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (d == <span class="number">16</span>) <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) a[i] %= mod;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += k * <span class="number">2</span>)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">				<span class="type">int</span> w = omega[d][tp &gt; <span class="number">0</span> ? j : k * <span class="number">2</span> - j];</span><br><span class="line">				ULL u = a[i + j], v = w * a[i + j + k] % mod;</span><br><span class="line">				a[i + j] = u + v;</span><br><span class="line">				a[i + j + k] = u - v + mod; &#125; &#125;</span><br><span class="line">	<span class="keyword">if</span> (tp&gt;<span class="number">0</span>) &#123;<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) c[i] = a[i] % mod;&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="type">int</span> inv = <span class="built_in">ksm</span>(n, mod - <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) c[i] = a[i] * inv % mod;&#125;&#125;</span><br><span class="line"><span class="function">poly <span class="title">poly_auto_mul</span><span class="params">(poly a, poly b)</span> </span>&#123; <span class="comment">// 自动判断长度的乘法</span></span><br><span class="line">	<span class="type">int</span> res_len = (<span class="type">int</span>)a.<span class="built_in">size</span>() + (<span class="type">int</span>)b.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> ntt_n = <span class="number">1</span>; <span class="keyword">while</span> (ntt_n &lt; res_len) ntt_n *= <span class="number">2</span>;</span><br><span class="line">	a.<span class="built_in">resize</span>(ntt_n); b.<span class="built_in">resize</span>(ntt_n);</span><br><span class="line">	<span class="built_in">ntt</span>(a.<span class="built_in">data</span>(), ntt_n, <span class="number">1</span>); <span class="built_in">ntt</span>(b.<span class="built_in">data</span>(), ntt_n, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ntt_n; i++)</span><br><span class="line">		a[i] = (LL)a[i] * b[i] % mod;</span><br><span class="line">	<span class="built_in">ntt</span>(a.<span class="built_in">data</span>(), ntt_n, <span class="number">-1</span>); a.<span class="built_in">resize</span>(res_len); <span class="keyword">return</span> a; &#125;</span><br><span class="line"><span class="type">int</span> n; LL g[N], f[N], fc[N], nfc[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solveg</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l == r) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">solveg</span>(l, mid);</span><br><span class="line">	&#123;</span><br><span class="line">		poly lg, rg;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= mid; i++) lg.<span class="built_in">push_back</span>(g[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r - l; i++) rg.<span class="built_in">push_back</span>(fc[i]);</span><br><span class="line">		poly ans = <span class="built_in">poly_auto_mul</span>(lg, rg);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = mid + <span class="number">1</span>; i &lt;= r; i++) g[i] = (g[i] - ans[i - (l + <span class="number">1</span>)] + mod) % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">solveg</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solvef</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">		<span class="comment">// assert(l != 3);</span></span><br><span class="line">		<span class="comment">// if(l == 3) cout &lt;&lt; f[l] &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">		f[l] = (f[l] + g[l] + g[l - <span class="number">1</span>]) * nfc[l] % mod;</span><br><span class="line">		<span class="built_in">assert</span>((<span class="number">1</span> - g[l] * nfc[l] % mod + mod) % mod != <span class="number">0</span>);</span><br><span class="line">		f[l] = f[l] * <span class="built_in">ksm</span>((<span class="number">1</span> - g[l] * nfc[l] % mod + mod) % mod, mod - <span class="number">2</span>) % mod;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">solvef</span>(l, mid);</span><br><span class="line">	&#123;</span><br><span class="line">		poly lg, rg;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= mid; i++) lg.<span class="built_in">push_back</span>(f[i] * g[i] % mod);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r - l; i++) rg.<span class="built_in">push_back</span>(fc[i]);</span><br><span class="line">		poly ans = <span class="built_in">poly_auto_mul</span>(lg, rg);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = mid + <span class="number">1</span>; i &lt;= r; i++) f[i] = (f[i] + ans[i - (l + <span class="number">1</span>)]) % mod;</span><br><span class="line"></span><br><span class="line">		lg.<span class="built_in">clear</span>(); rg.<span class="built_in">clear</span>(); ans.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= mid; i++) lg.<span class="built_in">push_back</span>(f[i] * fc[i] % mod);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r - l; i++) rg.<span class="built_in">push_back</span>(g[i]);</span><br><span class="line">		ans = <span class="built_in">poly_auto_mul</span>(lg, rg);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = mid + <span class="number">1</span>; i &lt;= r; i++) f[i] = (f[i] + ans[i - (l + <span class="number">1</span>)]) % mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">solvef</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">ntt_init</span>(<span class="number">1</span> &lt;&lt; <span class="number">20</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	nfc[<span class="number">0</span>] = nfc[<span class="number">1</span>] = fc[<span class="number">0</span>] = fc[<span class="number">1</span>] = <span class="number">1ll</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) nfc[i] = nfc[mod % i] * (mod - mod / i) % mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) nfc[i] = nfc[i] * nfc[i - <span class="number">1</span>] % mod, fc[i] = fc[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) g[i] = fc[i];</span><br><span class="line">	<span class="built_in">solveg</span>(<span class="number">1</span>, n);</span><br><span class="line">	<span class="built_in">solvef</span>(<span class="number">2</span>, n);</span><br><span class="line">	<span class="comment">// for(int i = 1; i &lt;= n; i++) cout &lt;&lt; g[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">	<span class="comment">// cout &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">	<span class="comment">// for(int i = 1; i &lt;= n; i++) cout &lt;&lt; f[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">	<span class="comment">// cout &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">	LL ans = <span class="number">0ll</span>; <span class="type">int</span> val = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="type">int</span> x;</span><br><span class="line">		cin &gt;&gt; x;</span><br><span class="line">		val = <span class="built_in">max</span>(val, x);</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">if</span>(val == i) ans = (ans + f[cnt]) % mod, cnt = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// cout &lt;&lt; val &lt;&lt; &quot; &quot; &lt;&lt; cnt &lt;&lt; &quot; &quot; &lt;&lt; ans &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$f$ 很显然只有一个半在线，$g$ 得到其实有点来头。</p>
<p>我一开始设的 $g_1,g_0$ ，$g_1$ 分段的时候会计入 shuffle 次数，$g_0$ 则是前面计入了，所以分段不会计入 shuffle 次数，但是发现好像转移式里可以把 $g_1$ 中的 $g_0$ 给化掉，所以就不需要 $g_0$ 了。思考组合意义会发现，shuffle 的次数计入是在最后一段计入的，即不能分段的时候再计入，按照这个重写一下转移式就行了，也可以先写出 $g_1,g_0$ 的转移式再化简。不过细节上还是有点区别的，但大体上是这样子。</p>
</div></details>
<h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><p>tag：构造</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>从来没有觉得做构造开心过。</p>
<p>首先显然不需要关心颜色的限制，因为每个点周围不超过 $25$ 个点，直接点染色就行了。</p>
<p>队长在赛时说应该不存在拉满的情况，我证明了一下：</p>
<p><img src="1.png" alt=""></p>
<p>不考虑拉满，只考虑能不能把最后一行填满，可以发现，无论哪种方法，最后一行占用几格，就一定需要占用上面那行同样多格，而两行格数不一样，必然会空出一格。</p>
<p>而显然总格数 $\mod{3}\equiv 1\mathrm{或者}3$，所以一定不可能在拉满的同时让三个底行同时有一个空格，故一定拉不满。</p>
<p>考虑三行三行递归构造，根据 $\mod{2}$ 来讨论，如果最后一行是奇数行，就空出 $1,4$ 格，然后倒数第四行占据 $1,3$ 格，偶数就反过来，在 $n\ge 7$ 时都可以这样递归讨论。</p>
<p>每三行后面的部分用平行四边形填满就行了，然后 $n\le 6$ 随便搞搞就行了。</p>
<p><img src="2.png" alt=""></p>
<p>上面的方案可能和代码中的不太一样，赛时的构造方案没保存就删了，我也懒得去对着代码重新画一遍，手动构造一遍快多了。</p>
<p>时间复杂度：$O(n^2)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1101</span>;</span><br><span class="line"><span class="type">int</span> a[N][N], n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> pn = n;</span><br><span class="line">    <span class="keyword">while</span>(n &gt;= <span class="number">7</span>)&#123;</span><br><span class="line">        <span class="type">int</span> len = n;</span><br><span class="line">        <span class="type">int</span> base = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            len -= <span class="number">7</span>;</span><br><span class="line">            a[n][<span class="number">2</span>] = a[n][<span class="number">3</span>] = a[n - <span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            a[n - <span class="number">1</span>][<span class="number">3</span>] = a[n - <span class="number">1</span>][<span class="number">4</span>] = a[n][<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line">            a[n - <span class="number">1</span>][<span class="number">5</span>] = a[n][<span class="number">6</span>] = a[n][<span class="number">7</span>] = <span class="number">3</span>;</span><br><span class="line">            a[n - <span class="number">3</span>][<span class="number">1</span>] = a[n - <span class="number">2</span>][<span class="number">1</span>] = a[n - <span class="number">1</span>][<span class="number">2</span>] = <span class="number">4</span>;</span><br><span class="line">            a[n - <span class="number">3</span>][<span class="number">3</span>] = a[n - <span class="number">2</span>][<span class="number">2</span>] = a[n - <span class="number">2</span>][<span class="number">3</span>] = <span class="number">5</span>;</span><br><span class="line">            a[n - <span class="number">2</span>][<span class="number">4</span>] = a[n - <span class="number">2</span>][<span class="number">5</span>] = a[n - <span class="number">1</span>][<span class="number">6</span>] = <span class="number">6</span>;</span><br><span class="line">            base = <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            len -= <span class="number">8</span>;</span><br><span class="line">            a[n][<span class="number">2</span>] = a[n - <span class="number">1</span>][<span class="number">1</span>] = a[n - <span class="number">2</span>][<span class="number">1</span>] = <span class="number">7</span>;</span><br><span class="line">            a[n - <span class="number">1</span>][<span class="number">2</span>] = a[n - <span class="number">1</span>][<span class="number">3</span>] = a[n][<span class="number">4</span>] = <span class="number">8</span>;</span><br><span class="line">            a[n - <span class="number">1</span>][<span class="number">4</span>] = a[n][<span class="number">5</span>] = a[n][<span class="number">6</span>] = <span class="number">9</span>;</span><br><span class="line">            a[n][<span class="number">7</span>] = a[n][<span class="number">8</span>] = a[n - <span class="number">1</span>][<span class="number">6</span>] = <span class="number">10</span>;</span><br><span class="line">            a[n - <span class="number">1</span>][<span class="number">5</span>] = a[n - <span class="number">2</span>][<span class="number">4</span>] = a[n - <span class="number">3</span>][<span class="number">4</span>] = <span class="number">11</span>;</span><br><span class="line">            a[n - <span class="number">2</span>][<span class="number">2</span>] = a[n - <span class="number">2</span>][<span class="number">3</span>] = a[n - <span class="number">3</span>][<span class="number">1</span>] = <span class="number">12</span>;</span><br><span class="line">            a[n - <span class="number">2</span>][<span class="number">5</span>] = a[n - <span class="number">2</span>][<span class="number">6</span>] = a[n - <span class="number">1</span>][<span class="number">7</span>] = <span class="number">13</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(len % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">2</span>)&#123;</span><br><span class="line">            a[n][n - i] = a[n][n - i - <span class="number">1</span>] = a[n - <span class="number">1</span>][n - <span class="number">1</span> - i - <span class="number">1</span>] = <span class="number">26</span> - t - base;</span><br><span class="line">            a[n - <span class="number">1</span>][n - <span class="number">1</span> - i] = a[n - <span class="number">2</span>][n - <span class="number">2</span> - i] = a[n - <span class="number">2</span>][n - <span class="number">2</span> - i - <span class="number">1</span>] = <span class="number">26</span> - t - base - <span class="number">1</span>;</span><br><span class="line">            t = (t + <span class="number">2</span>) % <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n -= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">6</span>)&#123;</span><br><span class="line">        a[<span class="number">6</span>][<span class="number">2</span>] = a[<span class="number">5</span>][<span class="number">1</span>] = a[<span class="number">4</span>][<span class="number">1</span>] = <span class="number">14</span>;</span><br><span class="line">        a[<span class="number">6</span>][<span class="number">4</span>] = a[<span class="number">5</span>][<span class="number">2</span>] = a[<span class="number">5</span>][<span class="number">3</span>] = <span class="number">15</span>;</span><br><span class="line">        a[<span class="number">6</span>][<span class="number">5</span>] = a[<span class="number">6</span>][<span class="number">6</span>] = a[<span class="number">5</span>][<span class="number">4</span>] = <span class="number">16</span>;</span><br><span class="line">        a[<span class="number">4</span>][<span class="number">2</span>] = a[<span class="number">3</span>][<span class="number">1</span>] = a[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        a[<span class="number">4</span>][<span class="number">3</span>] = a[<span class="number">4</span>][<span class="number">4</span>] = a[<span class="number">5</span>][<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line">        a[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">2</span>][<span class="number">2</span>] = a[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">5</span>)&#123;</span><br><span class="line">        a[<span class="number">5</span>][<span class="number">2</span>] = a[<span class="number">5</span>][<span class="number">3</span>] = a[<span class="number">4</span>][<span class="number">1</span>] = <span class="number">14</span>;</span><br><span class="line">        a[<span class="number">5</span>][<span class="number">5</span>] = a[<span class="number">4</span>][<span class="number">3</span>] = a[<span class="number">4</span>][<span class="number">4</span>] = <span class="number">15</span>;</span><br><span class="line">        a[<span class="number">4</span>][<span class="number">2</span>] = a[<span class="number">3</span>][<span class="number">1</span>] = a[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">16</span>;</span><br><span class="line">        a[<span class="number">3</span>][<span class="number">2</span>] = a[<span class="number">2</span>][<span class="number">2</span>] = a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">4</span>)&#123;</span><br><span class="line">        a[<span class="number">4</span>][<span class="number">2</span>] = a[<span class="number">3</span>][<span class="number">1</span>] = a[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">14</span>;</span><br><span class="line">        a[<span class="number">4</span>][<span class="number">4</span>] = a[<span class="number">3</span>][<span class="number">2</span>] = a[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">15</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">3</span>)&#123;</span><br><span class="line">        a[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">2</span>][<span class="number">1</span>] = a[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">14</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= pn; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= pn; j++) cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!a[i][j]) cout &lt;&lt; <span class="string">&quot;.&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; (<span class="type">char</span>)(<span class="string">&#x27;A&#x27;</span> + a[i][j] - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(j &lt; i) cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造想了挺久的，首先在想存不存在一个不用递归的显示构造，后面发现构造不出来。</p>
<p>遂考虑递归，考虑每次处理最后几行，根据前面的思路可以知道，如果要保证不空出更多的空格，填完最后几行的同时，要把上一行的一些格子也给填上，保证上几行在递归的时候不会空出这些格子出来。</p>
<p>由于显然可以拼出一个面积为 $6$ 的平行四边形，所以一开始想的是两行两行按照 $\mod{3}$ 讨论，但是很快发现不对劲，讨论量很大，而且两行的空间太小。而且要空几格是根据 $n\mod{3}$ 来的，以两行的步长减少 $n$ 很不对劲。而且每两行 $\mod{3}$ 的情况不一样，会出现最后一行需要空的格子数并不统一的情况，相当的麻烦。</p>
<p>所以后面开始三行三行、根据 $\mod{2}$ 讨论，手玩每次最后一行空出一格的情况，大战三百回合不可战胜，由于肯定会空出 $3$ 或者 $4$ 格，所以决定手玩最后一行空出两格的情况，大战三百回合依旧不可战胜。</p>
<p>在过了许久之后写暴力来帮忙找这个循环，发现奇数空 1,4 ，偶数空 1,3 ，可以很好的循环下去，遂做完。</p>
<p>要说怎么精简这个流程，我认为能精简的地方只有我早一点写暴力，这个思路我确实手玩不出来，主要之前我主观上是不太想过度依赖暴力来完成构造的，认为这样不能锻炼思维。</p>
<p>但是这个思路最后用程序跑完后就知道，如果自己手玩来构造这个会浪费大量的时间，而且按照我那种手玩方法，和乱试没什么区别，稍稍有条理一点而已，因此手玩的过程也谈不上什么锻炼思维，只是人工的进行了暴力的过程。所以就释怀了，感觉以后如果可以暴力辅助构造就还是写暴力吧，别把时间浪费在人工模拟暴力上面。</p>
<p>在写博客的时候突然意识到我好像没有用暴力找是否存在空一格的循环，遂尝试了一下，结果发现似乎在 $n\le 11$ 找不到。</p>
<p>下面是暴力的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">vector&lt;pair&lt;PII, PII&gt;&gt; poss;</span><br><span class="line"><span class="type">bool</span> a[N][N];</span><br><span class="line"><span class="type">int</span> base, i1, i2;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> x &lt;= base &amp;&amp; x &gt;= base - <span class="number">3</span> &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= x &amp;&amp; a[x][y] == <span class="number">1</span>;&#125;</span><br><span class="line"><span class="comment">// set&lt;pair&lt;PII, PII&gt; &gt; s;</span></span><br><span class="line"><span class="comment">// int g1, g2, g3, g4;</span></span><br><span class="line">set&lt;PII&gt; s;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> dep)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= base - <span class="number">3</span>; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!a[base - <span class="number">3</span>][j])&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> tx = <span class="number">0</span>, ty = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = base - <span class="number">2</span>; i &lt;= base; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j])&#123;</span><br><span class="line">                tx = i; ty = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tx) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!tx)&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; pos;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= base - <span class="number">3</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!a[base - <span class="number">3</span>][j]) pos.<span class="built_in">push_back</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(pos.<span class="built_in">size</span>() == <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">find</span>(&#123;i1, pos[<span class="number">0</span>]&#125;) == s.<span class="built_in">end</span>())&#123;</span><br><span class="line">            cout &lt;&lt; i1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; pos[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// if(pos[0] == g3 &amp;&amp; pos[1] == g4)&#123;</span></span><br><span class="line">            <span class="comment">//     for(int i = base - 3; i &lt;= base; i++)&#123;</span></span><br><span class="line">            <span class="comment">//         for(int j = 1; j &lt;= i; j++)&#123;</span></span><br><span class="line">            <span class="comment">//             printf(&quot;%4d&quot;, a[i][j]);</span></span><br><span class="line">            <span class="comment">//         &#125;</span></span><br><span class="line">            <span class="comment">//         printf(&quot;\n&quot;);</span></span><br><span class="line">            <span class="comment">//     &#125;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">insert</span>(&#123;i1, pos[<span class="number">0</span>]&#125;);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [d1, d2] : poss)&#123;</span><br><span class="line">        <span class="type">int</span> tx1 = d1.first + tx, ty1 = d1.second + ty;</span><br><span class="line">        <span class="type">int</span> tx2 = d2.first + tx, ty2 = d2.second + ty;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pd</span>(tx1, ty1) &amp;&amp; <span class="built_in">pd</span>(tx2, ty2))&#123;</span><br><span class="line">            a[tx][ty] = a[tx1][ty1] = a[tx2][ty2] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(dep + <span class="number">1</span>);</span><br><span class="line">            a[tx][ty] = a[tx1][ty1] = a[tx2][ty2] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">0</span>; t &lt; <span class="number">6</span>; t++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">-1</span>; d &lt;= <span class="number">1</span>; d += <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="type">int</span> tt = (t + d + <span class="number">6</span>) % <span class="number">6</span>;</span><br><span class="line">            poss.<span class="built_in">push_back</span>(&#123;&#123;dx[t], dy[t]&#125;, &#123;dx[t] + dx[tt], dy[t] + dy[tt]&#125;&#125;);</span><br><span class="line">            tt = (t + d * <span class="number">2</span> + <span class="number">6</span>) % <span class="number">6</span>;</span><br><span class="line">            <span class="keyword">if</span>(t &lt; tt) poss.<span class="built_in">push_back</span>(&#123;&#123;dx[t], dy[t]&#125;, &#123;dx[tt], dy[tt]&#125;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    cin &gt;&gt; base;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; base &gt;&gt; g1 &gt;&gt; g2 &gt;&gt; g3 &gt;&gt; g4;</span></span><br><span class="line">    <span class="comment">// i1 = g1; i2 = g2;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = base - <span class="number">3</span>; i &lt;= base; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) a[i][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(i1 = 1; i1 &lt;= base; i1++)&#123;</span></span><br><span class="line">    <span class="comment">//     for(i2 = i1 + 1; i2 &lt;= base; i2++)&#123;</span></span><br><span class="line">    <span class="comment">//         a[base][i1] = a[base][i2] = 0;</span></span><br><span class="line">    <span class="comment">//         dfs(0);</span></span><br><span class="line">    <span class="comment">//         a[base][i1] = a[base][i2] = 1;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// a[base][g1] = a[base][g2] = 0;</span></span><br><span class="line">    <span class="keyword">for</span>(i1 = <span class="number">1</span>; i1 &lt;= base; i1++)&#123;</span><br><span class="line">        a[base][i1] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        a[base][i1] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说起来也是蠢，当时还想用暴力输出方案，但实际上只要知道是空出哪几格后，手动构造方案很快的，没必要浪费那个时间去改代码输出方案。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>The 3rd Ucup Stage 2: M. Balance of Permutation</title>
    <url>/2024/06/27/The-3rd-Ucup-Stage-2-M-Balance-of-Permutation/</url>
    <content><![CDATA[<p>题目链接：<a href="https://contest.ucup.ac/contest/1699/problem/8529">https://contest.ucup.ac/contest/1699/problem/8529</a></p>
<p>题目大意：求长度为 $n$ 字典序排名为 $k$ 的满足 $\sum\limits_{|p_i-i|}=b$ 的排列。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>一开始看到数据范围这么小，下意识觉得可能是某种非常 interesting 的 meet in middle ，然后再优化了大半天状态以后发现好像可以直接多项式 $dp$ ，真是闹麻了。</p>
<p>注意到一个事情，如果观察 $\ge k$ 的数字和位置，可以发现有两种状态：空着和已经填上了，而且数字和位置同一状态的数量是一样的。</p>
<p>可以注意到，空着的数字或者位置总是要填的，而由于我们是按顺序枚举的，所以其的贡献已经可以算了，他们在绝对值中一定是大减小中的大者，按照这个思路直接 $dp$ 就行了。</p>
<p>单次枚举的时间复杂度是 ：$O(n^4)$ ，然后填数是 $O(n^2)$ 的，不过填数是从左到右的，方便起见，枚举也可以从小到大枚举。</p>
<p>这样就是 $O(n^6)$ 的。</p>
<p>代码也不难写。</p>
<p>但是呢，队长说题解的复杂度好像是 $O(n^5)$ 的，于是我接着想。（虽然后面看了题解发现是 $O(n^6)$ 的）</p>
<p>注意到一个事情，什么 $n$ 是可以被优化掉的，就是枚举这个位置放什么，我们可以锁住这个位置，不让这个位置放东西，然后前缀 $dp$ 一遍，后缀 $dp$ 一遍，当我要放 $val$ 的时候，就把 $val-1$ 的前缀和 $val+1$ 的后缀拿出来求出这个的贡献，就能优化掉一个 $n$ 。</p>
<p>原理类似于本来 $dp$ 合并是一个卷积，但是如果只用求特定项的系数，就可以线性求出。</p>
<p>最终时间复杂度：$O(n^5)$ 。</p>
<p>然后我就喜提 5.4k 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> __int128 IT;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">35</span>;</span><br><span class="line"><span class="comment">// &gt;=  and  &lt;</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getz</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c &gt; <span class="string">&#x27;9&#x27;</span> || c &lt; <span class="string">&#x27;0&#x27;</span>) c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (c - <span class="string">&#x27;0&#x27;</span>), c = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line">IT fl[N * <span class="number">2</span>][N][N * N * <span class="number">2</span>], fr[N * <span class="number">2</span>][N][N * N * <span class="number">2</span>], fc[N];</span><br><span class="line"><span class="type">int</span> v0[N], v1[N];</span><br><span class="line"><span class="type">int</span> vsl0[N][N], vsl1[N][N]; <span class="comment">//&lt;=</span></span><br><span class="line"><span class="type">int</span> vsr0[N][N], vsr1[N][N]; <span class="comment">//&gt;=</span></span><br><span class="line"><span class="type">int</span> n, S, a[N], Sb;</span><br><span class="line">IT K;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> ban)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)&#123;<span class="comment">//limit</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            vsl0[l][i] = vsl0[l][i - <span class="number">1</span>] + ((i == ban) || (v0[i] &amp;&amp; v0[i] &gt;= l));</span><br><span class="line">            vsl1[l][i] = vsl1[l][i - <span class="number">1</span>] + (v1[i] &amp;&amp; v1[i] &gt;= l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">            vsr0[l][i] = vsr0[l][i + <span class="number">1</span>] + ((i == ban) || (v0[i] &amp;&amp; v0[i] &lt;= l));</span><br><span class="line">            vsr1[l][i] = vsr1[l][i + <span class="number">1</span>] + (v1[i] &amp;&amp; v1[i] &lt;= l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addposleft</span><span class="params">(<span class="type">int</span> t, <span class="type">int</span> id, <span class="type">int</span> ban)</span></span>&#123;<span class="comment">//id - 1 -&gt; id;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n / <span class="number">2</span> + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">0</span>; s &lt;= Sb + Sb + Sb; s++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!fl[id - <span class="number">1</span>][i][s]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(t == ban || v0[t])&#123;</span><br><span class="line">                <span class="keyword">if</span>(t == ban || v0[t] &gt;= t) <span class="comment">/*-*/</span> fl[id][i + <span class="number">1</span>][s - t] += fl[id - <span class="number">1</span>][i][s];</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">/*+*/</span> fl[id][i][s + t] += fl[id - <span class="number">1</span>][i][s];</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                fl[id][i + <span class="number">1</span>][s - t] += fl[id - <span class="number">1</span>][i][s];<span class="comment">//-</span></span><br><span class="line">                <span class="keyword">if</span>(i) fl[id][i][s + t] += fl[id - <span class="number">1</span>][i][s] * (i - vsl1[t][t - <span class="number">1</span>]);<span class="comment">//+</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addnumleft</span><span class="params">(<span class="type">int</span> t, <span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n / <span class="number">2</span> + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">0</span>; s &lt;= Sb + Sb + Sb; s++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!fl[id - <span class="number">1</span>][i][s]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(v1[t])&#123;</span><br><span class="line">                <span class="keyword">if</span>(v1[t] &gt; t) <span class="comment">/*-*/</span> fl[id][i][s - t] += fl[id - <span class="number">1</span>][i][s];</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">/*+*/</span> fl[id][i - <span class="number">1</span>][s + t] += fl[id - <span class="number">1</span>][i][s];</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                fl[id][i][s - t] += fl[id - <span class="number">1</span>][i][s];<span class="comment">//-</span></span><br><span class="line">                <span class="keyword">if</span>(i) fl[id][i - <span class="number">1</span>][s + t] += fl[id - <span class="number">1</span>][i][s] * (i - vsl0[t][t]);<span class="comment">//+</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addnumright</span><span class="params">(<span class="type">int</span> t, <span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n / <span class="number">2</span> + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">0</span>; s &lt;= Sb + Sb + Sb; s++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!fr[id + <span class="number">1</span>][i][s]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(v1[t])&#123;</span><br><span class="line">                <span class="keyword">if</span>(v1[t] &lt;= t) <span class="comment">/*+*/</span> fr[id][i + <span class="number">1</span>][s + t] += fr[id + <span class="number">1</span>][i][s];</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">/*-*/</span> fr[id][i][s - t] += fr[id + <span class="number">1</span>][i][s];</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                fr[id][i + <span class="number">1</span>][s + t] += fr[id + <span class="number">1</span>][i][s]; <span class="comment">//+</span></span><br><span class="line">                <span class="keyword">if</span>(i) fr[id][i][s - t] += fr[id + <span class="number">1</span>][i][s] * (i - vsr0[t][t + <span class="number">1</span>]); <span class="comment">//-</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addposright</span><span class="params">(<span class="type">int</span> t, <span class="type">int</span> id, <span class="type">int</span> ban)</span></span>&#123;<span class="comment">//id + 1 -&gt; id;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n / <span class="number">2</span> + <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">0</span>; s &lt;= Sb + Sb + Sb; s++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!fr[id + <span class="number">1</span>][i][s]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(t == ban || v0[t])&#123;</span><br><span class="line">                <span class="keyword">if</span>(t == ban || v0[t] &lt; t) <span class="comment">/*+*/</span> fr[id][i][s + t] += fr[id + <span class="number">1</span>][i][s];</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">/*-*/</span> fr[id][i - <span class="number">1</span>][s - t] += fr[id + <span class="number">1</span>][i][s];</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                fr[id][i][s + t] += fr[id + <span class="number">1</span>][i][s]; <span class="comment">//+</span></span><br><span class="line">                <span class="keyword">if</span>(i) fr[id][i - <span class="number">1</span>][s - t] += fr[id + <span class="number">1</span>][i][s] * (i - vsr1[t][t]); <span class="comment">//-</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin.<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">getz</span>(n); Sb = n * (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">getz</span>(S);</span><br><span class="line">    <span class="built_in">getz</span>(K);</span><br><span class="line">    fc[<span class="number">0</span>] = <span class="number">1</span>; <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">1</span>; t &lt;= n; t++) fc[t] = fc[t - <span class="number">1</span>] * t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">1</span>; t &lt;= n; t++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(fl, <span class="number">0</span>, <span class="built_in">sizeof</span>(fl));</span><br><span class="line">        <span class="built_in">memset</span>(fr, <span class="number">0</span>, <span class="built_in">sizeof</span>(fr));</span><br><span class="line">        fl[<span class="number">0</span>][<span class="number">0</span>][Sb] = <span class="number">1</span>;</span><br><span class="line">        fr[n + n + <span class="number">1</span>][<span class="number">0</span>][Sb] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        v0[t] = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">init</span>(t);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="built_in">addposleft</span>(i, i * <span class="number">2</span> - <span class="number">1</span>, t);</span><br><span class="line">            <span class="built_in">addnumleft</span>(i, i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">            <span class="built_in">addnumright</span>(i, i * <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">addposright</span>(i, i * <span class="number">2</span> - <span class="number">1</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v1[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> l = i * <span class="number">2</span> - <span class="number">1</span>, r = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            IT now = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> jl = <span class="number">1</span>; jl &lt;= n / <span class="number">2</span> + <span class="number">1</span>; jl++)&#123;</span><br><span class="line">                IT k;</span><br><span class="line">                <span class="type">int</span> jr, c;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; t)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(jl - vsl0[i][i] &lt; <span class="number">0</span> || jl - <span class="number">1</span> - vsl1[i + <span class="number">1</span>][i - <span class="number">1</span>] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    jr = jl;</span><br><span class="line">                    k = fc[jl - vsl0[i][i]] * fc[jl - <span class="number">1</span> - vsl1[i + <span class="number">1</span>][i - <span class="number">1</span>]];</span><br><span class="line">                    c = -i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(jl - <span class="number">1</span> - vsr0[i][i + <span class="number">1</span>] &lt; <span class="number">0</span> || jl - <span class="number">1</span> - vsr1[i][i + <span class="number">1</span>] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    jr = jl - <span class="number">1</span>;</span><br><span class="line">                    k = fc[jl - <span class="number">1</span> - vsr0[i][i + <span class="number">1</span>]] * fc[jl - <span class="number">1</span> - vsr1[i][i + <span class="number">1</span>]];</span><br><span class="line">                    c = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> sl = <span class="number">0</span>; sl &lt;= Sb + Sb + Sb; sl++)&#123;</span><br><span class="line">                    <span class="type">int</span> sr = Sb + Sb + S - (sl + c);</span><br><span class="line">                    <span class="keyword">if</span>(sr &gt; Sb + Sb + Sb || sr &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(fl[l][jl][sl] &amp;&amp; fr[r][jr][sr])&#123;</span><br><span class="line">                        now += fl[l][jl][sl] * fr[r][jr][sr] * k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(now &lt; K) K -= now;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                v0[t] = i;</span><br><span class="line">                v1[i] = t;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cout &lt;&lt; v0[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过会长的最主要原因是有 $4$ 个长的几乎一样但是又不能合并的函数。</p>
<p>真是艹了。</p>
<p>官方题解和 $n^6$ 的做法基本一样，在此不再赘述。</p>
<p>但是有个问题，$n^6$ 我会写多长呢？</p>
<p>答案是 2.2k 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> __int128 IT;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">35</span>;</span><br><span class="line">IT dp[<span class="number">2</span>][N][N * N * <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sw</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(dp[<span class="number">0</span>], dp[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">memset</span>(dp[<span class="number">0</span>], <span class="number">0</span>, <span class="built_in">sizeof</span>(dp[<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> base;</span><br><span class="line"><span class="type">int</span> n, B;</span><br><span class="line">IT K;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getz</span><span class="params">(<span class="keyword">auto</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; c &gt;= <span class="string">&#x27;0&#x27;</span>) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (c - <span class="string">&#x27;0&#x27;</span>), c = <span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m1[N], m2[N];<span class="comment">// 1 : seat , 2 : number</span></span><br><span class="line"><span class="type">int</span> c1[N], c2[N];</span><br><span class="line"><span class="function">IT <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        c1[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) c1[i] += (m1[j] &amp;&amp; m1[j] &gt;= i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        c2[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++) c2[i] += (m2[j] &amp;&amp; m2[j] &gt;= i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sw</span>();</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][base] = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">sw</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= base * <span class="number">3</span>; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dp[<span class="number">1</span>][j][k]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(!(m1[i] &amp;&amp; m1[i] &lt; i) &amp;&amp; k &gt;= i) dp[<span class="number">0</span>][j + <span class="number">1</span>][k - i] += dp[<span class="number">1</span>][j][k]; <span class="comment">//-</span></span><br><span class="line">                <span class="keyword">if</span>(!(m1[i] &amp;&amp; m1[i] &gt;= i))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(m1[i]) dp[<span class="number">0</span>][j][k + i] += dp[<span class="number">1</span>][j][k];</span><br><span class="line">                    <span class="keyword">else</span> dp[<span class="number">0</span>][j][k + i] += dp[<span class="number">1</span>][j][k] * (j - c2[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sw</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= base * <span class="number">3</span>; k++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dp[<span class="number">1</span>][j][k]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(!(m2[i] &amp;&amp; m2[i] &lt;= i) &amp;&amp; k &gt;= i) dp[<span class="number">0</span>][j][k - i] += dp[<span class="number">1</span>][j][k];</span><br><span class="line">                <span class="keyword">if</span>(!(m2[i] &amp;&amp; m2[i] &gt; i))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(m2[i]) dp[<span class="number">0</span>][j - <span class="number">1</span>][k + i] += dp[<span class="number">1</span>][j][k];</span><br><span class="line">                    <span class="keyword">else</span> dp[<span class="number">0</span>][j - <span class="number">1</span>][k + i] += dp[<span class="number">1</span>][j][k] * (j - c1[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>][base + B];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">getz</span>(n); <span class="built_in">getz</span>(B); <span class="built_in">getz</span>(K);</span><br><span class="line">    base = n * (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m2[j]) <span class="keyword">continue</span>;</span><br><span class="line">            m1[i] = j;</span><br><span class="line">            m2[j] = i;</span><br><span class="line">            IT rk = <span class="built_in">solve</span>();</span><br><span class="line">            <span class="keyword">if</span>(rk &lt; K) K -= rk;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            m1[i] = <span class="number">0</span>;</span><br><span class="line">            m2[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cout &lt;&lt; m1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>短了一半，好写多了，真是艹了。</p>
<p>但是还是有点长，学习一下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://contest.ucup.ac/submission/442419</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> i128=__int128;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">31</span>;</span><br><span class="line"><span class="type">int</span> n,b,g[N],p[N];</span><br><span class="line">i128 f[N][N][N*N];</span><br><span class="line">string K;</span><br><span class="line"><span class="function">i128 <span class="title">val</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">	<span class="type">int</span> cnt=<span class="number">0</span>,m=n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(p[i]) cnt+=<span class="built_in">abs</span>(i-p[i]),m--;</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> c0=<span class="number">0</span>,c1=<span class="number">0</span>,t0=<span class="number">0</span>,t1=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++) c0+=!p[j],c1+=!g[j];</span><br><span class="line">		t0+=c0+(!p[i]);t1+=c1+(!g[i]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="built_in">min</span>(t0,t1);j++) <span class="keyword">for</span>(<span class="type">int</span> t=t0+t1-j*<span class="number">2</span>,k=t;k&lt;=b-cnt;k++)&#123;</span><br><span class="line">			f[i][j][k]=f[i<span class="number">-1</span>][j][k-t];</span><br><span class="line">			<span class="keyword">if</span>(!g[i]&amp;&amp;j) f[i][j][k]+=(c0-j+<span class="number">1</span>)*f[i<span class="number">-1</span>][j<span class="number">-1</span>][k-t];</span><br><span class="line">			<span class="keyword">if</span>(!p[i]&amp;&amp;j) f[i][j][k]+=(c1-j+<span class="number">1</span>)*f[i<span class="number">-1</span>][j<span class="number">-1</span>][k-t];</span><br><span class="line">			<span class="keyword">if</span>(!g[i]&amp;&amp;!p[i]&amp;&amp;j) f[i][j][k]+=f[i<span class="number">-1</span>][j<span class="number">-1</span>][k-t];</span><br><span class="line">			<span class="keyword">if</span>(!g[i]&amp;&amp;!p[i]&amp;&amp;j&gt;<span class="number">1</span>) f[i][j][k]+=(c0-j+<span class="number">2</span>)*(c1-j+<span class="number">2</span>)*f[i<span class="number">-1</span>][j<span class="number">-2</span>][k-t];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[n][m][b-cnt];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;b&gt;&gt;K;</span><br><span class="line">	i128 k=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x:K) k=k*<span class="number">10</span>+x-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="keyword">if</span>(!g[j])&#123;</span><br><span class="line">		g[j]=i;p[i]=j;</span><br><span class="line">		i128 cnt=<span class="built_in">val</span>();</span><br><span class="line">		<span class="keyword">if</span>(cnt&gt;=k)&#123;</span><br><span class="line">			cout&lt;&lt;j&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		k-=cnt;g[j]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$dp$ 外的部分没什么区别，但是 $dp$ 内的部分有很大区别，区别主要有 $3$ 个。</p>
<ol>
<li><p>我第二维记录的是还没成对的位置和数字，这有一个问题，虽然这两个数量确实相等，但是由于未成对里面可能有已经成对但是还没添加进来的数字或位置，这就导致在后面计算乘的系数的时候比较麻烦。</p>
<p>而他记录的是已经成了多少对（忽略外面成对的数字），这样遇到已经在外面成对的数字或者位置可以直接跳过，甚至后面计算系数也好算。</p>
</li>
<li>第三维，我记录的是每个数字的贡献，因此基础下标是 $\frac{n(n+1)}{2}$ ，但是他的贡献是实时算的，什么意思呢，就是如果我有 $k$ 个数字或位置在下面，每次往上移动一格，贡献为 $k$ ，而且忽略了外面成对数字的贡献，好处就是成对的数字或者位置可以直接跳过，而且 $dp$ 范围非常的自然。</li>
<li><p>我添加数字或者位置写了两个循环，但是他是合并了，至于这个，我觉得没有优劣之分。</p>
<p>主要是这两个添加时的判断都很少，所以合并起来也少。但是如果两个添加时有很多判断，合并起来实现复杂度是乘一起的。相比之下，虽然我的做法多了一层循环，但是条理更加清晰，犯错概率更低，所以我的代码之所以比他长，我觉得主要原因是前两条，而不是这一条，我觉得这一条各有优劣，没有对错之分。</p>
</li>
</ol>
<p>还是实现麻烦了，还得学，还得多练。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计数</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Treelection</title>
    <url>/2024/02/11/Treelection/</url>
    <content><![CDATA[<p>题目链接：<a href="https://qoj.ac/contest/1259/problem/6638">https://qoj.ac/contest/1259/problem/6638</a></p>
<p>题目大意：给一棵以 $1$ 为根的树，举办一场投票，每个人只能向祖先投票，问每个点存不存在一种情况使得这个点的得票数严格大于其他点的得票数。（根不投票）</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>考虑一个事情，一个子树大小为 $x$ 的点可以当选，那么显然一个子树大小 $y&gt;x$ 的点也一定可以当选，但是 $y=x$ 呢？</p>
<p>显然如果子树大小为 $x$ 的点的形状不是菊花就行，如果是菊花的话就还得另外考虑。</p>
<p>于是我们就发现，答案结构应该是存在一个 $limit$ ，$siz&gt;limit$ 一定可以，$siz=limit$ 得看情况（且必要条件是子树得是个菊花），考虑怎么找这个 limit ，显然得二分，但是怎么判断 $&gt;mid$ 的子树全都可以呢？</p>
<p>观察上述结论的证明过程，发现关键在于对于一个点 $x$ ，子树大小为 $siz$ ，要求每个点的得票数 $&lt;siz-1$ 时，这个子树能内部消化自己的得票数（也就是不是菊花），也就是说，存在一种情况使得整棵树的得票数的最大值 $&lt;siz-1$ ，因此做法就出来了。</p>
<p>如果存在一个情况，使得整棵树的得票数最大值 $\le mid-1$ ，那么 $limit \le mid$ ，显然树形DP即可。</p>
<p>在找到 $limit$ 后，考虑处理 $siz=limit$ 的点，用树形 DP 跑一遍每个点的最大容量只有 $limit-2$ 的情况，显然，只有当根节点得票数为 $limit-1$ 且这个点的 $siz=limit$ 且这个点到根节点这条路径上一直存在 $dp$ 值的有效转移时，这个点才是可以当选的点，否则不符合这种情况。（显然，能符合上述要求的点，子树一定是个菊花，这也符合上面的讨论）</p>
<p>时间复杂度：$O(n\log{n})$ </p>
<p>注：代码的实现思路和上面说的略有不同。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> p[N],siz[N],n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(siz+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        siz[i]+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">1</span>)siz[p[i]]+=siz[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[N];<span class="type">bool</span> v[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> U)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f+<span class="number">1</span>,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">2</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i]&lt;=U)v[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> v[i]=<span class="number">1</span>;</span><br><span class="line">        f[p[i]]+=<span class="built_in">max</span>(f[i]-U,<span class="number">0</span>)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[<span class="number">1</span>]-U;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> ac[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">3</span>,r=n+<span class="number">1</span>,mid,ans;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid<span class="number">-2</span>)&lt;=<span class="number">0</span>)r=mid<span class="number">-1</span>,ans=mid;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(siz[i]&gt;=ans)ac[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> ac[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ac[<span class="number">1</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(ans!=<span class="number">2</span> &amp;&amp; <span class="built_in">check</span>(ans<span class="number">-3</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">        v[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[p[i]] &amp;&amp; v[i])v[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> v[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(v[i] &amp;&amp; siz[i]==ans<span class="number">-1</span>)ac[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ac[n+<span class="number">1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,ac+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title>UKIEPC 2020 A. Arrange The Piranhas</title>
    <url>/2024/07/03/UKIEPC-2020-A-Arrange-The-Piranhas/</url>
    <content><![CDATA[<p>题目链接：<a href="https://qoj.ac/contest/531/problem/875">https://qoj.ac/contest/531/problem/875</a></p>
<p>题目大意： $n$ 个格子，有 $k$ 条食人鱼，每个格子只有至多一条食人鱼，每秒你可以把手指放到一个没有食人鱼的格子里，然后左右两边离你手指最近的食人鱼会朝你游动一格，要求移动后和你手指不在同一格里面，问最少需要多少秒才能变成目标状态。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>相当于把 $n$ 个格子切成 $k+1$ 份，每次操作可以将一个区间 $-2$ ，两边区间 $+1$ ，要求操作后的区间长度 $\ge 2$。（也就是差分，但需要注意的是两边的区间略有区别）</p>
<p>可以发现，根据目标状态可以列出 $k$ 个方程，设 $f_i$ 表示操作区间 $i$ 多少次。</p>
<p>那么有：$f_{i+1}-f_{i}=d_{i}-p_i$ ，可以把所有的 $f$ 用 $f_1$ 表示，显然所有 $f$ 都是非负的。</p>
<p>找到最小的 $f_1$ 使得所有 $f$ 非空，不妨猜测此时的 $f$ 的和就是答案。</p>
<p>这样就只需要验证是否可行就行了，显然 $f$ 的和是 $O(nk^2)$ 的（ $f_i$ 是 $O(nk)$ 的），直接验证就行了，时间复杂度：$O(nk^2)$ 。（题解做法）</p>
<p>什么叫直接验证呢？就是注意到一个区间如果能操作，那么不操作他他一直都处于能操作的状态，所以先后顺序无所谓，直接操作就行了，或者更准确的说，如果不操作一个区间，随着别的区间的操作，这个区间的可操作性是单调不降的，所以以任意顺序操作可操作的区间就是对的。</p>
<p>但是有没有更加快速的搞法呢？（毕竟正常人哪会想到，$n,k,1000$ 最终复杂度是 $O(nk^2)$ 的）</p>
<p>有，我们可以对一个前缀先操作到不能操作位置，然后找到最长的还需要操作的后缀，观察其每个区间的长度，一定是每个区间的长度 $\le 2$ （特殊的，对于第一个区间，我们给其 $+1$ ），然后可以发现，每次前缀外输送进来一个 $1$ ，会引发后缀一串连续的 $2$ 各操作一次（即操作一段连续的区间）。具体可以自己手模一下这个过程，就知道了。</p>
<p>因此，我们从左到右维护前缀，采用增量法的方式进行操作，这样给前缀输送 $1$ 的次数是多少次呢？注意到如果 $i≠k+1$ ，每次操作 $i$ ，不仅像 $i-1$ 这个前缀输送 $1$ ，也会像后输送 $1$ ，所以至多 $n$ 次，即 $nk$ 次，当 $i=k+1$ 时，其的操作次数是 $O(nk)$ 的，所以也至多输送 $O(nk)$ 次，综上，输送 $1$ 的次数是 $O(nk)$ 次的，</p>
<p>发现往前缀输送 $1$ 所引起的变化的这个过程是可以线段树维护的，于是就做完了，时间复杂度：$O(nk\log{k})$ 。</p>
<p>注：可以注意到，在同一个前缀下，不断给这个前缀的最后一个位置添加 $1$ ，后缀最长的连续的 $2$ 的长度，在没有位置操作次数达到的情况下，至多减少 $1$ ，而操作次数到的时候会把这个位置 $ban$ 掉，但至多 ban $k+1$ 次，而且，前缀变化也至多 $k+1$ 次，所以综上，后缀最长的连续的 $2$ 的长度至多变化 $O(nk)$ ，所以可以直接维护。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="comment">// struct node&#123;</span></span><br><span class="line"><span class="comment">//     int lc, rc;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], b[N], c[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span>&#123;</span><br><span class="line">    <span class="type">int</span> lc, rc;</span><br><span class="line">    <span class="type">int</span> val, lazy;</span><br><span class="line">&#125;tr[N * <span class="number">2</span>]; <span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushlazy</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    tr[x].val += k;</span><br><span class="line">    tr[x].lazy += k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].lazy)&#123;</span><br><span class="line">        <span class="built_in">pushlazy</span>(tr[x].lc, tr[x].lazy);</span><br><span class="line">        <span class="built_in">pushlazy</span>(tr[x].rc, tr[x].lazy);</span><br><span class="line">        tr[x].lazy = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;tr[x].val = <span class="built_in">min</span>(tr[tr[x].lc].val, tr[tr[x].rc].val);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bt</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = ++cnt;</span><br><span class="line">    tr[x].val = inf;</span><br><span class="line">    <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        tr[x].lc = <span class="built_in">bt</span>(l, mid);</span><br><span class="line">        tr[x].rc = <span class="built_in">bt</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findpos</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].val &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="built_in">findpos</span>(tr[x].rc, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">if</span>(!ans) ans = <span class="built_in">findpos</span>(tr[x].lc, l, mid);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ll, <span class="type">int</span> rr, <span class="type">int</span> k, <span class="type">int</span> type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt; ll || l &gt; rr || ll &gt; rr) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= ll &amp;&amp; r &lt;= rr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">0</span>) <span class="built_in">pushlazy</span>(x, k);</span><br><span class="line">        <span class="keyword">else</span> tr[x].val = k, tr[x].lazy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">change</span>(tr[x].lc, l, mid, ll, rr, k, type);</span><br><span class="line">    <span class="built_in">change</span>(tr[x].rc, mid + <span class="number">1</span>, r, ll, rr, k, type);</span><br><span class="line">    <span class="built_in">update</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> now;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    a[x] = s;</span><br><span class="line">    <span class="keyword">if</span>(s != <span class="number">2</span>) now = <span class="built_in">max</span>(x + <span class="number">1</span>, now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maintain</span><span class="params">(<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(now &lt;= f &amp;&amp; a[now] != <span class="number">2</span>) now++;</span><br><span class="line">    <span class="keyword">while</span>(now &gt; <span class="number">1</span> &amp;&amp; a[now - <span class="number">1</span>] == <span class="number">2</span>) now--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">oper</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">1</span>) a[x] --, a[x + <span class="number">1</span>] ++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x == m) a[x] --;</span><br><span class="line">    <span class="keyword">else</span> a[x] -= <span class="number">2</span>, a[x + <span class="number">1</span>] ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) cin &gt;&gt; b[i];</span><br><span class="line">    <span class="type">int</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        c[i + <span class="number">1</span>] = c[i] + b[i] - a[i];</span><br><span class="line">        base = <span class="built_in">min</span>(base, c[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//r[i] - l[i] = b[i] - a[i]</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; i++) c[i] -= base, ans += c[i];</span><br><span class="line">    m++;</span><br><span class="line">    <span class="built_in">bt</span>(<span class="number">1</span>, m);</span><br><span class="line"></span><br><span class="line">    a[m] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = m; i &gt;= <span class="number">1</span>; i--) a[i] = a[i] - a[i - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">    a[<span class="number">1</span>]++; a[m]++;</span><br><span class="line"></span><br><span class="line">    now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(c[i] &amp;&amp; a[i] &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(now &lt;= i - <span class="number">1</span>) a[i]++;</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>, <span class="number">1</span>, m, now, i - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(now != <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="type">int</span> pre = now;</span><br><span class="line">                <span class="keyword">if</span>(pre != i) <span class="built_in">change</span>(pre, <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">change</span>(pre - <span class="number">1</span>, a[pre - <span class="number">1</span>] == <span class="number">-1</span> ? <span class="number">-1</span> : a[pre - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">maintain</span>(i - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(tr[<span class="number">1</span>].val == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> pos = <span class="built_in">findpos</span>(<span class="number">1</span>, <span class="number">1</span>, m);</span><br><span class="line">                <span class="built_in">change</span>(<span class="number">1</span>, <span class="number">1</span>, m, pos, pos, inf, <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">change</span>(pos, <span class="number">-1</span>);</span><br><span class="line">                <span class="comment">// maintain(i - 1);</span></span><br><span class="line">            &#125;</span><br><span class="line">            c[i]--;</span><br><span class="line">            <span class="built_in">oper</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!c[i]) <span class="built_in">change</span>(i, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">assert</span>(a[i] &lt;= <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">change</span>(i, a[i]);</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>, <span class="number">1</span>, m, i, i, c[i], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// maintain(i);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tr[<span class="number">1</span>].val &lt;= n * n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">solve</span>()) cout &lt;&lt; <span class="string">&quot;impossible\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>假设现在有一个合法方案：$g_1,g_2,…,g_{k+1}(g_i&gt;0)$ ，现在证明 $g_1-1,g_2-1,…,g_{k+1}-1$ 也是合法的。</p></p>
<p>反证法，假设不行，我们先一直操作到不能操作为止。</p>
<p>这样，需要操作但是不能操作的区间又连续的构成一些区间，我们把其中一个区间拉出来。</p>
<p>显然，在合法方案 $g_{1},g_{2},…,g_{k+1}$ 下按照同样的顺序操作到这一步，这个区间也没办法全部操作两次及以上。（讨论一下就行了，至多一次）</p>
<p>所以矛盾，证毕。</p>
</div></details>
<p>还能更快吗？</p>
<p>其实是可以 $O(nk)$ 的。</p>
<p>注意到线段树维护的次数是一个后缀减，后缀查是否 $&lt;0$ ，而这我们可以维护一个严格递增的单调栈（即维护目前所有的后缀最小值），栈用链表维护，两个元素之间维护差值，同时维护链头的值，每次后缀减相当于在链表的某个位置减，但是代码前的注释可以知道，后缀连续 $2$ 的长度变化为 $O(nk)$ ，即后缀减长度变化至多 $O(nk)$ ，所以可以直接暴力在链表上跳。</p>
<p>但是这样我们并没有实际性的维护操作次数，最后怎么验证合法呢？</p>
<p>两个方法：</p>
<ol>
<li>每次把区间减在外面差分操作一下，最后前缀和算一下是否都等于 $0$ 。</li>
<li>至于算操作次数是否对上了，因为我们不会让一个位置的实际操作次数 $&gt;$ 需要的操作次数。</li>
</ol>
<p>这样，就能在 $O(nk)$ 的时间解决此题。</p>
<p>因为代码太难写了，所以没有代码。<del>摆了</del></p></div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>The 3rd Ucup Stage 5 赛后小结</title>
    <url>/2024/07/27/The-3rd-Ucup-Stage-5-%E8%B5%9B%E5%90%8E%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>比赛链接 ：<a href="https://qoj.ac/contest/1741">https://qoj.ac/contest/1741</a></p>
<p>开局队长秒了 M ，Imakf 秒了 A 。</p>
<p>然后队长秒了 I ，我秒了 F ，然后和队友交流 B ，但这时比较幽默的事情发生了，我以为交换 $x,y$ 是位置，但没想到是数值，应该问清楚的，难怪当时完全没听懂队友做法。</p>
<p>在过完这个题目后，和队友交流 K ，我说了一个 dp 状态，$dp[x][j]$ 表示在 $x$ 往上走 $j$ 条边的最大收益，但是实际我在想另外一个做法，然后 Imakf 和队长说这个玩意完全可以启发式合并，然后我就没再细想了，Imakf 上机写启发式合并。</p>
<p>这里我直接放弃我那个想法有问题吗？我觉得没问题，首先我没想明白，想明白花的时间 + 写的时间不一定小于队友直接上启发式合并，其次我这个搞法好不好写还说不一定呢（复盘发现确实难写，还要写个数据结构维护），而且甚至不一定可行，启发式合并是三人公认可行，所以稳健的搞法是直接上启发式合并，为什么我不上，我只能说我当时确实没想明白，因为一开始就没往启发式合并的角度想。</p>
<p>此时一小时过去了。</p>
<p>能启发式合并的原因是：$dp[x]$ 的有用的 $j$ 和其子树内的车厢个数有关，所以可以启发式合并。</p>
<p>然后 Imakf 接下来写了一段时间的 K ，这玩意我脑补了一下确实难写。</p>
<p>然后是 E ，和队长讨论情况，讨论到最后，队长很果断地上了，坚信这就是所有情况，但我没有一个确切地证明，所以不敢肯定是不是对的，队长送了过了，这里队长的决策是对的，队长伟大，无需多言。原因是证明花的时间很长，而队长已经写了个搜，在搜基础可以很快的加上我们当前已经讨论的所有情况，送一发过了血赚，没过 20 min 没亏到哪去，更何况队长的讨论一般不会漏情况，所以这确实是正确的抉择，只能说打 ACM 不需要证明了。</p>
<p>然后我先和队长讨论了一下 G ，搞了个泰勒展开，但精度不够，突然队长灵机一动，既然泰勒展开的精度在零点附近很高，那么能不能通过某种手段把 $x$ 压到零点附近，很有道理，怎么压呢？快速幂，注意到 $e^{x}=(e^{\frac{x}{2}})^2$ ，然后就可以压到 $\frac{x}{2^{k}}$ 了。（说起来也搞笑，快速幂是队长说了个搞法，我听错成快速幂了，结果发现快速幂很对，只能说沟通不畅有时候可以产生想法了）</p>
<p>然后队长上机写 G ，但是精度仍然不够，我对这种题没啥想法，去搞 C ，后面 Imakf AC 了 K ，和队长合理搞 G ，后面发现先泰勒展开两项再快速幂，调调参过了，队长说这种题以后要早点写 check 。</p>
<p>此时两小时过去了（指 Imakf AC K）</p>
<p>期间我在写 C ，写之前和 Imakf 交流了一下，发现只有 log 个不同的宽要关心，所以可以 $O(nm\log)$ 实现此题，感觉这题并不困难，留到后面纯属唐了。</p>
<p>但是越是开香槟，似地越惨，C 有个细节不对，此时三小时过去了，下机搞了半小时，再上机过了。</p>
<p>剩下一个半小时，队长看出 L 做法，差分约束，上机，我去想 D 。</p>
<p>最后剩半个小时，我上机 D ，过了，全队 try L ，被卡时，拼尽全力，期间尝试各种卡时技巧，不乏唐氏钢棍说 Bellman-Ford 改 SPFA 能快很多的唐氏言论（主要我对最短路不是很了解，当时还唐了，以为一个负环 SPFA 只用跑一遍），最后 Imakf 不知用了何种力量，以 2971ms 惊险 AC 。</p>
<p>最后 11 题结束比赛。</p>
<p>最大的问题：B 应该问清楚题意的，毕竟当时队友不是描述交换 $a[x],a[y]$ ，而是用了另外一种描述，这种异于平常的描述应该问清楚的，不然也不会跨服交流了。</p>
<p>接下来是部分的题解：</p>
<h1 id="M"><a href="#M" class="headerlink" title="M"></a>M</h1><p>最终答案一定是每个数字有个系数，考虑最大的 $k$ 个数字（如果有相同的数字则给他们贴上一个不影响数值的第二关键字，使得比较不存在等于号），其系数和一定 $\ge k-1$ ，原因是考虑只关心有关这 $k$ 个数字的合并，每次合并一定会使得其中至少一个数字的系数 $+1$ ，证毕。</p>
<p>所以答案下界是除最大值以外的数字和，而这显然可以构造，每次拿最大的数字和相邻数字合并即可。</p>
<p>时间复杂度：$O(n\log{n})$</p>
<p>PS：严格来说，这里的第二关键字可以是先把数组排序后的排名，两个集合比较如果和相同比较最小的排名是多少，由于所有数字排名不同，所以不存在等于号（两个集合交集为 $\empty$）。</p>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>注意到只有两个坐标都相同的点会有多的贡献。</p>
<h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p>一个比较简单的区间 dp ，注意到区间长度相同的时候，同层的更新是个最短路，用 Dijkstra 即可。</p>
<p>时间复杂度：$O(n^3)$</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>注意到最后排序前只关心每个数字在左还是在右，在最后一次排序后的操作模拟即可。</p>
<h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>注：后面的木板既有可能指没切的木板，也有可能指切了的木板，请根据语境自行甄别。</p>
<p>一个关键的观察：最终搞法可能是每个木板都切了一刀，然后拼起来，不一定只有边角料部分切了。</p>
<p>不妨假设 $h\le w$ 。</p>
<p>注意到 $h+w\ge 2s$ 的时候答案一定为 $\left\lceil\frac{2h+2w}{s}\right\rceil$ ，因为可以在两个 $h$ 处不断放木板，超出部分切掉放在同一个 $s$ ，然后从放了木板的 $s$ 出发，不断放木板，超出切了放另外一边，然后接着放直到超出，就是这个结果，而且显然这是下界。</p>
<p>然后队长声称剩下的情况只有两种可能的放置方案：</p>
<ol>
<li>四条边按照某个顺序依次放置，超出部分尝试裁了放到下一条边里面。</li>
<li>两条短边超出部分放到一条长边里。</li>
</ol>
<p>然后就过了，不懂，说的道理。</p>
<p>现在来讨论一下为啥是对的，先证明一个引理：</p>
<p>如果一边用了两个木板 $a,b$ ，且 $a+b\le s$ ，那么存在一种不劣的方案把这两个木板合为一体。</p>
<p>证明就是讨论一下，如果 $s-a,s-b$ 的两个木板都扔了，这个显然正确，不妨认为 $s-a$ 没扔，则我们设置一块 $s-(a+b)$ 的木板放在 $s-a$ ，然后剩余的部分有 $b,s-b$ ，所以仍然是对的。</p>
<p>这个引理有个妙用，如果我们已经确定了若干块木板的拜访，现在有一边的长度 $\le s$ ，我们就可以直接用一个木板放置，而接下来的讨论，就是根据这个这个木板放置后，其另外一块木板放在哪里展开的，不断讨论剩余木板的传递性，下面是一个图片展示：</p>
<p><img src="1.png" alt=""></p>
<p>依据这个引理，我们展开讨论，显然，答案为 $2$ 等价于 $h+w=s$ ，而且这个方案可以由上面的方案 $1$ 生成，严谨的证明考虑木板切开只有 $4$ 块，因此一定有两边加起来等于 $s$ ，讨论一下即可。</p>
<p>而我们要讨论 $h+w&lt;2s$ 的情况，显然答案只能是 $3/4$ ，而 $4$ 的方案显然也一定能由方案 $1$ 生成，所以现在讨论能不能是 $3$ ，相对应的方案能否用上面两个方案生成。</p>
<p>答案为 $3$ 的必要条件是 $h+w\le 1.5s,h+w≠s$ 。</p>
<p>因此考虑每次枚举一条边，放置一块木板并讨论另一块木板放在哪的传递链：$h-w,h-w-w$ （起点一定是 $h$ ，因为 $h&lt;s$ ），都能保证下一条边在放置了上一条边剩余的木板时剩余长度 $\le s$ 。</p>
<p>所以考虑讨论的过程，可以公式化成以下过程：</p>
<ol>
<li>如果只剩下长边 $w$，如果 $w\le s$ ，则仍然用引理讨论传递剩下木板，如果 $w&gt;s$ ，则显然答案为 $\left\lceil \frac{2w}{s} \right\rceil$ ，显然也可以用传递木板的方式生成，即第一种方案生成。</li>
<li>如果有短边，从短边出发，依次传递木板，直到放不下扔掉为止，或者主动扔掉。</li>
</ol>
<p>注意到，如果把 “ 主动扔掉 ” 的选择去掉，上述过程就是方案 $1$ 的子集，但是怎么证明如果空间够一定不会主动扔掉木板呢？</p>
<p>我们不妨给四条边编号 $1,2,3,4$ ，怎样编无所谓，后面不区分长短边了，假设存在 $3$ 块木板的方案。</p>
<p>如果每个边只有一块木板，那么恰好有两条边共享一块大木板，不妨认为 $1,2$ ，则按照 $1,2,3,4$ 的顺序一定可以跑出 $3$ 。</p>
<p>由于只有三块大木板，如果要丢掉一块木板，则在场上至多五块木板，所以剩余情况为恰好有一边有两块木板，不妨认为是 $1$ 边，如果 $2,3,4$ 中不共享一块木板，不妨认为 $1$ 和 $2,3$ 分别共享木板，则 $2,1,3,4$ 可以跑出 $3$ 。</p>
<p>如果共享，不妨设 $2,3$ 共享，则 $2,3,4,1$ 可以跑出 $3$ ，综上，只要存在 $3$ 块的方案，就一定可以用方案 $1$ 跑出来答案，证毕。</p>
<p>所以甚至第二种方案是多余的，只在证明 $h+w\ge 2s$ 的时候用到了这个方案，去掉后提交也 AC 了，至此，讨论结束，做毕。</p>
<p>有一说一，讨论起来确实麻烦，当然也有可能是我讨论烦了，这玩意要是再赛时讨论就炸了，直接送确实是明智之举，队长伟大，无需多言。</p>
<h1 id="K"><a href="#K" class="headerlink" title="K"></a>K</h1><p>我其实不知道队友具体实现，大概意思是：$dp[x][j]$ 表示 $x$ 往上霸占 $j$ 条边的最大收益，当然 $j$ 也可以是霸占到深度 $j$ ，这样不用数组偏移，然后 $j$ 的个数只与子树内车厢数量有关，因此可以启发式合并。</p>
<p>队友写的树上启发式合并，显然只用记录 $O(\log)$ 个数组，这样空间就能有保障了。</p>
<p>至于我那个搞法，我就只编所有边长为 $1$ 的情况好了，注意到可以设 $dp[x]$ 表示 $x$ 到父亲这条边被占据的最大收益，然后按照从深往浅的顺序 dp ，每次可以把能到这个深度的列车往上扩一节，时间复杂度：$O(n\log{n})$ ，边长为 $1$ 是好写的，但是不是就难写了，因为要用数据结构维护 $dp[x]$ ，原因是列车往上扩可能直接扩一条链，要维护一条链的增量，而启发式合并一层一层跳，然后全局加减，所以没有这个问题。</p>
<p>本来想赛后自己实现实现的，还要写个数据结构，太难写了，弃了，我人麻了。</p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>观察到最终答案一定是由一个矩形扩展出来的，原因是：可以注意到翻转后的最大面积黑矩形一定是由翻转前的某个黑矩形翻转得到的，溯源即可证明。</p>
<p>问题转变为，现在全是白色的纸上恰好只有一个矩形，如何求其的最小答案？</p>
<p>注意到可以关心最长有黑色的行的连续段和最长有黑色的列的连续段，和上面的证明过程一样，同时如果对称轴平行于行/列，那么只会增长行/列的最长连续段，可以得到下界是将上述两个变量全部变成对应的最大值的操作次数，而且显然这就是答案。</p>
<p>稍稍解释一下，假设矩形是 $[2,3]*[1,4]$ ，那么初始有黑色的行是 $[2,3]$ ，最长的有黑色的行的连续段是 $[2,3]$ ，而后面每次操作后的最长连续段一定是操作前的某个连续段翻转生成，例如如果翻转后为 $[2,5]$ ，那么一定是 $[2,3]$ 沿着 $3,4$ 行中间那条线翻转后生成的 $2,5$ ，而最终这个连续段是 $[1,n]$ ，溯源回去即可得到结论。</p>
<p>所以问题变成行列独立的问题，注意到每一维的答案量级为 $O(\log)$ ，所以钦定右下角，然后关心行的每一个答案所需要的最小行，用其找到最长的列，然后求列的答案即可，时间复杂度：$O(nm\log{n})$ 。</p>
<p>但还有个问题，就是怎么求答案，其实是这么个问题：</p>
<p>一段序列由 $x$ 个白色， $b$ 个黑色， $y$ 个白色依次构成，问最小翻转次数（ $x\le y,y≠0$ ）。</p>
<p>注意到一个下界是 ：$\log_2{(\left\lceil \frac{x}{b} \right\rceil+\left\lceil \frac{y}{b} \right\rceil)}$ ，而且这个下界 $+1$ 是一定能够成功的。</p>
<p>所以问题是什么时候能达到这个下界，不妨考虑在希望能够达到下界的条件下的可能的最优策略，注意到只有两种可能最优策略（考虑 $i$ 次操作后黑色区间长度和 $2^{i}*b$ 差值即可，这个证明在此不再赘述）：</p>
<p>不妨设 $2^{k}\le \left\lceil \frac{x}{b} \right\rceil&lt;2^{k+1}$</p>
<ol>
<li>当 $\left\lceil \frac{x}{b} \right\rceil$ 二进制从小到大第 $i$ 位是 $1$ 时，就在第 $i$ 次往左翻，否则往右翻。</li>
<li>选择某一次 $i&gt;k$ 的时间往左翻，其余向右翻。</li>
</ol>
<p>一个明显的直觉是，第一种策略优于第二种策略，现在证明之。</p>
<p>在第 $k+1$ 次操作中，选择了向左翻，此时黑色长度为 ：$b<em>2^{k+1}-r$ ，其中 $r=\left\lceil \frac{x}{b} \right\rceil</em>b-x$ ，所以往右翻后续的长度为 ：$b<em>2^{i}-r</em>2^{i-(k+1)}$ 。</p>
<p>而第二种，在第 $i$ 次操作后，为 $b*2^{i-1}+x$ ，两者相减可以得到：</p>
<p>$b<em>2^{i-1}-r</em>2^{i-(k+1)}-x&gt;b*(2^{i-1}-2^{i-(k+1)}-2^{k+1})$ ，如果 $k\ge 1$ 这显然 $\ge 0$ ，如果 $k=0$ ，则 $x+r=b$ ，显然也 $\ge 0$ ，所以就是第一种策略更优，所以直接用第一种策略判断一下是不是下界就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> st[N];</span><br><span class="line">	cin &gt;&gt; st;</span><br><span class="line">	<span class="built_in">memcpy</span>(s + <span class="number">1</span>, st, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(st) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a[N], b[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line">PII sta[N];</span><br><span class="line"><span class="type">int</span> top, len[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gt</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!x &amp;&amp; !y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(x &gt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">	<span class="type">int</span> ans = __lg((x + k - <span class="number">1</span>) / k + (y + k - <span class="number">1</span>) / k) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(x % k == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">	<span class="type">int</span> res = k - x % k;</span><br><span class="line">	<span class="type">int</span> lcnt = __lg((x + k - <span class="number">1</span>) / k) + <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> base = (<span class="number">1</span> &lt;&lt; lcnt) * k - res;</span><br><span class="line">	<span class="keyword">if</span>((base &lt;&lt; (ans - lcnt)) &gt;= x + k + y) <span class="keyword">return</span> ans;</span><br><span class="line">	<span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="built_in">get_char_array</span>(st);</span><br><span class="line">		b[i].<span class="built_in">resize</span>(m + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) b[i][j] = st[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n &gt; m)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">			a[i].<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) a[i][j] = b[j][i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">swap</span>(n, m);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">			a[i].<span class="built_in">resize</span>(m + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) a[i][j] = b[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	a[<span class="number">0</span>].<span class="built_in">resize</span>(m + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) a[i][j] += a[i - <span class="number">1</span>][j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		top = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> pre = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">			<span class="type">int</span> cnt = <span class="built_in">gt</span>(i - j, j, n - i);</span><br><span class="line">			<span class="keyword">if</span>(cnt != pre) sta[++top] = &#123;j, cnt&#125;, pre = cnt;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(len, <span class="number">0</span>, <span class="built_in">sizeof</span>(len));</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= top; k++)&#123;</span><br><span class="line">				<span class="keyword">auto</span> [l, c] = sta[k];</span><br><span class="line">				<span class="keyword">if</span>(a[i][j] - a[i - l][j] == l) len[k]++;</span><br><span class="line">				<span class="keyword">else</span> len[k] = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span>(!len[k]) <span class="keyword">continue</span>;</span><br><span class="line">				ans = <span class="built_in">min</span>(ans, c + <span class="built_in">gt</span>(j - len[k], len[k], m - j));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p>不知道队友怎么搞过去的，反正大概思路是泰勒展开两项 $e^{\frac{x}{2^{20}}}$ （到平方项），然后快速幂到 $e^{x}$ 。</p>
<p>听队友说道理是每次快速幂的相对误差会翻倍，但是离原点距离除 $2$ （$(1+\Delta)^2=1+2\Delta$ ，二阶小项忽略不计），两者权衡一下，可以得到最小误差是在泰勒展开两项的时候取得。（怎么得到这个结果的呢？如果我没猜错应该是试出来的，感觉不太能定量计算，而且队友确实在机上捣鼓了一段时间）</p>
<h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>首先可以注意到，最大值点一定只在 $a_{i}$ 处取得，而且只需要知道 $b=10^{5}$ 的构造即可。</p>
<p>这个题目什么个搞法呢？</p>
<p>首先不妨假设相邻两项的最大值分别在下标 $i,i+t$ 处取得，列个式子。（这个列出来是不会亏的，因为任何情况式子都适用，我们并没有在前面假定什么最大值点都是相邻的之类的东西）</p>
<p>则有 ：$a_{i}<em>(n-i+1)+\sum\limits_{k=i}^{i+t-1}a_{k}=a_{i+t}</em>(n-i-t+1)$</p>
<p>整理一下可以得到：$(a_{i+t}-a_{i})<em>(n-i+1)-t</em>(a_{i}+a_{i+t}-a_{i})=\sum\limits_{k=i}^{i+t-1}a_{k}$</p>
<p>再整理一下可以得到：$(a_{i+t}-a_{i})(n-i-t+1)=t*a_{i}+\sum\limits_{k=i}^{i+t-1}a_{k}$</p>
<p>$(a_{i+t}-a_{i})=\frac{t*a_{i}+\sum\limits_{k=i}^{i+t-1}a_{k}}{(n-i-t+1)}$</p>
<p>这个时候，敏锐的察觉到一种可能的答案模式，每隔一个小间隔得到一个最大值点，中间不是最大值点的 $a_{k}$ 只有很小的不会影响最大值的增幅，来让右边这个式子是整除的，所以可以认为上面基本是 $2t*a_{i}$ 量级的，而下面只要在最后一个最大值来临之后，$n-i+1$ 足够大，我们就可以认为分母也是足够量级的。</p>
<p>来尝试一手，不妨认为 $t=2$ （因为只要有 $a_{i+1}$ 就足够调整余数了，不够 $t$ 再变大）</p>
<p>为了让分母量级固定，不妨让 $n=5*10^5$ ，直接拉满</p>
<p>注意到调整余数会让 $a_{i+1}$ 增加不超过 $n$ 的增幅，为了让这个增幅不会成为最大值，我们需要让 $\frac{2a_{i}}{n-i}$ （也就是 $t=1$ 的增幅）大于 $n$ ，所以不妨让 $a_{1}&gt;\frac{n^2}{2}$ 。因此我选择了 $2*10^{11}$ 。</p>
<p>同时为了让 $a_{i+2}&gt;a_{i+1}$ ，同样需要让 $\frac{4a_{i}}{n-i-1}$ 大于 $n$ ，这显然被上面的要求包含，所以不用管。</p>
<p>在得到 $10^5$ 的最大值点后，贪心的，显然只要让后面的增量固定为 $1$ 就行了。</p>
<p>现在只有这么两个问题：</p>
<ol>
<li>后面增量为 $1$ 的部分有没有可能成为最值。</li>
<li>数字是否都在值域里。</li>
</ol>
<p>第一个问题非常的简单，从最后一个最值出发，有：$\frac{2ta_{i}}{n-i-t+1}$ 远大于 $n$ ，所以不会，而且从这个式子不难看出，越到后面，分子越大，分母越小，显然成为最大值的增量是总体上升的，前面的增量都大于 $n$ ，后面就不可能只有 $n$ 了，所以第一个问题不需要担心。</p>
<p>第二个问题显然跑一下就行了，当然也可以大概的估计一下，分母 $\le 3<em>10^5$ ，则相邻两项增量至多为 $\frac{2a_{i}}{3</em>10^{5}}+1$ ，不妨认为前面的数字都 $\le 7<em>10^{11}$ ，则有增量为 $\le 10^{5}</em>(\frac{14<em>10^{11}}{3</em>10^{5}} + 1)\le 4.9<em>10^{11}+10^{5}\le 5</em>10^{11}$ ，加上初始值，就似乎 $\le 7*10^{11}$ ，后面增量为 $1$ ，显然不会爆，证毕。</p>
<p>然后就做完了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> LL L = <span class="number">1e12</span>;</span><br><span class="line">LL a[N], sum[N];</span><br><span class="line"><span class="type">int</span> n = <span class="number">5e5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">1e5</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; n &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	a[<span class="number">1</span>] = <span class="number">2e11</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> t = <span class="number">2</span>; t &lt;= b; t++)&#123;</span><br><span class="line">		<span class="type">int</span> i = t * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> base = n - i + <span class="number">1</span>;</span><br><span class="line">		LL val = a[i - <span class="number">2</span>] * <span class="number">4</span> + <span class="number">1</span>;</span><br><span class="line">		LL res = <span class="number">0ll</span>;</span><br><span class="line">		<span class="keyword">if</span>(val % base != <span class="number">0</span>) res = base - (val % base);</span><br><span class="line">		a[i - <span class="number">1</span>] = a[i - <span class="number">2</span>] + res + <span class="number">1</span>;</span><br><span class="line">		val += res;</span><br><span class="line">		a[i] = a[i - <span class="number">2</span>] + val / base;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = b * <span class="number">2</span>; i &lt;= n; i++) a[i] = a[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="comment">// fflush(stdout);</span></span><br><span class="line">	<span class="comment">// sum[1] = a[1];</span></span><br><span class="line">	<span class="comment">// for(int i = 2; i &lt;= n; i++)&#123;</span></span><br><span class="line">	<span class="comment">// 	assert(a[i] &gt; a[i - 1]);</span></span><br><span class="line">	<span class="comment">// 	sum[i] = sum[i - 1] + a[i];</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="comment">// assert(a[n] &lt;= L);</span></span><br><span class="line">	<span class="comment">// LL maxnum = 0ll;</span></span><br><span class="line">	<span class="comment">// int cnt = 0;</span></span><br><span class="line">	<span class="comment">// for(int i = 1; i &lt;= n; i++)&#123;</span></span><br><span class="line">	<span class="comment">// 	LL val = a[i] * (n - i + 1) + sum[n] - sum[i - 1];</span></span><br><span class="line">	<span class="comment">// 	if(val &gt; maxnum) maxnum = val, cnt = 1;</span></span><br><span class="line">	<span class="comment">// 	else if(val == maxnum) cnt++;</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line">	<span class="comment">// cerr &lt;&lt; cnt &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">	<span class="comment">// fflush(stdout);</span></span><br><span class="line">	<span class="comment">// assert(cnt &gt;= b);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="L"><a href="#L" class="headerlink" title="L"></a>L</h1><p>非常牛的题，当时看到 $2*10^3$ 的数据范围，以为是找个结论然后 $dp$ ，鉴定为 ATcoder 做多了。</p>
<p>但是队长差分约束大师，一语道破天机，你说有没有可能是二分然后差分约束，最后找个离他最近的分数转成模意义下的答案，但这依赖于分母要是 $O(m)$ 量级的。</p>
<p>然后队长就上机了，后面 Imakf 证明了分母是 $O(m)$ 量级的，相当于直接把图建出来后，每个环有多少正边和负边，然后答案就是使得没有环是负环的最大值，显然这时一定有环是零环，所以分母一定是点数量级的，也就是至多 $2m$ 的。</p>
<p>但是 $O(m^2\log{m})$ 卡时限卡出痛苦面具，最后不知道改了什么，最后一分钟一发入魂 2971 ms AC ，Imakf 伟大，无需多言。</p>
<p>队长名言：看到比例就应该想到分数规划，然后就应该想到差分约束啊。</p>
<p>队长伟大，无需多言。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>Triathlon</title>
    <url>/2025/02/04/Triathlon/</url>
    <content><![CDATA[<p><a href="https://acm.timus.ru/problem.aspx?space=1&amp;num=1062">1062. Triathlon @ Timus Online Judge</a></p>
<p>一道不错的半平面交好题。</p>
<p>这里主要记录的不是题解，而是我自己的解题过程以及没做出来的发泄，主要面向群众是我自己，如果想要看题解请移步其余题解，请见谅。</p>
<p>首先，这道题目看到的第一个思想是如果有人三项比起都高，那么其就是NO，否则YES，肉眼可见的错误。</p>
<p>考虑枚举每个人与其余人的插值：</p>
<p>设 $a’_i=\frac{1}{a_i}$ ，其余类似。</p>
<p>那么其实就是要求 $(a’_i-a_j)x+(b’_i-b_j)y+(c’_i-c_j)z≥0$ </p>
<p>这条式子我当时以为是半立体交，不会，打算学，但是没找到。</p>
<p>发现必过 $(0,0,0)$ 点，没用，发现用一个平面截其实就是半平面交，推测可以证明只用有限个半平面交就能验证或者得出答案，但是思考了良久系数间的关系，什么结论证明都没有想出来，绝望了起来。</p>
<p>看了眼题解，标题半平面交，吓的我立马关掉。</p>
<p>总觉得三维不好想，先想想二维然后推广至三维，当把二维图一想，人傻了，如果 $(x,y)$ 可以，$(\frac{x}{2},\frac{y}{2})$ 也可以，也就是一条直线都可以，因此直接假定 $x=1$ 然后半平面交即可。</p>
<p>为什么没做出来？</p>
<p>三维空间想象能力太差，在做题的时候总是忘记可以先思考低维做法然后再推向高维，同时对于结论不够敏感。</p>
<p>总而言之就是我太弟了，菜！</p>
<p>呜呜呜┭┮﹏┭┮</p>
<p>代码后面补，不太想打了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>不过平心而论，确实妙，过 $(0,0,0)$ 点的半立体交因为如果 $(x,y,z)$ 在区域内，那么 $(kx,ky,kz)$ 也在区域内，所以一定是一个类似锥体的东西从原点发射出去，所以随便选定一个 $x$ 然后跑半平面交即可，这样就实现了 $3-&gt;2$ 的降维打击。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>半平面交</tag>
      </tags>
  </entry>
  <entry>
    <title>Travelling Tours</title>
    <url>/2025/02/03/Travelling-Tours/</url>
    <content><![CDATA[<p><a href="https://acm.timus.ru/problem.aspx?space=1&amp;num=1077">1077. Travelling Tours @ Timus Online Judge</a></p>
<p>大致题意就是一个无向图，让你找 $T$ 个环（环上点不能重复），要求每个环都至少含有一条边是其余边没有的，并且 $T$ 最大，然后让你输出这 $T$ 个环，有SPJ。</p>
<p>思路十分简单：</p>
<p>提示1：这道题目存在一个结论。</p>
<p>提示2：结论：一个 $n$ 个点 $m$ 条边的无向连通图一定有 $m-n+1$ 个环。</p>
<p>提示3：这道题的算法是 $DFS$ 加贪心算法。</p>
<p>提示4：考虑树加一条边变成一个环。</p>
<p>先证明一下结论：</p>
<p>考虑一个图的生成树，在树上加一条边就会变出一个环，这样就可以形成 $m-n+1$ 个环，但是这是不是上限呢？证明一下：</p>
<p>考虑已经选了 $T$ 个环，那么怎么选择 $T+1$ 个环呢，将环上不同于其他环的边称为特殊边，选新环即是在删掉了特殊边的原图上找环。在这之前证明一个性质：删掉特殊边不影响图的连通性。</p>
<p>先证明不破坏连通性的性质：如果删除了特殊边 $x,y$ ，假设 $tx,ty$ 连通性被破坏，因为环所以 $x,y$ 之间存在两条路径，则原来存在一条不经过 $x-y$ 的 $tx-x-y-ty$ 的路径，所以删除后连通性并没有被破坏，矛盾，证毕。</p>
<p>所以，我们假设现在有 $T$ 个环（ $T&gt;m-n+1$ ），从中挑出 $m-n+1$ 个，删除掉其的特殊边，则剩余$n-1$ 条边，则图变成了一棵树，则不可能存在一个环，与 $T&gt;m-n+1$ 矛盾，因此结论成立。</p>
<p>这样，这道题目就简单许多了，我们只需要暴力DFS就行了。</p>
<p>时间复杂度：$O(n+m+$环上点数的总和$)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 210</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 41000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> y,next;</span><br><span class="line">&#125;a[M];<span class="type">int</span> len=<span class="number">1</span>,last[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;len++;a[len].y=y;a[len].next=last[x];last[x]=len;&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"><span class="type">int</span> ans[<span class="number">1100000</span>],ll[M],rr[M],cnt,top,dep[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">findans</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span><span class="comment">/*x-&gt;y*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep[x]&lt;dep[y])<span class="keyword">return</span> ;<span class="comment">//上到下，下到上，防止重复</span></span><br><span class="line">	cnt++;ll[cnt]=top+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(x!=y)</span><br><span class="line">	&#123;</span><br><span class="line">		ans[++top]=x;</span><br><span class="line">		x=fa[x];</span><br><span class="line">	&#125;</span><br><span class="line">	ans[++top]=y;</span><br><span class="line">	rr[cnt]=top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=last[x];k;k=a[k].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> y=a[k].y;</span><br><span class="line">		<span class="keyword">if</span>(y!=fa[x])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!dep[y])</span><br><span class="line">			&#123;</span><br><span class="line">				fa[y]=x;dep[y]=dep[x]+<span class="number">1</span>;</span><br><span class="line">				<span class="built_in">dfs</span>(y);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">findans</span>(x,y);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">		<span class="built_in">ins</span>(x,y);<span class="built_in">ins</span>(y,x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!dep[i])</span><br><span class="line">		&#123;</span><br><span class="line">			dep[i]=<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">dfs</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,rr[i]-ll[i]+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=rr[i];j&gt;=ll[i];j--)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[j]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>吐槽：</p>
<p>语文不好，请见谅。</p>
<p>你以为我很会这道题，TM我是看题解的。</p>
<p>TMD没做出来，怎么当时就一点都没有想到DFS树呢？为什么当时想的结论一个比一个奇葩呢？？？</p>
<p>。。。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>UR1 缩进优化</title>
    <url>/2023/08/22/UR1-%E7%BC%A9%E8%BF%9B%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>题目链接：<a href="https://uoj.ac/contest/3/problem/21">https://uoj.ac/contest/3/problem/21</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>调和级数</tag>
      </tags>
  </entry>
  <entry>
    <title>UR1 外星人</title>
    <url>/2023/08/22/UR1-%E5%A4%96%E6%98%9F%E4%BA%BA/</url>
    <content><![CDATA[<p>题目链接：<a href="https://uoj.ac/problem/22">https://uoj.ac/problem/22</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>经典 trick 。</p>
<p>简单来说，对于 $x$ 个有标号的数字，让指定的数字站在开头的概率是多少？</p>
<p>答案：$\frac{1}{x}$ 。</p>
<p>证法：</p>
<ol>
<li>从随机性的角度考虑，第一个位置是某个数字的概率为 $\frac{1}{x}$ 。</li>
<li>从式子的角度分析：$\frac{(x-1)!}{x!}=\frac{1}{x}$ 。</li>
</ol>
<p>现在规定有 $y$ 个数字必须在某些数字前面，且对于第 $i$ 个数字，其必须在前面的数字包括其自己所构成的集合为 $S_i$ 。</p>
<p>如果满足：$S_{i}\subseteq S_{i-1}$ 。</p>
<p>那么概率的计算公式为：$\prod \frac{1}{|S_{i}|}$ 。</p>
<p>证法：</p>
<p>我们顺序考虑，假如第一个数字是 $x$ ，$S_1/x$ 的元素都要在其后面，那么为 $\frac{1}{S_1}$ ，显然剩下元素仍然是随机的，现在把 $S_1/S_2$ 的元素删掉，考虑 $S_2$ 的元素，其仍然是随机的，且不受前面影响，完全是一个子问题，那么直接乘就行了。</p>
<p>证毕。</p>
<p>这是一个很经典的概率 trick ，但是一定要谨记其的使用范围。</p>
<p>比如我稍微改变一下上面的条件，让 $S_i$ 不包含 $x$ 就已经错了。</p>
<p>例如：$1,2$ 都要在 $3$ 前面，那么：$\frac{1}{4}$ ，显然是错的。</p>
<p>为什么？原因是接下来的序列并不是一个完全的子问题，原因是：</p>
<p>例如 $13$ ，这个时候放 $2$ ，$23$ 的情况有两种：$213,123$ ，而 $32$ 的情况只有一种：$132$ ，所以并不满足不受前面影响这句话。</p>
<p>当然，也可以采用式子严谨证明：</p>
<p>显然，结果为：</p>
<p>定义 $|S_0|=n+1$ 。</p>
<p>公式为：$(\prod\limits_{i=1}^{m} C_{|S_{i-1}|-1}^{|S_i|}<em>(|S_{i-1}|-1-|S_{i}|)!)</em>\frac{(S_{m}-1)!}{S_{m}!}$ 。</p>
<p>展开可以发现就是结论中的式子。而上面的反例显然就是不满足这条计算公式，所以也就不能使用结论中的计算式进行计算。</p>
<p>利用这个 trick ，这道题目就随便做了，做法就不详写了，自己想想。</p>
<p>UPD：看了官方题解突然发现，貌似这道题目不用这个 trick 也能做，本质上是把官方题解的式子优化了一下。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>经典trick</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title>UR3-铀仓库</title>
    <url>/2023/08/25/UR3-%E9%93%80%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<p>题目链接：<a href="https://uoj.ac/contest/5/problem/49">https://uoj.ac/contest/5/problem/49</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>CNM，血压高了，一直卡在官方题解中的算法 2 ，根本就没有想到是二分答案，悲。</p>
<p>首先，一个十分显然的事情，这题有两种不同的二分方法：</p>
<ol>
<li>如果指定左右两边最远的到达距离，你可以在 $O(n)$ 的时间内对所有位置处理出其对应的区间，但是由于二分最远到达距离只能作用在一个数上，所以时间复杂度是： $O(n\log{n}\log_{X})$ ，也就是算法二。</li>
<li>既然答案要求箱子数，就二分箱子数 $K$ ，同理，可以在 $O(n)$ 的时间处理出对应的区间，然后算一下最小代价就行了，时间复杂度：$O(n\log{X})$ ，这就是题解的做法。</li>
</ol>
<p>为什么啊，纯二分题没有做出来，你真的是越来越菜了QAQ。</p>
<p>处理细节：考虑处理出包含 $x$ 的最长的区间，满足两个要求：</p>
<ol>
<li>区间内的箱子数和 $&lt;K$。</li>
<li>区间为这个位置搬箱子最优方案的一种。</li>
</ol>
<p>什么叫搬箱子的最优方案，显然：优先搬最近的。</p>
<p>所以每次把最近的不在区间中的位置加入区间所得到的任意一个方案都是最优方案。</p>
<p>可以证明，这个区间的左右端点会随着位置右移而非严格递增。</p>
<p>然后直接写就行了。</p>
<p>时间复杂度：$O(n\log{X})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 510000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">LL a[N],fa[N],ff[N],b[N],sum,T;</span><br><span class="line">LL limit;</span><br><span class="line"><span class="type">int</span> n,left,right;</span><br><span class="line"><span class="function">LL <span class="title">dis</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> b[y]-b[x];&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve1</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;<span class="keyword">while</span>(<span class="built_in">dis</span>(left,i)&gt;<span class="built_in">dis</span>(i,right) &amp;&amp; sum&gt;limit)sum-=a[left++];&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sum=<span class="number">0</span>;left=<span class="number">1</span>;right=<span class="number">0</span>;</span><br><span class="line">    LL mincost=T+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(right&lt;i)right++,sum+=a[right];</span><br><span class="line">        <span class="built_in">solve1</span>(i);</span><br><span class="line">        <span class="keyword">while</span>(right&lt;n &amp;&amp; (left==<span class="number">1</span> || <span class="built_in">dis</span>(left<span class="number">-1</span>,i)&gt;<span class="built_in">dis</span>(i,right+<span class="number">1</span>)) &amp;&amp; sum&lt;=limit)&#123;</span><br><span class="line">            right++,sum+=a[right];</span><br><span class="line">            <span class="built_in">solve1</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;limit)sum-=a[right--];</span><br><span class="line">        LL now=ff[right]-ff[i]-b[i]*(fa[right]-fa[i])+b[i]*(fa[i<span class="number">-1</span>]-fa[left<span class="number">-1</span>])-(ff[i<span class="number">-1</span>]-ff[left<span class="number">-1</span>]);</span><br><span class="line">        LL fnow=T+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;<span class="number">1</span>)fnow=<span class="built_in">min</span>(<span class="built_in">dis</span>(left<span class="number">-1</span>,i)*(limit-sum),fnow);</span><br><span class="line">        <span class="keyword">if</span>(right&lt;n)fnow=<span class="built_in">min</span>(<span class="built_in">dis</span>(i,right+<span class="number">1</span>)*(limit-sum),fnow);</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="number">1</span> &amp;&amp; right==n)fnow=<span class="number">0</span>;</span><br><span class="line">        mincost=<span class="built_in">min</span>(mincost,now+fnow);</span><br><span class="line">        <span class="comment">// printf(&quot;%d:%d %d %lld %lld %lld %lld\n&quot;,i,left,right,sum,mincost,now,fnow);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mincost*<span class="number">2</span>&lt;=T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;std.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;n,&amp;T);</span><br><span class="line">    LL l=<span class="number">0</span>,r=<span class="number">0</span>,ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);l=<span class="built_in">max</span>(a[i],l);r+=a[i];fa[i]=fa[i<span class="number">-1</span>]+a[i];&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)ff[i]=ff[i<span class="number">-1</span>]+b[i]*a[i];</span><br><span class="line">    <span class="comment">// printf(&quot;%lld %lld\n&quot;,l,r);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// limit=11;printf(&quot;%d\n&quot;,check());</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        limit=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>())ans=limit,l=limit+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r=limit<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>UR4-元旦三侠的游戏</title>
    <url>/2023/08/25/UR4-%E5%85%83%E6%97%A6%E4%B8%89%E4%BE%A0%E7%9A%84%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>题目链接：<a href="https://uoj.ac/problem/51">https://uoj.ac/problem/51</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>这道题目主要涉及到了一个转化的问题。</p>
<p> SG 函数一般是使用在了没得走的时候为必败态，但是如果题目是走到了某个状态就输了要怎么转化呢？</p>
<p>答案是，我们认为玩家绝顶聪明，那显然不会去走那些输了的状态，也就是状态树中只会去走那些不会立即输的状态。（对应在本题中就是走后一定要 $a^b\le n$） </p>
<p>那么显然，当一个点没的走的时候，其是不是就一定输了，因为其下一步必定要走到判定为输的局面，这样我们就转化为了 $SG$ 的常见模型：没得走的状态为必败态。</p>
<p>这道题目也是同理，经过这种转化后，就是一个非常裸的 SG 函数了。</p>
<p>可以直接按题解写的做：$O(\sqrt{n}\log{n})$ ，但是感觉也存在更加优秀的做法。</p>
<p>就是观察发现状态只有 $0,1,2$ 三种，而且 $2$ 不会相邻，观察不难发现，同一个 $b$ 至多一个 $2$ ，记录一下 $2$ 的位置以及同一个 $b$ 的 SG 函数的一些参数，应该是可以做到 $O(\text{预处理}+m\log{n})$ 的时间做出来这道题目的。</p>
<p>但是感觉上就非常难写，以及有很多细节，有兴趣的读者可以自行尝试，我就不尝试了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 110000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 40</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,a[M][N];</span><br><span class="line"><span class="type">int</span> b[M],top;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> now=n;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(now&lt;x)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            now/=x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(y!=<span class="number">1</span> &amp;&amp; now/x&lt;x)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        x=x*x;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">1</span> &amp;&amp; x&gt;b[<span class="number">2</span>])<span class="keyword">return</span> (n-x)&amp;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a[y][x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findans</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(now==x || now==y)now++;</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printf(&quot;%d\n&quot;,ksm(2,31));</span></span><br><span class="line"></span><br><span class="line">    b[top=<span class="number">1</span>]=n;</span><br><span class="line">    <span class="keyword">while</span>(b[top]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        b[++top]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">ksm</span>(b[top]+<span class="number">1</span>,top))b[top]++;</span><br><span class="line">    &#125;</span><br><span class="line">    top--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=top;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="built_in">min</span>(b[i],b[<span class="number">2</span>]);j&gt;=<span class="number">2</span>;j--)&#123;</span><br><span class="line">            <span class="type">int</span> x=<span class="number">-1</span>,y=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i==top || j&gt;b[i+<span class="number">1</span>]))x=a[i+<span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j!=b[i] &amp;&amp; !(i==<span class="number">1</span> &amp;&amp; j&gt;b[<span class="number">2</span>]))y=a[i][j+<span class="number">1</span>];</span><br><span class="line">            a[i][j]=<span class="built_in">findans</span>(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=top;i++)&#123;</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d %d: &quot;,i,b[i]);</span></span><br><span class="line">    <span class="comment">//     for(int j=2;j&lt;=b[i];j++)printf(&quot;%d &quot;,a[i][j]);</span></span><br><span class="line">    <span class="comment">//     printf(&quot;\n&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">solve</span>(a,b))<span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>SG</tag>
        <tag>博弈</tag>
        <tag>经典模型转化</tag>
      </tags>
  </entry>
  <entry>
    <title>UR4 元旦激光炮</title>
    <url>/2023/08/24/UR4-%E5%85%83%E6%97%A6%E6%BF%80%E5%85%89%E7%82%AE/</url>
    <content><![CDATA[<p>题目链接：<a href="https://uoj.ac/problem/52">https://uoj.ac/problem/52</a></p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>题解做法不难想到，每次把 $K$ 均摊到三个数组，查询三次，最小的那个数字显然一定在 $\le K$  的范围内。</p>
<p>操作次数：$n\log_{\frac{n}{n-1}}{K}$ 左右。</p>
<p>但是这个做法存在优化的空间：</p>
<ol>
<li>我们每次查询三个数组位置的和为 $K$ ，这个限制太强了，可以考虑放宽这个限制。</li>
<li>我们只利用到了最小的数字一定在 $\le K$ 的性质，没有利用到 最大的数字一定在 $\ge K$ 的性质。（但是上面那个做法每个数组查询的位置非严格单调递减，所以上面那个算法无法利用该性质进行优化。）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;kth.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> cnt[<span class="number">3</span>],ff[<span class="number">3</span>],fucknow[<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getans</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(type==<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">get_a</span>(x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">get_b</span>(x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">get_c</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> lastans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve1</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="type">int</span> pre=<span class="number">-1</span>,preval=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i]&lt;ff[i])&#123;</span><br><span class="line">                <span class="type">int</span> now=<span class="built_in">getans</span>(cnt[i],i);</span><br><span class="line">                <span class="keyword">if</span>(pre==<span class="number">-1</span> || <span class="built_in">now</span>&lt;preval)preval=now,pre=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[pre]++;k--;</span><br><span class="line">        lastans=preval;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lastans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> id[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> (ff[x]-cnt[x])&gt;(ff[y]-cnt[y]);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve2</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++)id[i]=i;</span><br><span class="line">    <span class="keyword">while</span>(k&gt;<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="type">int</span> now=k;</span><br><span class="line">        <span class="built_in">sort</span>(id,id+<span class="number">3</span>,cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="type">int</span> x=id[i],s=<span class="built_in">min</span>(ff[x]-cnt[x],now/(i+<span class="number">1</span>));</span><br><span class="line">            now-=s;fucknow[x]=cnt[x]+s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> pre=<span class="number">-1</span>,preval=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i]==ff[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> now=<span class="built_in">getans</span>(fucknow[i]<span class="number">-1</span>,i);</span><br><span class="line">            <span class="keyword">if</span>(pre==<span class="number">-1</span> || preval&gt;now)preval=now,pre=i;</span><br><span class="line">        &#125;</span><br><span class="line">        k-=fucknow[pre]-cnt[pre];cnt[pre]=fucknow[pre];</span><br><span class="line">        lastans=preval;</span><br><span class="line">        <span class="comment">// printf(&quot;%d\n&quot;,k);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">solve1</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_kth</span><span class="params">(<span class="type">int</span> n_a, <span class="type">int</span> n_b, <span class="type">int</span> n_c, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    ff[<span class="number">0</span>]=n_a;ff[<span class="number">1</span>]=n_b;ff[<span class="number">2</span>]=n_c;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">solve2</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于二分的做法：</p>
<p>接下来阐释做法时默认数字不同，相同的情况加个浮动可以转化为不同的情况。</p>
<p>每个数组都有个 $[L,R]$ ,考虑查询每个数组的 $mid$ ，$mid$ 总和为 $sum$ ， $sum\ge sum$ ，那么最大的数字一定在 $\ge sum$ 的位置。</p>
<p>$&lt;sum$ ，那么最小的位置一定在 $&lt;sum$ 的位置。</p>
<p>然后二分就行了。</p>
<p>最后把所有 $\ge K$ 的数字拉出来跑个最小值就行了。（不用搜索次数，之前自动记录）</p>
<p>至于为什么是对的？</p>
<p>证明：</p>
<p>首先，最后每个数字都会分为两类 $&lt;K,\ge K$ ，那么显然 $\ge K$ 的数字中最小的那个就是 $=K$ 的数字，证毕。</p>
<p>注：准确来说，$\ge K$ 又分为 $\ge K$ 和 $\ge K+1$ ，同时，根据过程和定义，显然 $&lt;K$ 里面有恰好 $K-1$ 个数字。</p>
<p>操作次数：$n\log_{2}{K}$ 左右，显然，这个做法完全优于上面的做法。</p>
<p>还没有明白怎么做的可以直接看代码，很好看懂的，我讲的确实有点抽象。</p>
<p>代码来自：<a href="https://uoj.ac/submission/243331">https://uoj.ac/submission/243331</a> 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kth.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">   </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,s,t) for(int i=(s),_t=(t);i&lt;_t;++i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> per(i,s,t) for(int i=(t)-1,_s=(s);i&gt;=_s;--i)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bug(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot; = &quot;</span>&lt;&lt;(x)&lt;&lt;<span class="string">&quot; &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) cerr&lt;&lt;#x&lt;&lt;<span class="string">&quot; = &quot;</span>&lt;&lt;(x)&lt;&lt;<span class="string">&quot;\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> db;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">rd</span><span class="params">(T &amp;x)</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> f;<span class="type">static</span> <span class="type">char</span> c;</span><br><span class="line">	f=<span class="number">1</span>;x=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(c=<span class="built_in">getchar</span>(),c&lt;<span class="number">48</span>)<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">do</span> x=x*<span class="number">10</span>+(c&amp;<span class="number">15</span>);</span><br><span class="line">	<span class="keyword">while</span>(c=<span class="built_in">getchar</span>(),c&gt;<span class="number">47</span>);</span><br><span class="line">	x*=f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">prin</span><span class="params">(T x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">0</span>)<span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>),x=-x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(!x)&#123;<span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);<span class="keyword">return</span> ;&#125;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> stk[<span class="number">100</span>],tp;</span><br><span class="line">	<span class="keyword">while</span>(x)stk[tp++]=x%<span class="number">10</span>,x/=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">while</span>(tp)<span class="built_in">putchar</span>(stk[--tp]^<span class="number">48</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">ptk</span><span class="params">(T x)</span></span>&#123;<span class="built_in">prin</span>(x);<span class="built_in">putchar</span>(<span class="string">&#x27; &#x27;</span>);&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">ptn</span><span class="params">(T x)</span></span>&#123;<span class="built_in">prin</span>(x);<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">Min</span><span class="params">(T &amp;a,T b)</span></span>&#123;<span class="keyword">if</span>(b&lt;a)a=b;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="function"><span class="type">void</span> <span class="title">Max</span><span class="params">(T &amp;a,T b)</span></span>&#123;<span class="keyword">if</span>(a&lt;b)a=b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=(<span class="type">int</span>)<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A[N],B[N],C[N];</span><br><span class="line"><span class="comment">//int get_a(int x);</span></span><br><span class="line"><span class="comment">//int get_b(int x);</span></span><br><span class="line"><span class="comment">//int get_c(int x);</span></span><br><span class="line"><span class="comment">//int get_a(int x)&#123;</span></span><br><span class="line"><span class="comment">//	return 1;</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//int get_b(int x)&#123;</span></span><br><span class="line"><span class="comment">//	return 1;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//int get_c(int x)&#123;</span></span><br><span class="line"><span class="comment">//	return 1;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find_a</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(A[x])<span class="keyword">return</span> A[x];</span><br><span class="line">	<span class="keyword">return</span> A[x]=<span class="built_in">get_a</span>(x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find_b</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(B[x])<span class="keyword">return</span> B[x];</span><br><span class="line">	<span class="keyword">return</span> B[x]=<span class="built_in">get_b</span>(x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find_c</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(C[x])<span class="keyword">return</span> C[x];</span><br><span class="line">	<span class="keyword">return</span> C[x]=<span class="built_in">get_c</span>(x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_kth</span><span class="params">(<span class="type">int</span> na, <span class="type">int</span> nb, <span class="type">int</span> nc, <span class="type">int</span> K)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> L[<span class="number">3</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,R[<span class="number">3</span>]=&#123;na,nb,nc&#125;,mid[<span class="number">3</span>],could[<span class="number">3</span>];</span><br><span class="line">	<span class="type">int</span> ans=(<span class="type">int</span>)<span class="number">1e9</span>;pii arr[<span class="number">3</span>];</span><br><span class="line">	<span class="keyword">while</span>(L[<span class="number">0</span>]&lt;=R[<span class="number">0</span>]||L[<span class="number">1</span>]&lt;=R[<span class="number">1</span>]||L[<span class="number">2</span>]&lt;=R[<span class="number">2</span>])&#123;</span><br><span class="line">		<span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(L[i]&lt;=R[i])mid[i]=(L[i]+R[i])&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> mid[i]=could[i];</span><br><span class="line">			sum+=mid[i];</span><br><span class="line">		&#125;</span><br><span class="line">		arr[<span class="number">0</span>]=<span class="built_in">pii</span>(<span class="built_in">Find_a</span>(mid[<span class="number">0</span>]),<span class="number">0</span>);</span><br><span class="line">		arr[<span class="number">1</span>]=<span class="built_in">pii</span>(<span class="built_in">Find_b</span>(mid[<span class="number">1</span>]),<span class="number">1</span>);</span><br><span class="line">		arr[<span class="number">2</span>]=<span class="built_in">pii</span>(<span class="built_in">Find_c</span>(mid[<span class="number">2</span>]),<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">sort</span>(arr,arr+<span class="number">3</span>);</span><br><span class="line">		<span class="keyword">if</span>(sum&gt;=K)&#123;<span class="comment">//找最大的 </span></span><br><span class="line">			<span class="built_in">Min</span>(ans,arr[<span class="number">2</span>].fi);</span><br><span class="line">			<span class="built_in">per</span>(i,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(L[arr[i].se]&lt;=R[arr[i].se])&#123;</span><br><span class="line">					R[arr[i].se]=mid[arr[i].se]<span class="number">-1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;<span class="comment">//找最小的 </span></span><br><span class="line">			<span class="built_in">rep</span>(i,<span class="number">0</span>,<span class="number">3</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(L[arr[i].se]&lt;=R[arr[i].se])&#123;</span><br><span class="line">					could[arr[i].se]=mid[arr[i].se];</span><br><span class="line">					L[arr[i].se]=mid[arr[i].se]+<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>交互</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>WC2016 论战捆竹竿</title>
    <url>/2024/03/18/WC2016-%E8%AE%BA%E6%88%98%E6%8D%86%E7%AB%B9%E7%AB%BF/</url>
    <content><![CDATA[<p>题目链接：<a href="https://www.luogu.com.cn/problem/P4156">https://www.luogu.com.cn/problem/P4156</a></p>
<p>题目大意：每一开始你有一个字符串 $s$ ，然后你可以在字符串末尾加入 $s$ 并删除末尾一个 $s$ 的 Border ，问你最终能得到多少个不超过 $w$ 的不同长度。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>首先，如何计数？观察到我们只要知道对于 $\forall k\in \{0,1,…,n-1\}$ ，最小的长度 $len_k$ 满足：$len_k\equiv k\mod{n}$ 。</p>
<p>这样就能够在 $O(n)$ 的时间内计算答案了。</p>
<p>这时一个很暴力的想法是求出所有的 Border 然后做同余最短路，时间复杂度 $O(n^2)$ 。</p>
<p>这个时候就要利用 Border 的性质做一些优化了，Border 有一个性质：能够把所有 Border 划分成恰好 $\log$ 段等差数列。</p>
<p>不妨将长度设为 $l,l+d,l+2d,…,l+(s-1)d$ 。</p>
<p>这时候还要观察到一个事情：如果把这个问题想象成背包，这个背包的体积和价值是一样的，这能够产生一个什么性质呢？不妨认为 $len_k\equiv t\mod{l}$ ，我们只要先在$\mod{l}$ 意义下跑出最小的 $len’_t$ ，然后再用 $len’_t$ 去更新 $len_k$ 即可。</p>
<p>前一部分可以用单调队列，后一部分连单调队列都不用。</p>
<p>时间复杂度：$O(Tn\log{n})$ 。</p>
<p>空间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> LL inf=<span class="number">1e18</span>+<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> !x?y:<span class="built_in">gcd</span>(y%x,x);&#125;</span><br><span class="line"><span class="type">int</span> fail[N],n;LL m,dp[N],tmp[N];</span><br><span class="line"><span class="type">char</span> st[N];</span><br><span class="line">PII lis[NN];</span><br><span class="line"><span class="type">int</span> head,tail;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> s,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;i++)tmp[i]=inf+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)tmp[dp[i]%l]=<span class="built_in">min</span>(tmp[dp[i]%l],dp[i]);</span><br><span class="line">    <span class="type">int</span> g=<span class="built_in">gcd</span>(l,d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g;i++)&#123;</span><br><span class="line">        head=<span class="number">1</span>;tail=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> now=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> lim=l/g*<span class="number">2</span>,ti=<span class="number">0</span>;lim;lim--,ti++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(head&lt;=tail &amp;&amp; ti-lis[head].second+<span class="number">1</span>&gt;s)head++;</span><br><span class="line">            <span class="keyword">if</span>(head&lt;=tail)tmp[now]=<span class="built_in">min</span>(tmp[now],tmp[lis[head].first]+<span class="number">1ll</span>*(ti-lis[head].second)*d+l);</span><br><span class="line">            <span class="keyword">while</span>(head&lt;=tail &amp;&amp; tmp[lis[tail].first]+(ti-lis[tail].second)*d&gt;tmp[now])tail--;</span><br><span class="line">            lis[++tail]=&#123;now,ti&#125;;</span><br><span class="line">            now=(now+d)%l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;i++)&#123;</span><br><span class="line">        dp[tmp[i]%n]=<span class="built_in">min</span>(dp[tmp[i]%n],tmp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    g=<span class="built_in">gcd</span>(l,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g;i++)&#123;</span><br><span class="line">        <span class="type">int</span> now=i;LL mi=inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> lim=n/g*<span class="number">2</span>;lim;lim--)&#123;</span><br><span class="line">            dp[now]=<span class="built_in">min</span>(dp[now],mi);</span><br><span class="line">            mi=<span class="built_in">min</span>(mi,dp[now])+l;</span><br><span class="line">            now=(now+l)%n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(m&lt;n)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m-=n;</span><br><span class="line">        fail[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(now!=<span class="number">-1</span> &amp;&amp; st[now+<span class="number">1</span>]!=st[i])now=fail[now];</span><br><span class="line">            fail[i]=++now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)dp[i]=inf+<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        now=fail[n];</span><br><span class="line">        <span class="keyword">while</span>(now)&#123;</span><br><span class="line">            <span class="type">int</span> nex=fail[now];</span><br><span class="line">            <span class="keyword">if</span>(nex+nex&lt;now)<span class="built_in">solve</span>(n-now,<span class="number">1</span>,<span class="number">1</span>),now=nex;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> p=now-nex;</span><br><span class="line">                <span class="type">int</span> l=now%p+p;</span><br><span class="line">                <span class="built_in">solve</span>(n-now,(now-l)/p+<span class="number">1</span>,p);</span><br><span class="line">                now=l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LL ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&lt;=m)ans+=(m-dp[i])/n+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我没做出来，我的评价是：菜就多练。</p>
<p>训，狠狠地训。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Border</tag>
        <tag>同余最短路</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>UR5 怎样提高智商</title>
    <url>/2023/08/29/UR5-%E6%80%8E%E6%A0%B7%E6%8F%90%E9%AB%98%E6%99%BA%E5%95%86/</url>
    <content><![CDATA[<p><a href="https://uoj.ac/contest/7/problem/60">https://uoj.ac/contest/7/problem/60</a></p>
<span id="more"></span>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>非常有意思的一道题目，结论不难猜，但是非常难证。</p>
<p>首先，答案为 $4*3^{n-1}$ ，达到上界也非常的简单，搞一堆 ‘A 0 0 0 0’ 就行了。</p>
<p>时间复杂度：$O(n)$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>我们认为如果一道题目的四个答案都是一样的，我们称其为 SB 题。</p>
<p>假设最早出现的 SB 题在第 $i$ 道。</p>
<p>那么显然。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    LL ans=<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)ans=ans*<span class="number">3</span>%mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">&quot;A 0 0 0 0\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details></div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>World Final 2015 K. Tours</title>
    <url>/2024/07/01/World-Final-2015-K-Tours/</url>
    <content><![CDATA[<p>题目链接：<a href="https://qoj.ac/contest/280/problem/4686">https://qoj.ac/contest/280/problem/4686</a></p>
<p>题目大意：给每个点染色，问有多少种染色数满足存在一种染色方案使得：</p>
<ol>
<li>每个颜色至少被染了一次，每个点都被染了一种颜色。</li>
<li>任意一个简单环上每种颜色的数量一样。</li>
</ol>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>注意到一个事情，两个环像个 $8$ 一样的相交，那么中间的那条路径也满足每种颜色的数量一样。</p>
<p>这启示我们或许可以把第二条当成方程一样，解一下方程。想到方程就想到了向量空间。<del>虽然这一步是队长想的，并不是我想的，也许这并不自然</del></p>
<p>设一个 $n$ 维的向量空间，定义其中一个子空间 $S$ 满足：</p>
<p>其为 $span\{L_i\}$ ，其中 $L_i$ 为第 $i$ 个环所生成的向量，即 $L_{i,x}=1$ 当且仅当 $x$ 在环上，否则为 $0$ 。</p>
<p>可以看到，对于任意一个合法的染色方案：元素 $(a_1,a_2,….,a_n)\in S$ 满足每种颜色的加权和相等，其中加权和表示如果 $x$ 染色某种颜色，其对这个颜色的贡献为 $a_x$ 。</p>
<p>由于我们实际上只是用方程多生成了一些线性无关的方程，所以这与前面第二条是相互充要的，即一个方案是合法的当且仅当其在 $S$ 内任意一个元素下的颜色加权和相等。</p>
<p>这意外着如果我们能找到 $S$ 的另外一组基，就可以把问题变成求这组基下的合法染色方案。</p>
<p>不妨猜基中每个分量要么 $0$ 要么 $1$ ，且每个分量最多在一个元素中不为 $0$，由此可以发现，两个分量在一个元素中同时为 $1$ 等价于这两个元素在任何方程中的值都相等且存在一个方程中，其系数不为 $0$ 。</p>
<p>因此基实际上可以等价的看成，把每条边按照其所在的环的集合作为标准划分等价类（空集的点扔掉）。</p>
<p>而这又可以等价于按照其所在的 DFS 环的集合作为标准划分等价类（DFS 环指的是做一遍 DFS 后，由恰好一条非树边构成的环），原因是根据异或路径那个结论，每个环都可以当成若干个 DFS 环在异或意义下的线性表示，所以 DFS 环划分的等价类和所有环划分的等价类是一样的。</p>
<p>这样的话题目就好做了，答案就是每条链的长度的最大公约数，就做完了。</p>
<p>时间复杂度：$O(nm)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> !x ? y : <span class="built_in">gcd</span>(y % x, x);&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> y, next;</span><br><span class="line">&#125;a[N * <span class="number">2</span>]; <span class="type">int</span> len = <span class="number">1</span>, las[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;a[++len] = &#123;y, las[x]&#125;; las[x] = len;&#125;</span><br><span class="line"><span class="type">int</span> col[N], tmp[N], fa[N];</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line"><span class="type">int</span> rk[N][<span class="number">2</span>], cnt;</span><br><span class="line"><span class="type">int</span> dfn[N], ti;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; x)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">	<span class="built_in">swap</span>(col, tmp);</span><br><span class="line">	<span class="built_in">memset</span>(rk, <span class="number">0</span>, <span class="built_in">sizeof</span>(rk));</span><br><span class="line">	rk[<span class="number">1</span>][<span class="number">0</span>] = cnt = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> y : x) v[y] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!rk[tmp[i]][v[i]]) rk[tmp[i]][v[i]] = ++cnt;</span><br><span class="line">		col[i] = rk[tmp[i]][v[i]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	dfn[x] = ++ti;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k = las[x]; k; k = a[k].next)&#123;</span><br><span class="line">		<span class="type">int</span> y = a[k].y;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[y])&#123;</span><br><span class="line">			fa[y] = k ^ <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">dfs</span>(y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(dfn[y] &lt; dfn[x] &amp;&amp; k != fa[x])&#123;</span><br><span class="line">			vector&lt;<span class="type">int</span>&gt; now;</span><br><span class="line">			now.<span class="built_in">push_back</span>(k / <span class="number">2</span>);</span><br><span class="line">			<span class="type">int</span> z = x;</span><br><span class="line">			<span class="keyword">while</span>(z != y)&#123;</span><br><span class="line">				now.<span class="built_in">push_back</span>(fa[z] / <span class="number">2</span>);</span><br><span class="line">				z = a[fa[z]].y;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">add</span>(now);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	cnt = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">		<span class="type">int</span> x, y;</span><br><span class="line">		cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		<span class="built_in">ins</span>(x, y);</span><br><span class="line">		<span class="built_in">ins</span>(y, x);</span><br><span class="line">		col[i] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[i]) <span class="built_in">dfs</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">		sum[col[i]]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> d = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= cnt; i++)&#123;</span><br><span class="line">		d = <span class="built_in">gcd</span>(d, sum[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(d % i == <span class="number">0</span>)&#123;</span><br><span class="line">			cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是怎么证明呢？</p>
<p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>首先，一个容易犯的误区是：等价类可以用 DFS 环划分，但是不代表 $S$ 就是可以只有 DFS 环所构成的元素生成。<del>因为我当时犯了这个错误</del></p></p>
<p>所以问题关键就是如何利用所有环进行线性组合，组合出那组基来。（显然 $S$ 是那组基的子空间，现在只要证明这组基能够被生成就行了）</p>
<p>设每个环都是异或意义下 DFS 环的线性组合（这是唯一的，我之前另外一篇博客有介绍）：$L=\{L_{x_1}\oplus L_{x_2}…\oplus L_{x_{k}}\}$ ，而 $L$ 的方程也是由 $L_{x_1},…,L_{x_{k}}$ 的方程异或出来的。</p>
<p>设 $L_y\notin L$ ，考察环 $\{L_y\}\cup L$ ，可以发现，就是对 $L_{y}$ 中的所有元素取个反，设 $f(L)$ 表示 $L$ 代表的元素。</p>
<p>考察 $f(\{L_y\}\cup L)-f(L)$ ，可以得到其在 $L_y$ 上的每个点的分量是 $±2$ 。</p>
<p>现在证明，每个基都可以求出来。</p>
<p>对于等价类 $L=\{L_1,L_2,…,L_k\}$ ，假设其补集为 $L’=\{L’_1,L’_2,…,L’_t\}$ ，那么我们这么计算：</p>
<script type="math/tex; mode=display">\sum\limits_{l\subset L,l'\subset L'}(-1)^{|L|-|l|}f(l\cup l')</script><p>这个值是多少呢？</p>
<p>假设对于一个点 $x$，其的等价类 $\cap L’≠\emptyset$ （设交集为 $A$），那么其的系数可以用下面这个式子证明为 $0$ ：</p>
<p>$f(S\cup a)+f(S)$ 在 $x$ 处的分量为 $0$，其中 $a\notin S$ ，即可证明。</p>
<p>假设为 $\emptyset$ ，但是等价类为 $L$ 的一个真子集，假设 $a\in L$ 不在里面。</p>
<p>那么有 $f(S\cup a)-f(S)$ 在 $x$ 处的分量为 $0$，其中 $a\notin S$ ，即可证明。</p>
<p>可以证明，等价类在恰好等于 $L\cup L_1$ 的点的分量为 $±2^{|L|+|L’|}≠ 0$ ，其中正负号一致。</p>
<p>证毕。</p>
</div></details>
<p>高中的时候，我知道了那个异或环的性质，但是不会证明，然后在今年会证了，这个结论在去年知道了，今年也会证了，感叹时光的流逝，在我会证明这些结论的时候，也是我即将退役的时候，哎。</p></div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>ZJOI2017 字符串</title>
    <url>/2024/02/18/ZJOI2017-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>题目链接：<a href="https://loj.ac/p/2572">https://loj.ac/p/2572</a></p>
<p>题目大意：</p>
<p>一个长度为 $n$ ，字符集大小为 $10^9$ 的字符串，要求完成 $m$ 次操作。</p>
<p>两种操作：</p>
<ol>
<li>区间 $+d$ ，$d$ 可以为负。</li>
<li>求区间的字典序最小的后缀。</li>
</ol>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>太唐了，都已经知道了 Significant Suffixes 都还不会，感觉自从高三回归课内搞了一年后，我信息学的许多基本功都下降了好多，悲。</p>
<p>首先，一个显然的事情，我们得先处理子串比较的问题，这个显然可以 二分+线段树+Hash 解决，时间复杂度：$O(n\log^2{n})$ 。（修改复杂度：$O(n\log{n})$）</p>
<p>其次，我们可以在线段树上维护每个区间的 Significant Suffixes 的集合，但是问题是怎么求 Significant Suffixes？</p>
<p>其实压根没有必要保证集合里面都是 Significant Suffixes，只需要保证 Significant Suffixes 一定在集合里面就行了，同时保证集合大小在 $O(\log)$ 即可。（当确定一个东西是什么十分困难时，不妨尝试确定一个东西不是什么）</p>
<p>根据 Significant Suffixes 的相关证明以及线段树的性质，不难发现，线段树上合并节点时，左节点只会贡献一个可能是 Significant Suffixes 的后缀。</p>
<p>而找到这个后缀的方法就是：在左节点的集合中找一种奇怪字典序最小的后缀，这种字典序最小是认为空字符大于所有字符，即如果 $A$ 是 $B$ 的真前缀且 $A$，则 $B&lt;A$ 。</p>
<p>但是可以发现，一次修改的时间复杂度高达：$O(\log^4)$ ，但如果你足够聪慧，你可以发现，Hash 修改的时间开销很小，但是查询的时间开销很大，所以我们希望牺牲一下修改复杂度，从而降低查询复杂度，不难想到分块，分块+Hash 修改复杂度 $O(\sqrt{n})$ ，查询复杂度 $O(1)$ ，这样修改的最终复杂度就能优化到：$O(\log^3{n}+\sqrt{n})$ 。</p>
<p>那查询咋整，如果和修改一样合并节点，就没法保证左右节点长度几乎相等的性质，那个做法就不能用了，虽然也能补救，就是从右往左合并，如果左边的长度大于右边的长度+1，那么就把左边那个节点变成这个节点的左儿子和又儿子再进行合并，显然这样的时间复杂度是 $O(\log^3)$ 的，但是比较麻烦，有没有简单点的方法。</p>
<p>变换思路，不合并了，反正就 $O(\log)$ 个节点，则集合的并的大小也就 $O(\log^2)$ 大小，直接比较大小就行了，时间复杂度：$O(\log^3)$ 。</p>
<p>所以，最终复杂度就出来：$O(n\log^2{n}+m(\sqrt{n}+\log^3{n}))$</p>
<p>空间复杂度：$O(n\log{n})$ </p>
<p>什么时候我能自己独立做出来一道这么牛逼的字符串题啊。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL,<span class="type">int</span>&gt; PLI;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">2000000239</span>;</span><br><span class="line"><span class="type">const</span> LL A=<span class="number">2000000137</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN=<span class="number">4e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> B=<span class="number">950</span>;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getz</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x=<span class="number">0</span>;<span class="type">int</span> f=<span class="number">1</span>;<span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c&gt;<span class="string">&#x27;9&#x27;</span> || c&lt;<span class="string">&#x27;0&#x27;</span>)c==<span class="string">&#x27;-&#x27;</span>?f=<span class="number">-1</span>:<span class="number">1</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;=<span class="string">&#x27;9&#x27;</span> &amp;&amp; c&gt;=<span class="string">&#x27;0&#x27;</span>)x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">    x=x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">mt</span><span class="params">(LL x)</span></span>&#123;<span class="keyword">return</span> x&gt;=mod?x-mod:(x&lt;<span class="number">0</span>?x+mod:x);&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Hash</span>&#123;</span><br><span class="line">    LL fb[N],ff[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fb[<span class="number">0</span>]=<span class="number">1</span>;fb[<span class="number">1</span>]=A;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)fb[i]=fb[i<span class="number">-1</span>]*A%mod;</span><br><span class="line">        ff[<span class="number">0</span>]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)ff[i]=<span class="built_in">mt</span>(ff[i<span class="number">-1</span>]+fb[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;has;</span><br><span class="line">PLI <span class="keyword">operator</span>+(PLI x,PLI y)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;(x.first*has.fb[y.second]+y.first)%mod,x.second+y.second&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> bel[N],lazy[N],ll[N],rr[N],val[N];</span><br><span class="line">PLI fl[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maintain</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=ll[x];i&lt;=rr[x];i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==ll[x])fl[i]=PLI&#123;val[i],<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">else</span> fl[i]=fl[i<span class="number">-1</span>]+PLI&#123;val[i],<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=ll[x];i&lt;=rr[x];i++)&#123;</span><br><span class="line">        val[i]+=lazy[x];</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=l &amp;&amp; i&lt;=r)val[i]+=d;</span><br><span class="line">    &#125;</span><br><span class="line">    lazy[x]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">maintain</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bel[l]==bel[r])<span class="built_in">change</span>(bel[l],l,r,d);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">change</span>(bel[l],l,r,d);</span><br><span class="line">        <span class="built_in">change</span>(bel[r],l,r,d);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=bel[l]+<span class="number">1</span>;i&lt;bel[r];i++)lazy[i]+=d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">PLI <span class="title">queryhash_nl</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==ll[bel[l]])<span class="keyword">return</span> fl[r];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> &#123;<span class="built_in">mt</span>(fl[r].first-fl[l<span class="number">-1</span>].first*has.fb[ r-l+<span class="number">1</span> ]%mod),r-l+<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">PLI <span class="title">hashplus</span><span class="params">(PLI x,LL d)</span></span>&#123;<span class="keyword">return</span> &#123;<span class="built_in">mt</span>(x.first+has.ff[x.second<span class="number">-1</span>]*d%mod),x.second&#125;;&#125;<span class="comment">/*x+dval*/</span></span><br><span class="line"><span class="function">PLI <span class="title">queryhash_l</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">hashplus</span>(<span class="built_in">queryhash_nl</span>(l,r),lazy[bel[l]]);&#125;</span><br><span class="line"><span class="function">PLI <span class="title">queryhas</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    PLI ans=&#123;<span class="number">0ll</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=bel[l];i&lt;=bel[r];i++)&#123;</span><br><span class="line">        ans=ans+<span class="built_in">queryhash_l</span>(<span class="built_in">max</span>(l,ll[i]),<span class="built_in">min</span>(rr[i],r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> lim,<span class="type">int</span> typ=<span class="number">0</span>)</span></span>&#123;<span class="comment">//return x&lt;y</span></span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>,r=lim-<span class="built_in">max</span>(x,y)+<span class="number">1</span>,mid,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">queryhas</span>(x,x+mid<span class="number">-1</span>)!=<span class="built_in">queryhas</span>(y,y+mid<span class="number">-1</span>))r=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>,ans=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==lim-<span class="built_in">max</span>(x,y)+<span class="number">1</span>)<span class="keyword">return</span> typ?x&lt;y:x&gt;y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> val[x+ans]+lazy[bel[x+ans]]&lt;val[y+ans]+lazy[bel[y+ans]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Segment</span>&#123;</span><br><span class="line">    <span class="type">int</span> lc,rc;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sign;</span><br><span class="line">&#125;tr[NN];<span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">// tr[x].sign.clear();</span></span><br><span class="line">    tr[x].sign=tr[tr[x].rc].sign;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> y:tr[tr[x].lc].sign)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ans || <span class="built_in">cmp</span>(y,ans,r,<span class="number">1</span>))ans=y;</span><br><span class="line">    &#125;</span><br><span class="line">    tr[x].sign.<span class="built_in">push_back</span>(ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bt</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=++cnt;</span><br><span class="line">    <span class="keyword">if</span>(l==r)tr[x].sign.<span class="built_in">push_back</span>(l);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        tr[x].lc=<span class="built_in">bt</span>(l,mid);</span><br><span class="line">        tr[x].rc=<span class="built_in">bt</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">updata</span>(x,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ll,<span class="type">int</span> rr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ll&gt;rr || rr&lt;l || ll&gt;r || (l&gt;=ll &amp;&amp; r&lt;=rr))<span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">change</span>(tr[x].lc,l,mid,ll,rr);</span><br><span class="line">    <span class="built_in">change</span>(tr[x].rc,mid+<span class="number">1</span>,r,ll,rr);</span><br><span class="line">    <span class="built_in">updata</span>(x,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> zans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ll,<span class="type">int</span> rr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ll&gt;rr || rr&lt;l || ll&gt;r)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=ll &amp;&amp; r&lt;=rr)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> y:tr[x].sign)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!zans || <span class="built_in">cmp</span>(y,zans,rr))zans=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">query</span>(tr[x].lc,l,mid,ll,rr);</span><br><span class="line">    <span class="built_in">query</span>(tr[x].rc,mid+<span class="number">1</span>,r,ll,rr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">getz</span>(n);<span class="built_in">getz</span>(q);</span><br><span class="line">    has.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">getz</span>(val[i]);</span><br><span class="line">        val[i]+=<span class="number">1000000001</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        bel[i]=i/B+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ll[bel[i]])ll[bel[i]]=i;</span><br><span class="line">        rr[bel[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=bel[n];i++)<span class="built_in">maintain</span>(i);</span><br><span class="line">    <span class="built_in">bt</span>(<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="type">int</span> typ;<span class="built_in">getz</span>(typ);</span><br><span class="line">        <span class="keyword">if</span>(typ==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> l,r,d;<span class="built_in">getz</span>(l);<span class="built_in">getz</span>(r);<span class="built_in">getz</span>(d);</span><br><span class="line">            <span class="built_in">change</span>(l,r,d);</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> l,r;<span class="built_in">getz</span>(l);<span class="built_in">getz</span>(r);</span><br><span class="line">            zans=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,zans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个题目有点卡常，这里说一下我是怎么卡常的：</p>
<ol>
<li>模数等量改成常数，同时将一些取模改成判断和加减的组合。</li>
<li>调调块长，在 $2\sqrt{n}$ 左右会快很多。</li>
<li>加快读。</li>
</ol>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Hash</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
        <tag>分块</tag>
        <tag>Significant Suffixes</tag>
      </tags>
  </entry>
  <entry>
    <title>sgu543 Cafe</title>
    <url>/2024/04/29/sgu543-Cafe/</url>
    <content><![CDATA[<p>题目链接：<a href="https://codeforces.com/problemsets/acmsguru/problem/99999/543">https://codeforces.com/problemsets/acmsguru/problem/99999/543</a></p>
<p>题目大意：有 $n$ 个团体，每张桌子有 $r$ 个位置，问最小多少张桌子能让所有人上桌，要求：一个桌子上不会出现一个团体只有一个人在这张桌子上。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>注意到一个事情：任何一个 $&gt;1$ 的正整数可以被拆分成若干 $2,3$ 的和，但问题是，我们不知道每个团体的人要被拆成多少个 $2,3$ （显然，知道有多少个 $2,3$ ，就可以在足够优秀的时间复杂度内得到最少的桌子数量）。</p>
<p>但是又注意到一个事情：一个桌子上有两个 $3$ 和一个团体被拆分成两个 $3$ 这两件事不会同时发生，因为发生这种情况时可以交换，然后把两个 $3$ 拆成 $3$ 个 $2$ 。</p>
<p>因此我们只要分成两种情况讨论就行了：</p>
<ol>
<li>每个团体至多拆出一个 $3$ 。</li>
<li>每个桌子至多放置一个 $3$ 。</li>
</ol>
<p>然后讨论一下就做完了，我采用了二分，所以时间复杂度是：$O(n\log{V})$ 的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, R, a[N];</span><br><span class="line"><span class="keyword">namespace</span> Solve1&#123;<span class="comment">//any team only one    </span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">evenpd</span><span class="params">(<span class="type">int</span> res, <span class="type">int</span> cnt, <span class="type">int</span> num2, <span class="type">int</span> num3)</span></span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(res % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1ll</span> * res * cnt &lt; num2 * <span class="number">2</span> + num3 * <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1ll</span> * res / <span class="number">6</span> * <span class="number">2</span> * cnt &gt;= num3) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> tmp = res % <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">if</span>(tmp &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0ll</span>;</span><br><span class="line">        num3 -= <span class="number">1ll</span> * res / <span class="number">6</span> * <span class="number">2</span> * cnt;</span><br><span class="line">        <span class="keyword">return</span> tmp * cnt &gt;= num3 * <span class="number">4</span> + num2 * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> cnt, <span class="type">int</span> num2, <span class="type">int</span> num3)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(R &amp; <span class="number">1</span>)) <span class="keyword">return</span> <span class="built_in">evenpd</span>(R, cnt, num2, num3);</span><br><span class="line">        <span class="keyword">if</span>(num3 &lt;= cnt) <span class="keyword">return</span> <span class="number">1ll</span> * (R - <span class="number">1</span>) * cnt &gt;= (num2 + num3) * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">evenpd</span>(R - <span class="number">3</span>, cnt, num2, num3 - cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> num2 = <span class="number">0</span>, num3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &amp; <span class="number">1</span>) num3 ++, num2 --;</span><br><span class="line">            num2 += a[i] / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">2000</span> * n, mid, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">pd</span>(mid, num2, num3)) ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Solve2&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> cnt, <span class="type">int</span> num2, <span class="type">int</span> num3, <span class="type">int</span> num6)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num3 &gt; cnt) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> use = num3 + <span class="built_in">min</span>((cnt - num3) / <span class="number">2</span> * <span class="number">2</span>, num6 * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> (num3 * <span class="number">3</span> + num2 * <span class="number">2</span> + num6 * <span class="number">6</span> + (cnt - use)) &lt;= <span class="number">1ll</span> * cnt * R;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(R &amp; <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1e9</span>;</span><br><span class="line">        <span class="type">int</span> num2 = <span class="number">0</span>, num3 = <span class="number">0</span>, num6 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> tmp = a[i];</span><br><span class="line">            <span class="keyword">if</span>(a[i] &amp; <span class="number">1</span>) num3 ++, tmp -= <span class="number">3</span>;</span><br><span class="line">            num6 += tmp / <span class="number">6</span>;</span><br><span class="line">            tmp %= <span class="number">6</span>;</span><br><span class="line">            num2 += tmp / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">2000</span> * n, mid, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">pd</span>(mid, num2, num3 ,num6)) ans = mid, r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">assert</span>(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; R;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">min</span>(Solve1::<span class="built_in">solve</span>(), Solve2::<span class="built_in">solve</span>()) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有个问题，如果知道了有多少个 $2,3$ ，可以多快知道有多少个桌子数，显然 $O(\log)$ 可以，但是可以线性吗？</p>
<p>我们不妨设 $f(x)$ 表示有 $x$ 张桌子的情况下，将 $3$ 的桌子放进去，最多还能放入多少的 $2$ ，而 $f$ 显然能写成 $O(1)$ 个分段函数相加，且边界可以在 $O(1)$ 的时间处理完，所以一定可以在 $O(1)$ 的时间解决，具体讨论不再赘述。</p>
<p>因此，每个团队至多一个 $3$ 的情况可以在 $O(1)$ 的时间内解决。</p>
<p>同理，每张桌子至多一个 $3$ 的情况，显然此时可以认为 $r$ 为奇数，$r$ 为偶数的情况这种情况肯定不如另一种情况优。</p>
<p>可以先把原来的团队分成：$0/1$ 个 $3$ ，最多的 $6$ 和剩下的 $2$。</p>
<p>设 $f(x)$ 表示有 $x$ 张桌子的话至多能放多少个人，其中 $x\ge 3$ 的个数，因此 $f(x)$ 关于 $x$ 是偶数和奇数分别是分段函数，因此类似上面的，只要肯讨论，也可以在 $O(1)$ 内解决。</p>
<p>综上，该问题可以在 $O(n)$ 时间内解决。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>lzqy_ の Strings Round 赛后总结</title>
    <url>/2024/03/21/lzqy-%E3%81%AE-Strings-Round-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="A-好奇心宝宝"><a href="#A-好奇心宝宝" class="headerlink" title="A 好奇心宝宝"></a>A 好奇心宝宝</h1><p><a href="https://www.luogu.com.cn/problem/P10270?contestId=155684">https://www.luogu.com.cn/problem/P10270?contestId=155684</a></p>
<p>题目大意：给一个网格，求两条从左上到右下的路径满足最长公共前缀最短，输出最短公共前缀长度。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然等价于找 $\{(x,y)|x+y=t\}$ 中最小的 $t$ 满足这个集合中的点的字符集大小 $&gt;1$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> st[N][N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st[i]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>+m<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> pre=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=i+<span class="number">1</span>;x++)&#123;</span><br><span class="line">            <span class="type">int</span> y=i-(x<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">1</span> &amp;&amp; y&gt;=<span class="number">1</span> &amp;&amp; x&lt;=n &amp;&amp; y&lt;=m)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!pre)pre=st[x][y];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pre!=st[x][y])&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n+m<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="B-漫长悄悄话"><a href="#B-漫长悄悄话" class="headerlink" title="B 漫长悄悄话"></a>B 漫长悄悄话</h1><p><a href="https://www.luogu.com.cn/problem/P10270?contestId=155684">https://www.luogu.com.cn/problem/P10270?contestId=155684</a></p>
<p>题目大意：对于 $i,j$ ，贡献为 $i,j$ 前缀的翻转和后缀的 $LCP$ （四个串的 LCP ），求最大贡献。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>等价于找最长的奇数长度回文串满足出现了至少两次。</p>
<p>接下来各显神通了，可以马拉车+Hash，可以回文自动机，也可以Hash+二分。</p>
<p>我用了回文自动机。</p>
<p>Hash+二分的做法详见官方题解：<a href="https://www.luogu.com/article/sfxeve97。（需要用到本质不同的回文串只有至多">https://www.luogu.com/article/sfxeve97。（需要用到本质不同的回文串只有至多</a> $n$ 个的性质）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">char</span> st[N][N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st[i]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>+m<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> pre=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=i+<span class="number">1</span>;x++)&#123;</span><br><span class="line">            <span class="type">int</span> y=i-(x<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=<span class="number">1</span> &amp;&amp; y&gt;=<span class="number">1</span> &amp;&amp; x&lt;=n &amp;&amp; y&lt;=m)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!pre)pre=st[x][y];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(pre!=st[x][y])&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n+m<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="C-在四方城外"><a href="#C-在四方城外" class="headerlink" title="C 在四方城外"></a>C 在四方城外</h1><p><a href="https://www.luogu.com.cn/problem/P10272?contestId=155684">https://www.luogu.com.cn/problem/P10272?contestId=155684</a></p>
<p>题目大意：每次操作在 $S$ 后面添加 $S$ 的 mxBd ，求第 $L$ 次操作和第 $R$ 次操作之间所有操作后的字符串长度之和。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>引理 1 ：若 $ST=TS$ ，则 $S,T$ 有相同的整周期。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">情况1：无Bd</summary><div class="toggle-content"><p>若原串的 $mxBd=0$ ，则答案为 $|S|*(r-l+1)$ 。</p>
</div></details></p>
<p><details class="toggle" ><summary class="toggle-button" style="">情况2：有整周期</summary><div class="toggle-content"><p>若原串有最小整周期 $p$ ，那么每次添加的长度必然是：$|S|-p$ ，否则一定会出现下面的情况：</p></p>
<p><img src="1.png" alt=""></p>
<p>那么根据引理，原串存在更小的整周期，矛盾，证毕。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">情况3：无整周期但有Bd</summary><div class="toggle-content"><p>这里给一些例子：abababababcab 、aaaaaaaba 。</p>
<p>为了方便下面叙述，我们设 $S_m$ 表示第 $m$ 操作后的字符串，$S_0=S$ ，然后设 $T_m=S_m-S,T_m’=(mxBd(S)+T_m)$ ，字符串 $S-T$ 定义为 $S$ 删去 $LCP(S,T)$ 。</p>
<p>显然，$|T_{m+1}|-|T_{m}|=|T’_{m+1}|-|T’_{m}|$ ，$|T_{m+1}|-|T_{m}|\le |T_{m+2}|-|T_{m+1}|$ </p>
<p>接下来先说结论，整个增长过程可以分成两个部分，先是 $|T’_{m+1}|=2|T’_m|$ ，然后 $|T_{m+1}|-|T_m|$ 恒定。</p>
<p>定理 1 ：$|mxBd(T_{m})|\le |T’_{m}|$ 。（显然，归纳一下就行了）</p>
<p>因此，$|T’_{m+1}|\le 2|T’_m|$ 。</p>
<p>定理 2 ： $|T’_{m+1}|&lt;2|T’_m|$ 时，则后面 $|T_{m+1}|-|T_m|$ 恒定。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>设 $U=mxBd(T’_{0})$ 。</p></p>
<p>$T_{m}-T_{m-1},T_{m+1}-T_m$ 是 $S$ 的一个 Bd ，显然 $T_{m}-T_{m-1}$ 是 $T_{m+1}-T_m$ 的一个 Bd 。可以得到 $T’_{0}$ 是 $T_{m+1}-T_m$ 的一个 Bd 。</p>
<p>根据引理 $1$ 可以得到 $U$ 是 $T_{m+1}-T_{m}$ 的最小整周期。</p>
<p>这个时候，可以把 $T’_{m+1},T’_{m}$ 等字符串想象成若干 $U$ 的拼接，显然 $U$ 也是 $T’_{m+1}$ 等字符串的最小整周期，否则最小整周期也是 $U$ 的整周期，与前面矛盾。</p>
<p><img src="3.png" alt=""></p>
<p>则 $|T’_{m+1}|&lt;2|T’_m|$ ，就已经说明了 $S_{m}$ 前面只有 $\frac{|T’_{m+1}|}{|U|}$ 个 $U$ ，没有 $\frac{|T’_{m+1}|}{|U|}+1$ 个 $U$ ，若 $|T_{m+2}|-|T_{m-1}|&gt;|T_{m+2}|-|T_{m-1}|$ ，则与 $U$ 的个数矛盾，证毕。</p>
</div></details>
<p>定理 3 ：若 $|T’_{m+1}|=2|T’_m|$ ，那么 $|T_{m+1}|-|T_{m}|&lt;|S|$。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>反证法，若 $\ge n$ 。</p>
<p>显然 $T’_{0}$ 是 $T_{m+1}-T_{m}$ 的一个周期，即 $S_{m}$ 一个 $\ge n$ 的 Bd 的周期是 $T’_{0}$ ，注意到 $T’_{0}$ 也出现在 $S$ 的末尾，根据引理 $1$ 知道 $S$ 有整周期，矛盾，证毕。</p>
</div></details>
<p>推论： $m=\left \lfloor \log_2{|S|} \right \rfloor+1$ ，则一定有 $|T’_{m+1}|&lt;2|T’_m|$ 。</p>
<p>于是就有很多种搞法了。</p>
<p>我的方法是直接 Kmp ，注意到长度 $\le 3n$ ，所以时间复杂度为：$O(n\log{n})$ ，空间复杂度为 : $O(n)$ 。</p>
<p>当然，根据上面的证明，有更加快速的搞法：求出 $U$ ，然后从左到右找至多有多少个 $U$ ，这样就可以在 $O(n)$ 的时间解决这个问题了。</p></div></details>
<p>注意：上面的时间复杂度都忽略了快速幂计算答案的时间。</p>
<p>综上，时间复杂度为：$O(n\log{n}+\log{R})$ ，空间复杂度：$O(n)$。</p>
<p>当然，时间复杂度可以优化到：$O(n+\log{R})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="function">LL <span class="title">ksm</span><span class="params">(LL x,LL y)</span></span>&#123;</span><br><span class="line">    LL ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(y)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x%mod;</span><br><span class="line">        x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> st[N*<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> fail[N*<span class="number">3</span>],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gp</span><span class="params">(<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    fail[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(now!=<span class="number">-1</span> &amp;&amp; st[now+<span class="number">1</span>]!=st[i])now=fail[now];</span><br><span class="line">        fail[i]=++now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fail[len];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> len[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,st+<span class="number">1</span>);n=<span class="built_in">strlen</span>(st+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> d=<span class="built_in">gp</span>(n),p=n-d;</span><br><span class="line">    <span class="keyword">if</span>(!d)&#123;</span><br><span class="line">        LL l,r;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(r-l+<span class="number">1</span>)*n%mod);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n%p==<span class="number">0</span>)&#123;</span><br><span class="line">        LL l,r;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        LL ans=<span class="built_in">ksm</span>(<span class="number">2</span>,l)*(<span class="built_in">ksm</span>(<span class="number">2</span>,r-l+<span class="number">1</span>)<span class="number">-1</span>+mod)%mod*(n-p)%mod;</span><br><span class="line">        ans=(ans+p*(r-l+<span class="number">1</span>))%mod;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pred,m=<span class="number">0</span>;</span><br><span class="line">    len[m]=n;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        m++;</span><br><span class="line">        len[m]=len[m<span class="number">-1</span>];</span><br><span class="line">        <span class="built_in">assert</span>(len[m]+d&lt;=n*<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=d;i++)st[++len[m]]=st[i];</span><br><span class="line">        pred=d;</span><br><span class="line">        d=<span class="built_in">gp</span>(len[m]);</span><br><span class="line">        p=len[m]-d;</span><br><span class="line">    &#125;<span class="keyword">while</span>(d==pred*<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//d is key;</span></span><br><span class="line">    LL l,r;<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">    LL ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=m &amp;&amp; i&lt;=r;i++)ans=(ans+len[i])%mod;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;r)&#123;</span><br><span class="line">        l=<span class="built_in">max</span>(l-m,<span class="number">1ll</span>);</span><br><span class="line">        r-=m;</span><br><span class="line">        ans=(ans+len[m]*(r-l+<span class="number">1</span>))%mod;</span><br><span class="line">        ans=(ans+(r+l)*(r-l+<span class="number">1</span>)/<span class="number">2</span>%mod*d)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感觉想出这个做法非常花时间啊。</p></div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方题解</summary><div class="toggle-content"><p>官方做法和我的 $O(n)$ 做法没什么区别，区别在于官方题解导出正解的路线非常短。</p>
<p>想想怎么更快的想出正解？</p>
<ol>
<li>首先注意到 $S$ 有整周期（简单的）和没有整周期（不简单的）是两种情况。</li>
<li>其次一个必要条件是足够快的想出引理 $1$ （我的做法有提到）。</li>
<li>然后要有足够的观察力观察到如果设 $U$ 是 $mxBd(S)$ 的最小整周期，那么 $U$ 是这个问题的关键。</li>
<li>需要观察到 $U$ 是每次添加的字符串的整周期（那么显然 $U$ 是最小的整周期），否则可以证明 $mxBd(S)$ 存在更小的整周期。</li>
<li>设 $l$ 是从左到右 $S$ 可以匹配上的 $U$ 的个数，$r$ 是从右到左的，如果 $(l+r-1)*|U|\ge |S|$ ，则可以说明 $S$ 有最小整周期，矛盾。</li>
<li>根据 $4,5$ 就可以得到 $O(n)$ 做法，也可以根据至多 $O(\log)$ 后增速固定，且在这之前字符串长度至多乘 $3$ 倍的性质，想出更加好写的 $O(n\log{n})$ 做法。</li>
</ol>
<p>观察上面过程，在第 $3$ 步之后对我而言比较自然，也就是想要更快的做出这题，更快的想出第 $2,3$ 步是关键。</p>
</div></details>
<h1 id="D-大娱乐至上"><a href="#D-大娱乐至上" class="headerlink" title="D 大娱乐至上"></a>D 大娱乐至上</h1><p>题目链接：<a href="https://www.luogu.com.cn/problem/P10273?contestId=155684">https://www.luogu.com.cn/problem/P10273?contestId=155684</a></p>
<p>题目大意：给你一个字符串，给一堆区间代表子串，问你每个区间能不能在只改变原串一个字母的情况下，使原本给出的小于它的子串现在大于等于它了。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>我考场的第一想法是后缀数组，但非常可惜的是太过答辩，以至于我根本没有时间在考场上品鉴完。</p>
<p>一个简单的思路是：要么改变这个子串，变小一个字母。要么让其余所有原本小于它的给定子串变大，变大一个字母。</p>
<p>基础实现思路：从小到大遍历子串，然后讨论当前这个子串是否可行，如果有多个相同的子串，则同时进行查询即可（即全部询问完后再执行相应的修改操作）。</p>
<p>然后就可以开始讨论了：</p>
<p>不妨设现在考虑的是 $[l_i, r_i]$ ，下面不加说明时，都仅考虑原本小于它的子串 $[l_j, r_j]$ ，设 $lcp(x,y)$ 表示 $x,y$ 后缀的最长公共前缀，同时下面提到的子串都指题目给定的子串。</p>
<p><strong>变小一个字母</strong>（一个基本性质是所有子串只可能变小不可能变大）：</p>
<ol>
<li>显然，如果要让 $[l_i, r_i]$ 小于等于 $[l_j,r_j]$ ，设 $len = min(lcp(l_i, l_j), r_j - l_j + 1, r_i - l_i + 1)$ ，则显然改的字符必须落在 $[l_i, l_i + len - 1]$ 。</li>
<li>同时如果改的字符同时落在 $[l_i, r_i]$ 和 $[l_j, r_j]$ ，那么显然必须有：$l_i &gt; l_j$ ，即如果有 $l_j \ge l_i$ 的话，修改的位置不能在 $[l_i,r_i]\cap [l_j,r_j]$ ，同时根据上一条可以知道，修改的位置不可能在 $l_j$ 之后，即落点只能落在 $[l_i, l_j - 1]$ 。（可以发现，找到右边最近的 $l_j$ 给个约束就行了，可以用单调栈预处理达到 $O(n)$ ）</li>
</ol>
<p>这样就可以得到修改的位置必须落在的区间，而且根据上面的讨论，不难发现只要落在这个区间，直接改到 $&lt;a$ 就可以符合要求了，即这个区间有可改的位置是改小可行的充要条件。</p>
<p>现在问题是，第一点怎么实现？</p>
<p>假设小于等于 $[l_i,r_i]$ 的子串（包括自己）中 $l$ 后缀 rank 最大为 $k$ ，同时所有给定的字符串中 rank 最小的 $l$ 的 rk 为 $smallrk$ 。</p>
<p>那么第一点的限制可以写成 $min(lcp(sa[smallrk],l),r_{j}-l_{j}+1(\forall j : [l_j,r_j]\le [l_i,r_i]))$ ，这样就可以维护了，具体实现中，还可以将 $lcp(sa[smallrk],l)$ 换成 $lcp(sa[k],l)$ ，因为显然 $lcp(sa[smallrk],sa[k])\ge min(r_{j}-l_{j}+1(\forall j : [l_j,r_j]\le [l_i,r_i]))$ 。</p>
<p>可以在询问的过程中一起维护，时间复杂度 $O(n)$ 。</p>
<p><strong>变大一个字母</strong>（一个基本性质是所有子串只可能变大不可能变小）：</p>
<ol>
<li>需要让这个位置落在所有 $[l_j,r_j]$ $([l_j,r_j]&lt;[l_i,r_i])$ 。（很容易 $O(n)$ 处理）</li>
<li>如果要让 $[l_i, r_i]$ 小于等于 $[l_j,r_j]$ ，则显然改的字符必须落在 $[l_j, l_j + lcp(l_i, l_j)]$ 。</li>
<li>如果要让 $[l_i, r_i]$ 小于等于 $[l_j,r_j]$ ，则显然改的字符必须落在 $[l_j, l_j + (r_i - l_i + 1) - 1]$ 。（很容易 $O(n)$ 处理）</li>
<li>若 $\exists j : l_j \le l_i ,[l_j,r_j] &lt;[l_i,r_i]$ ，则显然修改位置不能落在 $[l_i,r_i]$ ，否则 $[l_i,r_i]$ 的增大程度大于 $[l_j,r_j]$ 。（很容易 $O(n)$ 处理）</li>
</ol>
<p>这样就可以得到修改的位置必须落在的区间，而且根据上面的讨论，不难发现只要落在这个区间，直接改到 $&gt;z$ 就可以符合要求了，即这个区间有可改的位置是改大可行的充要条件。</p>
<p>现在问题是，第二点怎么实现？毕竟 $rk[l_i]$ 可以跳上跳下的 ，因此维护 $lcp(l_i,l_j)$ 是个很困难的事情。</p>
<p>假设大于等于 $[l_i,r_i]$ 的子串（包括自己）中 $l$ 后缀 rank 最大为 $k$ 。</p>
<p>那么实际上只需要考虑 $j:[l_j,r_j]&lt;[l_i,r_i],rk(l_j)&lt;k$ ，且 $lcp$ 只需要考虑 $lcp(l_j,sa[k])$ ，原因是这样子改的影响一定可以被其余三点消掉。（一个基本的事实是：若 $rk[l_i]\ge rk[l_j]$，但 $[l_i,r_i]\le[l_j,r_j]$ ，那么 $[l_i,r_i]$ 一定是 $[l_j,r_j]$ 的前缀）</p>
<p>这样子的好处是可以用一个栈轻松实现这个过程。</p>
<p>综上，在对子串排序后，所有的讨论都可以在线性的时间解决。</p>
<p>时间复杂度：$O(n\log{n})$</p>
<p>空间复杂度：$O(n\log{n})$</p>
<p>我的代码实现细节和上述实现不完全相同，但是思路是一致的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SN = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> ss[N],ch[N];</span><br><span class="line"><span class="type">char</span> ans[N];</span><br><span class="line">set&lt;<span class="type">int</span>&gt; chp;<span class="comment">//change pos</span></span><br><span class="line"><span class="function">PII <span class="title">getcp</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    PII x = &#123;n+<span class="number">1</span>, n+<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">auto</span> tmp = chp.<span class="built_in">lower_bound</span>(l);</span><br><span class="line">    <span class="keyword">if</span>(tmp != chp.<span class="built_in">end</span>()) x.first = *tmp;</span><br><span class="line">    tmp = chp.<span class="built_in">upper_bound</span>(r);</span><br><span class="line">    <span class="keyword">if</span>(tmp != chp.<span class="built_in">begin</span>())&#123;</span><br><span class="line">        tmp--;</span><br><span class="line">        x.second = *tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x.first &gt; r) x.first = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x.second &lt; l) x.second = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> SA&#123;</span><br><span class="line">    <span class="type">int</span> cc[N],sa[N],xx[N],yy[N],top,V;</span><br><span class="line">    <span class="type">int</span> rk[N],height[N],h[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getsa</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//need clear : height,h</span></span><br><span class="line">        V=<span class="number">26</span>;<span class="built_in">memset</span>(cc+<span class="number">1</span>,<span class="number">0</span>,V&lt;&lt;<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cc[xx[i]=ss[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=V;i++)cc[i]+=cc[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)sa[cc[xx[i]]--]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;n;k&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            top=<span class="number">0</span>;<span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;n-k;i--)yy[++top]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sa[i]&gt;k)yy[++top]=sa[i]-k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(cc+<span class="number">1</span>,<span class="number">0</span>,V&lt;&lt;<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cc[xx[i]]++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=V;i++)cc[i]+=cc[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)sa[cc[xx[yy[i]]]--]=yy[i];</span><br><span class="line">            <span class="built_in">swap</span>(xx,yy);</span><br><span class="line">            V=xx[sa[<span class="number">1</span>]]=<span class="number">1</span>;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)xx[sa[i]]=V+=!(sa[i]+k&lt;=n &amp;&amp; sa[i<span class="number">-1</span>]+k&lt;=n &amp;&amp; yy[sa[i]]==yy[sa[i<span class="number">-1</span>]] &amp;&amp; yy[sa[i]+k]==yy[sa[i<span class="number">-1</span>]+k]);</span><br><span class="line">            <span class="keyword">if</span>(V==n)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)rk[sa[i]]=i;</span><br><span class="line">        <span class="type">int</span> now=<span class="number">0</span>;ss[n+<span class="number">1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(now)now--;</span><br><span class="line">            <span class="keyword">if</span>(rk[i]==<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span>(ss[i+now]==ss[sa[rk[i]<span class="number">-1</span>]+now])now++;</span><br><span class="line">            h[i]=now;height[rk[i]]=now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> rmq[SN][N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init_rmq</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)rmq[<span class="number">0</span>][i]=height[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">19</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=n-(<span class="number">1</span>&lt;&lt;i)+<span class="number">1</span>;j&gt;=<span class="number">1</span>;j--)rmq[i][j]=<span class="built_in">min</span>(rmq[i<span class="number">-1</span>][j],rmq[i<span class="number">-1</span>][j+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getrmq</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> z=__lg(y-x+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(rmq[z][x],rmq[z][y-(<span class="number">1</span>&lt;&lt;z)+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getlcp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==y)<span class="keyword">return</span> n-x+<span class="number">1</span>;</span><br><span class="line">        x=rk[x];y=rk[y];</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y)<span class="built_in">swap</span>(x,y);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getrmq</span>(x+<span class="number">1</span>,y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> SA::getsa;</span><br><span class="line"><span class="keyword">using</span> SA::init_rmq;</span><br><span class="line"><span class="keyword">using</span> SA::getlcp;</span><br><span class="line"><span class="keyword">using</span> SA::height;</span><br><span class="line"><span class="keyword">using</span> SA::sa;</span><br><span class="line"><span class="keyword">using</span> SA::rk;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ql[N],qr[N],qlen[N],id[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="comment">//x&lt;y;</span></span><br><span class="line">    <span class="type">int</span> k=<span class="built_in">getlcp</span>(ql[x], ql[y]);</span><br><span class="line">    <span class="keyword">if</span>(qlen[x] &lt;= k || qlen[y] &lt;= k) <span class="keyword">return</span> qlen[x] &lt; qlen[y];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ss[ql[x] + k] &lt; ss[ql[y] + k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//small square</span></span><br><span class="line"><span class="type">int</span> smallrk,minlen;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; banp;<span class="comment">//ban pos</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//big square</span></span><br><span class="line"><span class="type">int</span> minl, maxl;</span><br><span class="line">PII stk[N];<span class="type">int</span> top;</span><br><span class="line"><span class="type">int</span> maxrk,rp;</span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; querypos;</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    cin &gt;&gt; ss+<span class="number">1</span> &gt;&gt; ch+<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">getsa</span>();</span><br><span class="line">    <span class="built_in">init_rmq</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch[i] == <span class="string">&#x27;1&#x27;</span>) chp.<span class="built_in">insert</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        cin &gt;&gt; ql[i] &gt;&gt; qr[i];</span><br><span class="line">        qlen[i] = qr[i] - ql[i] + <span class="number">1</span>;</span><br><span class="line">        id[i] = i;</span><br><span class="line">        ans[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        querypos.<span class="built_in">insert</span>(rk[ql[i]]);</span><br><span class="line">        v[ql[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(id + <span class="number">1</span>, id + m +<span class="number">1</span>, cmp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//small init</span></span><br><span class="line">    minlen = smallrk = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)smallrk = <span class="built_in">min</span>(smallrk, rk[ql[i]]);</span><br><span class="line">    <span class="comment">//max init</span></span><br><span class="line">    maxrk = maxl = <span class="number">1</span>;</span><br><span class="line">    minl = n + <span class="number">1</span>;</span><br><span class="line">    rp = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> tl = <span class="number">1</span>; tl &lt;= m; tl++)&#123;</span><br><span class="line">        <span class="type">int</span> tr = tl;</span><br><span class="line">        <span class="keyword">while</span>(tr &lt; m &amp;&amp; <span class="built_in">getlcp</span>(ql[id[tl]], ql[id[tr + <span class="number">1</span>]]) &gt;= qlen[id[tl]] &amp;&amp;</span><br><span class="line">            <span class="built_in">getlcp</span>(ql[id[tl]], ql[id[tr + <span class="number">1</span>]]) &gt;= qlen[id[tr + <span class="number">1</span>]] &amp;&amp; qlen[id[tl]] == qlen[id[tr + <span class="number">1</span>]]) tr++;</span><br><span class="line">        <span class="keyword">if</span>(tl == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = tl; i &lt;= tr; i++) ans[id[i]] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = tl; i &lt;= tr; i++)&#123;</span><br><span class="line">            <span class="comment">//small change</span></span><br><span class="line">            <span class="type">int</span> x = id[i];</span><br><span class="line">            <span class="type">int</span> l = ql[x], r = qr[x];</span><br><span class="line">            <span class="keyword">while</span>(rk[l] &gt; smallrk)&#123;</span><br><span class="line">                smallrk++;</span><br><span class="line">                minlen = <span class="built_in">min</span>(minlen, height[smallrk] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            minlen = <span class="built_in">min</span>(minlen, qlen[x]);</span><br><span class="line">            <span class="comment">//big change</span></span><br><span class="line">            <span class="keyword">while</span>((*querypos.<span class="built_in">begin</span>()) &gt; maxrk)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(v[sa[maxrk]])&#123;</span><br><span class="line">                    <span class="type">int</span> pos = sa[maxrk];</span><br><span class="line">                    stk[++top] = &#123;pos, n - pos + <span class="number">1</span>&#125;;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                maxrk++;</span><br><span class="line">                <span class="type">int</span> tmp = height[maxrk] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(top &amp;&amp; stk[top].second &gt; tmp)&#123;</span><br><span class="line">                    PII y = stk[top];</span><br><span class="line">                    <span class="keyword">while</span>(top &amp;&amp; stk[top].second &gt;= tmp)&#123;</span><br><span class="line">                        y.first = <span class="built_in">min</span>(y.first, stk[top].first);</span><br><span class="line">                        top--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    y.second = tmp;</span><br><span class="line">                    stk[++top] = y;</span><br><span class="line"></span><br><span class="line">                    rp = <span class="built_in">min</span>(rp, y.first + y.second - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = tl; i &lt;= tr; i++)&#123;</span><br><span class="line">            <span class="type">int</span> x = id[i];</span><br><span class="line">            <span class="type">int</span> l = ql[x], r = qr[x];</span><br><span class="line">            <span class="comment">//small query</span></span><br><span class="line">            <span class="keyword">if</span>(minlen)&#123;</span><br><span class="line">                <span class="type">int</span> rban= n + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">auto</span> tmp=banp.<span class="built_in">lower_bound</span>(l);</span><br><span class="line">                <span class="keyword">if</span>(tmp != banp.<span class="built_in">end</span>()) rban = *tmp;</span><br><span class="line">                <span class="keyword">auto</span> [al, ar] = <span class="built_in">getcp</span>(l, <span class="built_in">min</span>(rban - <span class="number">1</span>, l + minlen - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span>(al != n + <span class="number">1</span>) ans[x] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//big query</span></span><br><span class="line">            <span class="keyword">if</span>(maxl &lt;= <span class="built_in">min</span>(rp, minl + qlen[x] - <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">auto</span> [al, ar] = <span class="built_in">getcp</span>(maxl, <span class="built_in">min</span>(rp, minl + qlen[x] - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span>(al&lt;l) ans[x] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(minl &gt; l &amp;&amp; ar != n + <span class="number">1</span>) ans[x] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = tl; i &lt;= tr; i++)&#123;</span><br><span class="line">            <span class="type">int</span> x = id[i];</span><br><span class="line">            <span class="type">int</span> l = ql[x], r = qr[x];</span><br><span class="line">            <span class="comment">//small change</span></span><br><span class="line">            banp.<span class="built_in">insert</span>(l);</span><br><span class="line">            <span class="comment">//big change</span></span><br><span class="line">            querypos.<span class="built_in">erase</span>(querypos.<span class="built_in">find</span>(rk[l]));</span><br><span class="line">            </span><br><span class="line">            minl = <span class="built_in">min</span>(minl, l);</span><br><span class="line">            maxl = <span class="built_in">max</span>(maxl, l);</span><br><span class="line"></span><br><span class="line">            rp = <span class="built_in">min</span>(rp, r);</span><br><span class="line">        &#125;</span><br><span class="line">        tl = tr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans + <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能不能再快一点？空间能不能再小一点？</p>
<p>答案是可以的，首先后缀数组换成 SA-IS ，但即使换成 $O(n)-O(1)$ RMQ 排序也要 $O(n\log{n})$ ，如何处理呢？</p>
<p>注意到一个事情，排序的时候只关注子串是什么，而不关注子串的位置，因此只要我们能给每一个子串，找到最小的以该子串为前缀的后缀即可，做法也很简单：</p>
<p>将 height 从大到小跑，然后用并查集维护连接起来的一块，然后每次把一个子串送到所在连通块中排名最小的后缀即可。</p>
<p>这样就能在 $O(n\alpha(n))$ 时间排序完毕，再算上 $O(n)$ 的讨论，理论上能做到的最优复杂度：</p>
<p>时间复杂度：$O(n\alpha(n)))$ </p>
<p>空间复杂度：$O(n)$ </p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>tag说明</title>
    <url>/2023/09/04/tag%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>帮助更好的使用本网站的 tag 找到你想找到的内容。</p>
<details class="toggle" ><summary class="toggle-button" style="">字典序</summary><div class="toggle-content"><p>这里你会看到各种处理题目中最小字典序要求的做法，例如 DP 题要求最小字典序，字符串要求最小字典序等等。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">感觉</summary><div class="toggle-content"><p>依赖感觉的题目，难以证明。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>ACM杂类</tag>
      </tags>
  </entry>
  <entry>
    <title>WC2022 游记</title>
    <url>/2025/02/03/WC2022-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>寄了寄了，WC光荣爆零了，艹！</p>
<p>坐牢6天+光荣爆零，艹！一无所有。</p>
<p>这次竟然什么防护措施都不做，但是无所谓，作为一个Oier基本的自觉还是有的。</p>
<p>开始做了，这第一题什么东西。</p>
<p>括号序直接讨论太难了，所以要么折线法，要么括号树，折线法感觉不太行，那就括号树吧。</p>
<p>在长达两个小时的讨论后，我发现可以同时把s1,s2转化成()()()()()()()()的情况，然后两个半小时结束第一题。</p>
<p>第二道题目我一开始以为是分治<del>事实上确实有分治做法，但是我不会而已</del></p>
<p>然后一个小时砸在假做法上，第三道题目做个屁，这么不可做，继续想第二道题目的骗分，等会？回滚莫队很有戏，开写开写，等会？第三道题目有个词典？不管了，写写写，写完了，交~等等？为什么会有大数据，测一下，WA了？艹，哪里？排序放分块前面？艹，换回来，时间不够了，快交！艹！差一点交上去了。</p>
<p>现在只有0和<del>100</del>分了，艹！爆零了。日！</p>
<p>什么？？第二道题目莫队有可能满分？EMO了。</p>
<p>而后发现第一道题目原来是一个 $1$ 操作写成了 $4$ 操作导致了爆炸，艹！</p>
<p>中间还记错了讲评时间，导致了到处问做法的小丑行为🤡，哈哈哈哈哈。</p>
<p><del>不过BC问到了</del></p>
<p>只有 $A$ 没要到。</p>
<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>首先画出括号树，左边一条链直接拆，最终画成 () 和 (()) 的序列，对于 ()(()) ，直接 $3$ 操作变成 (())() ，对于(())(()) ，可以先 $3$ 后 $2$ 变成 (())()() ，然后把开头的 (()) 删了，在结尾添加 () 。</p>
<p>对于 s2 ，通过 $4$ 操作的逆操作，轻松变成 ()()()() ，当然，可能需要在最开始在字符串结尾补个 () 。</p>
<p>可以通过栈在 O(n) 的时间内解决。</p>
<p>听说这道题目的正解是用旋转想的，我死活想不明白这和旋转有什么关系，在<del>骚扰</del>询问了虎之后，我还是没有明白（不过根据他的说法优化了一下我原来的做法），看来只能等到洛谷题解出来后再看看了。</p>
<p>代码后面补。</p>
<h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>回滚莫队SB做法就不说了，分块是把值域分块，每个块只会有 $sqrt^2$ 种情况，预处理查询即可，太NB了。</p>
<p>nlog^2做法后面补</p>
<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p>本场比赛最迷惑的题目，正解是估值函数，根据询问情况给予每个单词一个估值，同样情况的不同字母估值都可能不同（根据出现次数决定），每次给出估值最大的单词即可AC。</p>
<p>代码也是后面再补。</p>
<h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><p>补一下AC代码。（只有C题的代码是需要从头开始码的，貌似C的代码也是最恶心的）</p>
<p>补充一下 A 的旋转思考方式。</p>
<p>补充一下 B 的polylog做法。</p>
<p><del>根据代码玩一下C题的游戏</del></p>
<p>本来有Au的QAQ</p>
<p>后排感谢虎的耐心讲解。</p>
<p><del>话说为什么我觉得树上硬搞比旋转好想好懂啊，虽然也花了我两个小时</del></p>
<p>不过这样看出了我的一个问题，在非OI赛制我的容错率比较低，我太逊了，乱搞题做的比较少，还要再接再厉，加油，奥里给！！！</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>五边形数定理学习笔记</title>
    <url>/2024/01/29/%E4%BA%94%E8%BE%B9%E5%BD%A2%E6%95%B0%E5%AE%9A%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<script type="math/tex; mode=display">\prod\limits_{i=1}^{\infty}(1-x^i)=\sum\limits_{k=-\infty}^{\infty}(-1)^{k}x^{\frac{k(3k-1)}{2}}=1+\sum\limits_{k=1}^{\infty}(-1)^{k}x^{\frac{k(3k\pm 1)}{2}}</script><details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>这个证明太厉害了，拍案叫绝。</p>
<p>首先，不难发现，$x^i$ 的系数是：偶数个不同正整数的拆分数的方案-奇数个不同正整数的拆分数的方案。</p>
<p>所以要证明这个定理就得找到一个关于偶数拆分和奇数拆的双射。</p>
<p>现在用一个点阵表示一个拆分，考虑把拆分数从大到小排序，然后第 $i$ 行的点的数量表示数的大小。（这玩意又叫Ferrers图）</p>
<p>下面是拆分：$6,5,3,1$ 的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0</span><br><span class="line">0 0 0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>考虑把最下面一行点的数量，也就是最小的数字设为 $s$ ，最右边 $45$ 度斜线的点的数量设为 $m$ 。</p>
<p>为了方便理解，对上面那个例子做了标记，$1$ 表示 $s$ ，$2$ 表示 $m$。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0 0 0 2</span><br><span class="line">0 0 0 0 2</span><br><span class="line">0 0 0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>如果 $s&gt;m$ 就把 $m$ 个元素放到最下面一行，否则把 $s$ 个元素放到 $m$ 个元素右边。</p>
<p>例如上面那个例子就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0 0 0 2 1</span><br><span class="line">0 0 0 0 2</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure>
<p>可以发现，这大部分情况下是一个双射，但是有一些特殊情况：</p>
<ol>
<li>$s=m+1$ ，同时拆分数的数字个数也就恰好 $m$ 个，这个时候如果拆出来就会有相同的两行：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0 0</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure>
这个时候数字总数为 ：$\frac{m(3m+1)}{2}$ ，系数为 $(-1)^m$ 。</li>
<li>$s=m$ ，同时拆分数的数字个数也就恰好 $m$ 个：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>
这个时候数字总数为 ：$\frac{m(3m-1)}{2}$ ，系数为 $(-1)^m$ 。</li>
</ol>
<p>综上，结论得证，证毕。</p>
<p>这个证明真的是太优美了。</p>
</div></details>
<p>参考资料：<a href="https://blog.csdn.net/visit_world/article/details/52734860">https://blog.csdn.net/visit_world/article/details/52734860</a></p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>五边形数定理</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>slope trick 学习笔记</title>
    <url>/2024/06/27/slope-trick-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>byd ，这么好用的东西怎么我上了大学才会啊 QAQAQAQAQAQAQAQ 。</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>题目链接：<a href="https://codeforces.com/problemset/problem/713/C">https://codeforces.com/problemset/problem/713/C</a></p>
<p>题目大意：给一个数字 $±1$ 的代价是 $1$ ，问给一个序列花最小多少代价可以变成严格递增序列。</p>
<p>$O(n^2)$ 的做法在此就不再赘述，主要讲解 slope trick 做法。</p>
<h1 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h1><p>注意到一个事情，我们设 $f_{i}$ 表示在处理完当前前缀后，最后一个数值是 $i$ 的最小代价。</p>
<p>那么每次添加一个数值 $a$ 就有两部分 $dp$ 过程：</p>
<p>$f_{i}=f_{i}+|a-i|$</p>
<p>$f_{i}=\min\limits_{j\le i}f_{j}$</p>
<p>可以观察到，$f$ 是长成下面那样的凸函数：</p>
<p><img src="1.png" alt=""></p>
<p>而 slope trick 就是维护斜率 $+1$ 的位置，也就是维护折点，但是有的折点如果要 $+k(k&gt;1)$ 咋整？那就维护 $k$ 个折点。（一般来说还要额外的维护一些值来保证函数能够唯一确定，比如本题就要维护当斜率为 $0$ 的值，用来确定函数的高度，同时也是最后的答案）</p>
<p>可以发现，上面两个过程分别对应：</p>
<ol>
<li>在 $a$ 处添加两个折点。</li>
<li>弹出最靠右的折点，并且维护函数的高度。</li>
</ol>
<p>然后就做完了，这个过程可以用堆维护，从而得到时间复杂度为 $O(n\log{n})$ 的做法。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">LL a[N];</span><br><span class="line">priority_queue&lt;LL&gt; p;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    LL ans = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        a[i] -= i;</span><br><span class="line">        p.<span class="built_in">push</span>(a[i]);</span><br><span class="line">        p.<span class="built_in">push</span>(a[i]);</span><br><span class="line">        ans += <span class="built_in">abs</span>(p.<span class="built_in">top</span>() - a[i]);</span><br><span class="line">        p.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="slope-trick"><a href="#slope-trick" class="headerlink" title="slope trick"></a>slope trick</h1><p>具体来说，当序列 $dp$ 满足：</p>
<ol>
<li>连续。</li>
<li>分段线性。</li>
<li>凸函数。</li>
</ol>
<p>就可以考虑 slope trick 。</p>
<p>而且这样的函数还有很好的性质，若 $f,g$ 满足，则 $f+g$ 也满足，且新的折点可重集合是 $f,g$ 可重集合合并起来。（是合并，不是并）</p>
<h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="1-A-New-Beginning"><a href="#1-A-New-Beginning" class="headerlink" title="1. A New Beginning"></a>1. A New Beginning</h2><p>题目链接：<a href="https://codeforces.com/problemset/problem/1534/G">https://codeforces.com/problemset/problem/1534/G</a></p>
<p>题目大意：在平面上，你初始在原点，每次只能往右往上走，然后有 $n$ 个点，你在 $(x,y)$ 与访问 $(x_i,y_i)$ 的代价是 $\max(|x_i-x|,|y_i-y|)$ ，然后问你访问所有点的最小代价。（访问并不会导致实际的移动）</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>可以发现，$(x_i,y_i)$ 在 $(x,y)$ $x+y=x_i+y_i$ 的时候访问一定是代价最小的，直接从斜线角度来看这道题目。</p>
<p>也可以换个角度，这个是切比雪夫距离，切比雪夫距离和曼哈顿距离可以互相转化，转化成曼哈顿距离以后就显然了，在 $x$ 坐标相等的时候访问就是代价最小的。</p>
<p>观察一下 $dp$ 式子，可以发现，我们要对这个函数维护两个过程。</p>
<ol>
<li>插入一个 V 字。</li>
<li>将斜率为 $0$ 的平台延长。</li>
</ol>
<p>用数据结构维护就是维护四个东西：</p>
<ol>
<li>斜率为 $0$ 的平台左/右边的折点。（可以用堆维护）</li>
<li>平台高度。</li>
<li>平台宽度。</li>
</ol>
<p>时间复杂度：$O(n\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">8e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    LL pos, val;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">priority_queue&lt;LL, vector&lt;LL&gt;, less&lt;LL&gt; &gt; l;</span><br><span class="line">priority_queue&lt;LL, vector&lt;LL&gt;, greater&lt;LL&gt; &gt; r;</span><br><span class="line">LL lazy, ans = <span class="number">0ll</span>;</span><br><span class="line"><span class="function">LL <span class="title">gettop</span><span class="params">(<span class="type">int</span> type)</span></span>&#123;</span><br><span class="line">    LL val;</span><br><span class="line">    <span class="keyword">if</span>(!type) val = l.<span class="built_in">top</span>();</span><br><span class="line">    <span class="keyword">else</span> val = r.<span class="built_in">top</span>() + lazy;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">poptop</span><span class="params">(<span class="type">int</span> type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!type) l.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">else</span> r.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushval</span><span class="params">(LL val, <span class="type">int</span> type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!type) l.<span class="built_in">push</span>(val);</span><br><span class="line">    <span class="keyword">else</span> r.<span class="built_in">push</span>(val - lazy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        LL x, y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        a[i].pos = x + y;</span><br><span class="line">        a[i].val = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, [](node x, node y)&#123;<span class="keyword">return</span> x.pos &lt; y.pos;&#125;);</span><br><span class="line">    l.<span class="built_in">push</span>(a[<span class="number">1</span>].val);</span><br><span class="line">    r.<span class="built_in">push</span>(a[<span class="number">1</span>].val);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        lazy += a[i].pos - a[i - <span class="number">1</span>].pos;</span><br><span class="line">        <span class="keyword">if</span>(a[i].val &lt;= <span class="built_in">gettop</span>(<span class="number">0</span>))&#123;</span><br><span class="line">            ans += <span class="built_in">abs</span>(a[i].val - <span class="built_in">gettop</span>(<span class="number">0</span>));</span><br><span class="line">            <span class="built_in">pushval</span>(<span class="built_in">gettop</span>(<span class="number">0</span>), <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">poptop</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">pushval</span>(a[i].val, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">pushval</span>(a[i].val, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i].val &gt;= <span class="built_in">gettop</span>(<span class="number">1</span>))&#123;</span><br><span class="line">            ans += <span class="built_in">abs</span>(a[i].val - <span class="built_in">gettop</span>(<span class="number">1</span>));</span><br><span class="line">            <span class="built_in">pushval</span>(<span class="built_in">gettop</span>(<span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">poptop</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">pushval</span>(a[i].val, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">pushval</span>(a[i].val, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">pushval</span>(a[i].val, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">pushval</span>(a[i].val, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://zhuanlan.zhihu.com/p/389740015">https://zhuanlan.zhihu.com/p/389740015</a></p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>slope trick</tag>
      </tags>
  </entry>
  <entry>
    <title>一句话题解.md</title>
    <url>/2023/08/22/%E4%B8%80%E5%8F%A5%E8%AF%9D%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<ol>
<li>UR 2 猪猪侠再战括号序列：<a href="https://uoj.ac/problem/31">https://uoj.ac/problem/31</a> 。</li>
<li>UR 3 核聚变反应强度：<a href="https://uoj.ac/problem/48">https://uoj.ac/problem/48</a> 。做法：把 $a_1$ 所有质因数找出来判一下就行了，时间复杂度：$O(n\log{V}+\sqrt{V})$ 。</li>
<li>ECNU 2023.8 A Extra Large Knapsack：<a href="https://acm.ecnu.edu.cn/contest/695/problem/A/">https://acm.ecnu.edu.cn/contest/695/problem/A/</a> 显然所有数字的异或和必须为 $0$ ，然后随便拉出一个数字出来就行了，记得特判 $n=1$ 的情况。</li>
<li>UR 8 赴京赶考：<a href="https://uoj.ac/problem/118">https://uoj.ac/problem/118</a> ，想想网格图长成啥样就知道怎么做了，时间复杂度：$O(n+m+q)$ 。</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 dp 优化的几种常用的证明方法</title>
    <url>/2024/07/04/%E5%85%B3%E4%BA%8E-dp-%E4%BC%98%E5%8C%96%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%81%E6%98%8E%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="减少转移"><a href="#减少转移" class="headerlink" title="减少转移"></a>减少转移</h1><p>有一种优化 $dp$ 的方式是减少转移，即我们发现某些转移就是不优秀的，然后扔掉，但是又怕多种转移扔掉后，相互作用，把答案扔掉了怎么办。</p>
<p>一种简单的证明方法是：</p>
<p>证明答案可以用当前 $dp$ 生成，即用现在的转移生成的的集合一定是原来转移集合的子集，答案一定不优于原答案，因此只要证明存在一种原答案的方案使得能够用这种转移生成就行。</p>
<h1 id="减少状态"><a href="#减少状态" class="headerlink" title="减少状态"></a>减少状态</h1><p>一种经典的 $dp$ 优化是我们记录二元组 $(x,y)$ ，发现 $y$ 单调，所以用 $f[x]$ 记录 $y$ 的最值。</p>
<p>但是这怎么用 $dp$ 语言证明呢？</p>
<p>我的建议是一种类似归纳的证法，从小到大，证明每个被丢掉的状态答案都一定不优于没被丢掉的状态，所以答案一定出在保留状态所能转移出来的答案中，即答案一定在保留状态能转移出来的集合中。</p>
<p>举个例子，我们证明 $(x,1)$ 根据<strong>现有转移</strong>所产生的的答案严格不优于 $(x,2)$ ，所以答案一定产生于 $(x,2)$ 转移出来的状态中，所以只关心 $(x,f[x])$ 转移出来的结果，然后再证明 $(x+1,f[x+1])$ ，以此类推，就可以证明该 $dp$ 的正确性了。（之所以要从小打大类似归纳，是因为我们在证明 $(x+1)$ 的时候，实际上就已经只在丢 $(x,f[x])$ 转移出来的没用的状态，那些之前就丢到的状态，甚至都没法转移，自然讨论 $x+1$ 的时候不会带上他们）</p>
<h2 id="既减少转移又减少状态"><a href="#既减少转移又减少状态" class="headerlink" title="既减少转移又减少状态"></a>既减少转移又减少状态</h2><p>这个时候要小心了，有可能减少转移的前提是存在某些状态，或者减少状态的前提是存在某些转移。</p>
<p>一种常见的流程是：先证明减少转移的正确性，再在减少过的转移下（即新问题下），证明减少状态的正确性，或者反过来。即先证明一个，再证明另外一个，但是注意后一个是基于前面一个已经实现的新问题上的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总之，上面说的证明思路总结下来就一条：</p>
<p>证明扔掉的部分答案小于等于留存的，从而证明答案一定出现在留存状态的集合中。（因为是减少状态或者转移，只能是原来状态的子集，因此答案只会变劣，不会变优，证明单边等号即可）</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>关于一个特殊背包的时间复杂度证明</title>
    <url>/2024/07/01/%E5%85%B3%E4%BA%8E%E4%B8%80%E4%B8%AA%E7%89%B9%E6%AE%8A%E8%83%8C%E5%8C%85%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<p>众所周知，如果完全背包中所有物品大小总和是 $V$ ，那么时间复杂度是 $O(V\sqrt{V})$ 的。</p>
<p> $01$ 背包也类似，但是我以前一直以为要写成多重背包的形式复杂度才是对的。</p>
<p>但实际上可以二进制拆分，时间复杂度也是对的，为什么呢？</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>首先，拆分中的最后一步，显然只有至多 $O(\sqrt{V})$ 种物品。</p>
<p>现在问题是那些 $2$ 的幂次的情况。</p>
<p>我们不妨考虑最坏情况，选择 $x$ 后，$\frac{x}{2^{i}}$ 全部都贡献了一次。</p>
<p>即对于 $x$ ，选其的贡献是最大的 $k$ ，满足：$x=2^ky$ 。</p>
<p>那么可以发现，这个贡献的数量级小于等于 $\sum\limits_{i=0}\sqrt{\frac{V}{2^{i}}}$ ，所以物品个数还是 $O(\sqrt{V})$ 的。</p>
<p>时间复杂度还是：$O(V\sqrt{V})$ ，比多重背包好写很多。</p>
</div></details>]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>关于如何思考有向图游戏上的不对称博弈问题</title>
    <url>/2024/08/01/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E6%80%9D%E8%80%83%E6%9C%89%E5%90%91%E5%9B%BE%E6%B8%B8%E6%88%8F%E4%B8%8A%E7%9A%84%E4%B8%8D%E5%AF%B9%E7%A7%B0%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>讲个笑话，这篇文章本来是想用来辅助证明 Moscow-International-Workshops-2017-Day-4-赛后小结中 I 的结论的，但是最后没有用到。</p>
<p>首先关于能建出 DAG 的不对称博弈，我们需要先确定一个事情，DAG dp 得到的 $ans$ 的就是答案。</p>
<p>原因是如果我是后手，只要给我 DAG 的 dp 转移过程，无论你是什么决策，我就一定能让你 $\ge ans$ ，而后手绝顶聪明，故答案 $\ge ans$ 。</p>
<p>同理，我是先手，可以证明 $\le ans$ ，所以是答案。</p>
<p>所以直接在 DAG 上 dp 是对的，问题是很多问题并不能在 DAG 上 dp ，所以就涉及了脱离 DAG 怎么思考不对称博弈的问题了。</p>
<p>不妨声称，我们只需要思考下面形式的决策：认为对手什么操作都做的出来，在任意一个状态，对手做出任何一个可行的操作后，我们会做出一个怎样的决策（即状态和对手操作唯一决定我的策略，没有任何别的因素）。这种决策很符合理性直觉。至于证明也非常简单，只要我们能构造一个答案相等的问题就行了。</p>
<p>为此，我们需要先思考一个问题，怎么知道一种决策对应的答案呢？即后手遵循怎样的策略呢？</p>
<ol>
<li>后手目的是为了使你的答案最劣，根据你的决策。（即在 DAG 上根据这个决策进行 dp ，得到使先手最劣的决策；也可以认为是后手根据先手的决策穷举所有的决策，最终得到使先手决策答案最劣的决策；或者认为是根据先手决策改造 DAG ，然后在这 DAG 上跑最长路）</li>
<li>后手目的是为了使你的答案最劣，根据你的最优决策。（这一句话指，忽略前面的操作，在当前状态下，后手会认为你绝顶聪明的情况下进行操作，使你的答案最劣。换句话说：其的决策是 DAG dp 上的其中一个最优转移）</li>
</ol>
<p>（如果你看过我后面写的内容，这里可以说一下为什么这里的方案 1 不会出现我预判你的预判的情况，因为这里先手指定策略完全不会受后手的具体决策影响，所以不会有这个问题）</p>
<p>显然，从 DAG dp 的角度可以证明，采用上面任意一种方案给每个决策赋予其答案，最终的最优答案都等于原问题的答案。<del>甚至混合使用也是，但是显然正常人不会这么干</del></p>
<p>但是采用方案 $2$ 有一个问题，就是可能会使不是最优决策的决策拥有最优答案，这在某些找最优决策的题可能会出问题。</p>
<p>总之，这个思考方法的核心就是，不要管别的乱七八糟的可能的决策，我们就划分出一块可以思考而且答案在里头的决策用于思考。</p>
<p>类似的，也可以用 DAG dp 证明一些别的思考方法，反正只要证明这个思考方法的答案不变就行了。</p>
<p>这里举个例子：一种可能的思考方式是认为后手在每个状态的决策是固定的，是 DAG dp 最优决策的其中一个（是哪一个在一开始就固定了，不会中途改变，虽然可以改变也是对的，但是思考起来可能会比较麻烦），在此基础上，先手要最优化答案，根据 DAG dp ，这显然也是对的。两个思考方法各有优劣，如果你能够思考出后者的最优策略，那么你就能直接当成一个非博弈题来做，但是如果你思考不出最优策略，那么一个存在但是你不知道的后手的固定策略反而会让你的思考僵化。</p>
<p>当然，除了直接思考不对称博弈的策略，还有许多种方法可以绕过这个过程，直接得到答案是啥：</p>
<ol>
<li>证明先手存在策略使得答案 $\le ans$ ，无论后手策略是啥；证明后手存在策略使得答案 $\ge ans$ ，无论先手策略是啥。所以答案就是 $ans$ 。</li>
</ol>
<p>下面的可以不用看了，想知道这篇博客背景的可以看看，上面已经总结完我最终得到的思考方法了。</p>
<hr>
<p>说起来，我在写小结的时候突然发现，我在思考不对称博弈的时候思维总是是混乱的，所以这里写一篇博客来理一理怎么思考不对称博弈。</p>
<p>这里放一个不对称博弈的例子：</p>
<p><a href="https://qoj.ac/contest/1213/problem/6370">https://qoj.ac/contest/1213/problem/6370</a></p>
<p>在思考这一类问题的时候，我总是会陷入一个误区，为什么不会出现我预判了你的预判的这种情况，就总是会想，虽然我可以证明这个世界线这样变方案不会更劣，但是说不定对手不如我的愿，改变了策略，反而使这种改变更劣了呢？</p>
<p>虽然直觉上，我改变了一条世界线，肯定不应该改变另外一条世界线，两者的决策应该是根据当前状态，而不会根据对手的策略，但是真要严谨证明上述过程，不借助具体模型，纯口胡总是很难表达清楚，总会陷入循环证明的情况；要么就十分的复杂，最后把自己都绕晕了；要么就涉及一点感性，怎么想都感觉别扭，什么一定最优，不会改变之类的（当然也有可能我是先天笨蛋圣体）。</p>
<p>以上面的例子为例，显然的，可以建出一个 DAG ，表示转移，显然最小值可以通过 DAG 转移出来，这样得出最小值的方法简单明了，清晰易懂，不会有任何争议。但是直接让我在原问题上想怎么通过优化决策的方式得到最小值，我就不知道为什么，总会觉得哪里很不对劲，哪里想错了，而且事实是在比赛时也确实想错了几次。</p>
<p>update ：后面发现有些疑惑的产生是因为题目让对手在大局上绝顶聪明，目标是阻止我，而细化到局部，“阻止我”这句话太过感性，没有具体的模型思考的话，我就总会感觉感性，会感觉怪怪的，所以解决方法就是找个模型就行了，具体见上面。</p>
<p>所以这里提供几个方法。</p>
<ol>
<li><p>直接证明这是答案的下界，然后取得到。</p>
<p>这种方法相当于直接规避掉了决策方案的讨论，类似投机取巧的方法，上面的那个问题就比较难用，但是方便直观。</p>
</li>
<li><p>仔细思考一下，上面我们为什么会陷入疑惑，即为什么两者的决策会跟对手有关，我思考了一下，感觉可能是潜意识中对下述两个问题的混淆：</p>
<ol>
<li><p>如何在知道对手决策的情况下使得其答案更劣？（指裁判方的决策，下个问题同）</p>
</li>
<li><p>如何在知道对手决策的情况下使得其在最优情况下答案更劣，或者换句话说，如果这个时候，对手换成绝顶聪明的人，我们什么操作能使对方得到最劣的答案？</p>
<p>说到底我会疑惑主要是很多时候陷入到了前者，但实际我们应该考虑后者。注意到后半句话其实和题目要求很像：认为对手绝顶聪明。这两个问题的本质区别在于，实际想问题的时候，我们在追求最优方案，即我们在尝试模拟绝顶聪明的人是怎么想的。但绝顶聪明是怎么定义的呢？怎样算绝顶聪明的呢？</p>
<p>如果在类似 LOL 这种游戏，必须要考虑对手决策的情况下，这种问题是难以回答的，但是在 DAG 上时，这种绝顶聪明是可以定义的，就是只要决策符合 DAG 上 dp 的最优转移，这个操作就是绝顶聪明的人能干出来的。</p>
<p>而我们在尝试找到己方最优方案的同时，我们在模拟对方的方案的时候，其实潜意识中认为了对方知道我们不是绝顶聪明的这个信息，从而对方会尝试通过我们的决策找到最劣的答案（问题 1）。但实际的问题一定是我们就是绝顶聪明，对手也知道（问题 2）。因此在 DAG 问题上，对手的操作可以认为是基本固定的。</p>
<p>因此，我们可以在疑惑的时候，多想想我们是不是把问题 2 搞错成了问题 1 。</p>
<p>所以一个好的<strong>解决方法</strong>就是，既然对手在问题 2 的情况下，操作是基本固定的，那么我们不妨就直接固定下来，具体来说，将问题转化为：</p>
<p>当对手碰到某个状态，一定会进行 DAG dp 上所指示的其的最优策略，有多个进行其中任意一个即可。显然这样不会改变答案（证明就 dp 一下就行了，发现转移是不变的），这样就将对手操作固定，从活物变成规则集，这样会好思考很多。</p>
<p>在这个新的问题上，为啥改变其中一条时间线不会影响到其他时间线的原因就显然了，只要我其他时间线的决策不变，而对手的决策是固定的，所以显然就不会变。</p>
</li>
</ol>
</li>
<li><p>就认为对手并不是绝顶聪明的，是一个会给出任意策略的神经，因此你在思考最优策略的时候，必须在所有状态，都决定好其打出任意可行操作后的策略，这个思考方法可以认为就是在有向图游戏上 dp 过程的具象化，有向图游戏上的 dp 过程在得到我方某个状态的最优解的时候，实际上就是穷举了对手下一步的所有操作并转移的。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>关于决策点单调右移的小杂谈</title>
    <url>/2025/02/03/%E5%85%B3%E4%BA%8E%E5%86%B3%E7%AD%96%E7%82%B9%E5%8D%95%E8%B0%83%E5%8F%B3%E7%A7%BB%E7%9A%84%E5%B0%8F%E6%9D%82%E8%B0%88/</url>
    <content><![CDATA[<p>决策点单调右移</p>
<p>如果是简单的决策点单调右移，分治即可搞定。</p>
<p>为什么是对原数组二分？难道决策点区间每次不减少二分之一也是对的。</p>
<p>可以发现每一层是 $O(n)$ ，而对原数组二分则是限制了层数是 $O(\log)$ 的。</p>
<p>因此时间复杂度是 $O(n\log{n})$ 。 </p>
<p>非常妙的分治做法啊，限制层数以达到 $\log$ 复杂度。</p>
<p>如果在此基础上，有更强的单调性，则可以直接双指针。</p>
<p>即如果 x&lt;y&lt;z 且 ax&lt;az ，那么有 ax&lt;ay&lt;az ，则可以直接双指针转移。</p>
<p>时间复杂度可以优化到：$O(n)$ 。 </p>
<hr>
<p>做题做到一道很有趣的决策点单调右移。</p>
<p><a href="https://pjudge.ac/contest/942/problem/21650">https://pjudge.ac/contest/942/problem/21650</a></p>
<p>十分显然的决策点单调左移，但是乍一看并不满足单调性，因此我当时采用了分治做法，事实上也确实能过，但是这道题目不止于此。</p>
<p><a href="https://pjudge.ac/submission/34246">https://pjudge.ac/submission/34246</a></p>
<p>如果把 $(a,b)$ 看成一个点，那么query函数就可以看成过这个点的一条斜线在 y 轴的截距，求最大截距，显然，答案只可能出在凸包上。</p>
<p>而且不难发现答案在凸包上具有单调性，于是可以用双指针做到 O(n) 。（有亿点像斜率优化） </p>
<p>不过可惜的是排序的 log 去不掉。 </p>
<p>感觉是十分 NB 的决策点单调右移题目。 </p>
<p>看完这道题目的题解，我开始思考，如果我不会分治做决策点单调右移题目，我是不是有机会想出这个双指针做法？</p>
<p>就像一些古文明没发展出铜，但是打制石器却能到今天的人都可望而不可即的境界。</p>
<p>后面，我想明白了，强不是限制自己的科技树从而做到某些方面登峰造极，而是在做到知识面开阔的情况还能灵活应用，这才是真正的高难度，真正的强者。</p>
<p>当然，这也是为什么某些人（包括我自己）知识面变得更加开阔的时候反而变得更弱的原因，所以只能说学知识是把双刃剑，能熟练掌握才是真正的神仙啊。 </p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>一个很好思考的分析下取整的方法</title>
    <url>/2024/09/05/%E4%B8%80%E4%B8%AA%E5%BE%88%E5%A5%BD%E6%80%9D%E8%80%83%E7%9A%84%E5%88%86%E6%9E%90%E4%B8%8B%E5%8F%96%E6%95%B4%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>哎，没办法，其余的分析方法都要想一会，就这个比较无脑。</p>
<p>考虑 $y = \frac{x}{result}$ 得到的是什么，是不是 $y$ 是一个实数满足：$\frac{x}{y}=res$ ，$y$ 增大一点则 $\frac{x}{y}$ 变小，否则增大。</p>
<p>所以可以知道 $\left\lfloor \frac{x}{res} \right\rfloor$ 得到的是最大的满足 $\left\lfloor \frac{x}{y}\ge res \right\rfloor$ 的 $y$ 。</p>
<p>这个就好想多了。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>关于某个奇怪的合并集合问题的时间复杂度证明</title>
    <url>/2024/07/24/%E5%85%B3%E4%BA%8E%E6%9F%90%E4%B8%AA%E5%A5%87%E6%80%AA%E7%9A%84%E5%90%88%E5%B9%B6%E9%9B%86%E5%90%88%E9%97%AE%E9%A2%98%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<p>其实是清华营 2024 预选赛的 K. String Mutation</p>
<p>题意大概是说给一个字符串，有三个操作：</p>
<ol>
<li>某个位置变成某个字符。</li>
<li>所有等于 $x$ 的位置全部变成 $y$ 。</li>
<li>查询两个子串是否一样。</li>
</ol>
<p>做法很简单，就是启发式合并然后用数据结构维护一下 Hash 值。</p>
<p>但是我用的线段树，后面和朋友交流发现可以用树状数组，这个玩意能求逆确实可以用树状数组，唐了。</p>
<p>然后呢，我本能的认为这玩意的复杂度应该是一个启发式合并 + 修改字符的复杂度，所以时间复杂度应该是 $O(n\log^2{n} + q\log{n})$ 。</p>
<p>但出乎意料的事情来了，首先，朋友告诉我，启发式合并的时间复杂度应该是 $\log{26}$ ，我一想还真是。</p>
<p>设计函数 $f(n,k)$ 表示集合大小为 $n$ ，合并了 $k$ 次的复杂度，那么有：</p>
<p>PS：下面的所有 $\log$ 全是以 $2$ 为底。</p>
<p>$f(n,0)\le n\log{(0+1)}$ ，现在归纳证明：$f(n,k)\le n\log{k+1}$ 。</p>
<p>假设合并的集合为 $x\le y,t\le t-1,k-t$ 。</p>
<p>那么有：$f(n,k)\le x\log{t}+y\log{k-t+1}+x$ ，只需证明右边 $\le n\log{k+1}$ 即可。</p>
<p>如果 $2t\le k+1$ 即 $2t-1\le k$，那么显然有 $x\log{t}\le x\log{k+1}-x$ 。</p>
<p>如果 $2(k-t+1)\le k+1$ ，即 $k\le 2t-1$ ，那么显然有 $y\log{k-t}\ke y\log{n}-y\le y\log{n} - x$ 。</p>
<p>而显然这两种情况必定发生一种。</p>
<p>综上归纳成立。</p>
<p>就在我以为这就结束的时候，我打算写下这篇博客，但是我想着干脆把给原题写个完整的证明吧。</p>
<p>意外发生了，原来后面不是 $q\log$ 的，是 $q\log^2$ 的。</p>
<p>一个简单的构造方法：</p>
<p>假设字符集无穷，一开始有 $n$ 个集合就可以达到 $n\log^{n}$ 。</p>
<p>如果一开始没有 $n$ 个集合，那么在用了 $S$ 次操作后，变出大小为 $n$ 的集合，然后用操作 $1$ 变出 $n$ 个集合。（$S$ 是初始的不同字符个数）</p>
<p>但是如果字符集不是无穷呢？也简单，调整一下操作的顺序就可以做到了，简单来说，类似二进制那样，现在有 $2^k$ 大小的集合，其中不同集合 $k$ 不同，然后每次让大集合吐出一个大小为 $1$ 的集合，然后从小到大把相同大小的集合合并即可。</p>
<p>可以注意到，这个过程实际上是把类似线段树一样的合并过程给全部完整的走了一遍的，所以时间复杂度是：$O(n\log^2{n})$ 的，而且付出的操作是 $O(n)$ 的，所以总的时间复杂度至少是 $O(q\log^2{n})$ 的。</p>
<p>而证明是这个复杂度也不难，一开始生成 $q$ 个大小为 $1$ 的集合，然后把操作 $1$ 看成合并。</p>
<p>这样时间复杂度是：$q\log^2{(n+q)}$ 的，欸，和 $q\log^2{n}$ 还有区别，那要怎么消除这个区别呢？</p>
<p>很简单，每隔 $n$ 次看一眼就行了，具体来说，将操作 $n$ 次分成一组，这样每 $n$ 组的时间复杂度按照上述证明，上界为 $\log^2{n}$ 的，所以总的时间复杂度是 $q\log^2{n}$ 的，证毕。</p>
<p>所以最终的时间复杂度是：$O(n\log{26}\log{n}+q\log^2{n})$ 的。</p>
<p>真是太 amazing 了。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>关于自学</title>
    <url>/2024/09/24/%E5%85%B3%E4%BA%8E%E8%87%AA%E5%AD%A6/</url>
    <content><![CDATA[<p>退役了，和室友交流了下怎么自学。</p>
<p>先写点交流过后的心得，自学一段时间后再更新想法。</p>
<h1 id="自学的方式"><a href="#自学的方式" class="headerlink" title="自学的方式"></a>自学的方式</h1><p>一般情况下要么看书要么看视频。</p>
<p>看书的好处：</p>
<ol>
<li>省去听的时间。</li>
<li>培养理解概念，和深入思考课程本质的能力，为未来看文献搞科研做准备。（这个是我以前没有想到过的）</li>
</ol>
<p>看视频的好处：</p>
<ol>
<li>老师会把概念搅碎喂给你，更易懂，同时会分享一些他对这个学科的看法和理解，更容易学到知识背后的本质（看老师）。</li>
</ol>
<p>一般情况下推荐看书，不懂再看视频。</p>
<p>再深入讨论一下看书的优点 2 ，一般情况下，在自学的时候限制某方面的捷径，就会培养对应的能力，比如看英文书培养英语能力。同理，不过度依赖老师讲出知识的本质，就能培养自己思考本质的能力。既然都要自学了，肯定是奔着提升能力去的，自然是怎样更好提升能力怎么来，只要不特别影响学习速度（不过如果实在学不明白还是要用轮椅学法的）。所以平时自学要思考，现在学的这么顺，是否是以牺牲了学习某方面能力的机会为代价的。</p>
<h1 id="关于疑惑"><a href="#关于疑惑" class="headerlink" title="关于疑惑"></a>关于疑惑</h1><p>解决方法：</p>
<ol>
<li>搁置，后面再看。</li>
<li>问人。（需要有志同道合的人或者老师）</li>
<li>上网搜资料。</li>
</ol>
<h1 id="关于笔记"><a href="#关于笔记" class="headerlink" title="关于笔记"></a>关于笔记</h1><p>搞清楚一些事情：</p>
<ol>
<li>学了不用总会忘的。</li>
<li><p>希望学了一遍书就写出知识的大纲是困难的。</p>
<p>具体来说，我之前不想学习有一个原因就是怕忘，我总觉得别人不会忘，我会忘，我就不想学了，但实际上不用就是会忘，问了室友发现也是。我之前希望能通过写大纲的方式来解决遗忘的问题，具体来说，写下大概率会忘的东西，比如概念、定理和对该学科的一些理解，隐去自己能记得、能推的或者不是特别重要的东西，例如证明和例题，这样到时候看一遍大纲就能回忆个七七八八。</p>
<p>但实际上这也是异想天开，希望学过一遍就写出具有这种作用还简洁的大纲不大可能，要么写漏很多，到时候还是看不懂，要么太冗杂，不如直接看书。一般情况下，只有真正忘记一遍，才会知道自己到底想记下来什么东西。</p>
<p>那笔记做些什么呢？首先写一遍关于定理的证明，作用是理思路，更深入了解定理及其证明，不要在脑子过一遍就过了，虽然快，但是实际上完全没用，就像看短视频一样，很快就忘了，什么都没留下。</p>
<p>其次，还是可以尝试记一下自己的理解和自己认为可能会忘的东西，虽然不大可能第一次就做出很好的知识大纲，但是做一下还是需要的，尤其是在没忘的特别干净之前看一下这种知识大纲还是可以的，同时也可以让自己整理一下学到了什么知识，类似思维导图的作用一样。</p>
<p>既然会忘干净为啥还要学？说到底忘干净还是玩笑话，学过再学会快很多，而且学过就会留下印象，在脑子里面留下相关的定义、定理、方法和思路，这对自我的提升都是有用的。</p>
<p>其次，读第二遍或者更多遍的时候，就可以尝试写出简洁的知识大纲了，一方面，理解更深了，更容易写出重要的、未来会用到的知识点，另一方面也更不容易忘记这些知识了，所以读更多遍后写出的知识大纲就会有用很多了。</p>
</li>
</ol>
<p>现在我的想法是笔记一页分为左右两部分，左边是大纲，写定理和定义啥的，右边写对应的证明、细节和理解，等到看大纲的时候就直接读左边就行了。</p>
<ol>
<li><p>笔记要尽可能简洁。</p>
<p>觉得大概率不会忘记的知识点不用记。</p>
<p>证明的细节不用记，记思路就行。</p>
<p>网上能搜到的东西不用记，例如网络的基本框架就不用记了，记这个干嘛呢，这么不相信自己的搜索能力。</p>
<p>一些故事和历史类型的知识点不用记，我又不是史学家，记这些干嘛。</p>
</li>
<li>笔记的载体可以是 ipad 或者电脑，一般来说，为了高效，数学用 ipad ，计算机用电脑。</li>
</ol>
<h1 id="看书的一些方法。"><a href="#看书的一些方法。" class="headerlink" title="看书的一些方法。"></a>看书的一些方法。</h1><ol>
<li>在看书的时候可以尝试揣测一下后面他会说什么，这样能激发自己对知识的思考，加深对知识的理解，尤其是学数学相关的内容，能培养所谓的数学直觉和数学的思考方法，学会如何自然的思考问题。（虽然计算机很多课程更多是架构之类的，但是猜一下也可以，思考一下如果是你来设计这种架构或者你写代码会怎么做，同样能加深理解，培养素养）</li>
<li>多提问题，为什么这么定义，为什么思考，为什么这么做，这样证明的动机是什么，知其然知其所以然，同样能够加深理解，培养学科素养，学会如何以数学的方式思考问题和发现问题（学数学的时候）。</li>
<li>组建自学团队，每过一段时间和队友交流一下看书心得。（暂时不打算用，社恐是这样子的）</li>
<li><p>update : 2024.10.22</p>
<p>最近看书发现了一个问题，自己自学数学的速度太慢了，于是询问了一下别人是怎么看书的。</p>
<p>主要集中在两个问题上：</p>
<ol>
<li>定理证多久比较好。</li>
<li>按照什么顺序看书比较好。</li>
</ol>
<p>首先是第一个问题，为什么会有这个问题，因为我犯了一个错误，自学和打竞赛不太一样，更注重的是对于知识体系的理解，而不是每个定理是否自己证出来了。如果自学数学每个定理都自己花很长时间去证，实在证不出来再看书，那么看书的进度会巨慢无比（除非你是个神犇）。</p>
<p>为什么不建议自己花长时间证明：</p>
<p>而且不只是速度问题。毕竟从自身来讲，首先自学本身就是在接触陌生的概念，证明起来本身就会有点生疏。而且在不熟悉知识体系的情况下，很多定理证明的动机、概念的目的和背景都不清楚，证明一些定理更是吃力，一个经典的例子（我还没学，同学跟我说的），抽代一些前面的定理，在后面看完伽罗瓦理论，对抽代的一些结构有了一定认知后，就会觉得这些定理是显然的（原因是学了后面的知识后，知道了这个定理提出的背景、想要解决的问题以及证明的动机），但是如果不了解相关背景直接硬证，就会觉得困难。</p>
<p>其次从定理角度来讲，很多定理本身就很难想，证法还会比较科技，经常会用一些让人匪夷所思的证法，在这种定理上花一两个小时证明，不会看书发现是这种科技证明，那感觉就跟吃了*一样，我不觉得在这种定理上花费时间去证明和浪费时间有什么区别，毕竟我们不是天才，无法所有定理都证明，对我们而言更重要的是其背后的思想和动机，一些数学思维。</p>
<p>再其次，从理解知识体系的角度考虑，有些定理的证明其实对理解这个知识体系没什么帮助，尤其是一些比较科技的证法，花太多时间沉迷于定理的证明以及这个知识体系的各种细节，有时候反而会阻碍对知识体系有个大的理解，我个人认为（主要还是和同学交流，认同他们的看法），学这些数学，最重要的是学到他们的思想，这个知识体系的作用，而不是学到一堆科技证明。</p>
<p>最后就是一个很有意思的观点，在接触新概念的时候，在证明很多定理的时候，花时间的实际上是弄清楚概念，比较一接触概念就能得心应手应用的人是少数，很多时候都是在证明的时候一边熟悉这个概念是什么，这个概念到底是为了赋予对象一个什么性质，这实际上占用了很多证明中的时间，一个好的解决方法是跳过证明，直接通读后面的部分，对概念比较熟悉后，再来补各种定理的细节，能省掉一些被浪费掉的时间。</p>
<p>那么一个比较好的做法是怎么做呢？我问了两个同学，他们给出了一些建议：</p>
<ol>
<li>对于证明时间的问题，如果一个定理看上去没感觉，没必要花时间，直接看书，有感觉的花个几分钟证证就行了，毕竟感觉可能会骗人。但在看完书上的证明后要尝试理解他是怎么证明的，为什么能想到这么证（动机）。</li>
<li><p>看概念的时候可以慢一点，慢一点指自己举些这个概念的例子，尝试理解这个概念提出的目的，或者说作用等等，然后还有能力的再猜猜这个概念的几个性质等等，总之就各种方法来熟悉这个概念。相当于把在证明中熟悉概念的实际单拉出来，成为一个具体的步骤，虽然同样要花时间在理解概念上，但是单独成为一个步骤后可能效率会高一点？</p>
<p>可能因为理解上不拘泥于对某个定理的证明，又或者说成为一个单独的步骤后，自己会想出很多方法来提高这个步骤的效率，比如前面说的几个方法（举例子啥的）。总之虽然不明白具体原因，但就是感觉单独成为一个步骤后效率会高点。</p>
</li>
<li><p>一个比较厉害的阅读顺序：先草草的通读一遍书，然后再回过头来补细节。好处就是虽然多花了点时间，但是能够很好的对知识体系建立一个整体的印象，这个时候再来证明定理会好很多（对知识体系有了解后对某些定理会有一个证明的动机或者说方向，就会好证很多），而且相当于看了两遍书，所以印象会更深一点。</p>
</li>
</ol>
<p>总结一下，我个人想边看边证，同时概念看的慢一点，证明时间方面，对于有感觉的定理，先自己想个几分钟，如果想不出来，就先放着，后几天有空的时候再拿出来想想，还想不出来再看书，防止在看书时延缓进度。至于为什么不提前向后看呢？首先是不习惯；其次虽然边看边证可能会花时间在熟悉概念上，但是用多长的时间熟悉一个概念，知道这个概念想干啥本身也是一种能力，一种数学思维，而直接向后看可能就失去了锻炼这种机会的能力，我觉得我是需要锻炼这种能力的，所以选择了边看边证。</p>
<p>至于这种读书方式好不好，就等过一段时间后再来更新了。</p>
</li>
<li><p>看书时会莫名其妙的效率低。</p>
<p>方法：边看书边记个表，在每个重要时间点记下当前时间和要干的事，一方面能监督自己不要偷懒（有人喜欢看一会书刷一会短视频，我不说是谁，诶诶），对时间有个概念，另一方面方便自己复盘，反思出更高效的看书方法。</p>
</li>
<li><p>update : 2024.10.31</p>
<p>书上的习题该不该做？</p>
<p>首先搞清楚做书上习题的目的是啥：</p>
<ol>
<li>巩固知识。</li>
<li>把过程写下来方便未来复习用。</li>
</ol>
<p>做题的形式有两种：</p>
<ol>
<li>写过程，能验证自己的证法对不对，能复习。</li>
<li>想清楚就行，主要是快。</li>
</ol>
<p>要不要做习题，以及用什么方式做习题，和经验丰富的室友交流了一下，现在总结一下想法：</p>
<ol>
<li>做书上习题的作用主要是巩固知识，方便复习是其次，主要复习一般会看书而不是习题，而且复习时看了习题不会做之前会做的题只有两种可能，要么之前做错了，要么复习的时候没复习仔细，所以其实第一次做题时留下的痕迹对复习并不是很重要。</li>
<li>我现在的观点还是只要是习题都可以做，但是对于比较简单的，直接写个显然然后过掉，比较难的放空闲时间想想，不耽误看书时间，还想不出来直接跳过（如果能搜到题解可以看看），没必要要求习题都能做出来，现在是在自学不是在打竞赛。</li>
<li>写题目过程时，只写比较难想的思路和细节（相对于我自己的实力而言），或者比较优美的证明，其余比较简单的东西直接跳过，或者写个显然，一方面能验证自己有没有证明对，另外一方面复习也能看，其次还节省时间。</li>
</ol>
</li>
</ol>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ol>
<li>学习要学会跳出舒适圈，才能更好的提升自我，查漏补缺，一个事情就算再抗拒，只要对你价值大，都要做。</li>
<li>无论采取什么自学方法，最难的地方都是坚持下去。坚持下去，才能品尝成功的果实。</li>
<li>开始自学后发现，每天自学完都有种我今天好像什么都没有学到的惶恐感，一个好的解决方法是每天回忆一下或者写个总结，回忆或总结今天学到了什么，一方面可以缓解焦虑感，另外一方面可以简单的复习一下今天学到的内容，巩固知识，其次还可以根据回忆或总结进行反思，制定更好的自学计划，或者养成更好的自学习惯。</li>
</ol>
<h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><ol>
<li>自学 CS : <a href="https://csdiy.wiki/">https://csdiy.wiki/</a></li>
</ol>
<h1 id="CS-学习计划"><a href="#CS-学习计划" class="headerlink" title="CS 学习计划"></a>CS 学习计划</h1><ol>
<li><p>计算机导论 ：<a href="https://www.bilibili.com/video/BV1EW411u7th/?vd_source=5dd17c0f68b735f1a16d0353c08bcc7a">https://www.bilibili.com/video/BV1EW411u7th/?vd_source=5dd17c0f68b735f1a16d0353c08bcc7a</a></p>
<p>前置知识：无。</p>
<p>进度：看完了，没做笔记（导论课做什么笔记）。</p>
</li>
<li><p>Missing Semester ：<a href="https://missing.csail.mit.edu/2020/">https://missing.csail.mit.edu/2020/</a></p>
<p>前置只是：无</p>
<p>相关网站：</p>
<p>   中文网站（里面附有习题讲解）：<a href="https://missing-semester-cn.github.io/">https://missing-semester-cn.github.io/</a></p>
<p>   熟肉视频：<a href="https://space.bilibili.com/518734451?spm_id_from=333.337.search-card.all.click">https://space.bilibili.com/518734451?spm_id_from=333.337.search-card.all.click</a></p>
<p>进度：第四章</p>
<p>笔记：</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>博客食用指北</title>
    <url>/2024/01/19/%E5%8D%9A%E5%AE%A2%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8C%97/</url>
    <content><![CDATA[<h1 id="2025-2-3"><a href="#2025-2-3" class="headerlink" title="2025.2.3"></a>2025.2.3</h1><p>退役半年力，这个博客也是时候该用于各种用途了，感觉以前对写博客的要求有点高，虽然写出来是一坨。</p>
<p>正在进行很久以前的博客的搬运工作，所以会很自然的出现晚写的博客比早写的博客唐很多的情况，希望各位谅解，当然，我猜很多能看到这个博客的人基本上也并不是奔着看题解来的，估计有很多人是我的熟人。</p>
<p>跟以前的风格不太一样，现在我写博客的风格更倾向于给定义，然后根据定义一步步推导，类似于形式化语言那样子的思路，如果你适应不了这样的语言那我感到抱歉，不过我个人认为形式化语言是比较严谨的呈现想法的一个方式（当然一开始不太习惯是真的，我去教培行业打工时也深刻感受到这一点）。当然，肯定还是会穿插我自己的感性理解的，毕竟形式化语言是表，而理解是里，二者缺一不可。</p>
<p>至于博客的风格吗，自然是想到哪写到哪，像之前那样遵循一个格式写，虽然博客会有一种统一的美，但是首先这样很累，适应得了叫习惯，适应不了叫麻烦，根据我以往的表现来看，显然是适应不了的；而且总会有风格变化的时候，那难道把前面的博客重新再改一遍？不可能，工程量太大了，最简单的方式当然是随心所欲了。</p>
<p>当然，肯定还是有可以固定的地方的，比如 tag ，如果是游记就都加上游记 tag 等等，方便浏览，同理，不同时期制定的规则都只适用于当时的文章。</p>
<p>至于各种文章都会留下一些坑，我的评价是就让他过去吧，可能有时候会去填这些坑，当我对这些坑整体的态度是放弃，在造坑的时候总想着以后会做，直到后面积少成多后放弃，我已经干了很多次这样的事情了，事实上最好的填坑时间是造坑的那几天，再过几天就不要再想着这些坑会填了。什么时候能改掉这cjb拖延的习惯。</p>
<p>然后文章内容的话，仍然会有一些意识流，我仍然会去思考怎样想一个东西会更加的自然，并且写在博客里面<del>不写出来让大家一起赤那我不是白想了</del>，当然，我会尽量放在文章最后，文章中间的内容尽量写的清晰一点，不要像以前一样揉成一坨，我自己看的都难受，即内容和感想分离开来，尽量让内容更加清晰，让大伙和未来的我看的更加明白一点。（那有人会想，你以前为啥不这么干，因为我以前虽然知道读者看不懂，但是我以为我未来能看得懂，结果就是现在我发现我对不上以前电波了，万分痛苦，世上唯一一个能对上过去自己电波的人消失了，那以前写的真就成矢了，我可不希望现在及以后写的东西也是这个下场）</p>
<p>然后现在做出一些约定：</p>
<ol>
<li>赛后总结类的文章不会总体标注出 tag ，但可以在每道题下面单独标注 tag ，方便搜索搜到。</li>
<li>对各种文章的标题、内容框架等都没有统一的约定，但是 tag 尽量标好，比如各种游记，要有游记 tag ，赛后总结则最好在标题清晰表明是哪场比赛，且标注是赛后总结，学习笔记同理。</li>
<li>对于各种题目该标什么 tag ，评价是涉及到什么标什么 tag （多个做法一般就都打上去），但部分情况下只会标重要的 tag ，比如学习笔记肯定只会标相关算法的 tag ，有些题目如果我觉得有些考点显然是不重要的也不会标（比如只要稍稍有点优化成分就会涉及到的线段树，以线段树为考点和用到线段树我觉得是不一样的）。</li>
<li>能归到小类就不会打大类的 tag ，比如我这道题目我知道是 kmp ，就不会打字符串的 tag 一样，大类的 tag 就是用来收纳不知道收纳啥的题目的，经典的就是杂项。（一个例外是 dp ，如果除了涉及到的小类 dp 例如状压之外，仍然有非常有意思的 dp 思想，则会在小类外加一个 dp 的 tag）</li>
<li>不涉及衍生算法，比如涉及网络流，不会把里面的最短路视为重要的。</li>
<li>除非涉及特定算法，否则一般标注问题类别，比如一道题目会用到生成树算法，则一般只会标注生成树，除非用到算法特性，比如 Boruvka 算法相关的题目；特别的，如果一道题目既可以用树状数组也可以用线段树，则只标明线段树。</li>
</ol>
<h1 id="以前"><a href="#以前" class="headerlink" title="以前"></a>以前</h1><p>我写博客有以下目的：</p>
<ol>
<li><strong>帮助我重新梳理一遍做法。</strong>（必要）（我自己写过的博客一般是不会自己再看一遍的，所以复习作用很小，更多的作用是帮助梳理）</li>
<li><strong>锻炼自己用简短语言描述做法的能力。</strong>（重要）（打ACM被队友吐槽表达能力不行，而且能简洁说明的事情为啥要长篇大论，还能节省写博客的时间）</li>
<li><strong>用更加标准公式化的方式描述做法，比如把某个题的做法和其他题目联系起来，总结成一类做法。</strong>（重要）（有助于能力提升）</li>
<li><strong>尝试扩展题目以及做法，学习更多的做法。</strong>（适当）（因为有些做法和题目就是没法扩展的，强行扩展可能浪费时间，但收益还行，学习做法这个事情也是两面的，有点显然，缺点是浪费时间，很多时候某些复杂做法其实就是简单做法的同构，但是需要等到看了很久才能发现这一点，这就会浪费很多时间，尤其是数据结构题）</li>
<li><strong>让读者看懂。</strong>（最次）（我的博客首先肯定是基于我自己再看一遍能懂的，所以肯定阅读门槛就是我自己的水平，或者比自己再弱一点的水平，如果你不能看懂请移步别人的博客。因为我写博客的初衷就是为了自己的提升，当作自己的笔记本用的，而不是造福广大OIer的。当然，如果几乎大部分人都看不懂的话我就有必要反思自己的语言表达能力了）</li>
</ol>
<p>至于第5条，对我自己最重要的警告就是，写博客要明白什么东西是要写的，什么东西是不用写的（我一定懂的），深刻明白这一点能够节省我很多时间，最大化博客对我的作用。（毕竟我之前经常放弃写博客的原因就是浪费时间，而且我写博客一贯的作风就是冗杂，对读者对我都不好，这点一定要改）</p>
<p>一个经典的例子是：一个题目有很多证明，不需要什么证明都写，写一两个个人认为最优美的证明就行了。不否认每个证明都有其自己的价值，但实际上有很多证明我自己心里也清楚，我绝对不会再想看他第二次了，感觉不如 ** 证明。（有很多做法的情况也是同理）</p>
<p>至于反思总结的工作，我会自己在本地机子上用excel编写，写在博客上一来我自己不会看，而且多篇博客的形式很不方便重新浏览这些总结，二来这些极具个人色彩的东西放在博客里也十分影响观感，而写在excel上清晰明了，方便反复查看，作用最大化。</p>
<p>比较简单的题目不会写博客，有时候可能会提一嘴。</p>
<p>附录：</p>
<ol>
<li>官方题解的部分不仅会解释官方题解，某些题目还会额外的思考：究竟如何思考这道题目，才能更快的想出做法。（思考如何正确的思考）</li>
<li>一场比赛的题目有时候会在比赛总结里面统一讲解，不会单独开一个博客单独讲解。</li>
</ol>
<h2 id="暂未解决"><a href="#暂未解决" class="headerlink" title="暂未解决"></a>暂未解决</h2><p>按照如下步骤进行：</p>
<ol>
<li>在文章的小标题（不是文章标题）中使用“坑”的标记。（结合第二条方便定位在文章中的位置）</li>
<li>在博客“待解决”中加入需要解决的事宜。（方便定位）</li>
<li>在本地机子的计划中写上期望解决的日期，到达这个日期就就将这个“坑”的解决提上日程。</li>
</ol>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>卡常的辅助方法</title>
    <url>/2024/02/20/%E5%8D%A1%E5%B8%B8%E7%9A%84%E8%BE%85%E5%8A%A9%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<ol>
<li><p>使用能够测量代码时间的代码辅助卡常。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> begin = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="keyword">auto</span> elapsed = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::nanoseconds&gt;(end - begin);</span><br><span class="line">cerr &lt;&lt; B &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; elapsed.<span class="built_in">count</span>() * <span class="number">1e-9</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li>警告：别开O3，那不真实，万一比赛ban了O3你就完了，老老实实卡常，练习卡常技巧。</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>卡常</tag>
      </tags>
  </entry>
  <entry>
    <title>可以尝试解决的题目</title>
    <url>/2023/09/04/%E5%8F%AF%E4%BB%A5%E5%B0%9D%E8%AF%95%E8%A7%A3%E5%86%B3%E7%9A%84%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<ol>
<li><a href="https://acm.ecnu.edu.cn/contest/695/problem/E/">https://acm.ecnu.edu.cn/contest/695/problem/E/</a></li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>杂题</tag>
        <tag>待解决</tag>
      </tags>
  </entry>
  <entry>
    <title>小凯的疑惑</title>
    <url>/2024/05/29/%E5%B0%8F%E5%87%AF%E7%9A%84%E7%96%91%E6%83%91/</url>
    <content><![CDATA[<p>题目链接：<a href="https://www.luogu.com.cn/problem/P3951">https://www.luogu.com.cn/problem/P3951</a></p>
<p>题目大意：给你两个互质的整数 $a,b$ ，求最大的不能由 $ka+tb$ 表示的数字，其中 $k,t$ 非负。</p>
<p>看到一个很好的解法，这里写一下。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>需要明白，不定方程和同余方程本质是一样的。</p>
<p>从同余方程的角度考虑，$ka\equiv x\mod{b}$ ，不妨令 $0\le k \le b-1$ ，那么 $x$ 能够表示的充要条件是 $\frac{x-ka}{b}\ge 0$ ，因此直接令 $k=b-1,\frac{x-ka}{b}=-1$ 就可以得到最大的不能被表示的数字：$ab-a-b$ 。</p>
<p>当然也可以从不定方程的角度考虑，对于任意一组解：$ka+tb=x$ ，则 $(k-b)a+(t+a)b=x$ ，所以不妨令 $0\le k\le b-1$ （即找到最小的非负的 $k$），然后能表示当且仅当 $t\ge 0$ ，所以令 $k=b-1,t=-1$ 就行了。</p>
<p>可以看到，这两个做法几乎一样，本质上是相同的。因此在做题目的时候，可以哪个角度好想就从哪个角度想。</p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>工具推荐</title>
    <url>/2025/02/03/%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<h1 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h1><p>简单的 OI 绘图工具：</p>
<p>Graphviz，安装教程：<a href="https://baijiahao.baidu.com/s?id=1611287090525587939&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1611287090525587939&amp;wfr=spider&amp;for=pc</a></p>
<p>Csacademy： <a href="https://csacademy.com/app/graph_editor/">https://csacademy.com/app/graph_editor/</a></p>
<p>数学画图网站：</p>
<p>GeoGebro： <a href="https://www.geogebra.org/graphing?lang=cn">https://www.geogebra.org/graphing?lang=cn</a></p>
<p>desmos：<a href="https://www.desmos.com/calculator?lang=zh-CN">https://www.desmos.com/calculator?lang=zh-CN</a></p>
<p>我更喜欢用 desmos ，比较流畅</p>
<h1 id="Latex"><a href="#Latex" class="headerlink" title="Latex"></a>Latex</h1><p>Latex 在线公式编辑：<a href="https://www.latexlive.com/">https://www.latexlive.com/</a></p>
<h1 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h1><p>deepl（听说用来翻译十分的不错）：<a href="https://www.deepl.com/translator">https://www.deepl.com/translator</a></p>
<h1 id="数学软件"><a href="#数学软件" class="headerlink" title="数学软件"></a>数学软件</h1><p>Wolfram|Alpha: Computational Intelligence (wolframalpha.com)：<a href="https://www.wolframalpha.com/">https://www.wolframalpha.com/</a></p>
<p>各种数学算式都可以用这个网站算，挺强大的。</p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>实验</title>
    <url>/2023/08/08/%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="喜"><a href="#喜" class="headerlink" title="喜"></a>喜</h1><h2 id="怒"><a href="#怒" class="headerlink" title="怒"></a>怒</h2><h3 id="哀"><a href="#哀" class="headerlink" title="哀"></a>哀</h3><h2 id="乐"><a href="#乐" class="headerlink" title="乐"></a>乐</h2><h1 id="典"><a href="#典" class="headerlink" title="典"></a>典</h1><p>$a_{i}=1$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>$good$<br>good</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello world.</span><br></pre></td></tr></table></figure>
<p><img src="1.png" alt="1.png"></p>
<p>😀</p>
<div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<p>现在已经知道 hidetoggle 和代码块嵌套会导致渲染出错。</p>
<p>解决方法为在每层嵌套中间加句号。</p>
<details class="toggle" ><summary class="toggle-button" style="">1</summary><div class="toggle-content"><p>。</p>
<p><details class="toggle" ><summary class="toggle-button" style="">2</summary><div class="toggle-content"><p>。</p></p>
<p><details class="toggle" ><summary class="toggle-button" style="">3</summary><div class="toggle-content"><p>。</p>
</div></details></p>
<p>。</p></div></details>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>。</p></div></details>
<details class="toggle" ><summary class="toggle-button" style="">1</summary><div class="toggle-content"><p><details class="toggle" ><summary class="toggle-button" style="">2</summary><div class="toggle-content"><details class="toggle" ><summary class="toggle-button" style="">3</summary><div class="toggle-content"></div></details>&lt;/div&gt;&lt;/details&gt;<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
</div></details>]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>感悟</title>
    <url>/2023/09/01/%E6%84%9F%E6%82%9F/</url>
    <content><![CDATA[<ol>
<li>锻炼在写 DP 之前先把转移方程写出来的能力，方便自己写代码，也方便队友 Debug ，还有就是变量名一定要和代码中的是一样的。</li>
<li>要多锻炼动笔想题的能力，防止一动笔脑子就宕机。</li>
<li>赛时只要证明了做法是对的就直接写，赛后可以思考一下更加优美的证明，但是不要太久，思考太久的话还不如直接去多做几道题目。</li>
<li>即使 AC 了题目，也要看看题解，因为题解中可能会有值得学习的点，如果一直沉浸在自己的世界，不去接受一些别人的东西，进步起来是非常慢的。</li>
<li>转换后的思路未必是正确的，如果固执的认为一定是这个转化，则容易让你拐弯进死胡同然后拐不回来。比如问题让你求 $a$ ，然后你转换了一下求 $b$ ，结果想不出来，一看直接顺着 $a$ 想就出来了，更有甚者如果在转换过程中出错，那就直接 $G$ 掉了，可见转换思路有时候未必是正确的。（update：此事在ICPC2023杭州站E亦有记载）</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>ACM杂类</tag>
      </tags>
  </entry>
  <entry>
    <title>我在WF2024是怎么爆炸的</title>
    <url>/2024/09/27/%E6%88%91%E5%9C%A8WF2024%E6%98%AF%E6%80%8E%E4%B9%88%E7%88%86%E7%82%B8%E7%9A%84/</url>
    <content><![CDATA[<p>利益相关：WF2024排名 “4” * 2 。</p>
<p>看到队长写了，有感而发，我也写一个，估计 99% 概率是最后一届参加 WF 了，在退役之前最后写点东西了。</p>
<p>前排提示：有 WF 2024 题目的部分做法，要训这场的不建议看。</p>
<p>先复盘现场我在干什么，在一开始的时候，我读到了 C ，我知道这应该是签到，改一下标号随便做做应该就对了，但我给他的定位是半个小时后开始写，直觉告诉我这题没那么好写。</p>
<p>然后开始读接下来的题目，对所有题目有个大概的认知，意识到 C 大概率就是第二道签到题了，此时队友写 B ，我开始想 C ，发现按照 365 分组时间复杂度就对了，在队友过了 B 后我就上去写了。在过了样例后送，WA了。</p>
<p>按照平时训练的习惯，送打印然后下机了，然后本场比赛第一个出人意料的事情来了，半个小时后我拿到了半个小时前的 C 题代码，在仔细检查后，我和队长提出要发个 Clar ，问一下 0000 年 00 月 01 日之前 “我” 是否在这座城市，我以为我代码判了，我以为题目实际上认为不是。</p>
<p>在队友过 F 后，我上机发了个 Clar ，然后造了组上面情况的例子，发现原来我的代码压根没判对这种情况，改了过这个例子后，Clar 回复 No comment，让我确信应该算在城市里，送了过了，此时一个小时，我们走出了很牢的局面，至少还是有机会翻的。</p>
<p>刚刚在机下等打印的时候和队友交流了 D 的做法，过了 C 后就接着开写了，毫不意外的又 WA 了，又等打印半小时，在队长认可这个做法的情况下，我又说给了另外一个队友听，虽然可能是多余的行为，但是从最终结果上看很关键，因为在拿到打印后，给队友看了代码，队友立马发现我把 s 写成 n 了，改了过了。</p>
<p>在等 D 的期间，队长和我说了 A 的做法，我觉得很对，队长就直接上了，在 D 过了后，由于打印慢，此时已经两小时了，我看了 G 的题意，和队友交流了下，队友说这不是基环树吗，我一听很有道理，突然觉得这题很可做，先想了点充分条件，然后去管 I 了。</p>
<p>至于 I， 在等 C 打印的时候，我就和队友交流过这题，由于队长之前出了个边权为 1 的版本，以至于我们先入为主的认为应该从深往浅考虑每个点是否被覆盖了，然后优化这个过程，当时我觉得如果是优化过程，队友一定能搞出来，我就一直没管了。</p>
<p>在两个小时后，我突然发现 I 大伙都过了，就和队友交流了一下，发现大伙没什么想法，队长有个标记做法，但当时我没听懂，而且感觉过这么多个队没道理这么麻烦，所以没准备写这个做法。但换个角度想，我们三个人顺着这个角度想都没想出来，说明一定不是这个角度，于是换了个方向，发现直接 DFS 贪心就行了，写了过了，此时三个小时。队友开始写 L ，我们的 A 开始 WA 。</p>
<p>在三个小时的时候，虽然我的欲望让我很想去开新题，但我的理智告诉我得管队友了，我去查询了队长的情况，但查询无果，我觉得他就是被卡精度了，起码大方向绝对没写错，后面看了眼榜，既然帮不上队友，那我必须得开新题了。和队长交流了下 K，可惜我不会玩汉诺塔，想了一会没想明白汉诺塔应该怎么贪心，因为我正着想的，所以我的思路是找最大的 i ，使得 1~i 是连续的，讨论 i + 1, i + 2 的位置，但没编出个对的道理。</p>
<p>万幸的是队长给出了贪心思路，直接倒着考虑就很对了，首先要把最大的盘放到 1/2 号柱等等，虽然现在没 AC 这个题，但我觉得这个贪心非常的对，然后发现维护答案 ± 一个很小的值，就能把过程的计数变成 + 2^k ，这维护起来显然是简单的，但我不会写，我不会写这种狗屎。</p>
<p>这个时候队友的 L WA 了，我无论如何都得上了，不上没机会了。</p>
<p>在四个小时的时候，我声称我想好了，我上机了，这时队友已经是绝望的眼神了，但我觉得绝望中还存有一线生机，狠狠开写。后来越写越晕。</p>
<p>在四个半小时，队长换了个精度更好的做法，15 min 过了，我下机，因为理智告诉我我不可能 AC 这个题了，写得完也调不对。然后全力 All in L ，没 All in 出来。聆听比赛结束的声音，陷入一片茫然，好像平静的接受了这个结果。</p>
<p>至于 J 题全程没看，因为队友声称他会了，而且难写，我就没管了。G 题在三个小时我接着想发现后面是无穷无尽的讨论就弃了。</p>
<p>很难评价这一场，前期我在犯罪，打印迟迟不来，后期队长A题被卡精度，直接导致后期决策爆炸，而我不能写狗屎题间接导致比赛爆炸。哎，在正赛时总会发生一些出乎意料的事情，可惜我们前期调整过来了，后期没有调整过来。</p>
<p>在来盘盘场外的问题，在之前，遇到模拟、几何、数据结构，默认丢给了队长和队友，我对这种屎题本能抗拒，写的也少，平时自己加训也少，导致了最后我两个小时等价于啥事没干，假设 K 做法是对的，我不觉得一个训过比较多狗屎题的人不能在一个半小时写出来。真得吃屎啊，无论抱着什么目的来打这个比赛，只要想在 WF 打出成绩，就一定要训练代码能力。</p>
<p>其次，英语不好，直接导致了读题成本增加，所以本场 J 我就没读了，可能 J 比 K 可写一点，对我来说？不管怎样，真得加训英语啊。</p>
<p>然后，平时的分工就该跟队友沟通好，在组队一开始，我和队友在分工上产生了一点冲突，后面各自做出了一些让步，但是并没有实际解决，我也没有进一步跟队友交流，虽然这个问题不是大的问题，但我奉劝各位选手，如果想要经历一段快乐的 ACM 时光，在队内出现矛盾的时候不要忍着，沟通才是最优解，但凡队友是个正常人，都一定会有好的沟通结果。</p>
<p>最后，老生常谈的，多训练，尤其是补题和加训，队友做的题自己也要做做，不过老生常谈了。</p>
<p>至于分锅，我先说一下我的锅，平时训练完就回去打游戏，导致我自己训练很少，而在训练时基本上几何和模拟都丢给了队友，所以我平时的代码能力就是依托，我现在的代码水平和高中相比甚至更低，这间接导致了后期的无能为力，直接导致了前期机时的爆炸。再洗一下，我不觉得队长问题大，总不可能 A 被卡精度了就是他锅最大，“不做不错，少做少错” 这句话我觉得纯放屁，只能说精度题是这样子的，虽然训练赛时有一万种方式可以解决，但正赛没法在前几遍过掉就会十分影响比赛进程。</p>
<p>总结一下我短暂的 ACM 生涯，刚打 ACM 想要大显身手，在秦皇岛开局开 L 被逮捕了，导致秦皇岛爆炸，在此之后我不再干这种犯罪的事情，啥时间就该干啥事。</p>
<p>沈阳干出了 char kmp[N] 的抽象事情，但是发现了，没酿成大祸，出线了。</p>
<p>杭州犯罪，至今都忘不了那个 E ，因为方向错了牢了一整场，导致队伍爆炸。</p>
<p>EC final 菜了，被妙妙题送走，又把我能写的一个题丢给了没讨论明白的队友。</p>
<p>暑假猛猛训，但就是不喜欢写屎题，相信队友，队友确实给力，这期间的屎题全吃完了。</p>
<p>结果偷懒都得应验的，WF 最后两小时挂机。爆。</p>
<p>多么短暂而又印象深刻的 ACM 啊。</p>
<p>打 ACM 的收获还是很多的，实力的提升是一方面，还交到不少朋友，能与两个知名网红做队友，队友教了我不少的东西，感谢队友。而且比以前更懂得合作了。也学习了怎么伪装成心智成熟的大人：多尝试自己解决问题、有问题多沟通、真遇到问题请求他人的帮忙、有机会多尝试。同时也意识到不应该勉强自己干一些事（指打ACM），还是自己所热爱的才能坚持下去，纯为了结果还是太难坚持了，这影响了我未来的人生规划。</p>
<p>感谢各位，希望未来有队伍能重振荣光。</p>
<p>最后给点建议：</p>
<ol>
<li>首先不要依赖 gdb ，机下调试能省机时。其次尽量一遍写对，如果出了不能对拍的题目就爆了。</li>
<li>队伍里面如果不是单核队伍，而是三个人负责不同的题目，三个人的代码能力都应该够好。</li>
<li>有问题多沟通。</li>
<li>不够热爱比赛的不建议打这个比赛，不够努力又没天赋的人打不出结果的，如果是这样子建议别跟想出成绩的队友组队，不然以后频繁训练的时候指定得发生矛盾。</li>
</ol>
<p>UPD：队友看了说太恶心了，在几天后修改了部分可能会让人不适的内容。</p>
<p>本来还想写点高中的东西的，但似乎之前写过了，而且写了的话，这篇文章就太杂了，就不写了。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>待解决</title>
    <url>/2024/01/20/%E5%BE%85%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>学习书籍 《A course in combinatorial optimization》，在网上突然看到的，感觉这一本书还是很有学习的必要的。</p>
<ol>
<li>“MEXimum Spanning Tree” 中的根号做法是什么。（解决条件：学会 Hopcroft Karp 的复杂度分析）</li>
<li>“拟阵学习笔记”：<ol>
<li>匹配拟阵交换性的证明。（用增广路的证明）</li>
<li>用基的定义能不能再弱一点。</li>
<li>带权拟阵交。</li>
<li>学习剩下的内容。</li>
</ol>
</li>
<li>Game of Connect(Shannon’s Switching Game) 学会 Shannon’s Switching Game 。</li>
<li>Graffiti 那个dp分块到底是哪一年提高组初赛的题目。</li>
<li>Not Intersect 的生成函数做法。</li>
<li>The 2nd Ucup Stage 2: SPb M. Hardcore String Counting 写代码</li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>ACM杂类</tag>
      </tags>
  </entry>
  <entry>
    <title>弱多项式复杂度最小费用流算法</title>
    <url>/2025/02/05/%E5%BC%B1%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%B5%81%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Ouuan Orz</p>
<p>当然，先说一下弱多项式是啥？</p>
<p>OI 界中叫做 Dinic 和 EK 的那两个最大流算法，把其中的 BFS 改成求最短路，复杂度都是与值域多项式相关的，即复杂度是伪多项式的。</p>
<p>多项式复杂度有弱多项式和强多项式两种，弱多项式就是关于输入长度（ $n$、 $m$ 之类的，以及 $log 值域$ ）为多项式复杂度，强多项式就是在加减乘除为 $O(1)$ 时复杂度关于数据规模为多项式（就是说跟值域完全无关，只和 $n, m$ 之类的相关，复杂度关于 $n, m$ 之类的为多项式）。</p>
<p>当然，这时 Ouuan 说的。</p>
<h1 id="算法讲解"><a href="#算法讲解" class="headerlink" title="算法讲解"></a>算法讲解</h1><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ol>
<li>$st$ 无入边，$ed$ 无出边。</li>
<li>可以有负环。</li>
</ol>
<h2 id="无源汇最小费用流"><a href="#无源汇最小费用流" class="headerlink" title="无源汇最小费用流"></a>无源汇最小费用流</h2><p>对于有源汇最小费用最大流的定义我们改一下：</p>
<p>没有 $st$ 和 $ed$，同时最小化 $\sum\limits_{(i,j)∈E} cost(i,j)*f(i,j)$ 。</p>
<p>当然，这个时候你可能会好奇这个我们讲的有源汇最小费用最大流有个 $der$ 的关系？</p>
<p>那如果我们从 $ed$ 向 $st$ 连接一条无限小的边，使得流量越多越好，然后后面减掉就行了。</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>首先，这个流是最小费用当且仅当图中不存在负环，证明和上篇重制版最小费用最大流博客雷同，不予以赘述。</p>
<p>首先明白一个定理：如果把每条边容量乘 $2$，则对应流量乘 $2$，最小费用乘 $2$，因为乘 $2$ 一定不存在负环。</p>
<p>那么接下来就非常简单了，把边权拆成二进制，维护残余网络 $G$ ，一开始 $G$ 中的容量和流量都为 $0$，然后二进制从高到低扫描，每一位把所有边的容量和流量乘 $2$，但是需要注意，有些边这一位二进制可能为 $1$，因此这条边会加入到残余网络中，这就非常的蛋疼了，好的方法是这条边是 $(x,y)$，在加入前从 $y$ 跑一遍最短路，如果 $d[x]+cost(x,y)&lt;0$ ，那么就不加入，并且把 $y$ 到 $x$ 的最短路的流量全部减一，当然，如果这条边原本就存在，则直接流量 $+1$ 即可。</p>
<p>至于为什么直接跑最短路即可，因为我们维护的残余网络中一定没有负环啊。</p>
<p>时间复杂度： $O(nm^2\log{U})$ ，$U$ 是边中的最大流量。</p>
<p>例题：<a href="https://uoj.ac/problem/487">https://uoj.ac/problem/487</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 5100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 110000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">mymin</span><span class="params">(T x,T y)</span></span>&#123;<span class="keyword">return</span> x&lt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">mymax</span><span class="params">(T x,T y)</span></span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x,y,next;</span><br><span class="line">    LL c<span class="comment">/*表示它们现在现有的流量*/</span>,d;</span><br><span class="line">&#125;a[M];<span class="type">int</span> len=<span class="number">1</span>,last[N];</span><br><span class="line">LL cap[N];<span class="comment">//表示它们原本的流量 </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ins_node</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,LL c,LL d)</span></span>&#123;len++;a[len].x=x;a[len].y=y;a[len].d=d;cap[len]=c;a[len].next=last[x];last[x]=len;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,LL c,LL d)</span></span>&#123;<span class="built_in">ins_node</span>(x,y,c,d);<span class="built_in">ins_node</span>(y,x,<span class="number">0</span>,-d);&#125;</span><br><span class="line"><span class="comment">//SPFA</span></span><br><span class="line">LL d[N];</span><br><span class="line"><span class="type">int</span> list[N],head,tail,pre[N];</span><br><span class="line"><span class="type">bool</span> v[N],vv[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> st,<span class="type">int</span> ed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list[head=<span class="number">1</span>]=st;tail=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">20</span>,<span class="built_in">sizeof</span>(d));d[st]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="built_in">sizeof</span>(pre));</span><br><span class="line">    <span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="built_in">sizeof</span>(v));v[st]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(head!=tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=list[head++];<span class="keyword">if</span>(head==n+<span class="number">1</span>)head=<span class="number">1</span>;</span><br><span class="line">        v[x]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=last[x];k;k=a[k].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=a[k].y;</span><br><span class="line">            <span class="keyword">if</span>(a[k].c&gt;<span class="number">0</span> &amp;&amp; d[y]&gt;d[x]+a[k].d)</span><br><span class="line">            &#123;</span><br><span class="line">                d[y]=d[x]+a[k].d;</span><br><span class="line">                pre[y]=k;</span><br><span class="line">                <span class="keyword">if</span>(!v[y])</span><br><span class="line">                &#123;</span><br><span class="line">                    v[y]=<span class="number">1</span>;</span><br><span class="line">                    list[tail++]=y;</span><br><span class="line">                    <span class="keyword">if</span>(tail==n+<span class="number">1</span>)tail=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">LL cost=<span class="number">0</span>,ans=<span class="number">0</span>,ffuck=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">trash</span><span class="params">(<span class="type">int</span> st,<span class="type">int</span> ed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL mmax=<span class="number">0</span><span class="comment">/*,sum=0用来记录st-ed添加的那一条边应该是多少*/</span>,summ=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        summ+=cap[i];</span><br><span class="line">        mmax=<span class="built_in">mymax</span>(mmax,cap[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ins</span>(ed,st,summ,-(LL)<span class="number">999999999</span>);</span><br><span class="line">    mmax=<span class="built_in">mymax</span>(mmax,cap[len<span class="number">-1</span>]);</span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(((LL)<span class="number">1</span>&lt;&lt;l)<span class="number">-1</span>&lt;mmax)l++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> ll=l;ll&gt;=<span class="number">1</span>;ll--)<span class="comment">//从高位到低位开始扫描二进制 </span></span><br><span class="line">    &#123;</span><br><span class="line">        cost&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        LL shit=((LL)<span class="number">1</span>&lt;&lt;(ll<span class="number">-1</span>));</span><br><span class="line">        <span class="built_in">memset</span>(vv,<span class="number">0</span>,<span class="built_in">sizeof</span>(vv));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i].c&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[i].c)a[i].c+=(cap[i]&amp;shit)&gt;<span class="number">0</span>,vv[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对于所有已经存在的边不用扫描 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vv[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(cap[i]&amp;shit)<span class="comment">//反向边绝对不会进来 </span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x=a[i].x,y=a[i].y;</span><br><span class="line">                <span class="built_in">spfa</span>(y,x);</span><br><span class="line">                <span class="keyword">if</span>(d[x]+a[i].d&lt;<span class="number">0</span><span class="comment">/*负环!!!!*/</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    cost+=a[i].d;</span><br><span class="line">                    x=pre[x];</span><br><span class="line">                    <span class="keyword">while</span>(x)</span><br><span class="line">                    &#123;</span><br><span class="line">                        cost+=a[x].d;</span><br><span class="line">                        a[x].c--;a[x^<span class="number">1</span>].c++;</span><br><span class="line">                        x=pre[a[x].x];</span><br><span class="line">                    &#125;</span><br><span class="line">                    a[i^<span class="number">1</span>].c++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> a[i].c++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=last[st];k;k=a[k].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(k&amp;<span class="number">1</span>))ans+=cap[k]-a[k].c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>,ans,cost-(cap[len<span class="number">-1</span>]-a[len<span class="number">-1</span>].c)*a[len<span class="number">-1</span>].d+ffuck);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> st,ed;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;st,&amp;ed);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;LL c,d;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld%lld&quot;</span>,&amp;x,&amp;y,&amp;c,&amp;d);</span><br><span class="line">        <span class="keyword">if</span>(x==y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(d&lt;<span class="number">0</span>)ffuck+=c*d;<span class="comment">//自环 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">ins</span>(x,y,c,d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">trash</span>(st,ed);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><h2 id="无限小？"><a href="#无限小？" class="headerlink" title="无限小？"></a>无限小？</h2><p>坑</p>
<h2 id="边权？"><a href="#边权？" class="headerlink" title="边权？"></a>边权？</h2><p>坑</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>放心，因为比赛一般都是构图题，难以卡掉 $ZKW$ 和 $EK$，所以，大胆的，放心的用 $ZKW$ 吧，学这个算法就图一乐。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>洛谷的讨论：<a href="https://www.luogu.com.cn/discuss/show/161006">https://www.luogu.com.cn/discuss/show/161006</a></p>
<p>弱多项式复杂度算法非常非常好的常考资料，真的非常非常好：<a href="https://ouuan.github.io/post/%E5%9F%BA%E4%BA%8E-capacity-scaling-%E7%9A%84%E5%BC%B1%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%B5%81%E7%AE%97%E6%B3%95/">https://ouuan.github.io/post/%E5%9F%BA%E4%BA%8E-capacity-scaling-%E7%9A%84%E5%BC%B1%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%B5%81%E7%AE%97%E6%B3%95/</a></p>
<h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><p>要准备 NOIP 啦，赛后补充 Dij 的做法，还有亿点细节补充。</p>
<p>代码也要补点注释。</p>
<p>赛前还是直接打个简单思路就去准备比赛了。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路相关的删除问题</title>
    <url>/2025/02/03/%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%9B%B8%E5%85%B3%E7%9A%84%E5%88%A0%E9%99%A4%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="无向正权-非负权图"><a href="#无向正权-非负权图" class="headerlink" title="无向正权/非负权图"></a>无向正权/非负权图</h1><h2 id="删边最短路"><a href="#删边最短路" class="headerlink" title="删边最短路"></a>删边最短路</h2><p>正权的无向图，删除一条边，问之后的最短路是多少。</p>
<p>例题：CF1163F Indecisive Taxi Fee</p>
<p>引理1：只有删除掉最短路上的边才可能导致删边最短路增大。</p>
<p>引理2：删边后的最短路一定是经过最短路一段前缀+中间的一些不在最短路的边+最短路一段后缀。</p>
<p>证明显然，不再赘述。</p>
<p>因此，我们可以设必须经过一个点的起点到终点的最短路经过最短路前缀几个点为 $pre$ ，后缀几个点为 $suf$ 。</p>
<p>如果存在多种选择随便选择一个即可。</p>
<p>引理3：$pre_x≤suf_x$</p>
<p>证明也很简单，如果大于，说明起点到 $x$ 或者 $x$ 到终点至少有一条不是最短路。</p>
<p>这条引理是证明后面一条引理的关键，也是可以随便选择 $pre$ 或者 $suf$ 的原因，但是如果存在 $0$ 边，就要选择最小的 $pre$ ，最大的 $suf$ ，这样才能保证正确性，同时如果是有向图这一结论也不成立。</p>
<p>引理4：设最短路 $I$ ，删除边 $(u,v)∈I$ ，设新最短路为 $L$ ，存在一条路径 $L$ 以及 $(x,y)∈L$ 使得 $L$ 是经过 $(x,y)$ 的最短路。</p>
<p>这条引理是做法正确性的关键，来看看怎么证明：</p>
<p>为了方便，不妨设 $I$ 为 $1-n$ 连续编号的一条路径，其他点的编号大于 $n$ ，设 $L$ 的点序列为 $x_1,x_2,…,x_k$ 。</p>
<p>一定存在一个 $L$ 满足 $pre,suf$  非严格递增，因为如果 $pre_{x_i}&gt;pre_{x_{i+1}}$ ，那么可以直接走 $1-x_{i+1}$  的最短路即可，$suf$ 同理。</p>
<p>因此，现在就是证明存在 $i$ 使得 $pre_{i}≤u,suf_{i+1}≥v=u+1$ 。</p>
<p>首先 $x_1=1,x_{k}=n,pre_{x_1}=1,sur_{x_k}=n$</p>
<p>如果 $pre_{i}≤u,suf_{i+1}≤u$ ，那么 $pre_{i+1}≤u$ ，继续观察 $i+1$ ，如果同理如果都大于等于 $v$ 则观察 $i-1$ 。</p>
<p>不难看出，类似中值定理一样，一定存在一个 $i$ 满足上述要求，经过 $(x_{i},x_{i+1})$ 的其中一条最短路便是删边最短路，得证。</p>
<p>也就是说如果存在删边最短路，图中一定存在某条边，强制以某个方向经过这条边的最短路便是删边最短路。</p>
<p>因此预处理出每个点的 $pre,suf$ ，暴力遍历每条边的两个方向的最短路即可求出其可能是最短路上哪些边的删边最短路，直接区间取min即可。</p>
<p>当然，如果离线可以差分加 multiset 。</p>
<p>具体可以看洛谷上这一道题目的题解，这里着重证明其正确性。</p>
<p>需要注意的是，如果有 $0$ 边需要取最小的 $pre$ ，最大的 $suf$ ，否则可能导致引理 $3$ 不正确，当然此题是正权，随便取就行了。</p>
<p>代码？没有，口胡罢了。洛谷的题解也不少了，应该够了。</p>
<h2 id="删点最短路"><a href="#删点最短路" class="headerlink" title="删点最短路"></a>删点最短路</h2><p>正权图，删起终点以外的点。</p>
<p>不能直接套用删边最短路。</p>
<p>为什么？</p>
<p>因为有可能一个点的 $pre=suf$ ，导致直接卡死，拆点又是有向图，不行。</p>
<p>因此，我们着重处理一个点 $pre=suf$ 的情况。</p>
<p>先解释一下为什么，修改删点最短路中定理的描述，改成 $pre_x<i$ 且 $suf_x>i$ 的话，那么会有也只会有一个问题，中间会不会有点 $pre=suf=i$ ，仔细想想就知道。</p>
<p>那么，我们只需要针对最短路的每个点 $i$ 把 $pre=suf=i$ 的点提取出来，然后将相邻的 $pre<i$ 点处理出到起点的最短路，$suf>i$ 处理出到终点的最短路，相加统计贡献就行了。</p>
<p>时间复杂度依旧是带个 $log$ 。</p>
<p>讨论一下 $pre,suf$ 可不可以随机取的问题，最大最小能过，且在找 $pre=suf=i$ 时这样的点一定与最短路的 $i$ 相连，可以 $BFS$ 找出。但是随机取的话没有零边（删边最短路部分就不行了），也行，只不过可能不能 $BFS$ 找出了，毕竟随机的话不一定存在与最短路相连的路径了，可能需要预处理出每个 $i$ 对应的点集才能保证时间复杂度正确，不过也不一定，没有具体实践卡过，例题部分去掉 $min,max$ 也能过，只是单纯个人感觉罢了。不过出于保险起见我还是会打最大最小的，不怕一万就怕万一。</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://acm.timus.ru/problem.aspx?space=1&amp;num=2006">2006. Kirill the Gardener @ Timus Online Judge</a></p>
<p>网格图的删点最短路。</p>
<p>直接套就行了，慢慢做，不要慌张。</p>
<p>不过去掉了 $min,max$ 部分也能 AC ，说明有可能随机也可以直接 $BFS$ 处理出 $pre=suf$ 的点。</p>
<p>$L$ 就是 $pre$ ，$R$ 就是 $suf$ 。</p>
<p>时间复杂度：$O(nm\log{nm})$</p>
<p>空间复杂度：$O(nm)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NM 110000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">mymin</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&lt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">mymax</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line"><span class="type">int</span> dx[]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> n,m,nm;</span><br><span class="line"><span class="type">char</span> ss[NM];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">	<span class="built_in">node</span>(<span class="type">int</span> xx=<span class="number">0</span>,<span class="type">int</span> yy=<span class="number">0</span>)&#123;x=xx;y=yy;&#125;</span><br><span class="line">&#125;list[NM],st,ed,pre[NM],ord[NM];<span class="type">int</span> h1[NM],h2[NM],h[NM],head,tail,limit;</span><br><span class="line"><span class="type">int</span> fid[<span class="number">1100</span>][<span class="number">1100</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">id</span><span class="params">(node x)</span></span>&#123;<span class="keyword">return</span> fid[x.x][x.y];&#125;<span class="comment">//1</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&gt;=<span class="number">1</span> &amp;&amp; y&gt;=<span class="number">1</span> &amp;&amp; x&lt;=n &amp;&amp; y&lt;=m &amp;&amp; ss[<span class="built_in">id</span>(<span class="built_in">node</span>(x,y))]==<span class="string">&#x27;.&#x27;</span>;&#125;</span><br><span class="line"><span class="type">int</span> L[NM],R[NM];</span><br><span class="line"><span class="type">bool</span> v[NM];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">bool</span> b1,<span class="type">bool</span> b2)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in">sizeof</span>(h));<span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="built_in">sizeof</span>(pre));</span><br><span class="line">	<span class="keyword">if</span>(!b2)list[head=tail=<span class="number">1</span>]=st,h[<span class="built_in">id</span>(st)]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> list[head=tail=<span class="number">1</span>]=ed,h[<span class="built_in">id</span>(ed)]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(head&lt;=tail)&#123;</span><br><span class="line">		node x=list[head++];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;=<span class="number">3</span>;t++)&#123;</span><br><span class="line">			node y=<span class="built_in">node</span>(x.x+dx[t],x.y+dy[t]);</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">pd</span>(y.x,y.y))&#123;</span><br><span class="line">				<span class="keyword">if</span>(!h[<span class="built_in">id</span>(y)])&#123;</span><br><span class="line">					list[++tail]=y;h[<span class="built_in">id</span>(y)]=h[<span class="built_in">id</span>(x)]+<span class="number">1</span>;pre[<span class="built_in">id</span>(y)]=x;</span><br><span class="line">					<span class="keyword">if</span>(b1)&#123;</span><br><span class="line">						<span class="keyword">if</span>(!v[<span class="built_in">id</span>(y)])&#123;</span><br><span class="line">							<span class="keyword">if</span>(!b2)L[<span class="built_in">id</span>(y)]=L[<span class="built_in">id</span>(x)];</span><br><span class="line">							<span class="keyword">else</span> R[<span class="built_in">id</span>(y)]=R[<span class="built_in">id</span>(x)];</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(h[<span class="built_in">id</span>(y)]==h[<span class="built_in">id</span>(x)]+<span class="number">1</span>)&#123;</span><br><span class="line">					<span class="keyword">if</span>(b1)&#123;</span><br><span class="line">						<span class="keyword">if</span>(!v[<span class="built_in">id</span>(y)])&#123;</span><br><span class="line">							<span class="keyword">if</span>(!b2)L[<span class="built_in">id</span>(y)]=<span class="built_in">mymin</span>(L[<span class="built_in">id</span>(x)],L[<span class="built_in">id</span>(y)]);</span><br><span class="line">							<span class="keyword">else</span> R[<span class="built_in">id</span>(y)]=<span class="built_in">mymax</span>(R[<span class="built_in">id</span>(x)],R[<span class="built_in">id</span>(y)]);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; add[NM],del[NM];</span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; fuck;</span><br><span class="line"><span class="type">int</span> sta[NM],top;</span><br><span class="line"><span class="type">int</span> zans[NM];</span><br><span class="line"><span class="type">int</span> d1[NM],d2[NM],dd[NM];</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;(node x,node y)&#123;<span class="keyword">return</span> dd[<span class="built_in">id</span>(x)]&gt;dd[<span class="built_in">id</span>(y)];&#125;</span><br><span class="line">priority_queue&lt;node,vector&lt;node&gt;,greater&lt;node&gt; &gt; smile;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pao</span><span class="params">(<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(!smile.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		node x=smile.<span class="built_in">top</span>();smile.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;=<span class="number">3</span>;t++)&#123;</span><br><span class="line">			node y=<span class="built_in">node</span>(x.x+dx[t],x.y+dy[t]);</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">pd</span>(y.x,y.y)==<span class="number">1</span> &amp;&amp; h[<span class="built_in">id</span>(y)]==now &amp;&amp; !dd[<span class="built_in">id</span>(y)])&#123;</span><br><span class="line">				dd[<span class="built_in">id</span>(y)]=dd[<span class="built_in">id</span>(x)]+<span class="number">1</span>;</span><br><span class="line">				smile.<span class="built_in">push</span>(y);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> ttx,<span class="type">int</span> tty)</span></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">	list[head=tail=<span class="number">1</span>]=st,h[<span class="built_in">id</span>(st)]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(head&lt;=tail)&#123;</span><br><span class="line">		node x=list[head++];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;=<span class="number">3</span>;t++)&#123;</span><br><span class="line">			node y=<span class="built_in">node</span>(x.x+dx[t],x.y+dy[t]);</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">pd</span>(y.x,y.y) &amp;&amp; !(y.x==ttx &amp;&amp; y.y==tty) &amp;&amp; !h[<span class="built_in">id</span>(y)])list[++tail]=y,h[<span class="built_in">id</span>(y)]=h[<span class="built_in">id</span>(x)]+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!h[<span class="built_in">id</span>(ed)])<span class="keyword">return</span> <span class="number">999999999</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> h[<span class="built_in">id</span>(ed)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);nm=n*m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;st.x,&amp;st.y,&amp;ed.x,&amp;ed.y);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,ss+(i<span class="number">-1</span>)*m+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)fid[i][j]=(i<span class="number">-1</span>)*m+j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">bfs</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	limit=h[<span class="built_in">id</span>(ed)];</span><br><span class="line">	node x=ed;</span><br><span class="line">	<span class="keyword">while</span>(h[<span class="built_in">id</span>(x)])&#123;<span class="comment">//1&#x27;</span></span><br><span class="line">		ord[h[<span class="built_in">id</span>(x)]]=x;</span><br><span class="line">		L[<span class="built_in">id</span>(x)]=R[<span class="built_in">id</span>(x)]=h[<span class="built_in">id</span>(x)];</span><br><span class="line">		v[<span class="built_in">id</span>(x)]=<span class="number">1</span>;</span><br><span class="line">		x=pre[<span class="built_in">id</span>(x)];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(limit==<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(ss[fid[i][j]]==<span class="string">&#x27;.&#x27;</span> &amp;&amp; !v[fid[i][j]])&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,i,j);</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">bfs</span>(<span class="number">1</span>,<span class="number">0</span>);<span class="built_in">memcpy</span>(h1,h,<span class="built_in">sizeof</span>(h));</span><br><span class="line">	<span class="built_in">bfs</span>(<span class="number">1</span>,<span class="number">1</span>);<span class="built_in">memcpy</span>(h2,h,<span class="built_in">sizeof</span>(h));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">			node x=<span class="built_in">node</span>(i,j);</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">pd</span>(i,j) &amp;&amp; h1[<span class="built_in">id</span>(x)])&#123;<span class="comment">//能够到达 </span></span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;=<span class="number">3</span>;t++)&#123;</span><br><span class="line">					<span class="type">int</span> tx=i+dx[t],ty=j+dy[t];</span><br><span class="line">					<span class="keyword">if</span>(<span class="built_in">pd</span>(tx,ty) &amp;&amp; h1[<span class="built_in">id</span>(<span class="built_in">node</span>(tx,ty))])&#123;</span><br><span class="line">						<span class="type">int</span> ll=L[<span class="built_in">id</span>(x)],rr=R[<span class="built_in">id</span>(<span class="built_in">node</span>(tx,ty))],val=h1[<span class="built_in">id</span>(x)]+h2[<span class="built_in">id</span>(<span class="built_in">node</span>(tx,ty))];ll++;rr--;</span><br><span class="line">						<span class="keyword">if</span>(ll&lt;=rr)add[ll].<span class="built_in">push_back</span>(val),del[rr].<span class="built_in">push_back</span>(val);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;limit;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;add[i].<span class="built_in">size</span>();j++)fuck.<span class="built_in">insert</span>(add[i][j]);</span><br><span class="line">		<span class="keyword">if</span>(fuck.<span class="built_in">empty</span>())zans[i]=<span class="number">999999999</span>;</span><br><span class="line">		<span class="keyword">else</span> zans[i]=(*fuck.<span class="built_in">begin</span>());</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;del[i].<span class="built_in">size</span>();j++)fuck.<span class="built_in">erase</span>(fuck.<span class="built_in">find</span>(del[i][j]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;limit;i++)&#123;</span><br><span class="line">		list[head=tail=<span class="number">0</span>]=ord[i];h[<span class="built_in">id</span>(ord[i])]=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">while</span>(head&lt;=tail)&#123;</span><br><span class="line">			node x=list[head++];</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;=<span class="number">3</span>;t++)&#123;</span><br><span class="line">				node y=<span class="built_in">node</span>(x.x+dx[t],x.y+dy[t]);</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">pd</span>(y.x,y.y)==<span class="number">1</span> &amp;&amp; L[<span class="built_in">id</span>(y)]==R[<span class="built_in">id</span>(y)] &amp;&amp; L[<span class="built_in">id</span>(y)]==i &amp;&amp; !h[<span class="built_in">id</span>(y)])h[<span class="built_in">id</span>(y)]=i,list[++tail]=y;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tail;j++)&#123;</span><br><span class="line">			node x=list[j];dd[<span class="built_in">id</span>(list[j])]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;=<span class="number">3</span>;t++)&#123;</span><br><span class="line">				node y=<span class="built_in">node</span>(x.x+dx[t],x.y+dy[t]);</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">pd</span>(y.x,y.y)==<span class="number">1</span> &amp;&amp; L[<span class="built_in">id</span>(y)]&lt;i)&#123;</span><br><span class="line">					dd[<span class="built_in">id</span>(y)]=h1[<span class="built_in">id</span>(y)];smile.<span class="built_in">push</span>(y);<span class="comment">//2</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">Pao</span>(i);<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tail;j++)d1[<span class="built_in">id</span>(list[j])]=dd[<span class="built_in">id</span>(list[j])],dd[<span class="built_in">id</span>(list[j])]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tail;j++)&#123;</span><br><span class="line">			node x=list[j];</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;=<span class="number">3</span>;t++)&#123;</span><br><span class="line">				node y=<span class="built_in">node</span>(x.x+dx[t],x.y+dy[t]);</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">pd</span>(y.x,y.y)==<span class="number">1</span> &amp;&amp; R[<span class="built_in">id</span>(y)]&gt;i)&#123;</span><br><span class="line">					dd[<span class="built_in">id</span>(y)]=h2[<span class="built_in">id</span>(y)];smile.<span class="built_in">push</span>(y);<span class="comment">//2</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">Pao</span>(i);<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tail;j++)d2[<span class="built_in">id</span>(list[j])]=dd[<span class="built_in">id</span>(list[j])],dd[<span class="built_in">id</span>(list[j])]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tail;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(d1[<span class="built_in">id</span>(list[j])] &amp;&amp; d2[<span class="built_in">id</span>(list[j])])zans[i]=<span class="built_in">mymin</span>(zans[i],d1[<span class="built_in">id</span>(list[j])]+d2[<span class="built_in">id</span>(list[j])]<span class="number">-1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;node ansxy;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;limit;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(zans[i]&gt;ans)ans=zans[i],ansxy=ord[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,ansxy.x,ansxy.y);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说说我踩的3个坑。</p>
<ol>
<li>如果路径长度为 $2$ ，随便找一个点堵上就行，对应是 WA9 。</li>
<li>代码中 $1$ 的位置可以换成 (x.x-1)*m+x.y，不过要特判 $id({0,0})=0$ ，不然在 $1’$ 会访问负数下标导致错误，我曾经就疯狂 TLE8。</li>
<li>代码中 $2$ 的位置一定要在加入堆之前赋值，我之前打反导致我一直以为 STL 的堆出问题了，顺便提一嘴，原来小根堆要重载大于号。</li>
</ol>
<p>花了几天终于AC了，不容易不容易，感谢U群的各位了。</p>
<h1 id="DAG"><a href="#DAG" class="headerlink" title="DAG"></a>DAG</h1><p>DAG的删点最短路</p>
<p><a href="https://ac.nowcoder.com/acm/problem/14293?&amp;headNav=acm">https://ac.nowcoder.com/acm/problem/14293?&amp;headNav=acm</a></p>
<p>算是U群的意外收获吧。</p>
<p>其实发现一个事情，上面的关键结论其实对DAG也生效，单纯的对有环有向图不生效而已，删点最短路也是满足的，因此直接做就行了。</p>
<p>讨论里也有题解可以参考一下。</p>
<p>会了删边最短路的套路后这个就基本不难了，举一反三就行了。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>拟阵初级学习笔记</title>
    <url>/2024/01/26/%E6%8B%9F%E9%98%B5%E5%88%9D%E7%BA%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>建议直接去看原论文，哪篇论文放在参考文献了。</p>
<p>前排提示，本篇中对于集合操作 $+$ 和 $\cup$ 没有区分，都表示<strong>并</strong>的意思，$-$ 和 $\setminus$ 同理。</p>
<h1 id="拟阵的入门"><a href="#拟阵的入门" class="headerlink" title="拟阵的入门"></a>拟阵的入门</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="幂集"><a href="#幂集" class="headerlink" title="幂集"></a>幂集</h3><p> $2^S$ 称作 $S$ 的拟阵当且仅当 $2^S$ 是 $S$ 所有子集构成的集合。</p>
<p> 例如：$\{1,2\}$ 的幂集是 $\{\{1,2\},\{1\},\{2\},\emptyset\}$ 。</p>
<h3 id="拟阵"><a href="#拟阵" class="headerlink" title="拟阵"></a>拟阵</h3><p>记 $M=(S,\mathcal{I})$ 表示一个定于在有限集合 $S$ 且独立集的集合为 $\mathcal{I}$ 的当且仅当满足以下三条：</p>
<ol>
<li>$\mathcal{I}\subset 2^S$</li>
<li><strong>遗传性</strong> ：如果 $J\subset I\in \mathcal{I}$，那么 $J\in \mathcal{I}$ 。</li>
<li><strong>交换性/扩张性</strong> ：如果 $I,J\in\mathcal{I},|J|&lt;|I|$，那么 ${\exists}z\in J\setminus I , I\cup z\in \mathcal{I}$ 。</li>
</ol>
<p>为了方便，我们一般认为 $\emptyset \in \mathcal{I}$ ，即认为独立集的集合是非空的。</p>
<p>我们称 $\mathcal{I}$ 的元素为独立集。</p>
<p>例子：</p>
<p><strong>均匀拟阵</strong> ：$U^k_n=(S,\mathcal{I})$，其中 $|S|=n,\mathcal{I}=\{I\subset S : |I| \le k \}$ 。</p>
<p><strong>图拟阵</strong> ：令无向图 $G=(V,E)$，令图拟阵：$M=(E,\mathcal{I})$ ，其中 $\mathcal{I}=\{F\subset E : F 无环\}$ 。</p>
<p>为啥是拟阵这件事不难自证，不再赘述。</p>
<p>图拟阵非常的重要，因为他提供了一个形象想象拟阵的工具，在前期学习拟阵在图拟阵上想想是非常有用的方法。</p>
<p>不过图拟阵在有向图上不一定成立，一样的定义，只不过把无向图换成有向图。</p>
<p><img src="1.png" alt=""></p>
<p><strong>匹配拟阵</strong> ：令无向图 $G=(V,E)$，匹配拟阵：$M=(V,\mathcal{I})$ ，其中一个点集是独立集当且仅当存在一个匹配能够覆盖点集中的所有点（可以覆盖点集外的点）。</p>
<p>遗传性显然，交换性不会。</p>
<p>拟阵同时还可以与高代联动，对于一个有限的向量空间，一个独立集定义为线性无关的向量组，非常有意思的是，此时下面基的定义就是高代中基的定义，环是最小的线性相关的向量组，而引理1.2对应的就是基扩张定理。（从这个角度来看，很多拿到一个子空间的极大独立集，直接扩张成大空间的极大独立集的证明，突然就熟悉多了，这也能与课内联动？）</p>
<p>这么说的话，用线性空间来作为拟阵的例子辅助思考貌似也是一个不错的选择。</p>
<h6 id="坑1"><a href="#坑1" class="headerlink" title="坑1"></a>坑1</h6><p>不会交换性的证明。</p>
<h3 id="基"><a href="#基" class="headerlink" title="基"></a>基</h3><p>独立集 $I$ 是基当且仅当加入 $S/I$ 中的任何一个元素都不是独立集。</p>
<p>这种拟阵中的极大元素，在拟阵的研究中发挥着至关重要的作用。</p>
<h3 id="环"><a href="#环" class="headerlink" title="环"></a>环</h3><p>一个非独立集 $I’$ 是环当且仅当 $I’$ 删除其中任意一个元素都是独立集。</p>
<p>例子：图拟阵中的简单环。</p>
<p>我们用 $C(M)$ 表示拟阵 $M$ 中所有的环。</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p><strong>引理 1.1</strong> ：基的大小相同。（用交换性显然）</p>
<p><strong>引理 1.2</strong> ：${\forall} J \in \mathcal{I},{\exists} 基I:J\in I$ 。（用交换性显然）</p>
<p>该引理说明任意一个元素都属于一个基，所以对于一个拟阵，只要知道基，加上遗传性就可以知道所有独立集。</p>
<p>但是能不能凭借此定义独立集的集合呢？</p>
<p>还需要一个定理：</p>
<p><strong>定理 1.3(基交换定理)</strong> ：${\forall}基A,B,A\ne B,{\forall} z\in A\setminus B,{\exists} y\in B\setminus A:A-\{z\}+\{y\}\in \mathcal{I}$ 。（用遗传性显然）</p>
<p>满足基交换定律且大小相同的基的集合可以定义一个拟阵。（可以证明交换性成立，并不困难，在此不再赘述，证明过程类似【完美匹配那个证明】）</p>
<p>这种定义相较于原来定义的优势在于检验拟阵的工作量小了，本来对于每一对独立集都要检验，现在只需要检验基，尤其是对于自己随手写的拟阵，例如：$\{\{1,3,4\},\{2,3,4\}\}$ 。</p>
<h6 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h6><p>完美匹配定理的编号。</p>
<h6 id="坑2"><a href="#坑2" class="headerlink" title="坑2"></a>坑2</h6><p>其实我觉得这里的大小相同的限制可以改得再弱一点：基之间没有包含关系，我严重怀疑没有包含关系可以推出大小相同，但是水平有限，目前我证不出来。</p>
<p>基交换定理可以放宽一下条件，仍然成立：</p>
<p>${\forall}A,B\in \mathcal{I},|A|\le|B|,{\forall} z\in A,{\exists} y\in B\setminus (A-\{z\}):A-\{z\}+\{y\}\in \mathcal{I}$ 。</p>
<p><strong>引理 1.4</strong> ：$I$ 不是独立集，则一定有一个子集是环 。（显然）</p>
<p><strong>引理 1.5</strong> ：${\forall}X,Y\in C(M),X\subset Y:X=Y$ 。（显然）</p>
<p><strong>引理 1.6</strong> ：${\forall}X,Y\in C(M),X\ne Y,e\in X\cap Y:{\exists} C\in C(M),C\subset X\cup Y-\{e\}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>等价于证明 $X\cup Y-\{e\}$ 不是独立集。</p>
<p>证明一个集合不是独立集，思考一下条件：环、一个已知的集合。因此我们考虑利用这个已知的集合用反证法，通过构造与环产生矛盾。</p>
<p>反证法：已知 $X\cap Y \in \mathcal{I}$ ，然后用 $X\cup Y-\{e\}$ 扩大这个集合到同样的大小，由于环的限制， $X\setminus Y,Y\setminus X$ 都要丢掉一个元素，所以集合大小最大是 $|X|+|Y|-2$ ，然而可以扩展到 $|X|+|Y|-1$ ，矛盾，证毕。</p>
<p>至于更加严谨的写法，这里引用一下2018国集论文（根据引理编号对内容做了一点更改）：</p>
<p>证明：由引理 1.5 可得， $X\setminus Y$ 非空，设 $f \in X\setminus Y$ 。假设 $X\cup Y − \{e\}$ 是独立集。由于 $X$ 是环，<br>所以 $X − \{f\}$ 是独立集，假设 $X\cup Y$ 中最大的包含 $X − \{f\}$ 的独立集是 $Z$ 。由于 $Y$ 不是独立<br>集，所以 $Y \not\subset Z$ 。由此可得 $|Z|\le |X\cup Y − \{f\}| − 1 \le |X \cup Y| − 2 &lt; |X \cup Y − \{e\}|$ 。因为 $Z$ 已经<br>是最大的独立集了，所以 $X\cup Y − \{e\}$ 不可能是独立集（否则由交换性可以扩大 $Z$ ），命题得证。</p>
</div></details>
<p><strong>引理 1.7</strong> ：$I$ 是基，$e\notin I$ ，那么 $I+\{e\}$ 包含一个唯一的环。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>至少有一个环是显然的，每个环都有 $e$ 是显然的。</p>
<p>引理 1.6 告诉我们只要有两个环，就可以构造出不含 $e$ 的环，所以至多只有一个环。</p>
<p>证毕。</p>
</div></details>
<h1 id="秩函数"><a href="#秩函数" class="headerlink" title="秩函数"></a>秩函数</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>对于拟阵 $M=(S,\mathcal{I})$ ，基的元素的个数称为拟阵的秩，对于任意一个 $U\subset S$，定义秩函数 $r(U)$ 表示 $U$ 中极大独立集的大小。</p>
<h2 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h2><p><strong>定理 2.1(有界性)</strong> ：${\forall}U\subset S, 0\le r(U)\le|U|$</p>
<p><strong>定理 2.2 (单调性)</strong> ：${\forall}A\subset B\subset S,r(A)\le r(B)$</p>
<p><strong>定理 2.3 (次模性)</strong> ：${\forall}A,B\subset S,r(A\cup B)+r(A\cap B)\le r(A)+r(B)$</p>
<p>定理1,2都是显然的，下面证明定理3。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>首先，我们使用构造方法，证明一个集合的秩的下界是更加容易的（构造一个独立集总比说明独立集大小的上界要容易得多），根据这个方向，我们得到这个证明：</p>
<p>先找到 $A\cap B$ 的极大独立集，然后用交换性扩大成 $A\cup B$ 的极大独立集，然后把扩大的部分，按照 $A\setminus B,B\setminus A$ 分成两部分，和 $A\cap B$ 的极大独立集合成 $A,B$ 的独立集，然后就证完了。</p>
<p>更加严谨的写法看国集论文，这里懒得复制粘贴了，思路是一样的。</p>
</div></details>
<p>那么问题来了，我们能否用秩函数定义拟阵？答案是：可以。</p>
<p>如果我们有一个函数 $r$ ；$2^S\to \mathbb{Z}$，定义 $\mathcal{I}={I:r(I)=|I|}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">遗传性证明</summary><div class="toggle-content"><p>在遗传性的证明中，我们更希望证明一个集合是独立集，也就是证明 $r(I)=I$ ，显然，我们其实是需要证明 $r(I)\ge I$ ，所以在证明中应该更多的将目标集合放在 $\le$ 的右边。</p>
<p>$A=J,B=I\setminus J$，即可证明。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">交换性证明</summary><div class="toggle-content"><p>在交换性的证明中，由于找到具体哪个集合是独立集有点困难，采用反证，则考虑限制集合秩的上界，去证明大集合（$I$）并不是独立集，此时把目标集合（$I$）放在 $le$ 左边限制上界。</p>
<p>令 $\{b_1,b_2,…,b_n\}=I\setminus J$</p>
<p>考虑 ：$A=J+\{b_1\},B=J+\{b_2\}$，则可以证明 $r(J+\{b_1,b_2\})=|J|$，然后将其作为新的 $A$，令 $B=J+\{b_3\}$ ，不断往下做，直到合成出 $I\cup J$ 为止，此时 $r(I\cup J)=|J|&lt;|I|=r(I)$ ，矛盾，证毕。</p>
</div></details>
<p>说点抽象的话：</p>
<p>事实上，定理 3 变换一下可以得到另外一个形式：$r(A\cup B)-r(A)\le r(B)-r(A\cap B)$ ，然后变个符号：$r(A\cup C)-r(A)\le r(B\cup C)-r(B),B\subset A$ 。</p>
<p>在面对一个集合时，小集合的增量要不劣于大集合的增量，这说明小集合比起大集合具有更大的增长潜力，在后面闭包算子中会反复提及这一点。</p>
<p>当然，对于这一点，可以这么理解，现在假设有个空集，他可以到达任何的基，但是随着元素一个个被确定，能到达的基越来越少，选择也越来越少，因此增长潜力也在减小，极端的，当为基的时候，没有选择，增长不了，增长潜力达到最低值。</p>
<h1 id="拟阵最优化"><a href="#拟阵最优化" class="headerlink" title="拟阵最优化"></a>拟阵最优化</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>定义函数 $w:S\to \mathbb{R}$ ，定义一个集合的权值为：$w(I)=\sum\limits_{e\in I}w(e)$，找 $\mathcal{I}$ 中最大的 $w(I)$ 。</p>
<p>例子：最小生成树。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><del>最小生成树plus版</del></p>
<p>以下先默认权值非负，因此显然权值最大的基就是权值最大的独立集。</p>
<ol>
<li>把 $S$ 中的元素按照从大到小的顺序排序，记作 $s_1,s_2,s_3,…,s_n$ 。</li>
<li>维护一个集合 $I$ ，初始为空，按顺序考虑 $s_i$ ，如果 $I$ 加上 $s_i$ 是独立集就加入，否则就不加入。</li>
</ol>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>没看懂论文第二步的证明，自己瞎掰了一个。</p>
<p>记 $U_i=\{s_1,s_2,…,s_i\}$，$I_i$ 为考虑完 $s_i$ 后的 $I$ 。</p>
<p>$|I_i|=r(U_i)$ ，否则$|I_i|$ 可以扩大，加入的元素为 $s_j(j\le i)$ ，则一定会在考虑到 $s_j$ 的时候加入该元素，矛盾，所以成立。</p>
<p>所以最后 $I$ 是一个基。</p>
<p>考虑把每个独立集用其所含元素的下标从小到大呈现，例如：$\{1,2,4\}$ 表示其含有 $s_1,s_2,s_4$ 。</p>
<p>那么对于 $I$ ，假设其呈现出来是：$a_1,a_2,…,a_t$ , 对于任意一个基而言，是：$a’_1,a’_2,…,a’_t$ ，那么显然有 $a_i\le a’_i$ ，则显然 $I$ 是权值最大的基。</p>
</div></details>
<p>事实上，同样的证明方法，不一定要 $I$ 是基，可以扩展，当 $|I|$ 的大小为 $t$ 时，$I$ 就是所有大小为 $t$ 的独立集中权值最大的。</p>
<p>所以就算权值是非负的，如果指定了目标独立集的大小，仍然可以用此算法。（不过如果已经指定了大小，令总体权值加减一个数字只会让答案改变 $siz*val$，也能把问题转化到非负情形下）</p>
<p>但是如果权值可以是负数呢？</p>
<p>显然当 $s_i\le 0$ 时推出就行了，显然正确，考虑答案只可能出在 $I_i$ 就行了。（显然，$I_i$ 是同集合大小的独立集中权值最大的，只考虑他就行了）</p>
<h1 id="拟阵交"><a href="#拟阵交" class="headerlink" title="拟阵交"></a>拟阵交</h1><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>对于 $M_1=(S,\mathcal{I}_1)$，$M_2=(S,\mathcal{I}_2)$ ，定义 $M_1,M_2$ 的交是所有 $I$ 的集合 ，$I$ 满足在两个集合中都是独立集。</p>
<p>首先，拟阵的交是拟阵吗？不是。</p>
<p>反例：$S=\{1,2,3\},\mathcal{I}_1=\{\emptyset,\{1\},\{2\},\{3\},\{1,2\},\{1,3\}\},\mathcal{I}_2=\{\emptyset,\{1\},\{2\},\{3\},\{1,2\},\{2,3\}\}$ 。</p>
<p>交为：$\{\emptyset,\{1\},\{2\},\{3\},\{1,2\}\}$</p>
<p>显然不是拟阵。</p>
<p>不过拟阵交虽然不是拟阵，但是显然是个集合，那问题来了，这个集合中大小最大的独立集有多大？并且求出一个合法解。</p>
<p>这个问题在两个拟阵的交时有多项式求法，但是三个以上是 NP-hard 的。</p>
<p>所以接下来的讨论默认是两个拟阵的交。</p>
<h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><h3 id="闭包算子"><a href="#闭包算子" class="headerlink" title="闭包算子"></a>闭包算子</h3><p>对于 $A\subset S$ ，我们定义 $A$ 的闭包算子 $cl(A)=\{e\in S : r(A\cup \{e\})=e(A)\}$ 。</p>
<p>也就是加入后不会影响 $A$ 的秩的元素。</p>
<p>一个显然的事情：$A\subset cl(A)$ 。</p>
<h3 id="交换图"><a href="#交换图" class="headerlink" title="交换图"></a>交换图</h3><p>对于 $I\in \mathcal{I}$，定义一个二分图，一边是 $I$ ，一边是 $S\setminus I$ ，存在边 $(x,y)(x\in I,y\in S\setminus I)$ 当且仅当 ：$I-\{x\}+\{y\}\in \mathcal{I}$ 。</p>
<p>称此二分图为 $I$ 的交换图，记作 $D_M(I)$ 。</p>
<h2 id="性质-2"><a href="#性质-2" class="headerlink" title="性质"></a>性质</h2><p><strong>引理 4.1</strong> ：如果 $A\subset B$ ，那么 $cl(A)\subset cl(B)$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>兄弟，来一个极其富有高代特色的证明。</p>
<p>对于任意一个 $z\in cl(A)$ ，找到 $A$ 的一个极大独立集，然后在 $B+\{z\}$ 中扩大，那么一定会得到一个不含 $z$ 的极大独立集，所以 $z$ 不会扩大 $B$ 的秩。</p>
<p>这个证明用到了一个显然正确的结论：如果加入 $z$ 后，存在一个极大独立集不包含 $z$ ，那么 $z$ 一定在该集合的闭包算子中，否则不在。</p>
<p>论文采用秩函数证明：</p>
<p>$r(A+\{z\})+r(B)\ge r((A+\{z\})\cap B)+r(B+\{z\})\ge r(A)+r(B+\{z\})$ 。（也可以由 $r(A+\{z\})-r(A)\ge r(B+\{z\})-r(B)$ 得到，这个式子在上面的次模性的变形中给出过）</p>
<p>又 $r(A+\{z\})=r(A)$ ，所以 $r(B)\ge r(B+\{z\})$，所以 $r(B)=r(B+\{z\})$ ，证毕。</p>
</div></details>
<p>这个定理同样反映了小集合比大集合更加具有增长潜力，一个元素对小集合没有贡献，那么对大集合同样没有贡献。</p>
<p><strong>引理 4.2</strong> ：$A\subset S,e\in cl(A)$ ，那么 $cl(A)=cl(A\cup \{e\})$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>${\forall} z \in cl(A\cup \{e\}),r(A)=r(A+\{z\})=r(A+\{e,z\})$，则 $r(A)\le r(A+\{z\})\le r(A+\{e,z\})$ ，所以 $r(A)=r(A+z)$ ，证毕。</p>
<p>人话讲就是，如果加到大集合秩不变，由于大集合秩等于小集合，大集合的秩本来就比小集合大，如果小集合变大了，就比大集合大了，所以加入到小集合中秩也不能变大。</p>
<p>所以如果 $r(A)=r(B),A\subset B$，那么 $cl(A)=cl(B)$ 。（引出下文）</p>
</div></details>
<p><strong>引理 4.3</strong> ：$cl(A)=cl(cl(A)),r(A)=r(cl(A))$ 。（反复用 引理 4.2 就行了）</p>
<p>上面两个引理说明了个什么事呢？（包括证明过程）</p>
<p>显然的事情：</p>
<ol>
<li>$A\subset B,r(A)=r(B)$，那么 $cl(A)=cl(B),B\setminus A \subset B\subset cl(B)=cl(A)$ 。（秩相同则 $cl$ 相同）</li>
<li>${\forall} B\subset cl(A):cl(A\cup B)=cl(A),r(A\cup B)=r(A)$ 。（这一条主要是对引理4.3的扩展）</li>
<li>$A\subset B,cl(A)=cl(B):r(A)=r(B)$ 。（因为 $B\subset cl(B)=cl(A)$，所以 $r(B)=r(A\cup B)=r(A)$ ）（ $cl$ 相同则秩相同）</li>
</ol>
<p>因此，如果子集之间相互包含，那么秩相同和 $cl$ 相同同时成立，也很符合直觉，集合变大，秩不变，那一定是你一直在加一些没有贡献的元素进来。同时，加入没有贡献的元素进来，也并不会改变没贡献的元素的集合，也就是说没贡献的元素之间不会产生联动，突然就产生贡献了，没用就是一直没用，直到秩增大。</p>
<p>这几个引理还可以从另外一个视角看：若 $C\subset cl(B)$ ，$B\subset cl(A)$ ，那么 $C\subset cl(A)$ ，这体现了闭包的传递性。</p>
<p>这也说明了一个事情：在产生秩增量这件事情上， $B$ 没用，$C$ 一定没用，$C$ 有用，$B$ 一定有用，也就是说某种程度上讲 $B$ 覆盖了 $C$ 的功能，这在后面的某些证明中有所体现。</p>
<p>在图拟阵中的一个体现就是：$(x,y)$ 和一个简单路径 $x\to y$ 形成了一个简单环，$(x,y)$ 的作用是有他在的边集合中，最大的独立集 $x,y$ 一定是联通的，而 $x\to y$ 一样能办到这件事。（此时 $(x,y)\in cl(x\to y))$）</p>
<p>注意一个特殊的集合：环，对于环 $I’,{\forall} z\in I’:z\in cl(I’-\{z\})$ ，这在后面的证明中会用到。</p>
<p><strong>定理 4.4(强基交换定理)</strong> ：对于两个不同的基 $A,B$ ，${\forall}x\in A\setminus B,{\exists} y\in B\setminus A : A-\{x\}+\{y\},B-\{y\}+\{x\}$ 都是基 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>先写论文的证法：</p>
<p>将 $x$ 加入 $B$ 中得到一个环 $C$ 。</p>
<p>则 $x\in cl(C-\{x\})$ ，则 $x\in cl((A\cup C)-\{x\})$ ，那么 $cl((A\cup C)-\{x\})=cl(A\cup C)$ ，所以 $r((A\cup C)-\{x\})=r(A\cup C)$ ，综上，存在 $y\in C-\{x\}$ ，满足 $A-\{x\}+\{y\}$ 是基，同时因为 $y$ 是环中的一个元素，所以 $B-\{y\}+\{x\}$ 也是环中的一个基。</p>
<p>这里其实就是用 $C-\{x\}$ 去代替 $x$ 的作用，然后找到是哪个元素起到了作用，将他作为 $y$ 。</p>
<p>当然，可以从染色的视角去看这个问题：</p>
<p>如果把这个问题放在图拟阵，也就是 $A$ 的一条边 $(x,y)$ 放到 $B$ 中，然后需要我去证明在 $B$ 的环中存在一条不是刚刚加入进来的边，满足能够填补 $A$ 的空缺。（一般的，我们认为 $A,B$ 都是生成树，就算是生成森林，边所在的联通块是一致的）</p>
<p>那么把 $A$ 中 $(x,y)$ 切断，与 $x$ 联通染蓝色， $y$ 联通染红色，显然，$B$ 中与 $(x,y)$ 形成环的路径上一定存在一条边，一端红色，一端蓝色，他就是我们要找的边。（因为路径两端一端红色，一端蓝色）</p>
<p>但是对点染色貌似和拟阵没什么关系，但是不妨换个角度看，我们要找的是路径上两端异色的边，所以我们不妨对边也染色，两端同色染为白色，异色染为黑色，观察一下这是什么？这就是 $cl(A-\{x\})$ ，也就是说 $cl$ 其实可以看成一种染色，无用染白，有用染黑。</p>
<p>有了这个想法，证明就轻松多了，显然在图拟阵中，一个环不能只有恰好一条黑边，否则从 $x$ 的联通块走黑边到达 $y$ 联通块，就没有另外一条黑边走回来了，与简单环的定义矛盾。所以去掉这条黑边是一个独立集（环的定义），加上这条黑边还是个独立集，与环矛盾，证毕。</p>
<p>用拟阵的话就是：反证法，如果 $C-\{x\}\subset cl(A-\{x\})$ ，那么 $x\notin cl(A-\{x\})$ ，则 $x\notin cl(C-\{x\})$ ，与环的定义矛盾，证毕。</p>
<p>所以 $cl$ 某种角度上可以算是拟阵的染色法。（先从图拟阵的角度思考是有道理的，直观）</p>
</div></details>
<p>当然，由上面的证明过程，可以放宽定理条件：$A,B$ 不一定得是基，只要满足 $|A|\le|B|$ 即可。</p>
<p>即：</p>
<p>${\forall}A,B\in \mathcal{I},|A|\le|B|,{\forall} x\in A,{\exists} y\in B\setminus (A-\{x\}):A-\{x\}+\{y\}，B+\{x\}-\{y\}\in \mathcal{I}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>$B+\{x\}$ 不是独立集就类似上面证明就行了，小改即可。</p>
<p>是独立集，则 $|B+\{x\}|=|B|+1&gt;|A|$ ，则有交换性，存在 $y\in B:A+\{y\}\in\mathcal{I}$ 。</p>
<p>则 $A+\{y\}-\{x\}\in \mathcal{I}$ 。</p>
<p>这里还有个非常有意思的想法，用上面的思路证完 $|A|=|B|$ 的情况，然后对于 $|A|&lt;|B|$ 的情况，先用 $B$ 把 $A$ 扩大到相同大小，然后强交换，由于用于扩大的集合是两个集合的交集，所以不会出现在 $x,y$ 中，所以可以直接用遗传性再缩小回去，从而完成 $|A|&lt;|B|$ 的证明。</p>
<p>但是上面的思路可以直接把两种情况都证了，也就不需要多此一举了。</p>
</div></details>
<p><strong>引理 4.5</strong> ：对于独立集 $I,J,I\ne J,|I|=|J|$ ，则 $I\setminus J$ 与 $J \setminus I$ 存在完美匹配。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>很有意思的构造性解，反正我没有证出来，思路确实新奇，小清新构造。（mad，没有证出来真TM不爽）</p>
<p>对于元素 $y\in J\setminus I$ ，由强交换定理可知存在 $x\in I\setminus J$ ，使得 $I-\{x\}+\{y\},J-\{y\}+\{x\}$ 仍然是独立集。</p>
<p>则认为 $x,y$ 匹配，然后令 $J=J+\{x\}-\{y\}$ ，接着构造，直到 $I=J$ ，构造完毕。</p>
</div></details>
<p><strong>引理 4.6</strong> ：对于独立集 $I$ 和集合 $J,I\ne J,|I|=|J|$ ，且 $I\setminus J$ 与 $J \setminus I$ 存在唯一的完美匹配，则 $J$ 也是独立集。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>显然，要直接证明 $J$ 是不是独立集这件事情非常的困难，所以我的思路是构造+归纳，通过已有的信息，把 $I$ 构造出 $J$ 。</p>
<p>我们考虑把 $I\setminus J$ 换成 $J\setminus I$ 的一个元素，变成 $I’$ ，使得 $I’$ 与 $J$ 仍然只存在唯一的完美匹配。</p>
<p>考虑对于 $(x,y),x\in I\setminus J,y\in J\setminus I$ ，如果 唯一匹配是 $(x,y)$ ，则认为是 $x\to y$ ，否则认为是 $y\to x$ ，由于无环，所以是拓扑图。（因为是唯一匹配，所以无环，唯一匹配这个信息，显然是要往无环的角度去靠）</p>
<p>所以一定存在一个点 $x\in I\setminus J$ ，$x$ 没有入边，即在由 $I\setminus J$ 与 $J\setminus I$ 的导出子图中，$x$ 只有一条边。</p>
<p>考虑直接把 $x$ 换成与他匹配的 $y$ 。</p>
<p>不难证明（用交换性搞搞就行了），在 $D_M(I’)$ 中 $I’\setminus J$ 与 $J\setminus I’$ 的导出子图中的边一定在 $D_M(I)$ 中出现，同时 原来的匹配边也一定在新的导出子图中，所以仍然是唯一匹配。（匹配边还在，非匹配边减少了）</p>
<p>然后归纳就行了。</p>
<p>不过论文给了种更加简单的证明，不过我觉得本质应该差不多。</p>
<p>首先把匹配写成 $(x_1,y_1),(x_2,y_2),…,(x_t,y_t)$ 的形式，一般的，当 $i&lt;j$ 时， $x_i,y_j$ 没有边。（把 $x$ 按照拓扑序从小到大排就行了） </p>
<p>然后假设 $J$ 不是独立集，那么就存在环，假设为 $C$ ，并且其中下标最小的是 $y_i$ （显然一定有 $J\setminus I$ 的元素）。</p>
<p>考虑 $I-\{x_i\}$ ，那么 $C-y_i\subset cl(I-\{x_i\})$ ，又 $y_i\subset cl(C-y_i)\subset cl(cl(I-\{x_i\}))=cl(I-\{x_i\})$ ，这与 $x_i,y_i$ 匹配矛盾，证毕。</p>
<p>本质上就是 $C-\{y_i\}$ 能够替代 $y_i$ 的功能，但是由唯一匹配可以导出不能替代，从而导致了矛盾。</p>
</div></details>
<p><strong>引理 4.7</strong> ：$I,J\in \mathcal{I},|I|=|J|,{\forall} z\in J\setminus I,I+\{z\}\notin\mathcal{I},x\in S\setminus I,I+\{x\}\in \mathcal{I}$ ，那么 $J+\{x\}\in \mathcal{I}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>$J\setminus I\subset cl(I)$ ，如果 $x\in cl(J)$ ，那么 $x\in cl(I)$ ，矛盾，证毕。</p>
</div></details>
<p><strong>定理 4.8(最小最大定理)</strong> ：$\max\limits_{I\in \mathcal{I_1}\cap\mathcal{I_2}} |I|=\min\limits_{U\subset S}(r_1(U)+r_2(S\setminus U))$</p>
<p>这里证明 $\le$ 是显然的，$|I\cap U|\le r_1(U)$ ，另一边同理，加起来就行了。</p>
<p>但是证明相等比较麻烦，后面在算法中用构造性方法证明。</p>
<h2 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h2><p>现在给出算法流程。</p>
<p>现有集合 $I,X_1=\{x\in S\setminus I:I+\{x\}\in \mathcal{I_1}\},X_2=\{x\in S\setminus I:I+\{x\}\in \mathcal{I_2}\}$ ，初始时 $I=\emptyset$ 。</p>
<p>定义交换图（有向图） $D_{M_1,M_2}(I)$ 为 ：</p>
<ol>
<li>$x\in I,y\in S\setminus I$ ，如果 $(x,y)\in D_{M_1}(I)$ ，那么 $x\to y\in D_{M_1,M_2}(I)$ 。</li>
<li>$x\in I,y\in S\setminus I$ ，如果 $(x,y)\in D_{M_2}(I)$ ，那么 $y\to x\in D_{M_1,M_2}(I)$ 。</li>
</ol>
<p>重复进行算法流程：</p>
<ol>
<li>在 $D_{M_1,M_2}(I)$ 找到一条起点属于 $X_1$ ，终点属于 $X_2$ 的最短路 $P$。（没有就结束算法）</li>
<li>令 $I=I∆P$ 。（ $∆$ 表示集合的对称差操作）</li>
</ol>
<p>最后得到的 $I$ 就是一个最大大小的拟阵交，同时 $U=\{x\in S:x 在D_{M_1,M_2}(I)能够到达 X_2 中的点\}$ 。</p>
<p>这个算法的正确性要证明两件事：</p>
<ol>
<li>$I$ 为什么仍然是拟阵交。</li>
<li>为什么 $|I|=r_1(U)+r_2(S\setminus U)$ 。</li>
</ol>
<details class="toggle" ><summary class="toggle-button" style="">证明1</summary><div class="toggle-content"><p>先证明新的 $I\in \mathcal{I_1}$ 。</p>
<p>令路径 $P=\{y_0,x_1,y_1,…,y_t\}$ ，令 $J=I-\{x_1,x_2,…,x_t\}+\{y_1,y_2,…,y_t\}$ ，由最短路可以导出是唯一匹配（因为 $D_{M_1}(I)$ 的结构类似 DAG 那样，BFS图），所以 $J$ 也是独立集，且同时可以直到 $y_1,y_2,…,y_t\in cl(I)$ ，由引理 4.7可知 $I+\{x\}\in \mathcal{I_1}$ 。</p>
<p>同理可证 $I\in \mathcal{I_2}$ 。</p>
<p>证毕。</p>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">证明2</summary><div class="toggle-content"><p>假设 $r_1(U)&gt;|I\cap U|$ ，则 ${\exists} z\in U\setminus I,(I\cap U)+\{z\}\in\mathcal{I_1}$ ，如果 $I+\{z\}\in \mathcal{I_1}$ ，则显然存在路径 $P$ ，否则，显然，$|I|&gt;|I\cap U|$ ，所以用 $I$ 把 $I\cap U +\{z\}$ 扩大，则显然存在 $x\in S\setminus U,I-\{x\}+\{z\}\in\mathcal{I_1}$ ，所以存在 $x\to z$ ，这与 $x\notin S$ 矛盾。</p>
<p>另外一边类似，不再赘述。</p>
<p>证毕。</p>
</div></details>
<p>这样，就证明了最小最大定理，同时也给出了一个求一组 $I,U$ 的多项式算法。</p>
<p>分析一下时间复杂度。</p>
<p>不计建 $D_{M_1,M_2}(I)$ 的复杂度，令 $n=|S|,r=\max(r_1(S),r_2(S))$ ，每次增广的代价是 $O(rn)$ ，每轮 $|I|$ 增大 $1$ ，所以至多进行 $r$ 轮，所以时间复杂度为 $O(r^2n)$ 。</p>
<p>非常优秀的时间复杂度。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="三个以上的拟阵交为什么是-NP-Hard-的"><a href="#三个以上的拟阵交为什么是-NP-Hard-的" class="headerlink" title="三个以上的拟阵交为什么是 NP-Hard 的"></a>三个以上的拟阵交为什么是 NP-Hard 的</h3><p>可以证明难于哈密顿路径：</p>
<p>对于有向图 $G=(V,E)$ ，求 $s\to t$ 的哈密顿路径。</p>
<p>构造拟阵：</p>
<ol>
<li>令 $M_1$ 为边集满足把有向边看成无向边，则无环。</li>
<li>令 $M_2$ 为 $s$ 的入度为 $0$ ，其余点入度至多为 $1$ 。</li>
<li>令 $M_3$ 为 $t$ 的出度为 $0$ ，其余点出度至多为 $1$ 。</li>
</ol>
<p>求出这三个拟阵的拟阵交显然就能求出哈密顿路径，或者证明无解。</p>
<p>所以求三个及以上的拟阵交是 NP-Hard 的。</p>
<h3 id="带权拟阵交"><a href="#带权拟阵交" class="headerlink" title="带权拟阵交"></a>带权拟阵交</h3><p>定义权值函数：$w:S\to \mathbb{R}$ ，求 $\max\limits_{I\in \mathcal{I_1}\cap\mathcal{I_2}}\sum\limits_{e\in I}w(e)$ 。</p>
<p>扩展版本的最小最大定理我没看懂，这一部分建议自己去看论文。我没看懂这一部分，就不在这里胡说八道了。</p>
<p>算法流程就是把最短路径换成，以点权和最大为第一关键字，最少边数为第二关键字找路径。</p>
<p>其中 $I$ 的点权为 $-w(e)$ ，$S\setminus I$ 为 $w(e)$ 。</p>
<p>论文里写的是点权和最小，但是一个很简单的例子，所有独立集大小最大为 $1$ ，然后让这个拟阵自己和自己做交，那么最大值是什么？显然是权值最大的元素，但是按照论文里写的会找权值最小的元素，这显然是错误的。</p>
<p>更重要的是，在做题的时候，我写最长路过了。</p>
<p>至于为什么不会有正环，为什么算法一定会停止，为什么这个算法对，我一概不知，我只知道写最长路能过，仅此而已，现在当黑盒用了。</p>
<p>时间复杂度：$O(r^2n^2)$ 。</p>
<h6 id="坑3"><a href="#坑3" class="headerlink" title="坑3"></a>坑3</h6><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>兄弟，学了这么久，该做做题了，不然你学拟阵干什么。</p>
<p>拟阵交的题目一般是题目的条件无法直接使用拟阵，但是单看其中的一部分条件是满足拟阵要求的，所以就搞两个拟阵交起来，获得一个满足多个条件的集合，这种题目最难的就是怎么去构造合适的拟阵。</p>
<h3 id="二分图匹配"><a href="#二分图匹配" class="headerlink" title="二分图匹配"></a>二分图匹配</h3><p>虽然二分图匹配的匹配点集本身就是个拟阵，但是检验一个子集是否是独立集，就需要判断是否被一个匹配覆盖，这显然是难的。（我都能找匹配了，为什么还要多此一举再用个拟阵=.=）</p>
<p>所以构造拟阵。</p>
<ol>
<li>第一个拟阵 $M_1=(E,\mathcal{I_1})$ ，满足左部点的每个点的度数至多为 $1$ 。</li>
<li>第二个拟阵 $M_2=(E,\mathcal{I_2})$ ，满足右部点的每个点的度数至多为 $1$ 。</li>
</ol>
<p>拟阵交即可。</p>
<p>其实如果思考一下，会发现拟阵交找的增广路和匈牙利算法找的是一样的。</p>
<h3 id="最小树形图"><a href="#最小树形图" class="headerlink" title="最小树形图"></a>最小树形图</h3><p>给定带权有向图 $G=(V,E)$ ，求以 $root$ 为根的最小权外向树。</p>
<ol>
<li>第一个拟阵 $M_1=(E,\mathcal{I_1})$ ，满足把有向边看成无向边无环。</li>
<li>第二个拟阵 $M_2=(E,\mathcal{I_2})$ ，除 $root$ 之外入度至多为 $1$ ，$root$ 入度为 $0$ 。</li>
</ol>
<p>然后用带权拟阵交。</p>
<h3 id="Colorful-Tree"><a href="#Colorful-Tree" class="headerlink" title="Colorful Tree"></a>Colorful Tree</h3><p>给定带权无向图 $G=(V,E)$ ，每条边有一个 $1$ 到 $n-1$ 的颜色，求一个最大权的生成树，满足每个颜色恰好出现一次。</p>
<ol>
<li>第一个拟阵 $M_1=(E,\mathcal{I_1})$ ，无环。</li>
<li>第二个拟阵 $M_2=(E,\mathcal{I_2})$ ，每个颜色至多出现一次。</li>
</ol>
<p>带权拟阵交。</p>
<h1 id="一些拟阵的操作"><a href="#一些拟阵的操作" class="headerlink" title="一些拟阵的操作"></a>一些拟阵的操作</h1><p>在理解接下来的操作时，推荐用基的定义去理解，优先考虑基的变化，会很有助于理解这个拟阵在这个操作后会发生什么变化。</p>
<h2 id="对偶拟阵"><a href="#对偶拟阵" class="headerlink" title="对偶拟阵"></a>对偶拟阵</h2><p>定义：对于拟阵 $M=(S,\mathcal{I})$ ，定义 $M$ 的对偶拟阵 $M^{<em>}=(S,\mathcal{I^</em>})$ ，其中 $I^*=\{U\subset S:{\exists}基I\in \mathcal{I},I\subset S\setminus U\}$ 。</p>
<p>遗传性显然，现在证明交换性：</p>
<details class="toggle" ><summary class="toggle-button" style="">交换性的证明</summary><div class="toggle-content"><p>假设 $|U_1|&gt;|U_2|$ ，设基 $I_1\subset S\setminus U_1,I_2\subset S\setminus U_2$ 。</p>
<p>设基 $I_3=I_1\setminus U2$ ，然后用 $I_2$ 去扩张 $I_3$ 成基 $I_4$ 。</p>
<p>那么 $|I_4\cap U_1|\le|I_4\setminus I_3|\le |U_2|-|U_1\cap U_2|&lt; |U_1|-|U_1\cap U_2|$ 。</p>
<p>显然 $I_4\subset S\setminus U_2$ ，所以显然 ${\exists} z\in U_1\setminus U_2: U_2+\{z\}\in \mathcal{I_2}$ 。</p>
</div></details>
<p>对偶拟阵的秩函数：</p>
<p>$r^<em>(U)=\max\limits_{I\subset U,I\subset I^</em>}|I|=\max\limits_{B是M中的基}|U\setminus B|=|U|-\min\limits_{B是M中的基}|U\cap B|=|U|-r(S)+\max\limits_{B是M中的基}|B\cap (S\setminus U)|=|U|-r(S)+r(S\setminus U)$</p>
<p>也可以用秩函数证明这是个拟阵，在这里就不展开讲了，不是很麻烦，可以自证。</p>
<p>对偶拟阵的用途很广，他代表了一般拟阵的另外一个方面，举个例子：图拟阵的对偶就是去掉哪些边仍能保证图是联通的。</p>
<p>对偶拟阵实际上就是把所有基的补集作为了基的集合定义的拟阵。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>对于拟阵 $M=(S,I)$ ，和 $Z\subset S$ ，定义拟阵 $M$ 删除子集 $Z$ 的拟阵为 $(S\setminus Z,\mathcal{I’}), \mathcal{I’}=\{I:I\subset S\setminus Z, I\in \mathcal{I}\}$ 。记为 $M\setminus Z$ 。</p>
<p>这个操作非常好理解，就是只考虑和 $Z$ 没有交集的独立集，秩函数直接用原来的就行，非常的简单。</p>
<h2 id="收缩"><a href="#收缩" class="headerlink" title="收缩"></a>收缩</h2><p>对于拟阵 $M=(S,I)$ ，和 $Z\subset S$ ，定义拟阵 $M$ 删除子集 $Z$ 的拟阵为 $(M^<em>\setminus Z)^</em>$ 。记为 $M/Z$ 。</p>
<p>由于是用上面两个操作定义的，所以显然是个拟阵。</p>
<p>这个操作理解起来会比较困难。</p>
<p>考虑 $M/Z$ 的基，首先得是 $M^<em>\setminus Z$ 的基的补集，$M^</em>\setminus Z$ 的基又得是 $M^<em>$ 中和 $Z$ 交集最小的基去掉交集部分的集合，而 $M^</em>$ 中和 $Z$ 交集最小的基对应的是 $M$ 中和 $Z$ 交集最大的基的补集。</p>
<p>综上，可以得出，$M/Z$ 的基是原来和 $Z$ 交集最大的基去掉交集的部分，同理，独立集也是类似的。</p>
<p>当然也可以从秩的角度考虑，这里不再赘述，直接给出秩函数的式子：</p>
<p>$r_{M/Z}(U)=r_M(Z\cup U)-r_M(Z)$ 。</p>
<p>例子：图拟阵中的缩边操作。</p>
<h2 id="极小元"><a href="#极小元" class="headerlink" title="极小元"></a>极小元</h2><p>对于一个拟阵，经过一系列删除和收缩操作得到的任意拟阵 $M’$ ，称作拟阵 $M$ 的极小元。</p>
<h1 id="拟阵并"><a href="#拟阵并" class="headerlink" title="拟阵并"></a>拟阵并</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>对于给定的 $k$ 个拟阵 $M_i=(S_i,\mathcal{I_i}),1\le i\le k$ 。定义这 $k$ 个拟阵的并为 $M=(S,\mathcal{I})$ ，其中 $S=\bigcup\limits_{i=1}^k S_i,\mathcal{I}=\{\bigcup\limits_{i=1}^k I_i:I_i\in \mathcal{I_i}\}$ 。</p>
<p>遗传性非常简单，重点是交换性。</p>
<details class="toggle" ><summary class="toggle-button" style="">交换性的证明</summary><div class="toggle-content"><p>不妨认为 $|I|&lt;|I’|$</p>
<p>不妨这么考虑一个事情，首先不妨认为：$I_i\cap I_j=\emptyset,i\ne j$ 。</p>
<p>同理对于 $I’_i$ 也是。</p>
<p>这样 $|I|=\sum\limits|I_i|,|I’|=\sum\limits|I’_i|$ 。</p>
<p>所以一定存在 $i:|I’_i|&gt;|I_i|$ ,所以考虑一定存在 $x\in I’_i,I_i+\{x\}\in \mathcal{I_i}$ ，如果 $x\in \mathcal{I}$ ，则说明 $x\in I_j,i\ne j$ ，所以令 $I_j$ 删掉 $x$ ，$I_i$ 加上 $x$ ，然后重新进行这个过程，反之，则交换性成立。</p>
<p>由于 $\sum\limits |I_i\cap I’_i|$ 会不断变大，所以这个过程一定会停下来，即交换性一定成立，证毕。</p>
<p>论文是一开始就找使 $\sum\limits |I_i\cap I’_i|$ 最大的 $I_i$ ，所以不用重复这个过程。</p>
</div></details>
<h2 id="秩函数-1"><a href="#秩函数-1" class="headerlink" title="秩函数"></a>秩函数</h2><script type="math/tex; mode=display">r_M(U)=\min\limits_{T\subset U}(|T|+\sum\limits_{i=1}^k r_{M_i}((U\setminus T)\cap S_i))</script><p>要证明这个定理，我们需要证明一个引理：</p>
<p><strong>引理 6.1</strong> ：拟阵 $\hat{M}=(\hat{S},\hat{\mathcal{I}})$ ，定义函数 $f:\hat{S}\to S$ ，定义拟阵 $M=(S,\mathcal{I}),I=\{f(\hat{I})\:\hat{I}\in\hat{\mathcal{I}}\}$ ，则 $M$ 的秩函数为：</p>
<script type="math/tex; mode=display">r_M(U)=\min\limits_{T\subset U}(r_{\hat{M}}(f^{-1}(U\setminus T))+|T|)</script><p>注 ： $f^{-1}(T)=\{x\in\hat{U}:f(x)\in T\}$ 。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>这个证明不需要证明这是个拟阵，但是这并不难证，交换性的证明，和拟阵并交换性的证明是几乎一样的。（也可以先证了秩函数再导出其是个拟阵）</p>
<p>考虑构造一个划分拟阵 $(\hat{S},\mathcal{I_p})$ ，其中 $I\in \mathcal{I_p}$ 当且仅当 $I$ 中不存在两个元素 $f$ 的映射值相等。</p>
<p>这样的话，$r_M(U)$ 实际上就是拟阵 $\hat{M}$ 和 $(\hat{S},\mathcal{I_p})$ 限制在 $f^{-1}(U)$ 集合的拟阵交，用最小最大定理便可证明。</p>
</div></details>
<p>用引理证明秩函数并不困难，令 $S_i$ 中的元素 $e$ 变成二元元素 $(e,i)$ ，从而区分开所有的元素，再构造函数 $f((e,i))=e$ 即可得证。</p>
<h6 id="坑4"><a href="#坑4" class="headerlink" title="坑4"></a>坑4</h6><p>后面那些判断独立集啥的，还有表示法啥的还没有学，以后再说，先咕咕了，得去做些题目了，太久没敲代码手感不对了，现在。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>国家集训队2018论文：《浅谈拟阵的一些拓展及其应用》—- 江苏省淮阴中学 杨乾澜</p>
<p>图片生成：<a href="https://csacademy.com/app/graph_editor/">https://csacademy.com/app/graph_editor/</a></p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>拟阵</tag>
      </tags>
  </entry>
  <entry>
    <title>求图上最大异或和路径的证明</title>
    <url>/2024/02/27/%E6%B1%82%E5%9B%BE%E4%B8%8A%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%92%8C%E8%B7%AF%E5%BE%84%E7%9A%84%E8%AF%81%E6%98%8E/</url>
    <content><![CDATA[<p>还记得 OI 时期有一道典的不能再典的题目：给一张图，求一条从 $s$ 到 $t$ 的最大异或和的路径。</p>
<p>一个很典的结论是：跑一棵生成树，然后把这棵生成树上的环全部拿下来做个线性基，然后用任意一条 $s\to t$ 的路径丢进线性基里求最大值。</p>
<p>之前一直不知道怎么证明。</p>
<p>现在来证明一手：</p>
<p>不妨假设图中只有一个联通图。</p>
<p>可以发现，答案路径和随便一条路径的对称差满足每个点的度数都为  $0$ ，我们不妨把所有满足所有点度数为 $0$ 的边集集中到一个集合 $S$ 。</p>
<p>显然，不仅路径的对称差属于 $S$ ，$S$ 的任意一个元素都显然可以称为路径的对称差，因此，任意一条路径的异或和，和答案的异或值，可以且仅可以是 $S$ 中某个元素的异或值。</p>
<p>然后在这个集合上定义一种类似异或的运算：对应两个集合 $X,Y$ ，这种运算的返回结果为：$(X\cup Y)\setminus(X\cap Y)$ ，下面直接称这种运算为异或。</p>
<p>显然这个运算是封闭的（即结果还在这个集合内），显然这个结构能够像线性基一样定义基（把存在或不存在看成 $0/1$ 就可以直接看成线性基了），如果能够证明基的大小是 $m-(n-1)$ ，那么这个问题就解决了。</p>
<p>考虑生成树用到的边集 $E_1$ ，那么显然 $E\setminus E_1$ 中的每个元素都会生成一个环，这下环构成的集合我们称为 $S’$ ，显然 $S’\subset S$ ，且 $S’$ 线性无关，现在我们证明这个组合能够表示出 $S$ 就行了。</p>
<p>对于任意一个 $S$ 的元素 $L$，对于 $L$ 中非 $E_1$ 的元素，我们将他们拉出来异或，得到元素 $L’$ ，显然 $L,L’$ 在 $E\setminus  E_1$ 的部分是相同的，而在 $E_1$ 的部分，显然也能根据树的结构以及度数都为 $0$ 这一性质证明是相同的，这样，就构造性的证明了 $L’=L$ ，因此 $S’$ 就是 $S$ 的一组基。</p>
<p>证毕。</p>
<p>说起来，现在用异或的角度观察图的结构发现，图的结构其实和向量空间很像，不过只有一个运算。</p>
<p>同时从拟阵的角度来看，图拟阵和有限的向量空间都是拟阵。</p>
<p>太神奇了，可惜碍于我浅薄的知识面，无法看见更加深层次的联系，实在可惜。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>楼房重建</title>
    <url>/2024/03/20/%E6%A5%BC%E6%88%BF%E9%87%8D%E5%BB%BA/</url>
    <content><![CDATA[<p>题目链接：<a href="https://www.luogu.com.cn/problem/P4198">https://www.luogu.com.cn/problem/P4198</a></p>
<p>题目大意：维护有多少个不同的前缀最大值（相同数值但是位置更靠后的认为更大且两数不同，即认为每个数字加上与位置成正比的浮动）</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>非常经典的题目，众所周知，信息学有一类题目的出题方法就是打破常规。</p>
<p>这道题目就是个经典的打破常规的题目，当然你也可以从别的角度去看他。</p>
<p>正常的线段树 updata 都是 $O(1)$ 的，但是这道题目的 updata 是 $\log$ 的。</p>
<p>更详细的来说，维护这么一个函数 $g(x,k)$ ，能够维护 $x$ 所管理的区间中 $\ge k$ 的不同前缀最大值个数。</p>
<p>这个函数可以 $\log$ ，当左区间的最大值 $&lt;k$ ，那么直接去右区间，左区间贡献为 $0$ 。否则，说明考虑左区间的话，对右区间的不同前缀最大值没有影响，直接去左区间就行了，而右区间的贡献就是 $x$ 的不同前缀最大值个数，减去左儿子的。（满足可减性）</p>
<p>用这个函数可以在 $\log$ 的时间轻松实现 updata ，这样就可以在 $O(\log^2)$ 的时间解决这个问题。</p>
<p>显然，这个做法还能轻松实现区间不同的前缀最大值个数。</p>
<p>时间复杂度： $O(n+q\log^2n)$ 。</p>
<p>空间复杂度： $O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NN=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fac</span>&#123;LL a,b;&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(Fac x,Fac y)&#123;<span class="keyword">return</span> x.a*y.b&lt;x.b*y.a;&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;=(Fac x,Fac y)&#123;<span class="keyword">return</span> !(y&lt;x);&#125;</span><br><span class="line">Fac a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> lc,rc,c;</span><br><span class="line">    Fac mx;</span><br><span class="line">&#125;tr[NN];<span class="type">int</span> len;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findans</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,Fac k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> k&lt;=tr[x].mx &amp;&amp; tr[x].mx.a;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(tr[tr[x].lc].mx&lt;k)<span class="keyword">return</span> <span class="built_in">findans</span>(tr[x].rc,mid+<span class="number">1</span>,r,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> tr[x].c-tr[tr[x].lc].c+<span class="built_in">findans</span>(tr[x].lc,l,mid,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> mid,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(tr[x].lc &amp;&amp; tr[x].rc);</span><br><span class="line">    tr[x].mx=<span class="built_in">max</span>(tr[tr[x].lc].mx,tr[tr[x].rc].mx);</span><br><span class="line">    tr[x].c=tr[tr[x].lc].c+<span class="built_in">findans</span>(tr[x].rc,mid+<span class="number">1</span>,r,tr[tr[x].lc].mx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bt</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=++len;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        tr[x].lc=<span class="built_in">bt</span>(l,mid);</span><br><span class="line">        tr[x].rc=<span class="built_in">bt</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="built_in">updata</span>(x,l,mid,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> tr[x].mx=a[l];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> id,Fac k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        tr[x].mx=k;</span><br><span class="line">        tr[x].c=k.a&gt;<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(id&lt;=mid)<span class="built_in">change</span>(tr[x].lc,l,mid,id,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(tr[x].rc,mid+<span class="number">1</span>,r,id,k);</span><br><span class="line">    <span class="built_in">updata</span>(x,l,mid,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i]=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">bt</span>(<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        a[x]=&#123;y,x&#125;;</span><br><span class="line">        <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,x,a[x]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tr[<span class="number">1</span>].c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这个问题还能扩展。</p>
<p>思考一下，假如维护的信息不满足可减性怎么办呢？</p>
<p>答案是每个点不维护区间的答案，而是维护在考虑左区间的情况下右区间的贡献即可。</p>
<p>这个方法又有个别名，叫兔队线段树。</p>
<p>原链接在这：<a href="https://www.cnblogs.com/PinkRabbit/p/Segment-Tree-and-Prefix-Maximums.html">https://www.cnblogs.com/PinkRabbit/p/Segment-Tree-and-Prefix-Maximums.html</a></p>
<p>一道练习题在这：<a href="https://codeforces.com/contest/671/problem/E">https://codeforces.com/contest/671/problem/E</a></p>
<p>具体做法看原链接吧，我感觉粉兔已经说的很明白了。<del>其实是因为我懒</del></p>
</div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>经典问题</tag>
      </tags>
  </entry>
  <entry>
    <title>插值法学习笔记</title>
    <url>/2025/02/05/%E6%8F%92%E5%80%BC%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h1><p>告诉你一个函数会经过 $n$ 个点（$n$个点各不相同），然后让你计算其余几个位置的取值。（应该吧，个人理解）</p>
<p>一般情况下可能会用在一些数据统计中函数的拟合。（不然为什么会有这么多乱七八糟的拟合啊QAQ）</p>
<p>当然，这里主要涉及的是多项式插值，即利用经过这$n$个点的最高次项次数小于$n$的关于$x$的那个多项式，通过代入或者其他方法求出这几个位置的取值。</p>
<p>当然，这里给出一道模板题，在拉格朗日插值和牛顿插值时就是用这个模板题的。</p>
<p><a href="https://www.luogu.com.cn/problem/P4781">模板题</a></p>
<p>当然，这种题目暴力用高斯消元也是能做的，可惜A不了，毕竟时间复杂度时$O(n^3)$</p>
<p>下文都认为给出的是$n+1$个点，点的标号从$0$开始，同时设第$k$个点为$(x_{k},y_{k})$。</p>
<h1 id="拉格朗日插值法"><a href="#拉格朗日插值法" class="headerlink" title="拉格朗日插值法"></a>拉格朗日插值法</h1><h2 id="普通拉格朗日插值法"><a href="#普通拉格朗日插值法" class="headerlink" title="普通拉格朗日插值法"></a>普通拉格朗日插值法</h2><p>观察模板题和高斯消元，你会发现我们把这个多项式解出来真的太浪费啦。</p>
<p>有没有不用求出多项式也能求值的方法呢？</p>
<p>有！</p>
<p>拉格朗日发表了这么一个方法：</p>
<p>$L(x)=\sum\limits_{i=0}^nℓ_{i}(x)y_{i}$</p>
<p>其中$ℓ_{i}(x)$叫 拉格朗日基本多项式 ，$L(n)$叫 拉格朗日插值多项式 。</p>
<p>$ℓ_{i}(x)=\prod\limits_{j=0,j≠i}^n\frac{(x-x_{j})}{(x_{i}-x_{j})}$</p>
<p>这个多项式有个非常NB的性质（其实也非常显然）</p>
<p>就是$ℓ_{i}(x)$在$x_{j}(j≠i)$处为$0$，在$x_{i}$处为$1$。</p>
<p>那么显然，$L(x)$经过这$n$个点。</p>
<p>这样，我们就只需要把$k$代入，就可以在$O(n^2)$的时间内求解了。</p>
<p>显然，我们节省的是求出这个多项式的时间。</p>
<p>当然，可以证明的是，这个拉格朗日插值多项式是唯一一个次数≤$n$的经过这$n+1$个点的多项式。</p>
<h3 id="唯一性"><a href="#唯一性" class="headerlink" title="唯一性"></a>唯一性</h3><p>假设存在两个$n$次多项式，都经过这$n+1$个点，假设这两个多项式为$P_1,P_2$</p>
<p>$P_3=P_2-P_1$</p>
<p>那么$P_3$显然$≠0$。</p>
<p>而且因为都经过$n+1$个点，所以有$n+1$个根，所以$P_3$的次数为$n$。</p>
<p>而且可以写成</p>
<p>那么$P_{3}$可以写成$k\prod\limits_{i=0}^n(x-x_i)$</p>
<p>但是这样次数是$n+1$的，显然不对，矛盾，证毕。</p>
<p>所以最多存在这样唯一一个多项式。</p>
<h3 id="存在性"><a href="#存在性" class="headerlink" title="存在性"></a>存在性</h3><p>首先，不一定存在次数为 $n$ 的多项式，举个例子：</p>
<p>$(1,1),(2,2),(3,3)$就不能被一个二次方程经过。</p>
<p>当然，能经过这$n+1$个点的也不一定要是个次数大于$0$的多项式，比如你给$n+1$个$y$值相等的点，怎么可能存在一个$n$次多项式能够经过$n+1$个$y$值相同的点啊（因为这和一个多项式能有$n+1$个点的命题是等价的，这个命题先让错误，不然可以写成$(x-x_{i})$的形式，证明这个形式次数大于$n$）。</p>
<p>所以下面假定至少存在两个点 $y$ 值不同。</p>
<p>在这个条件下，我们可以证明$L(x)$是一个次数大于$0$的多项式。</p>
<p>我们假设存在一组$a_0,a_1,a_2,…a_{n+1}$系数，使得：</p>
<p>$P(x)=\sum\limits_{i=0}^na_{i}ℓ(i)=a_{n+1}$</p>
<p>首先，因为$ℓ_{i}(x)$函数只有在$x_{i}$处为$1$，其余$x_{j}$处都是为$0$的，所以显然$P(x_{i})=a_{i}$，但是呢，这个函数的值又是恒定的，所以$a_{0}=a_{1}=a_{2}=….=a_{n+1}$。</p>
<p>又因为$y_{i}$并不相同，所以证毕。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>当然，这道题目我还是有🐎代码的。</p>
<p>时间复杂度$O(n^2)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  N  2100</span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="type">long</span>  <span class="type">long</span>  LL;</span><br><span class="line"><span class="type">const</span>  LL  mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  LL  <span class="title">ksm</span><span class="params">(LL  x,LL  y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	x%=mod;</span><br><span class="line">	LL  ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(y)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(y&amp;<span class="number">1</span>)ans=ans*x%mod;</span><br><span class="line">		x=x*x%mod;y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>  ans;</span><br><span class="line">&#125;</span><br><span class="line">LL  n,k;</span><br><span class="line">LL  xx[N],yy[N];</span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">calc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL  ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		LL  shit=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  j=<span class="number">0</span>;j&lt;=n;j++)<span class="keyword">if</span>(i!=j)shit=(k-xx[j]+mod)*<span class="built_in">ksm</span>(xx[i]-xx[j]+mod,mod<span class="number">-2</span>)%mod*shit%mod;</span><br><span class="line">		ans=(shit*yy[i]+ans)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;k);n--;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">0</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;xx[i],&amp;yy[i]);</span><br><span class="line">	<span class="built_in">calc</span>();</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这样🐎是$O(n^2\log{n})$的，改进的方法也比较简单，分母乘起来最后求逆元就行了。</p>
<p>这样就可以到严格的$O(n^2)$了。</p>
<h3 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h3><p>这里直接照搬<a href="https://www.cnblogs.com/ECJTUACM-873284962/p/6833391.html的，因为我自己根本就不了解插值，OI中也基本上不会去处理数据拟合，下面是OI的貌似也不太需要的亚子。">https://www.cnblogs.com/ECJTUACM-873284962/p/6833391.html的，因为我自己根本就不了解插值，OI中也基本上不会去处理数据拟合，下面是OI的貌似也不太需要的亚子。</a></p>
<p>拉格朗日插值法的公式结构整齐紧凑，在理论分析中十分方便，然而在计算中，当插值点增加或减少一个时，所对应的基本多项式就需要全部重新计算，于是整个公式都会变化，非常繁琐。这时可以用重心拉格朗日插值法或牛顿插值法来代替。此外，当插值点比较多的时候，拉格朗日插值多项式的次数可能会很高，因此具有数值不稳定的特点，也就是说尽管在已知的几个点取到给定的数值，但在附近却会和“实际上”的值之间有很大的偏差（如右下图）。这类现象也被称为龙格现象，解决的办法是分段用较低次数的插值多项式。</p>
<h3 id="连续情况"><a href="#连续情况" class="headerlink" title="连续情况"></a>连续情况</h3><p>当然，在给定的取值是连续的情况下（即等差数列），可以做到$O(n)$的插值。（当然，前提是你得花$n\log{n}$检验其是否是等差数列，当然，有时候是已知条件）</p>
<p>你可以通过函数的缩放，把$x$转变成：$x_{i}=i$的情况。</p>
<p>至于怎么做，照搬你谷日报：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/aee6b9c74bffe68289f482c96cbf6dd2.png" alt="我们可以用"><br>而且，如果是在模运算的情况下，只要$O(n)$预处理逆元，也一样可以办到$O(n)$。</p>
<p>代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//你谷日报的代码</span></span><br><span class="line"><span class="comment">//当x_i=i时求L_n(k) </span></span><br><span class="line"><span class="type">double</span> L_n_k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">if</span> ((n-i)%<span class="number">2</span>) L_n_k+=y[i]*((pre[i<span class="number">-1</span>]*suf[i+<span class="number">1</span>])/(-fac[i]*fac[n-i]));</span><br><span class="line">    <span class="keyword">else</span> L_n_k+=y[i]*((pre[i<span class="number">-1</span>]*suf[i+<span class="number">1</span>])/(fac[i]*fac[n-i]));</span><br></pre></td></tr></table></figure></p>
<h2 id="重心型拉格朗日插值法"><a href="#重心型拉格朗日插值法" class="headerlink" title="重心型拉格朗日插值法"></a>重心型拉格朗日插值法</h2><h3 id="Ⅰ型"><a href="#Ⅰ型" class="headerlink" title="Ⅰ型"></a>Ⅰ型</h3><p>总所周知，普通拉格朗日插值法在新增加一个点的时候就需要重新$O(n^2)$计算一下。（雾</p>
<p>不是，为什么啊(・∀・(・∀・(・∀・*)，难道不是只要把$ℓ_{i}(x)$用数组存起来，计算不也是轻轻松松的事吗，当然，如果不用模运算的话时间复杂度是$O(n)$，如果要用模运算，计算逆元的时间就比较久了，会到达$O(n\log{n})$。</p>
<p>如果是要另外求个点，求先把分子求出来，然后不断逆元乘法也能解决，复杂度跟上面同理。</p>
<p>为什么要$O(n^2)$。<del>不过我没有去打代码验证</del></p>
<p>但是仔细想想上述的做法如果处理不好还是有一定弊端的，如果要另外求个点，而且是浮点数运算的话，这种做法可能掉精比较厉害，严重的可能精度直接起飞了，不过一般去到$10^3$一般也会加$\mod{}$运算吧，不过也很好解决，只要处理出现在分子和新的分子的比值再乘，那么掉精问题估计也就没有那么严重了。</p>
<p>额，认真的讲一下你谷博客中的$Ⅰ$型吧。</p>
<p>如果我们改变一下上述的式子：</p>
<p>$L(n)=\sum\limits_{i=0}^ny_{i}\frac{\prod\limits_{j=0}^n(x-x_{i})}{(x-x_{i})\prod\limits_{j=0,i≠j}^n(x_{i}-x_{j})}$</p>
<p>当然，这样插值的前提是要求$x≠x_{i}$，否则式子就爆炸了啊。</p>
<p>设$ℓ(x)=\prod\limits_{i=0}^n(x-x_{i}),w_{i}=\frac{y_{i}}{\prod\limits_{j=0,i≠j}^n(x_{i}-x_{j})}$</p>
<p>那么$L(n)=ℓ(x)\sum\limits_{i=0}^n\frac{w_{i}}{(x-x_{i})}$</p>
<p>其中$w_{i}$叫做重心权。</p>
<p>同样的，这个可以支持$O(n)$撤销点，加入点。</p>
<p>同时也支持$O(n)$求另外一个点。</p>
<p>但是如果在模运算下，这些运算的复杂度统统都是$O(n\log{n})$的，我是真的没有找到这个东西到底有什么用，而且如果在非模运算下，这个做法求新的$f(k)$好像更加的容易掉精…，而且补救方法我也没有想到，除非直接像普通的那样维护，把$ℓ(x)$乘进$\sum$里面同时维护，好像就不太需要担心掉精问题了。</p>
<p>可能这一块内容就是为引出下一块内容准备的吧QAQ。</p>
<p>Ⅰ型具有向后稳定性。</p>
<h3 id="Ⅱ型"><a href="#Ⅱ型" class="headerlink" title="Ⅱ型"></a>Ⅱ型</h3><p>我们插值一下$f(x)=1$：</p>
<p>$f(x)=ℓ(x)\sum\limits_{i=0}^n\frac{w_{i}}{(x-x_{i})}$</p>
<p>然后用$L(x)$除$f(x)$。</p>
<p>$L(x)=\frac{\sum\limits_{i=0}^ny_{i}\frac{w_{i}}{(x-x_{i})}}{\sum\limits_{i=0}^n\frac{w_{i}}{(x-x_{i})}}$</p>
<p>就得到了Ⅱ型。</p>
<p>当然，分母一般情况下是不为$0$的，同理也是要求$k≠x_{i}$</p>
<p>$f(x)=ℓ(x)\sum\limits_{i=0}^n\frac{w_{i}}{(x-x_{i})}=1$</p>
<p>所以$\sum\limits_{i=0}^n\frac{w_{i}}{(x-x_{i})}$是绝对不为 $0$ 的。</p>
<p>可以发现，这个式子不用去计算$ℓ(x)$，计算也是比较方便，可以说是一个优势。</p>
<p>它的另一个优势是，结合切比雪夫节点（$x_{i}=cos(\frac{(2i+1)\pi}{2(n+1)}),i∈[0,n]∩Z$）进行插值的话，可以很好地模拟给定的函数，使得插值点个数趋于无穷时，最大偏差趋于零。同时，重心拉格朗日插值结合切比雪夫节点进行插值可以达到极佳的数值稳定性。（这段话来自<a href="https://www.cnblogs.com/ECJTUACM-873284962/p/6833391.html）">https://www.cnblogs.com/ECJTUACM-873284962/p/6833391.html）</a></p>
<p>Ⅱ型具有向前稳定性，并且勒贝格常数很小。</p>
<p>个人认为，复杂度其实也是类似$Ⅰ$型，但是在浮点数误差下，这个貌似更难去处理误差，只能硬生生的维护重心权$w_{i}$，但是在$n$去到较大级别时，$w_{i}$要么太大，要么太小，都是难伺候的主啊，特别容易产生较大的精度误差，所以我也是没有找到这个的作用在哪。。。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在OI中感觉这三种类型都差不多，其实，那些向前稳定和向后稳定我都不知道是什么，阿巴QAQ，OI中应该不会涉及这么一些东西。（上面那些专业术语都是看别人博客的QAQ）</p>
<p>而且这三种类型在OI中应该可以算是等价的了。</p>
<p>我还是用普通型的吧，告辞。</p>
<h1 id="牛顿插值"><a href="#牛顿插值" class="headerlink" title="牛顿插值"></a>牛顿插值</h1><p>差商是什么？</p>
<p>准确定义我反复读了三遍也没有看懂定义在阿巴什么，但是这里给出下面会用到的式子定义。</p>
<p>设$f[x_0,x_1,…x_k]$为$f(x)$的$k$阶差商。（所以我觉得 $k$ 阶差商应该是有很多值的）</p>
<p>定义：$f[x_0]=f(x_0)$<br>$f[x_{0},x_{1}…,x_{k}]=\frac{f[x_{1},x_{2}…,x_{k}]-f[x_0,x_1,x_2…,x_{k-1}]}{x_{k}-x_{0}}$</p>
<p>同时要求$x_{i}≠x_j(i≠j)$（其实你可以发现如果把$k$阶差商全部展开成$0$阶差商并且不通分约分合并，你会发现对于任意的 $(x_{i}-x_{j})$ ，存在 $k∈${$1,-1$} 使得 $k(x_i-x_j)$ 存在在某个分数的分母）。</p>
<p>那么$f(x)=f[x]$</p>
<p>$\frac{f[x]-f[x_{0}]}{x-x_0}=f[x,x_0]$</p>
<p>$f[x]=(x-x_0)f[x,x_0]+f[x_0]$</p>
<p>代回原式：$f(x)=f[x_0]+(x-x_0)f[x,x_0]$</p>
<p>由于计算$f[x,x_0]$仍然需要我们计算$f(x)$的值，所以我们继续像刚才一样展开：</p>
<p>$f[x,x_0]=(x-x_1)f[x,x_0,x_1]+f[x_0,x_1]$<br>$f[x,x_0,x_1]=(x-x_2)f[x,x_0,x_1,x_2]+f[x_0,x_1,x_2]$<br>…</p>
<p>然后不断的代回原式，直到出现$f[x,x_0,x_1,x_2,…,x_{n+1}]$，此时停止展开，式子为：</p>
<p>$f(x)=f[x,x_0,x_2,…,x_{n+1}]\prod\limits_{j=0}^{n}(x-x_i)+\sum\limits_{i=0}^nf[x_0,x_1,x_2,…,x_i]\prod\limits_{j=0}^{i-1}(x-x_i)$</p>
<p>然后我们设$R_n(x)=f[x,x_0,x_2,…,x_{n+1}]\prod\limits_{j=0}^{n}(x-x_i),N_{n}(x)=\sum\limits_{i=0}^nf[x_0,x_1,x_2,…,x_i]\prod\limits_{j=0}^{i-1}(x-x_i)$</p>
<p>那么$f(x)=N_{n}(x)+R_{n}(x)$。</p>
<p>其中$N_{n}(x)$为牛顿插值公式，$R_{n}(x)$为插值余项。</p>
<p>而在插值的时候，我们忽略$R_{n}(x)$，用$N_{n}(x)$的值表示$f(x)$</p>
<p>当然，至于正确性吗。</p>
<p>当然，为什么在展开到$f[x,x_0,x_2,…,x_{n+1}]$的时候就停下来了呢？</p>
<p>因为$\prod\limits_{j=0}^{n}(x-x_i)$已经是个$n+1$次数的多项式，已经没有用了，反正我们是用$n$次多项式拟合的，$n+1$次已经超了，直接扔掉。</p>
<p>但是目前的任务是确定$N_{n}(x)$是不是一个经过这$n+1$个点的多项式？（实际上拟合出来的多项式应该是和拉格朗日插值多项式是一模一样的）</p>
<p>当然，其实也特别好证明，因为$R_{n}(x_i)=0$，所以$f(x_{i})=N_{n}(x_{i})$。</p>
<p>就证明完了，所以在求$n$次多项式拟合的时候，其实这两种插值法求出的多项式，我个人认为都没有什么区别好吧。</p>
<p>至于计算，可以直接用递推计算$n$阶差商的值，然后从左往右暴力硬推，处理好一点，应该可以做到空间上的$O(n)$，但是时间上因为要用递推定义式计算，所以还是要$O(n^2)$。</p>
<p>但是呢，这个牛顿插值我个人认为最NB的东西也就在这，就是他同样可以做到$O(n^2)$的时间插出原来多项式的系数，而且是全部系数，只要多项式加乘即可，当然，其实拉格朗日用上多项式除法（都是只用乘除$x+a$，非常的简单）同样可以办到一样的效果，其实这两个也没什么区别啦QMQ。</p>
<p>当然，比较鸡肋的是，如果你不花$O(n^2)$的空间记录下所有差商的信息，你会发现添点你做起来跟掐了 * 一样难搞，我个人认为搞不了，因为新的差商那也是真的难计算，当然，计算一个新的$f(k)$就只需要记录系数就行了，这个推起来还是挺简单的好吧。</p>
<p>当然，在牛顿插值中如果新增了一个点，那么只会增加一个项，这或许是优点，但是这个项的系数很难计算啊。</p>
<p>当然，其实还是有方法的，这个就要涉及到差商的通项公式了，这样只要记录通项公式中的分母，一样可以做到$O(n)$计算猛如虎，求新的点值在模意义下可以到达$O(n)$，只要你$O(n)$记录系数，这个做法最妙的地方估计就是$x$不在分母位置，不用计算跟$x$有关的逆元，不过在模意义下，添加新点的代价依旧是$O(n\log{n})$，没什么好说的。</p>
<p>但是呢，虽然新的点值可以到达$O(n)$，但是与之相对的，如果是浮点数运算，在规模较大的情况下，系数的值可能会偏小，导致误差高涨，总之就是误差问题，如果不担心误差随便用好吧。</p>
<p>当然，扩展一下，这里介绍一下差商的性质。</p>
<h2 id="差商的性质"><a href="#差商的性质" class="headerlink" title="差商的性质"></a>差商的性质</h2><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>$f[x_{0},x_1,x_2,x_3…,x_n]=\sum\limits_{j=0}^k\frac{f(x_j)}{\prod\limits_{i=0,i≠j}^k(x_{j}-x_i)}$</p>
<p>证明：</p>
<p>数学归纳法证明，当$k=0$时，显然成立。</p>
<p>当$k&gt;0$时。</p>
<p>$\frac{\sum\limits_{j=1}^{k+1}\frac{f(x_j)}{\prod\limits_{i=1,i≠j}^{n+1}(x_{j}-x_i)}-\sum\limits_{j=0}^k\frac{f(x_j)}{\prod\limits_{i=0,i≠j}^k(x_{j}-x_i)}}{(x_{k+1}-x_0)}$</p>
<p>对于$j=k+1$，分母乘$(x_{k+1}-x_0)$直接变成$\frac{f(x_{k+1})}{\prod\limits_{i=0}^{n}(x_{k+1}-x_i)}$</p>
<p>对于$j=0$，分母乘$(x_{k+1}-x_0)$，可以把负号和这个合并，变成$(x_{0}-x_{k+1})$，于是和$k+1$一样，变成了$k+1$阶差商中应该有的样子。</p>
<p>对于$j=[1,k]∩Z$</p>
<p>$\frac{f(x_j)}{\prod\limits_{i=1,i≠j}^{n+1}(x_{j}-x_i)}-\frac{f(x_j)}{\prod\limits_{i=0,i≠j}^{n}(x_{j}-x_i)}=\frac{x_j(x_{k+1}-x_0)}{\prod\limits_{i=0,i≠j}^{n+1}(x_{j}-x_i)}$</p>
<p>刚好除去$(x_{k+1}-x_0)$，同理也变成$k+1$阶差商的样子，归纳法证明完毕。</p>
<p>这个式子可以说明顺序在差商中是没有用的，差商具有对称性。</p>
<p>当然，我这里给出一个我认为正确的另外一种差商的计算式：</p>
<p>定义 $c(A)$ 为这个集合的大小，集合 $A$ 中的元素都是实数，如果集合$A,B$大小相同，且$A,B$中只有一个元素不同，那么$A-B=x$当且仅当$x∈A且x∉B$。（这里是我个人定义，请不要带到这篇博客以外的地方使用）</p>
<p>那么 $f[A]$ 为 $c(A)-1$ 阶差商，定义$A_1,A_2$为$A$的两个不同的大小为$c(A)-1$的子集，那么 $f[A]=\frac{f[A_1]-f[A_2]}{(A_1-A_2)-(A_2-A_1)}$ </p>
<p><del>其实就是把定义式利用顺序不影响结果这一条结论改了一下而已QMQ</del></p>
<h3 id="一个我不知道是什么的导数性质"><a href="#一个我不知道是什么的导数性质" class="headerlink" title="一个我不知道是什么的导数性质"></a>一个我不知道是什么的导数性质</h3><p>对于$f(x)$的$k$阶差商，如果一个区间$[a,b]$满足$x_{i}(0≤i≤k)∈[a,b]$，且$[a,b]$存在$k$阶导数，那么存在一个$t∈[a,b]$，满足：</p>
<p>$f[x_0,x_1,x_2,x_3…,x_t]=\frac{f^{(k)}(t)}{k!}$</p>
<p>至于证明，学完微积分补，好吧。</p>
<p>当然，证明文档的链接放在参考文献中了，可以自行消化。</p>
<p>用处吗，不知道，就当扩展眼界了。</p>
<h2 id="等距节点的牛顿插值"><a href="#等距节点的牛顿插值" class="headerlink" title="等距节点的牛顿插值"></a>等距节点的牛顿插值</h2><p>看这个也就图一乐好吧。</p>
<p>插值，其中$x_{i}-x_{i-1}(i&gt;0)$是个定值，我们设其为$h$。</p>
<p>这个东西貌似也是只要根据等距的性质来，基本也不会有什么问题，不过如果你直接把其的节点缩放成$x_{i}=i$，岂不美哉，这样就更加好处理了啊QMQ。</p>
<p>定义差分：<br>一阶前向差分：$△f_{k}=f_{k+1}-f_{k},k=0,1,2,…,n-1$<br>$t$阶前向差分：$△^tf_{k}=△^{t-1}f_{k+1}-△^{t-1}f_{k}$</p>
<p>一阶后向差分：$∇f_{k}=f_{k}-f_{k-1},k=0,1,2,…,n-1$<br>$t$阶后向差分：$∇^tf_{k}=∇^{t-1}f_{k}-∇^{t-1}f_{k-1}$</p>
<h3 id="差分公式"><a href="#差分公式" class="headerlink" title="差分公式"></a>差分公式</h3><p>差分公式：<br>$△^tf_{k}=\sum\limits_{i=0}^t(-1)^iC_{t}^if(k+t-i)$<br>$∇^tf_{k}=\sum\limits_{i=0}^t(-1)^iC_{t}^if(t-i)$</p>
<p><del>可能写错了</del></p>
<p>证明的话也是非常的简单，这里证明前向差分，后向差分类似证明。</p>
<p>回归到杨辉三角形：<br>$△^tf_{k}$<br>$△^{t-1}f_{k+1}$ $△^{t-1}f_{k}$<br>$△^{t-2}f_{k+2}$ $△^{t-2}f_{k+1}$ $△^{t-2}f_{k}$<br>…</p>
<p>其实对于$f(i)$的系数就是所有从$△^tf_{k}$到达$f(i)$的路径方案的权值和。</p>
<p>那么一个路径方案的权值是多少呢？</p>
<p>一个路径从起点出发，权值为$1$，如果往下走，乘$1$，往右下走，乘$-1$，最终得到的值为此方案的权值，又发现，往右下走列数$+1$，所以方案的权值大小只与终点列数相关。</p>
<p>所以所有从$△^tf_{k}$到达$f(i)$的路径方案的权值都是一样的，要么$1$，要么$-1$，显然，为$(-1)^{t+k-i}$。</p>
<p>至于系数，你可以发现，如果把每个值的系数算成绝对值，这就是一个活生生的杨辉三角形啊。</p>
<p>得证。</p>
<h3 id="差商与差分的关系"><a href="#差商与差分的关系" class="headerlink" title="差商与差分的关系"></a>差商与差分的关系</h3><p>等距节点差商与差分的关系：</p>
<p>那么有：</p>
<p>$f[x_0,x_{1},…,x_{m}]=\frac{△^mf_0}{m!h^m}=\frac{∇^mf_m}{m!h^m}$</p>
<p>至于证明，也是非常的简单，代入就可以轻松证明（这里证明前向差分，后向不证明了，类似）：</p>
<p>计算对于$f(x_{i})$的系数。</p>
<p>那么值就等于：$\frac{(-1)^{m-i}C_{m}^if(x_{i})}{m!h^m}$</p>
<p>对比一下$\frac{f(x_i)}{\prod\limits_{j=0,i≠j}^m(x_i-x_j)}=\frac{f(x_i)}{h^mi!(m-i)!*(-1)^{m-i}}$</p>
<p>整理一下就发现两者一模一样。</p>
<h3 id="牛顿前向插值公式"><a href="#牛顿前向插值公式" class="headerlink" title="牛顿前向插值公式"></a>牛顿前向插值公式</h3><p>$x_{i}=x_{0}+ih$</p>
<p>设$x=x_0+th$（在模运算中，可以通过同余方程得到，在浮点数运算中，直接除法得到$t$）</p>
<p>所以设$w_{i}(x)=\prod\limits_{j=0}^{i-1}(x-x_j)=\prod\limits_{j=0}^{i-1}(t-j)h=h^i\prod\limits_{j=0}^{i-1}(t-j)$</p>
<p>插值公式：<br>$N_{n}(x)=f[x_0]+\sum\limits_{i=1}^nf[x_0,x_1…,x_i]w_{i}(x)$<br>$N_{n}(x_0+th)=f[x_0]+\sum\limits_{i=1}^n[\frac{△^if_{0}}{i!h^i}h^i\prod\limits_{j=0}^{i-1}(t-j)]=f[x_0]+\sum\limits_{i=1}^n[\frac{△^if_{0}}{i!}\prod\limits_{j=0}^{i-1}(t-j)]$</p>
<p>貌似计算还是$O(n^2)$的，额，那好像还是没有太大用处。</p>
<p>插值余项就不算了，当然，后向插值公式也懒得搞了，这些都与OI没有太大关系，扩展到这里其实也就差不多了（其实就是我累了），有兴趣的可以在参考资料中自行进行学习，后续补一下导数性质的证明吧。</p>
<p>至于其余扩展的东西，等我大学无聊有时间学一下吧，现在学这么久与OI无关的东西已经很拖时间了，告辞。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>摘自<a href="https://blog.csdn.net/littlely_ll/article/details/71107092：">https://blog.csdn.net/littlely_ll/article/details/71107092：</a><br>牛顿插值法优缺点<br>牛顿插值法的优点是计算较简单，尤其是增加节点时，计算只增加一项，这是拉格朗日插值无法比的。<br>缺点是仍没有改变拉格朗日的插值曲线在节点处有尖点，不光滑，插值多项式在节点处不可导等缺点。</p>
<p>摘自<a href="https://www.luogu.com.cn/blog/zhang-xu-jia/ji-zhong-cha-zhi-fang-fa-yang-xie">https://www.luogu.com.cn/blog/zhang-xu-jia/ji-zhong-cha-zhi-fang-fa-yang-xie</a><br>不过它比拉格朗日插值更好的是，它可以插出多项式的系数。当给出的节点等距时，使用差分能达到更优的效果，其计算更加简便。</p>
<p>不过我是真的没有看出来牛顿插值方便计算在哪了？（估计是我傻吧，只会口胡阿巴，望各位大佬指点一下我）</p>
<p>但是模意义求新的点值可以到$O(n)$是真的香好吧。</p>
<h1 id="泰勒插值"><a href="#泰勒插值" class="headerlink" title="泰勒插值"></a>泰勒插值</h1><p>基本就是阿巴过了。</p>
<p>已知函数在$x_0$处的$i$阶导数。$0≤i≤k$</p>
<p>$0$阶导数其实就是它的函数值。</p>
<p>求一个多项式满足这个条件。</p>
<p>泰勒展开随便搞。（当然，其实不用也可以，直接导数的定义也是可以处理的）</p>
<p>$f(x)=f(x_i)+\sum\limits_{i=1}^n\frac{f^{(i)}(x_i)}{i!}(x-x_0)^i$</p>
<p>然后就搞定啦。</p>
<p>时间复杂度：$O(n^2)$</p>
<p>应该是唯一的，且存在的。</p>
<p>你谷奆佬评价：<br>又慢，限制又多。<br>不过有的时候还是比较方便的。</p>
<h1 id="多项式快速插值"><a href="#多项式快速插值" class="headerlink" title="多项式快速插值"></a>多项式快速插值</h1><p>也就是求一个小于$n+1$次的多项式经过给定的$n+1$个点。</p>
<p>要求输出多项式的系数。</p>
<p><a href="https://www.luogu.com.cn/problem/P5158">例题</a></p>
<p>高斯消元$O(n^2)$，牛顿迭代$O(n^2)$，但是还有更快的，想不到吧。</p>
<h2 id="nlog-3做法"><a href="#nlog-3做法" class="headerlink" title="nlog^3做法"></a>nlog^3做法</h2><p>没🐎代码，后面补，现在更多学的是理论的东西。</p>
<p>其实就是分治，但是我不会QAQ。</p>
<p>学还是学得懂，就是比较阿巴。</p>
<p>同分治一样，把点拆分成$0-\left \lfloor \frac{n}{2} \right \rfloor$和$(\left \lfloor \frac{n}{2} \right \rfloor+1)-n$的两个部分，分别命名为点集$X_0,X_1$。</p>
<p>设多项式$A_0(x)$是$X_0$的插值。</p>
<p>设$P(x)=\prod\limits_{i=0}^{\left \lfloor \frac{n}{2} \right \rfloor}(x-x_i)$。</p>
<p>那么我们可以得到：</p>
<p>$A(x)=P(x)A_1(x)+A_0(x)$。</p>
<p>$A_1(x)$是什么，看下去就知道了。</p>
<p>怎么求出$A_1(x)$呢？</p>
<p>$y_i=P(x_i)A_1(x_i)+A_0(x_i)((\left \lfloor \frac{n}{2} \right \rfloor+1)≤i≤n)$</p>
<p>$A_{1}(x_i)=\frac{y_i-A_0(x_i)}{P(x_i)}$</p>
<p>这样，我们就可以得到新的$X_1$，而$A_{1}(x)$是这个新的$X_{1}$的插值多项式。</p>
<p>但是呢，这里有几个细节，首先是关于如何求出新的$X_1$，原文没说，这里推测是用多项式多点求值（但是我不会QAQ），至于求$P(x)$，分治一下就行了，将$(x-a)$左右分成两半再用$NTT$乘起来，时间复杂度都是$O(n\log^2{n})$。</p>
<p>这样就可以完成多项式插值了。</p>
<p>于是就得到了这条式子：</p>
<p>$T(n)=2T(\frac{n}{2})+n\log^2{n}$</p>
<p>然后就可以得到时间复杂度是$O(n\log^3{n})$，常数还有亿点点大。。。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.luogu.com.cn/blog/zhang-xu-jia/ji-zhong-cha-zhi-fang-fa-yang-xie">https://www.luogu.com.cn/blog/zhang-xu-jia/ji-zhong-cha-zhi-fang-fa-yang-xie</a><br>（讲真你谷初中生随便吊打我个高中生QAQ，我到现在都不会微积分）</p>
<p><a href="https://blog.csdn.net/littlely_ll/article/details/71107092">https://blog.csdn.net/littlely_ll/article/details/71107092</a></p>
<p><a href="https://wenku.baidu.com/view/568b7fbb336c1eb91b375df4.html">https://wenku.baidu.com/view/568b7fbb336c1eb91b375df4.html</a></p>
<p>百度百科</p>
<p><a href="https://www.cnblogs.com/ECJTUACM-873284962/p/6833391.html">https://www.cnblogs.com/ECJTUACM-873284962/p/6833391.html</a></p>
<p><a href="https://www.docin.com/p-632016518.html">https://www.docin.com/p-632016518.html</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/66793653">https://zhuanlan.zhihu.com/p/66793653</a></p>
<p>论如何在参考文献一坨的情况下学得一知半解的QAQ。</p>
<p>可恶，欺负我个不会微积分的人QAQ。</p>
<h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><p>补导数证明</p>
<p>补充你谷日报中提到的其余差分。</p>
<p>补充代码</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>插值</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵切割算法学习笔记</title>
    <url>/2025/02/03/%E7%9F%A9%E9%98%B5%E5%88%87%E5%89%B2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://acm.timus.ru/problem.aspx?space=1&amp;num=1147">1147. Shaping Regions @ Timus Online Judge</a></p>
<p>大意：一坨有颜色的矩阵依次覆盖，最后每个颜色有多少种面积。</p>
<p>坑点：矩阵不一定在白布上。</p>
<h1 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h1><p>讲讲做法，对于一个矩阵 $X$ 覆盖在另外一个矩阵 $Y$ 上，我们可以尝试把 $Y$ 没有被覆盖的部分分成好几份。</p>
<p>但是要怎么切割，怎样切割会比较优秀呢？（切的尽量的少）</p>
<p>我们记 $X$ 左下角 $x,y$ 坐标为 $X(x_1)$ 和 $X(y_1)$ ，右上角是 $X(x_2)$ 和 $X(y_2)$ ，$((a,b),(c,d))$为以 $(a,b)$ 为左下角，$(c,d)$ 为右上角的矩阵。</p>
<p>我们不妨考虑 $X$ （红色）和 $Y$ （蓝色）在 $x$ 轴投影的位置关系：</p>
<p><img src="matrixcut-1.png" alt="matrixcut-1"><br>如果 $X$ 的左边的 $x$ 坐标在 $Y$ 的 $x$ 轴投影内，即：$Y(x_1)&lt;X(x_1)&lt;Y(x_2)$，那么 $Y$ 在 $[Y(x_1),X(x_1)]$ 上的矩阵都没有被覆盖，即：$((Y(x_1),Y(y_{1}),(X(x_1),Y(y_{1}))$ 没有被覆盖，右边同理。</p>
<p>但是还有中间的情况，$X,Y$ 在 $x$ 轴投影重叠部分的上方（红色框住的位置）：这个区间既包括 $Y$ 矩阵，也包括 $X$ 矩阵未被覆盖的部分（可能没有），这个时候分 $y$ 轴讨论就行了。</p>
<p>不难发现，这样在任何情况下都是最优的割法。</p>
<p>给上一份代码，网上抄的，当时学的拿来用了，现在不知道是谁的了QAQ，如果知道是谁的通知一声，我马上标注，放上这份代码的原因是和上面讲的比较符合，比较好理解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,m,n) for(i=m;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rsp(it,s) for(set<span class="string">&lt;int&gt;</span>::iterator it=s.begin();it!=s.end();it++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vi vector<span class="string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pi acos(-1.0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Lson L, mid, rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Rson mid+1, R, rt&lt;&lt;1|1</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">3e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll p,ll q)</span></span>&#123;<span class="keyword">return</span> q==<span class="number">0</span>?p:<span class="built_in">gcd</span>(q,p%q);&#125;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll p,ll q)</span></span>&#123;ll f=<span class="number">1</span>;<span class="keyword">while</span>(q)&#123;<span class="keyword">if</span>(q&amp;<span class="number">1</span>)f=f*p;p=p*p;q&gt;&gt;=<span class="number">1</span>;&#125;<span class="keyword">return</span> f;&#125;</span><br><span class="line"><span class="type">int</span> n,m,k,t,ans[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x1,x2,y1,y2,c;</span><br><span class="line">    <span class="built_in">node</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> _x1,<span class="type">int</span> _x2,<span class="type">int</span> _y1,<span class="type">int</span> _y2,<span class="type">int</span> _c)</span><br><span class="line">    &#123;</span><br><span class="line">        x1=_x1,x2=_x2,y1=_y1,y2=_y2,c=_c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;op[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(node p,<span class="type">int</span> nt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(nt&lt;=k&amp;&amp;((p.x1&gt;=op[nt].x2)||(p.x2&lt;=op[nt].x1)||(p.y1&gt;=op[nt].y2)||(p.y2&lt;=op[nt].y1)))<span class="comment">//如果两个矩阵没有相交，直接进入下一层</span></span><br><span class="line">        nt++;</span><br><span class="line">    <span class="keyword">if</span>(nt&gt;k)<span class="keyword">return</span> (p.x2-p.x1)*(p.y2-p.y1);</span><br><span class="line">    <span class="keyword">if</span>(p.x1&lt;op[nt].x1)</span><br><span class="line">        ans+=<span class="built_in">get</span>(<span class="built_in">node</span>(p.x1,op[nt].x1,p.y1,p.y2,op[nt].c),nt+<span class="number">1</span>),p.x1=op[nt].x1;<span class="comment">//如果左边存在一整个块都没有被覆盖，就切割下来。</span></span><br><span class="line">    <span class="keyword">if</span>(p.x2&gt;op[nt].x2)</span><br><span class="line">        ans+=<span class="built_in">get</span>(<span class="built_in">node</span>(op[nt].x2,p.x2,p.y1,p.y2,op[nt].c),nt+<span class="number">1</span>),p.x2=op[nt].x2;<span class="comment">//如果右边存在一整个块都没有被覆盖，就切割下来。</span></span><br><span class="line">    <span class="keyword">if</span>(p.y1&lt;op[nt].y1)</span><br><span class="line">        ans+=<span class="built_in">get</span>(<span class="built_in">node</span>(p.x1,p.x2,p.y1,op[nt].y1,op[nt].c),nt+<span class="number">1</span>),p.y1=op[nt].y1;<span class="comment">//如果中间下面存在块，切下来</span></span><br><span class="line">    <span class="keyword">if</span>(p.y2&gt;op[nt].y2)</span><br><span class="line">        ans+=<span class="built_in">get</span>(<span class="built_in">node</span>(p.x1,p.x2,op[nt].y2,p.y2,op[nt].c),nt+<span class="number">1</span>),p.y2=op[nt].y2;<span class="comment">//如果中间上面存在块，切下来</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    ans[<span class="number">1</span>]=n*m;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,k)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;op[i].x1,&amp;op[i].y1,&amp;op[i].x2,&amp;op[i].y2,&amp;op[i].c);</span><br><span class="line">    <span class="keyword">for</span>(i=k;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[op[i].c]+=(j=<span class="built_in">get</span>(op[i],i+<span class="number">1</span>));</span><br><span class="line">        ans[<span class="number">1</span>]-=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">rep</span>(i,<span class="number">1</span>,<span class="number">2500</span>)<span class="keyword">if</span>(ans[i])<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,i,ans[i]);</span><br><span class="line">    <span class="comment">//system(&quot;Pause&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这份代码有几个细节可以优化一下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(p.x1&lt;op[nt].x1)</span><br><span class="line">        ans+=<span class="built_in">get</span>(<span class="built_in">node</span>(p.x1,op[nt].x1,p.y1,p.y2,op[nt].c),nt+<span class="number">1</span>),p.x1=op[nt].x1;<span class="comment">//如果左边存在一整个块都没有被覆盖，就切割下来。</span></span><br><span class="line"></span><br><span class="line">这个相当于什么？不就相当于对两个 $x1$ 取 max 吗？</span><br><span class="line"></span><br><span class="line">因此可以化成这样：</span><br><span class="line"></span><br><span class="line">​```cpp</span><br><span class="line"><span class="type">int</span> x=<span class="built_in">max</span>(p.x1,op[nt].x1);</span><br><span class="line"><span class="keyword">if</span>(p.x1&lt;x)</span><br><span class="line">        ans+=<span class="built_in">get</span>(<span class="built_in">node</span>(p.x1,x,p.y1,p.y2,op[nt].c),nt+<span class="number">1</span>);<span class="comment">//如果左边存在一整个块都没有被覆盖，就切割下来。</span></span><br><span class="line"><span class="comment">//然后后面的p.x1全部用x代替。</span></span><br></pre></td></tr></table></figure>
<p>然后，其实四个元都可以如此去做，然后我就自己打了一份代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这份代码其实参考了参考链接中的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x1,y1,x2,y2,co;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">mymin</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&lt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">mymax</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;q)<span class="keyword">return</span> (x2-x1)*(y2-y1);</span><br><span class="line">    <span class="keyword">if</span>(a[k].x1&gt;=x2 || a[k].x2&lt;=x1 || a[k].y1&gt;=y2 || a[k].y2&lt;=y1)<span class="keyword">return</span> <span class="built_in">dfs</span>(x1,y1,x2,y2,k+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> k1=<span class="built_in">mymax</span>(x1,a[k].x1);</span><br><span class="line">    <span class="type">int</span> k2=<span class="built_in">mymin</span>(x2,a[k].x2);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x1&lt;k1)ans+=<span class="built_in">dfs</span>(x1,y1,k1,y2,k+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(k2&lt;x2)ans+=<span class="built_in">dfs</span>(k2,y1,x2,y2,k+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> k3=<span class="built_in">mymax</span>(y1,a[k].y1),k4=<span class="built_in">mymin</span>(y2,a[k].y2);</span><br><span class="line">    <span class="keyword">if</span>(y1&lt;k3)ans+=<span class="built_in">dfs</span>(k1,y1,k2,k3,k+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(k4&lt;y2)ans+=<span class="built_in">dfs</span>(k1,k4,k2,y2,k+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans[<span class="number">2600</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    q++;a[<span class="number">1</span>].x2=n;a[<span class="number">1</span>].y2=m;a[<span class="number">1</span>].co=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=q;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;a[i].x1,&amp;a[i].y1,&amp;a[i].x2,&amp;a[i].y2,&amp;a[i].co);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)ans[a[i].co]+=<span class="built_in">dfs</span>(a[i].x1,a[i].y1,a[i].x2,a[i].y2,i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2500</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[i])<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,i,ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间空间消耗等会说。</p>
<h1 id="另外的做法"><a href="#另外的做法" class="headerlink" title="另外的做法"></a>另外的做法</h1><h2 id="此题另一种矩阵切割的实现方式"><a href="#此题另一种矩阵切割的实现方式" class="headerlink" title="此题另一种矩阵切割的实现方式"></a>此题另一种矩阵切割的实现方式</h2><p>观察就会发现，实际上上面的实现方法，是对一个矩阵，用后面的矩阵对其进行切割，但实际上，我们可以换个角度出发，从可用面积的角度出发，即将背景墙扔进去，从后往前切割，每个矩阵会对背景墙割掉一块，其实这就相当于对每一个矩阵找其没有被后面矩阵覆盖的部分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x1,y1,x2,y2,co;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="type">int</span> ans[<span class="number">2600</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">mymin</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&lt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">mymax</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!k)<span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(a[k].x1&gt;=x2 || a[k].x2&lt;=x1 || a[k].y1&gt;=y2 || a[k].y2&lt;=y1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(x1,y1,x2,y2,k<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k1=<span class="built_in">mymax</span>(x1,a[k].x1);</span><br><span class="line">    <span class="type">int</span> k2=<span class="built_in">mymin</span>(x2,a[k].x2);</span><br><span class="line">    <span class="keyword">if</span>(x1&lt;k1)<span class="built_in">dfs</span>(x1,y1,k1,y2,k<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(k2&lt;x2)<span class="built_in">dfs</span>(k2,y1,x2,y2,k);</span><br><span class="line">    <span class="type">int</span> k3=<span class="built_in">mymax</span>(y1,a[k].y1),k4=<span class="built_in">mymin</span>(y2,a[k].y2);</span><br><span class="line">    <span class="keyword">if</span>(y1&lt;k3)<span class="built_in">dfs</span>(k1,y1,k2,k3,k<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(k4&lt;y2)<span class="built_in">dfs</span>(k1,k4,k2,y2,k<span class="number">-1</span>);</span><br><span class="line">    ans[a[k].co]+=(k2-k1)*(k4-k3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    q++;a[<span class="number">1</span>].x2=n;a[<span class="number">1</span>].y2=m;a[<span class="number">1</span>].co=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=q;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;a[i].x1,&amp;a[i].y1,&amp;a[i].x2,&amp;a[i].y2,&amp;a[i].co);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">10000</span>,<span class="number">10000</span>,q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2500</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[i])<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,i,ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这确实是一个不错的转化思路，从每个矩阵最后在背景板的占地面积出发做题。</p>
<p>关于两种做法的空间以及效率问题，空间上的消耗比较小，空间复杂度 $O(q)$ ，但是时间上的消耗就比较玄学了，这个实现方法封顶是 $O(背景板面积)$ ，而上面的做法封顶应该是 $O(所有矩阵面积)$ ，但是实际远小于这个上限，都可以通过该题。</p>
<p>但是呢，我们来比较一下这两个做法：</p>
<p>不难发现，在小规模下，矩阵之间并未相交多次时，这个实现方法对背景板的切割次数较多，较慢，上面的方法因为相交不多，所以会较快，但实际因为规模小，可能不痛不痒，但是在超大规模下，背景板被占满好几次，那么这个方法要远远快于上面的方法，因为这个方法封顶背景板面积，而上面每个矩阵都要计算每个矩阵对其的影响，因此要慢上不少。</p>
<p>但是在中等的规模的数据下呢，鉴于我比较菜，没有时间<del>没有实力</del>去从理论分析（或者实验分析）其在随机数据下的时间表现，也不知道这两个做法较好的卡法，所以希望如果有读者知道，私信我一下，我会写在博客内。当然，我们还是可以阿巴一下的，不难发现，背景板切割只用对一个矩阵切一次（虽然这种切割比较大型），而上面的做法对每个矩阵都要去用后面矩阵切割一次，理论来讲上面做法应该会更慢一点，而在做此例题也确实如此，上面的方法我改了一下每个矩阵后面矩阵的切割顺序（从后往前改成从前往后），超时了，但是即使不改，其依旧比该方法满了一倍的时间。再阿巴一下卡法，显然，很容易构造出一个使上面做法时间超过这个做法时间的数据（把整个背景板加入到数据中）。因此，这道题目方法的选择，我更推荐这种做法。</p>
<p>当然，矩阵切割本身就是暴力算法，优点就是代码好打，比较灵活，空间占用小，缺点就是时间玄学，因此在使用的时候，应该根据题目，主动去思考常数更加小的实现方法，从而骗到更多的分数或者更快的AC题目。</p>
<h2 id="关于例题线段树做法"><a href="#关于例题线段树做法" class="headerlink" title="关于例题线段树做法"></a>关于例题线段树做法</h2><p>当然，这道题目我一开始的做法是线段树做法，首先离散化，那么 $n,m$ 范围便只剩下了 $2000$ ，接着，类似最早的思考，考虑每个矩阵被其余矩阵覆盖了多少，类似扫描线一样扫过去就行。</p>
<p>时间复杂度：$O(q^2\log{q})$</p>
<p>空间复杂度：$O(q)$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 2100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MM 4100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">mymin</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&lt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">mymax</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line"><span class="type">int</span> be1[M],to1,cn1,cn2,to2,be2[M];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lc,rc;</span><br><span class="line">    <span class="type">int</span> min,minsum,lazy;</span><br><span class="line">&#125;tr[MM];<span class="type">int</span> len;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushlazy</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;tr[x].min+=k;tr[x].lazy+=k;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[tr[x].lc].min&lt;tr[tr[x].rc].min)tr[x].min=tr[tr[x].lc].min,tr[x].minsum=tr[tr[x].lc].minsum;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[tr[x].lc].min&gt;tr[tr[x].rc].min)tr[x].min=tr[tr[x].rc].min,tr[x].minsum=tr[tr[x].rc].minsum;</span><br><span class="line">    <span class="keyword">else</span> tr[x].min=tr[tr[x].rc].min,tr[x].minsum=tr[tr[x].lc].minsum+tr[tr[x].rc].minsum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[x].lazy)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushlazy</span>(tr[x].lc,tr[x].lazy);<span class="built_in">pushlazy</span>(tr[x].rc,tr[x].lazy);</span><br><span class="line">        tr[x].lazy=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bt</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=++len;</span><br><span class="line">    tr[x].min=<span class="number">0</span>;tr[x].minsum=be1[r]-be1[l];tr[x].lazy=<span class="number">0</span>;tr[x].lc=tr[x].rc=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l+<span class="number">1</span>&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        tr[x].lc=len+<span class="number">1</span>;<span class="built_in">bt</span>(l,mid);</span><br><span class="line">        tr[x].rc=len+<span class="number">1</span>;<span class="built_in">bt</span>(mid,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ll,<span class="type">int</span> rr,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==ll &amp;&amp; r==rr)&#123;<span class="built_in">pushlazy</span>(x,k);<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(rr&lt;=mid)<span class="built_in">change</span>(tr[x].lc,l,mid,ll,rr,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mid&lt;=ll)<span class="built_in">change</span>(tr[x].rc,mid,r,ll,rr,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(tr[x].lc,l,mid,ll,mid,k),<span class="built_in">change</span>(tr[x].rc,mid,r,mid,rr,k);</span><br><span class="line">    <span class="built_in">updata</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Query</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x<span class="comment">/*ењЁ[x,x+1]жњџй—ґиї›иЎЊиЇҐж“ЌдЅњ*/</span>,l,r,k,tim<span class="comment">/*и¦†з›–ж—¶й—ґ*/</span>;</span><br><span class="line">&#125;qu[M];<span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp1</span><span class="params">(Query x,Query y)</span></span>&#123;<span class="keyword">return</span> x.x&lt;y.x;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Ver</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x1,y1,x2,y2,co;</span><br><span class="line">&#125;a[M];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *x,val;</span><br><span class="line">&#125;b1[M],b2[M];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp2</span><span class="params">(node x,node y)</span></span>&#123;<span class="keyword">return</span> x.val&lt;y.val;&#125;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> ans[MM];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    q++;a[<span class="number">1</span>].x1=a[<span class="number">1</span>].y1=<span class="number">0</span>;a[<span class="number">1</span>].x2=n;a[<span class="number">1</span>].y2=m;a[<span class="number">1</span>].co=<span class="number">1</span>;</span><br><span class="line">    b1[++to1].x=&amp;a[<span class="number">1</span>].x1;b1[to1].val=a[<span class="number">1</span>].x1;</span><br><span class="line">    b1[++to1].x=&amp;a[<span class="number">1</span>].x2;b1[to1].val=a[<span class="number">1</span>].x2;</span><br><span class="line">    b2[++to2].x=&amp;a[<span class="number">1</span>].y1;b2[to2].val=a[<span class="number">1</span>].y1;</span><br><span class="line">    b2[++to2].x=&amp;a[<span class="number">1</span>].y2;b2[to2].val=a[<span class="number">1</span>].y2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;a[i].x1,&amp;a[i].y1,&amp;a[i].x2,&amp;a[i].y2,&amp;a[i].co);</span><br><span class="line">        b1[++to1].x=&amp;a[i].x1;b1[to1].val=a[i].x1;</span><br><span class="line">        b1[++to1].x=&amp;a[i].x2;b1[to1].val=a[i].x2;</span><br><span class="line">        b2[++to2].x=&amp;a[i].y1;b2[to2].val=a[i].y1;</span><br><span class="line">        b2[++to2].x=&amp;a[i].y2;b2[to2].val=a[i].y2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(b1+<span class="number">1</span>,b1+to1+<span class="number">1</span>,cmp2);</span><br><span class="line">    <span class="built_in">sort</span>(b2+<span class="number">1</span>,b2+to2+<span class="number">1</span>,cmp2);</span><br><span class="line">    *b1[<span class="number">1</span>].x=*b2[<span class="number">1</span>].x=cn1=cn2=<span class="number">1</span>;be1[<span class="number">1</span>]=b1[<span class="number">1</span>].val;be2[<span class="number">1</span>]=b2[<span class="number">1</span>].val;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=to1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b1[i<span class="number">-1</span>].val!=b1[i].val)cn1++,be1[cn1]=b1[i].val;</span><br><span class="line">        <span class="keyword">if</span>(b2[i<span class="number">-1</span>].val!=b2[i].val)cn2++,be2[cn2]=b2[i].val;</span><br><span class="line">        *b1[i].x=cn1;*b2[i].x=cn2; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        qu[++cnt].x=a[i].y1;qu[cnt].l=a[i].x1;qu[cnt].r=a[i].x2;qu[cnt].tim=i;qu[cnt].k=<span class="number">1</span>;</span><br><span class="line">        qu[++cnt].x=a[i].y2;qu[cnt].l=a[i].x1;qu[cnt].r=a[i].x2;qu[cnt].tim=i;qu[cnt].k=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(qu+<span class="number">1</span>,qu+cnt+<span class="number">1</span>,cmp1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[i].x1&lt;a[i].x2)<span class="built_in">bt</span>(a[i].x1,a[i].x2);</span><br><span class="line">        <span class="type">int</span> now=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=a[i].y1;j&lt;a[i].y2;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(now&lt;=cnt &amp;&amp; qu[now].x&lt;=j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(qu[now].tim&gt;i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> l=<span class="built_in">mymax</span>(a[i].x1,qu[now].l),r=<span class="built_in">mymin</span>(a[i].x2,qu[now].r);</span><br><span class="line">                    <span class="keyword">if</span>(l&lt;r)<span class="built_in">change</span>(<span class="number">1</span>,a[i].x1,a[i].x2,l,r,qu[now].k);</span><br><span class="line">                &#125;</span><br><span class="line">                now++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!tr[<span class="number">1</span>].min)ans[a[i].co]+=(be2[j+<span class="number">1</span>]-be2[j])*tr[<span class="number">1</span>].minsum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2500</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[i])<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,i,ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，你也可以用线段树实现矩阵切割第二种方法类似的思路（每个矩阵在背景板的占地面积），但是貌似这样子常数更大。QMQ</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>介绍了矩阵切割算法，一个灵活的、空间小的、代码好打的、好想的、但时间玄学的算法，在范围在千以内的时候可以试着使用一下，万以上就不知道了。（其实我也就用过一次，什么时候可以用还是你们自己去摸索吧。）</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/modiz/article/details/38542749">&lt;模板&gt; 矩形分割_无奈滴微笑-CSDN博客</a></p>
<p><a href="https://www.luogu.com.cn/blog/George-Clus/solution-p6432">题解 P6432 【[USACO3.1]形成的区域 Shaping Regions】 - blog-lhm - 洛谷博客 (luogu.com.cn)</a></p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
  </entry>
  <entry>
    <title>组合计数练习</title>
    <url>/2024/02/01/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="括号序列和折线法"><a href="#括号序列和折线法" class="headerlink" title="括号序列和折线法"></a>括号序列和折线法</h1><p>一个经典的问题：一个括号序列的最长的合法括号子序列有多长。</p>
<h2 id="折线法解决经典问题"><a href="#折线法解决经典问题" class="headerlink" title="折线法解决经典问题"></a>折线法解决经典问题</h2><p>不难发现，每一个左括号，也就是上升的部分，我们总能指定他右边和他同高度的右括号，然后消掉。</p>
<p><img src="1.png" alt=""></p>
<p>所以消到最后，我们总是会得到一条先下降后上升的折线，可以发现，这样子消不会改变整个折线的最低点，所以，<strong>一个指定起终点的折线，其最长的合法括号子序列取决于这条折线的最低点</strong> 。</p>
<p>这也是用折线法解决括号序列问题会非常方便的原因。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>指定起终点，问最低点低于某个高度的折线数量。</p>
<p>对应在括号序列：指定左括号和右括号的数量，限制最长合法括号序列的长度小于某个值。</p>
<p>做法就是折一下就行了。</p>
</li>
<li><p>有多少个折线满足 $(0,0)\to(len,0)$ 且在 $y=0$ 上方，且恰好有 $m$ 个点在 $y$ 轴上。</p>
<p>对应在括号序列：有多少个合法的括号序列满足可以恰好分成 $m-1$ 份，使得满足每一份都是：$(A)$ ，$A$ 是一个合法的括号序列。</p>
<p>做法就是：考虑每次要到 $y=0$ 的那一段就去掉，认为起点是在 $(1,1)$ ，同时整条折线不能碰到 $y=0$ 这条线，则答案等价于从 $(1,1)\to (len-m+1,m-1)$ 的折线数量。（认为起点在 $(1,1)$ 是因为我们要求这条线不能碰到 $y=0$ ）</p>
<p><img src="3.png" alt=""></p>
</li>
</ol>
<h1 id="使用排列计算概率的方法"><a href="#使用排列计算概率的方法" class="headerlink" title="使用排列计算概率的方法"></a>使用排列计算概率的方法</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>有些时候，一些问题会涉及到等概率选择一些剩余的点，并且删除这个点和一些与这个点有关联的点集，然后问关于这个过程的一些概率或者是数量问题，就可以尝试使用这个方法。</p>
<p>这个方法的关键在于：考虑将被删除这个操作看成一个删除标记，只有当一个点被选中，才会被真正的删除，这样每个点恰好被选一次，只不过，如果选中了一个点有删除标记，就重新选（这个点也视作已经被选了，真正删除掉），直到选到没有标记的为止，由于没有标记的点数量不变，所以每个点在各种情况下被选中的概率不变。</p>
<p>形式化的表述就是：对于任意一个排列，其对应的情况为：每个点有被选中当且仅当能删除他的节点都在他后面，而选中的先后顺序就是排列的先后顺序。</p>
<p>则一种情况的概率就是能对应到这种情况的排列的出现概率。</p>
<p>这样，就把计算概率，变成了统计符合条件的排列数量。</p>
<h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>现在有 $n$ 个数字，每次选择一个没被删除的数字，并且删除这个数字的所有倍数，问每个数字被选中的概率。</p>
<p>设 $d(i)$ 为 $i$ 的约数个数，显然答案就是 $\frac{1}{d(i)}$ 。</p>
</li>
<li><p>给定一个 $DAG$ ，每次选择一个没被删除的点，然后删除他能到达的所有点，问期望进行几轮。</p>
<p>期望可以转化为求每个点被选中的概率和，一个点被选中的概率为 $\frac{1}{能到达他的点的数量}$ 。</p>
</li>
<li><p>给定一个数字 $n$ ，令 $n=等概率选择1到n-1中的一个数字$ ，直到 $n\le k$ ，问期望轮数。</p>
<p>同理：可以看成是每个点可以删除所有 $\ge$ 他的点，和上一题基本一样，答案就是所有 $&gt;k$ 的点的经过概率之和。</p>
<p>答案为：$1+\sum\limits_{i=k+1}^{n-1}\frac{1}{i}$ 。</p>
<p>这道题目还有个加强版，但是做法基本一样，讨论一下就行了：<a href="https://codeforces.com/contest/1924/problem/E">Codeforces Round 921 Div.1 E.Paper Cutting Again</a></p>
<p>题目大意：给定 $n*m$ 的纸，每次可以等概率选择 $n-1$ 条整数横线或者 $m-1$ 条整数竖线，剪开然后丢掉下面或者右边的部分，问当面积小于 $k$ 时至多需要多少轮。</p>
<p>$n,m\le 10^{6},2\le k\le 10^{12}$  </p>
</li>
</ol>
<h1 id="图计数"><a href="#图计数" class="headerlink" title="图计数"></a>图计数</h1><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><ol>
<li><p>求 $n$ 个有标号点的无向图的数量。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>容斥原理，枚举 $1$ 号点的连通块大小就行了。</p>
<script type="math/tex; mode=display">f_i=2^{\frac{i(i-1)}{2}}-\sum\limits_{j=1}^{i-1}\binom{i-1}{j-1}*f_{j}*2^{\frac{(i-j)(i-j-1)}{2}}</script><p>时间复杂度：$O(n^2)$ 。</p>
</div></details></li>
<li><p>求 $n$ 个有标号的点的边双联通图的数量。</p>
<details class="toggle" ><summary class="toggle-button" style="">DP做法</summary><div class="toggle-content"><p>方法 1 ：设 $dp[i][j]$ 表示有 $j$ 个点，恰好有 $i$ 个连通块的图的权值和（一个图的权值定义为每个连通块大小的乘积），然后枚举 $1$ 号点所在的边双大小进行容斥。</p>
<p>设 $f_i$ 表示 $i$ 个点的联通块数量， $g_i$ 表示 $i$ 个点的边双联通块数量。</p>
<script type="math/tex; mode=display">g_i=f_i-\sum\limits_{j=1}^{i-1}\binom{i-1}{j-1}*g_{j}*\sum\limits_{k=1}^{i-j}dp[k][i-j]*j^{k}</script><p>方法 2 ：设 $dp[i][j]$ 表示有 $j$ 个点，恰好有 $i$ 个点双连通块且点双之间不连通的图的权值和（一个图的权值定义，为每个点双连通块大小的乘积）。</p>
<p>显然：$dp[i][j]=\sum\limits_{k=1}^{j-(i-1)}dp[i-1][j-k]<em>\binom{j-1}{k-1}</em>k*g_k$ 。</p>
<p>注意到，先固定一个 $j$ ，除了 $dp[1][j]$ 以外的 $dp[i][j]$ 的转移都不依赖 $g_j$ ，所以考虑先处理出 $dp[i][j],(i\ne 1)$ ，然后用容斥算出 $g_j$ ，然后再求 $dp[1][j]$ ，从而完成 $dp[i][j]$ 对所有 $i$ 的转移。</p>
<p>实现上就是 $j$ 从小到达枚举，每一层先对 $i\ne 1$进行转移，再求 $g_j$ ，再求 $dp[1][j]$ 即可。</p>
<p>至于容斥的式子：$g_j=f_j-\sum\limits_{i=2}^{i}dp[i][j]*j^{i-2}$ 。</p>
<p>时间复杂度：$O(n^3)$ 。</p>
<p>方法 $1$ 更加自然，方法 $2$ 主要是感觉 $dp$ 顺序非常的奇妙，所以就记录一下。</p>
</div></details>
</li>
</ol>
<h1 id="一些奇奇怪怪的方法"><a href="#一些奇奇怪怪的方法" class="headerlink" title="一些奇奇怪怪的方法"></a>一些奇奇怪怪的方法</h1><h2 id="必定经过的事件集"><a href="#必定经过的事件集" class="headerlink" title="必定经过的事件集"></a>必定经过的事件集</h2><p>想法来自：</p>
<p><a href="https://www.luogu.com.cn/blog/xuanxuan001/solution-cf1924e">https://www.luogu.com.cn/blog/xuanxuan001/solution-cf1924e</a></p>
<h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>当你想要求一个事件的概率时，可以找一些其他事件，使得这个事件集必然发生，且在这个事件集发生的条件下，这个事件集内的每个事件的发生概率固定，那么就可以知道我们想要的事件的概率。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ol>
<li><p><a href="https://codeforces.com/contest/1924/problem/E">Codeforces Round 921 Div.1 E.Paper Cutting Again</a></p>
<p>题目大意：给定 $n*m$ 的纸，每次可以等概率选择 $n-1$ 条整数横线或者 $m-1$ 条整数竖线，剪开然后丢掉下面或者右边的部分，问当面积小于 $k$ 时至多需要多少轮。</p>
<p>$n,m\le 10^{6},2\le k\le 10^{12}$  </p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>假设纸张为 $(n’,m’)$。</p>
<p>不难想到先转化为 $(n’=x,m’=y):xy\ge k$ 的事件的经过概率之和。</p>
<p>那么经过 $(x,y)$ 的概率有多少呢？</p>
<p>不妨先假设 $m=y$ 。</p>
<p>不难发现，第一次使得 $n’\le x$ 或者 $m’&lt;m$ 的事件集构成了一个必然事件集，且内部的事件都是等概率的。</p>
<p>所以使得 $n’=x,m’=m$ 的概率为：$\frac{1}{x+m-1}$ 。</p>
<p>那么当 $x&lt;n,y&lt;m$ 如何处理？</p>
<p>首先，我们得求得第一次使得 $n’=x,m’=y$ 的概率，类似的，令第一次 $n’\le x$ 或者 $m’\le y$ 构成一个事件集，所以 $n’=x$ 或者 $m’=y$ 的概率为 $\frac{2}{x+y}$ ，然后剩下的情况就和前面的情况一样了，概率为 $\frac{1}{x+y-1}$ ，乘在一起就是：$\frac{2}{(x+y)(x+y-1)}$ 。</p>
<p>然后裂项求个和就可以在 $O(n+m)$ 的时间得到答案了。</p>
</div></details></li>
</ol>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>线段间最短距离</title>
    <url>/2025/02/04/%E7%BA%BF%E6%AE%B5%E9%97%B4%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<p>如何求两条线段间的最短距离。</p>
<p>相交了那么显然是 $0$ ，因此我们判断不相交的线段，这里有一个结论：只需要找到四个端点到另外一条线段的距离的最小值即可。</p>
<p>证明也是非常的简单，设两条线段为 $AB,CD$​ ，如果 $AB,CD$​ 平行那么显然，如果不平行，设非端点 $X,Y$​ 之间的距离是最小值。</p>
<p>如果 $XY$​ 不垂直 $AB,CD$​ ，那么设 $XK⊥CD$ ，可知 $K$ 不在 $CD$ 上，于是变成了这样：</p>
<p><img src="1.png" alt="QAQ"></p>
<p>显然，$XC,XD$ 必有一条长度小于 $XY$ 。</p>
<p>假设$XY⊥CD$，那么显然不垂直 $AB$ ，我们设 $YK⊥AB$，$|YK|&lt;|XY|$ ，所以 $K$ 不在 $AB$ 上，假设 $X$ 与 $K$ 中间夹着 $A$ ，那么显然 $|AY|&lt;|XY|$ ，证毕。</p>
<p><img src="2.png" alt=""></p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>经典trick汇总</title>
    <url>/2023/09/04/%E7%BB%8F%E5%85%B8trick%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<details class="toggle" ><summary class="toggle-button" style="">时间复杂度</summary><div class="toggle-content"><details class="toggle" ><summary class="toggle-button" style="">分数之和</summary><div class="toggle-content"><ol>
<li>$O(\sum\limits_{i=1}^{n})=O(\log{n})$ （调和级数）</li>
<li>$O(\sum\limits_{i=1}^n)=O(1)$ （可以用积分、裂项证明，也可以搜搜’巴塞尔问题’，这个式子收敛于 $\frac{\pi^2}{6}$ ）</li>
</ol>
</div></details></div></details>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>ACM杂类</tag>
      </tags>
  </entry>
  <entry>
    <title>支配树学习笔记</title>
    <url>/2025/02/03/%E6%94%AF%E9%85%8D%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一个非常毒瘤的事情，2021联合省选竟然考了支配树，甚至名字还叫支配？？？</p>
<p>当然，其实那道题目不用支配也能做，但是我太菜了，不会，然后就弃掉了。</p>
<p>现在学了一下支配树，来写个模板。</p>
<p>注：支配树证明部分基本沿用了王梦迪大佬PPT的证明，因此如果是寻求另类解释的OIer可以撤了。（曾经我也想看完做法后好好理解看看自己能不能领悟证明，事实证明我错了，自己思考除了浪费时间貌似一点作用都没有，菜就是菜QAQ）</p>
<h1 id="支配树简介"><a href="#支配树简介" class="headerlink" title="支配树简介"></a>支配树简介</h1><p>在一个有向图上，保证 $1$ 号点能到达所有的点，如果 $1$ 到达 $x$ 的所有路径都要经过点 $y$ ，则称 $y$ 支配 $x$ ，当然，特殊的，$1$ 和点 $x$ 本身都支配点 $x$ 。</p>
<p>当然，有时候不一定 $1$ 号点能到达所有的点，你就把到不了的点剔除在外就行了。</p>
<p>仔细想想支配有什么性质？</p>
<p>其实画个图不难发现支配是呈现树状结构的，此话怎讲？</p>
<p>例如 $x,y$ 都支配 $k$ ，你认为 $x,y$ 能是什么关系？</p>
<p>如果 $x,y$ 互相并不支配，那么想想看，假设存在一条路径是从 $1-&gt;x-&gt;y-&gt;k$ 的，那么因为 $x$ 并不支配 $y$ ，那么只要在另找一条不包括 $x$ 到 $y$ 的路径代替就可以变成：$1-&gt;y-&gt;k$ 了，这与 $x$ 支配 $k$ 矛盾，因此 $x,y$ 之间一定有支配关系。</p>
<p>另外，$x,y$ 之间也不能互相支配，假设 $x,y$ 互相支配，则到 $y$ 的一条简单路径为：$1-&gt;x-&gt;y$ ，但是 $y$ 支配 $x$ ，所以为：$1-&gt;y-&gt;x-&gt;y$，与简单路径矛盾，所以 $x,y$ 最多只能是单向支配关系（所以支配关系是一个 $DAG$ 图，当然，自己支配自己不考虑在这个图内）。</p>
<p>还有一条性质：如果 $x$ 支配 $y$ ，那么支配 $x$ 的点也支配 $y$ 。</p>
<p>继续仔细观察，不难发现，对于一个点 $x$ ，如果假设支配他的点的集合为 $V$ ，将 $V$ 中的 $x$ 踢出去，那么 $V$ 中一定有个点 $y$ 能被 $V$ 中所有点支配，我们称 $y$ 是 $x$ 的支配点（因此 $k$ 支配 $x$ 不一定代表 $k$ 是 $x$ 的支配点）。</p>
<p>当然，除 $1$ 以外的点都有支配点，至于为什么，可以发现，支配关系一定是一个 $DAG$ 图，然后如果我们讨论踢到 $x$ 的 $V$ 的导出子图，就会发现，这个点数为 $t$ 的导出子图每个点的度数都是 $t-1$ ，且样子是固定的，每个点的入度和出度都从 $0$ 到 $t-1$ 完完整整的来了一遍（这个用数学归纳法很好证），那个入度为 $t-1$ 出度为 $0$ 的点就是支配点。（当然，深入一点，这个子图上每个点的入度加一其实就表示了在支配树上的深度，这一点目前无关紧要。）</p>
<p>举个栗子：</p>
<p>$1-&gt;3-&gt;2-&gt;5$</p>
<p>这一条链中 $1,3,2$ 都能支配 $2$ ，看 $1,3$ ，发现只有 $3$ 是被 $1,3$ 支配，所以 $3$ 是 $2$ 的支配点。</p>
<p>然后我们让每个点 $x$ （除 $1$ 以外）的支配点连向 $x$ ，便可以得到一个新的树，这个树就叫支配树。（至于为什么是树嘛，$n-1$ 条边，且没有环，不就是树吗？而且还是个以 $1$ 为根的外向树，除 $1$ 外每个点的入度都是 $1$ ）</p>
<p>在这节最后总结一下：</p>
<p>$x,y$ 不能互相支配，如果他们支配同一个点，他们之间存在支配关系，同时，支配关系具有传递性。</p>
<p>支配树的概念基本就讲完了，其实支配树就是支配关系DAG图中的一个生成树罢了。</p>
<p>接下来会介绍一种做法： Lengauer Tarjan算法。名字上的两个人就是发明者。</p>
<p>时间复杂度：$O((n+m)α(n))$，空间复杂度：$O(n+m)$。</p>
<p>当然，你乐意的话其实可以把 $α(n)$ 换成 $log$ 的，反正我是这样干的。</p>
<h1 id="支配树的构造方法"><a href="#支配树的构造方法" class="headerlink" title="支配树的构造方法"></a>支配树的构造方法</h1><p><a href="https://www.luogu.com.cn/problem/P5180">P5180 [模板]支配树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>先来分析一下这道题目和支配树有什么关系，来一条性质：</p>
<p>$x$ 如果支配 $y$ ，那么 $x$ 在支配树上一定是 $y$ 的祖先。</p>
<p>证明：</p>
<p>设支配 $y$ 的点集为 $V$ ，$k$ 是 $y$ 的支配点，因为支配具有传递性，所以支配 $k$ 的点集是 $V$ 的一个子集，且大小只相差 $1$ ，这样不断下去，就会发现，其实点集呈现一条链状，所以 $x$ 是 $y$ 的祖先，其实这条链中每个点的深度上面也提到了，就是 $V$ 导出子图中每个点的入度加一。</p>
<p>因此，实际上一个点所支配的点就是其子树（同理，支配一个点的点就是其到根节点的这一条链），因此这道题目实际就是问每个点在支配树上的子树大小。</p>
<p>接下来会提到暴力和特殊情况，如果要看做法直接跳到正确做法即可。</p>
<h2 id="暴力构造法"><a href="#暴力构造法" class="headerlink" title="暴力构造法"></a>暴力构造法</h2><p>这个方法的时间复杂度是 $O(n^2)$ ，但这次省选D2T3应该这个复杂度就够了。</p>
<p>没什么实际作用，但是应该能提升一点点理解吧。</p>
<p>设置 $idom$ 表示一个点的支配点编号。</p>
<p>简单来说，去掉一个点 $t$ ，然后跑 $BFS$ ，然后便会有一些点会到不了，记作点集 $V$ ，对于点 $x∈V$，首先 $t$ 支配 $x$  ，如果 $idom[x]$ 为 $0$ ，那么 $t$ 可能是 $x$ 的支配点，或者 $idom[x]∉V$ ，说明 $idom[x]$ 支配 $t$ ，所以 $t$ 可能是 $x$ 的支配点。</p>
<p>但是，如果 $idom[x]∈V$ ，那 $t$ 便不可能是 $x$ 的点集。</p>
<p>然后依次去掉每个点，便可以完成此暴力，时间复杂度 $O(n^2)$ ，空间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 210000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 310000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> y,next;</span><br><span class="line">&#125;a[M];<span class="type">int</span> len,last[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;len++;a[len].y=y;a[len].next=last[x];last[x]=len;&#125;</span><br><span class="line"><span class="type">int</span> ban;</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line"><span class="type">int</span> pre[N];<span class="comment">//其实就是前面的idom数组，这个代码敲的比较早，所以用的是pre</span></span><br><span class="line"><span class="type">int</span> list[N],head,tail;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list[head=tail=<span class="number">1</span>]=<span class="number">1</span>;<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="built_in">sizeof</span>(v));v[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(head&lt;=tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=list[head++];</span><br><span class="line">        <span class="keyword">if</span>(x==ban)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=last[x];k;k=a[k].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=a[k].y;</span><br><span class="line">            <span class="keyword">if</span>(!v[y])</span><br><span class="line">            &#123;</span><br><span class="line">                v[y]=<span class="number">1</span>;</span><br><span class="line">                list[++tail]=y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v[ban]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ban=i;</span><br><span class="line">        <span class="built_in">bfs</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!v[j] &amp;&amp; i!=j<span class="comment">/*将自环情况剔除在外*/</span> &amp;&amp; (!pre[j] || v[pre[j]]))pre[j]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> siz[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    siz[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=last[x];k;k=a[k].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=a[k].y;</span><br><span class="line">        <span class="built_in">dfs</span>(y);siz[x]+=siz[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">ins</span>(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    len=<span class="number">0</span>;<span class="built_in">memset</span>(last,<span class="number">0</span>,<span class="built_in">sizeof</span>(last));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)<span class="built_in">ins</span>(pre[i],i);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,siz[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DAG特殊情况"><a href="#DAG特殊情况" class="headerlink" title="DAG特殊情况"></a>DAG特殊情况</h2><p><a href="https://www.luogu.com.cn/problem/P2597">[P2597 ZJOI2012]灾难 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>
<p>来看种特殊情况，即原图没有环的情况，也是算加深理解顺便做道题目吧。</p>
<p>首先将其和支配扯上关系：将被捕者向捕食者连边，如果从所有生产者出发到这个点 $x$ 都要经过一个点 $y$ ，那么 $y$ 支配 $x$ ，为了方便，我们加入一个超级源点，向所以入度为 $0$ 的点连边，这样就重新变成了我们原本所定义的支配关系了。</p>
<p>该怎么做呢？实际上非常的简单<del>但我不会</del>，做法就是拓扑排序+倍增，在边跑拓扑排序的时候（这里我们将入度为 $0$ 作为入队要求），当一个点入度变为 $0$ 加入队列时，便更新其倍增数组，倍增数组维护的是其在分配树上的祖先，而一个点在分配树上的祖先就是连向他的在支配树上的 $LCA$ 。</p>
<p>举个例子：如果 $1,2,3$ 都连向 $4$ ，那么 $4$ 的支配点就是 $1,2,3$ 在支配树上的 $LCA$ 。</p>
<p>比较简单，不证明了。</p>
<p>然后就做完了。</p>
<p>时间复杂度：$O(n\log{n})$，空间复杂度：$O(n\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建反图，求支配树，然后求出每个点在支配树上的子树大小 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 71000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SN 22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 1100000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span>&amp;y)</span></span>&#123;x^=y^=x^=y;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> y,next;</span><br><span class="line">&#125;a[M];<span class="type">int</span> len,last[N],in[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;len++;a[len].y=y;a[len].next=last[x];last[x]=len;in[y]++;&#125; </span><br><span class="line"><span class="type">int</span> fa[N][SN],dep[N];</span><br><span class="line"><span class="type">int</span> list[N],head,tail;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">18</span> &amp;&amp; fa[x][i<span class="number">-1</span>];i++)fa[x][i]=fa[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">18</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[fa[y][i]]&gt;=dep[x])y=fa[y][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">18</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> siz[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            <span class="keyword">if</span>(!x)<span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">ins</span>(x,i);</span><br><span class="line">        &#125;</span><br><span class="line">        siz[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!in[i])<span class="built_in">ins</span>(n+<span class="number">1</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    n++;</span><br><span class="line">    list[head=tail=<span class="number">1</span>]=n;dep[n]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(head&lt;=tail)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=list[head++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=last[x];k;k=a[k].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=a[k].y;</span><br><span class="line">            in[y]--;</span><br><span class="line">            <span class="keyword">if</span>(!fa[y][<span class="number">0</span>])fa[y][<span class="number">0</span>]=x;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                fa[y][<span class="number">0</span>]=<span class="built_in">lca</span>(fa[y][<span class="number">0</span>],x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!in[y])</span><br><span class="line">            &#123;</span><br><span class="line">                dep[y]=dep[fa[y][<span class="number">0</span>]]+<span class="number">1</span>;</span><br><span class="line">                list[++tail]=y;</span><br><span class="line">                <span class="built_in">updata</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    len=<span class="number">0</span>;<span class="built_in">memset</span>(last,<span class="number">0</span>,<span class="built_in">sizeof</span>(last));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=tail;i&gt;=<span class="number">1</span>;i--)siz[fa[list[i]][<span class="number">0</span>]]+=siz[list[i]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,siz[i]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="正确做法"><a href="#正确做法" class="headerlink" title="正确做法"></a>正确做法</h2><h3 id="DFS树"><a href="#DFS树" class="headerlink" title="DFS树"></a>DFS树</h3><p>首先，我们跑个 $DFS$ ，可以得到 $DFS$ 序 $dfn$ 数组。（记录 $DFS$ 中的访问时间）</p>
<p>同时我们可以得到一个 $DFS$ 树。（下文中的父亲，祖先关系都是在 $DFS$ 树上，与半支配树以及支配树无关）</p>
<h4 id="符号定义"><a href="#符号定义" class="headerlink" title="符号定义"></a>符号定义</h4><p>下文中 $DFS$ 树用 $T$ 代替，$DFS$ 树中的边用 $E$ 表示，原图中的边用 $E’$ ，为了方便，下文点的编号全部用 $dfn$ 重新编号。</p>
<p>$x-&gt;y$ 表示 $x-&gt;y$ 的路径，包括左右两个点。</p>
<p>$(x-&gt;y)$ 表示 $x-&gt;y$ 在 $T$ 中的路径，不包括左右两个点，$[x-&gt;y]$ 表示 $x-&gt;y$ 在 $T$ 中的路径，包括左右两个点（类似开闭区间）。</p>
<p>$x+-&gt;y$ 表示 $x$ 在 $T$ 中是 $y$ 的祖先，且 $x≠y$ 。</p>
<p>$x.-&gt;y$ 表示 $x$ 在 $T$ 中是 $y$ 的祖先，但可能 $x=y$ 。</p>
<h4 id="讨论性质"><a href="#讨论性质" class="headerlink" title="讨论性质"></a>讨论性质</h4><ol>
<li><p>如果​ $x$ 支配 $y$ ，那么 $x$ 在 $T$ 上一定是 $y$ 的祖先，这个非常简单，因为树上 $1$ 到 $x$ 这条链上的点才有资格去支配 $x$ 。</p>
</li>
<li><p>定义：如果一条边是 $x-&gt;y$ ，且 $x,y$ 在树上的 $LCA$ 不是 $x,y$ ，则称这条边为横叉边，可以发现 $x&gt;y$ ，证明：如果$x<y$，那么 $x$ 优先于$y$ 访问，则 $y$ 应该在 $x$ 子树内，与横叉边定义矛盾，所以 $x>y$ 。</p>
</li>
<li><p>路径引理：如果 $x&lt;y$ ，那么 $x$ 到 $y$ 的每条路径都包括一个他们的公共祖先（不一定是 $LCA$ ，不同路径也不一定是同一个）。</p>
<p> 证明：先明白一个事情，一个点的两个儿子子树，根据 $T$ 的定义，肯定是一个儿子子树的点的编号普遍大于另外一个儿子子树的点，因此如果对于 $k$ ，$x,y$ 位于其两个不同的儿子子树，$x&lt;y$，你在 $x$ 所在的儿子子树是找不到一个点的编号大于 $y$ 的，因此，我们可以根据这个勉强的认为一个点的不同儿子子树间存在大小。</p>
<p> <img src="zhipeitree-1.png" alt="zhipeitree-1"></p>
<p> 回归我们要证的题目，红色三角形表示整体小于 $y$ 的子树（其实 $x$ 所在的那个三角形也应该是红色），蓝色则是整体大于 $y$ 的，可以发现，$x$ 不管走横叉边还是儿子边，最终都只能到达另外一个红色三角形，只有走返祖边，到达 $x,y$ 的其中一个公共祖先，才可以到达蓝色三角形。</p>
<ol>
<li><p>如果 $x+-&gt;y$ ，则 $x.-&gt;idom[y]$ 或 $idom[y].-&gt;idom[x]$ 。<img src="zhipeitree-2.png" alt="zhipeitree-2"></p>
<p> 换言之，$idom[y]$ 不可能卡在 $idom[x],x$ 中间。</p>
<p> 为什么？如果 $idom[y]$ 卡在中间，那么存在一条路径不经过 $idon[y]$ 直接到 $x$ 然后再到 $y$ 即可，矛盾。</p>
</li>
</ol>
</li>
</ol>
<h3 id="半支配点"><a href="#半支配点" class="headerlink" title="半支配点"></a>半支配点</h3><p>半支配点是什么？</p>
<p>如果 $x$ 是满足存在一条 $x$ 到 $y$ 的路径使得除 $x,y$ 以外的点编号都大于 $y$ 且编号最小的点，那么就称 $x$ 是 $y$ 的半支配点。（默认 $1$ 没有半支配点）</p>
<p>不难发现，$x$ 的父亲有可能成为 $x$ 的半支配点，我们认为，$sdom[x]$ 为 $x$ 的半支配点。</p>
<p>性质：</p>
<ol>
<li><p>$x$ 的半支配点一定是 $x$ 的祖先。</p>
<p> 证明：假设 $y$ 不是 $x$ 的祖先，那么假想一下 $y$ 那条满足要求的路径吧，假设路径第一条边到 $t$ ，且是横叉边，则$y&gt;t&gt;x$，那还不如 $x$ 不如让 $x$ 的父亲当半支配点， $dfn$ 更小。</p>
<p> 如果不是横叉边，而是指向 $y$ 子树的边，那么同理证否，如果指向的是 $y$ 的祖先，那么让 $y$ 的祖先当这个半支配点更好，证毕。</p>
<p> EX： 因此，如果我们认为将 $sdom[x]$ 连向 $x$ 能构造成一棵树，这棵树叫半支配树。</p>
</li>
<li><p>$x$ 的半支配点 $y$ 在 $x$ 到支配点 $k$ 的路径上（包括两端）。</p>
<p> 证明一下：首先，不难发现， $k$ 到根节点的点（不包括 $k$ ）由于到 $x$ 都要经过 $k$  ，所以不可能满足要求，则半支配点一定在 $x$ 到支配点 $k$ 的路径上，当然，也不一定 $y=k$ ，可以举个反例：</p>
<p> 比如：$1-&gt;2-&gt;3-&gt;4-&gt;5$，如果还存在边：$1-&gt;3-&gt;5,2-&gt;4$，那么 $1$ 是 $5$ 支配点，但是 $4$ 是 $5$ 的半支配点。</p>
</li>
<li><p>如果不存在 $z∈(sdom[x]-&gt;x)$ 使得 $sdom[z]&lt;sdom[x]$，$sdom[x]=idom[x]$ 。</p>
<p> 证明：只要证明 $sdom[x]$ 支配 $x$ 即可，我们假设 $k∈1-&gt;x$ ，且满足是最后一个编号小于 $x$ 的点（肯定有，如果没有，则 $sdom[x]=1$ ，同样结论成立），$y$ 是 $k$ 之后第一个属于 $[sdom[x]-&gt;x]$ 的点，设 $v_{i}$ 是路径上介于 $k,y$ 之间的点，现在证明 $v_{i}&gt;y$ 。</p>
<p> <img src="zhipeitree-3.png" alt="zhipeitree-3"></p>
<p> 如果 $sdom[x]<v_i<y$ ，那么则 $LCA(y,v_i)∈[sdom[x]->y)$  ，则肯定存在另外一个 $v_{j}∈[sdom[x]-&gt;y)$ ，那么就与 $y$ 定义矛盾了，则 $dfn[v_{i}]&gt;y$ 。</p>
<p> 那么，则 $k≥sdom[y]$ （ $k$ 满足 $sdom[y]$ 的要求），则 $sdom[y]≤k&lt;sdom[x]$ ，因此，$y$ 只能是 $sdom[x]$ 了， $sdom[x]$ 支配 $x$ ，证毕。</p>
</li>
<li><p>如果存在 $sdom$ 最小的 $z∈(sdom[x]-&gt;x)$ 使得 $dfn[sdom[z]]&lt;dfn[sdom[x]]$，$idom[z]=idom[x]$ 。</p>
<p> 证明：运用 DFS 性质 $4$ ，我们可以发现 $sdom[x]&gt;z&gt;x$ ，那么就不可能是情况一了，只能是第二种情况，这样我们只需要证明 $idom[x]$ 支配 $y$ 即可。（即：$idom[x].-&gt;idom[z]-&gt;z-&gt;x$）</p>
<p> <img src="zhipeitree-4.png" alt="zhipeitree-4"></p>
<p> 类似的，我们设一个 $k$ ，表示 $1-&gt;y$ 路径上最后一个 $dfn$ 小于 $idom[z]$ 的点设为 $k$ ，同时第一个属于 $[idom[z]-&gt;y]$ 的点设 $y$ ，那么类似的可以证明 $sdom[y]<idom[z]$，先思考， $z$ 能在 $1$ 号位置吗？因为 $z$ 已经是 $[sdom[x]->x]$ 上 $sdom$ 最小的，因此$idom[z]≤sdom[z]≤sdom[y]$ ，矛盾，因此，$z$ 只能在 $2$ 号位置上，即 $[idom[z]-&gt;y]$ 上，但是因为 $sdom[y]&lt;idom[z]$ ，如果 $y≠idom[z]$ 则与 $idom[z]$ 支配 $z$ 矛盾，所以 $y=idom[z]$ ，$idom[z]$ 支配 $x$ ，证毕。</p>
</li>
<li><p>将半支配树和支配树合在一起构成一个新图，新图和原图的支配关系不变。</p>
<p> 证明：实际只要求每个点的支配点不变就行，根据性质 $4,5$ ，可以发现新图上每个点的支配点其实是不变的。</p>
<p> EX：因此，根据这条性质，如果我们求出了半支配点，就可以直接将 $T$ 和半支配树合在一起用 DAG 求法达到比较完美的 $O(n\log{n}+求半匹配点时间)$ 。</p>
</li>
<li><p>$sdom[x]=min(\{y|(y,x)∈E’,y<x\}∪\{sdom[z]|z.->y,z&gt;x,(y,x)∈E’\})$</p>
<p> 证明：我们设 $g$ 等于等号右边。</p>
<ol>
<li><p>$sdom[x]≤g$</p>
<p> 对于第一种情况， $y$ 显然满足半支配点的要求，可以作为考虑对象。</p>
<p> 对于第二种情况，显然，存在一条路径 $sdom[z]-&gt;z$ 且使得路径中间的点都大于 $z$ （ $sdom[z]$ 定义），将 $z.-&gt;y-&gt;x$ 加上，显然整条路径的的中间也都大于 $x$ ，因此，$sdom[z]$ 也可以是 $x$ 的半支配点。</p>
</li>
<li><p>$sdom[x]≥g$</p>
<p> 我们假设存在一条路径 $sdom[x]-&gt;v_1-&gt;v_2-&gt;v_i-&gt;v_k-&gt;x$ 那么如果 $k=0$ ，则 $sdom[x]$ 将在第一种情况被判断到（注意 $sdom[x]<x$ ），如果 $k>0$ ，那么设 $v_{i}$ 是路径上除 $sdom[x],v_{1}$ 后第一个满足 $v_{i}.-&gt;v_{k}$ 的点（ $v_{1}$ 则会被右式包含到），显然一定存在，因为 $v_{k}$ 自己就是。</p>
<p> 显然，$v_{j}&gt;v_{i}(1≤j&lt;i)$ ，因为如果小于，则一定经过 $v_{i}$ 的祖先，那么违反定义，则 $g≤sdom[v_{i}]≤sdom[x]$ 。</p>
<p>综上，$g=sdom[x]$。</p>
</li>
</ol>
</li>
</ol>
<p>根据性质 $6$ 不难发现，该式子只要右边的 $sdom$ 都是正确的，则一定可以保证左边的正确，因此，我们只需要按编号从大往小扫，只要保证编号最大的 $sdom$ 正确（显然，此时只有第一类），就可以类似数学归纳的思路保证所有的 $sdom$ 都是正确的。</p>
<p>但是具体做法是什么呢？</p>
<p>右式第一类比较好讨论，但是第二类呢？不难发现，其实 $z.-&gt;y$ 对应在树上就是一条链，因此，我们可以利用带权并查集的思路，维护一个点到目前最晚遍历到的祖先这么一条链上最小的 $sdom$ 即可。</p>
<p>最后只要依次从大到小遍历，然后在反图遍历 $x$ 的边即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dfn[N],id[N],top;</span><br><span class="line"><span class="type">int</span> fa[N],mn[N]<span class="comment">/*记录fa中最小的sdom*/</span>;</span><br><span class="line"><span class="type">int</span> idom[N],sdom[N],ff[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==fa[x])<span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">int</span> y=<span class="built_in">findfa</span>(fa[x]);</span><br><span class="line">    <span class="keyword">if</span>(dfn[sdom[mn[x]]]&gt;dfn[sdom[mn[fa[x]]]])mn[x]=mn[fa[x]];</span><br><span class="line">    fa[x]=y;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)idom[i]=sdom[i]=fa[i]=mn[i]=i,siz[i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">2</span>;i--)<span class="comment">//根节点不用找，肯定没有支配点 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x=id[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=last[<span class="number">1</span>][x];k;k=a[<span class="number">1</span>][k].next)<span class="comment">//反图的边目录</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=a[<span class="number">1</span>][k].y;</span><br><span class="line">        <span class="built_in">findfa</span>(y)<span class="comment">/*更新一下你的父亲*/</span>;</span><br><span class="line">        <span class="keyword">if</span>(dfn[sdom[x]]&gt;dfn[sdom[mn[y]]])sdom[x]=sdom[mn[y]];</span><br><span class="line">    &#125;</span><br><span class="line">    fa[x]=ff[x];<span class="comment">//更新到父亲</span></span><br><span class="line">    <span class="built_in">ins</span>(<span class="number">2</span>,sdom[x],x);<span class="comment">//维护半支配树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，$mn$ 维护的并不是链上最小的 $sdom$ ，而是持有最小 $sdom$ 的点（相同则 $dfn$ 大的优先）。（为后面更高效的做法作准备）</p>
<p>同时，虽然链的顶部 $x$ 是没有被访问的点，但是无伤大雅，因为 $sdom[x]=x$ ，而其儿子的 $sdom$ 肯定是 $x$ 或者 $x$ 祖先，所以 $x$ 后代的 $mn$ 不会等于自己，无伤大雅。</p>
<p>接下来只要跑个 $DAG$ 就完事了。</p>
<p>但是，神犇并不满足于此。</p>
<h3 id="更加高效的做法"><a href="#更加高效的做法" class="headerlink" title="更加高效的做法"></a>更加高效的做法</h3><p>其实性质 $3,4$ 点便是根据 $sdom$ 求 $idom$ 的方法。</p>
<p>但是这个具体应该怎么搞呢？</p>
<p>难道我们真的要傻傻的枚举 $x-&gt;sdom[x]$ 路径上的点？（<del>其实貌似用倍增依旧是一个log</del>）</p>
<p>当然不用，其实我们不需要从 $x$ 出发考虑，我们可以从 $sdom[x]$ 出发考虑，当我们遍历到 $sdom[x]$ 的一个儿子 $y$ 的时候（ $x$ 在 $y$ 子树内），由于 $DFS$ 树的定义，$y$ 的子树肯定也都被遍历过了，也就是说， $[x-&gt;y]$ 这一条链实际上都已经被遍历过了，则并查集中 $x$ 的 $mn[x]$ 实际可能就是 $[x-&gt;y]$ 中我们要找的 $z$ （为什么是可能，因为可能没有 $z$ ，如果有，那么就是我们要的 $z$ ），因此，只要我们遍历完 $x$ ，我们就遍历 $x$ 的父亲在半支配树上的儿子来判断，但是需要注意的是，因为接下来会遍历 $x$ 父亲的其余儿子子树，为了防止在其余儿子子树重复判断 $x$ 子树的点，因此在 $x$ 遍历完后，要把 $x$ 父亲在半支配树上的儿子全部删掉。（当然，不删掉不会导致错误，但时间会假）</p>
<p>如果我们发现，不存在 $z$ ，那么 $idom[x]=sdom[x]$ ，但是如果存在 $z$ ，$idom[x]=idom[z]$ ，$idom[z]$ 此时一定还没找到，怎么办？其实可以先用 $idom[x]=z$ ，最后正序扫描一遍赋值即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)idom[i]=sdom[i]=fa[i]=mn[i]=i,siz[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">2</span>;i--)<span class="comment">//根节点不用找，肯定没有支配点 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=id[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=last[<span class="number">1</span>][x];k;k=a[<span class="number">1</span>][k].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=a[<span class="number">1</span>][k].y;</span><br><span class="line">            <span class="built_in">findfa</span>(y)<span class="comment">/*更新一下你的父亲*/</span>;</span><br><span class="line">            <span class="keyword">if</span>(dfn[sdom[x]]&gt;dfn[sdom[mn[y]]])sdom[x]=sdom[mn[y]];</span><br><span class="line">        &#125;</span><br><span class="line">        fa[x]=ff[x];<span class="comment">//更新到父亲</span></span><br><span class="line">        <span class="built_in">ins</span>(<span class="number">2</span>,sdom[x],x);<span class="comment">//维护半支配树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=last[<span class="number">2</span>][x=ff[x]];k;k=a[<span class="number">2</span>][k].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=a[<span class="number">2</span>][k].y;</span><br><span class="line">            <span class="built_in">findfa</span>(y);</span><br><span class="line">            idom[y]=(mn[y]==x?y:mn[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        last[<span class="number">2</span>][x]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=id[i];</span><br><span class="line">        <span class="keyword">if</span>(idom[x]==x)idom[x]=sdom[x];</span><br><span class="line">        <span class="keyword">else</span> idom[x]=idom[idom[x]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完整的代码"><a href="#完整的代码" class="headerlink" title="完整的代码"></a>完整的代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 210000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 310000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">mymin</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&lt;y?x:y;&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> y,next;</span><br><span class="line">&#125;a[<span class="number">3</span>][M];<span class="type">int</span> len[<span class="number">3</span>],last[<span class="number">3</span>][N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">ins</span><span class="params">(<span class="type">int</span> type,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;len[type]++;a[type][len[type]].y=y;a[type][len[type]].next=last[type][x];last[type][x]=len[type];&#125;</span><br><span class="line"><span class="type">int</span> dfn[N],id[N],top;</span><br><span class="line"><span class="type">int</span> fa[N],mn[N]<span class="comment">/*记录fa中有最小的sdom的点*/</span>;</span><br><span class="line"><span class="type">int</span> idom[N],sdom[N],ff[N];<span class="comment">//需要注意的是，这些存的都是点的编号，而不是dfn</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findfa</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==fa[x])<span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">int</span> y=<span class="built_in">findfa</span>(fa[x]);</span><br><span class="line">    <span class="keyword">if</span>(dfn[sdom[mn[x]]]&gt;dfn[sdom[mn[fa[x]]]])mn[x]=mn[fa[x]];</span><br><span class="line">    fa[x]=y;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=++top;id[top]=x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=last[<span class="number">0</span>][x];k;k=a[<span class="number">0</span>][k].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=a[<span class="number">0</span>][k].y;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])ff[y]=x,<span class="built_in">dfs</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> siz[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)idom[i]=sdom[i]=fa[i]=mn[i]=i,siz[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">2</span>;i--)<span class="comment">//根节点不用找，肯定没有支配点 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=id[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=last[<span class="number">1</span>][x];k;k=a[<span class="number">1</span>][k].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=a[<span class="number">1</span>][k].y;</span><br><span class="line">            <span class="built_in">findfa</span>(y)<span class="comment">/*更新一下你的父亲*/</span>;</span><br><span class="line">            <span class="keyword">if</span>(dfn[sdom[x]]&gt;dfn[sdom[mn[y]]])sdom[x]=sdom[mn[y]];</span><br><span class="line">        &#125;</span><br><span class="line">        fa[x]=ff[x];<span class="comment">//更新到父亲</span></span><br><span class="line">        <span class="built_in">ins</span>(<span class="number">2</span>,sdom[x],x);<span class="comment">//维护半支配树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=last[<span class="number">2</span>][x=ff[x]];k;k=a[<span class="number">2</span>][k].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=a[<span class="number">2</span>][k].y;</span><br><span class="line">            <span class="built_in">findfa</span>(y);</span><br><span class="line">            idom[y]=(mn[y]==x?y:mn[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        last[<span class="number">2</span>][x]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)<span class="comment">//正着赋值一遍</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=id[i];</span><br><span class="line">        <span class="keyword">if</span>(idom[x]==x)idom[x]=sdom[x];</span><br><span class="line">        <span class="keyword">else</span> idom[x]=idom[idom[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">2</span>;i--)siz[idom[id[i]]]+=siz[id[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">ins</span>(<span class="number">0</span>,x,y);<span class="built_in">ins</span>(<span class="number">1</span>,y,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,siz[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不难发现，此做法时间复杂度 $O((n+m)\log{n})$ ，空间复杂度：$O(n+m)$ ，比起 $DAG$ 做法，空间少个 $\log$ ，常数还比较小（但复杂度一样），因此，在洛谷上高效做法比 $DAG$ 做法整整快了 $3s$ （高效采用我的代码，$DAG$ 采用 XZY 的代码），当然，可以把并查集改成 $α(n)$ 的，这样时间复杂度就变成 $O((n+m)α(n))$ 。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Lengauer 和 Tarjan 太强啦。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>王梦迪 支配树PPT</p>
<p><a href="https://www.luogu.com.cn/blog/xzyxzy/solution-p5180">题解 P5180 【【模板】支配树】 - xzyxzy 的博客 - 洛谷博客 (luogu.com.cn)</a></p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>支配树</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流经典模型</title>
    <url>/2025/02/05/%E7%BD%91%E7%BB%9C%E6%B5%81%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前文申明：此博客主题内容是《胡伯涛: 最小割模型在信息学竞赛中的应用》中的部分内容。</p>
<p>但是因为此资料是本地资料，不知道原文地址在哪，且不知道怎么联系胡伯涛奆佬，所以标的是原创，还请谅解。</p>
<p>其实网络流还有不少技巧，比如说什么拆点拆边什么啦，但是都是一些比较小的技巧，等以后无聊了再统一的整理一下。</p>
<p>这里介绍两个网络流比较NB的模型。（觉得NB可能是因为我菜吧）</p>
<h1 id="最大权闭合子图"><a href="#最大权闭合子图" class="headerlink" title="最大权闭合子图"></a>最大权闭合子图</h1><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>[六省联考2017]寿司餐厅：<a href="https://www.luogu.com.cn/problem/P3749">https://www.luogu.com.cn/problem/P3749</a></p>
<p><del>当时就想着用DP搞，结果死活搞不出那个m=1的做法</del></p>
<h2 id="最大权闭合子图介绍"><a href="#最大权闭合子图介绍" class="headerlink" title="最大权闭合子图介绍"></a>最大权闭合子图介绍</h2><p>给你新的一道题目，有 $n$ 个点，每个点有个 $a$ 值，选了就会加上其 $a$ 值，那么很明显加上全部正的 $a$ 即可。</p>
<p>但是现在要求给你一些关系：选了 $x$ 必须选 $y$ 。</p>
<p>我们现在的 $ans$ 先加上所有的正数。</p>
<p>那么，考虑最小割，如果在最小割中割了 $x$ 和 $s$ 的边，表示不选 $x$ ，而割了 $x$ 和 $t$ 的边，然后需要注意的是，边权不是价值，而是<strong>代价</strong>，也就是需要从 $ans$ 中减去的东西。（当然，倒过来应该也没有问题。）</p>
<p>对于一个点 $i$ ，如果 $a_i&gt;0$ ，则向 $S$ 连边权为 $a_i$ 的边，向 $t$ 连边权为 $0$ 的边，如果 $a_i≤0$ ，则向 $S$ 连边权为 $0$ 的边，向 $T$ 连边权为 $-a_i$ 的边。</p>
<p>好，那么如果选了 $x$ 必须选 $y$ ，就把 $x$ 向 $y$ 连一条边，边权为 $\infty$ ，为什么？</p>
<p>因为如果 $x$ 选了，割了与 $t$ 的边，$y$ 不选，割了与 $s$ 的边，那么就一定存在一条路径：$s-&gt;x-&gt;y-&gt;t$。</p>
<p>所以 $x$ 选了，$y$ 必须被选。</p>
<p>这就是最大权闭合子图。</p>
<h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>仔细一看，对于 $d_{i,j}$ 而言，选了其必须选择 $d_{i+1,j},d_{i,j-1}$，而对于 $d_{i,i}$ 而言，选了其必须删去 $i$ 的代号，而对于 $i$ ，如果其被选择，那么也要删去其代号的平方乘 $m$ 。</p>
<p>然后跑Dinic即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>时间复杂度：$O(MaxFlow(n,n+m))$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  N  110</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  NN  12000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  M  110000</span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">int</span>  <span class="title">mymin</span><span class="params">(<span class="type">int</span>  x,<span class="type">int</span>  y)</span></span>&#123;<span class="keyword">return</span>  x&lt;y?x:y;&#125;</span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span>  y,next,c;</span><br><span class="line">&#125;a[M];<span class="type">int</span>  len=<span class="number">1</span>,last[NN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">ins_node</span><span class="params">(<span class="type">int</span>  x,<span class="type">int</span>  y,<span class="type">int</span>  c)</span></span>&#123;len++;a[len].y=y;a[len].c=c;a[len].next=last[x];last[x]=len;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">ins</span><span class="params">(<span class="type">int</span>  x,<span class="type">int</span>  y,<span class="type">int</span>  c)</span></span>&#123;<span class="built_in">ins_node</span>(x,y,c);<span class="built_in">ins_node</span>(y,x,<span class="number">0</span>);&#125;</span><br><span class="line"><span class="type">int</span>  list[NN],head,tail,h[NN],st,ed;</span><br><span class="line"><span class="function"><span class="type">bool</span>  <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="built_in">sizeof</span>(h));h[ed]=<span class="number">1</span>;</span><br><span class="line">	head=<span class="number">1</span>;tail=<span class="number">1</span>;list[<span class="number">1</span>]=ed;</span><br><span class="line">	<span class="keyword">while</span>(head&lt;=tail)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span>  x=list[head++];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  k=last[x];k;k=a[k].next)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span>  y=a[k].y;</span><br><span class="line">			<span class="keyword">if</span>(a[k^<span class="number">1</span>].c  &amp;&amp;  !h[y])</span><br><span class="line">			&#123;</span><br><span class="line">				h[y]=h[x]+<span class="number">1</span>;</span><br><span class="line">				list[++tail]=y;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>  h[st];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">dinic</span><span class="params">(<span class="type">int</span>  x,<span class="type">int</span>  f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x==ed)<span class="keyword">return</span>  f;</span><br><span class="line">	<span class="type">int</span>  s=<span class="number">0</span>,t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  k=last[x];k;k=a[k].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span>  y=a[k].y;</span><br><span class="line">		<span class="keyword">if</span>(a[k].c  &amp;&amp;  h[x]==h[y]+<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			s+=t=<span class="built_in">dinic</span>(y,<span class="built_in">mymin</span>(f-s,a[k].c));</span><br><span class="line">			a[k].c-=t;a[k^<span class="number">1</span>].c+=t;</span><br><span class="line">			<span class="keyword">if</span>(s==f)<span class="keyword">return</span>  s;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	h[x]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span>  s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span>  v[<span class="number">1100</span>];</span><br><span class="line"><span class="type">int</span>  ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">void</span>  <span class="title">jian</span><span class="params">(<span class="type">int</span>  x,<span class="type">int</span>  v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(v&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		ans+=v;</span><br><span class="line">		<span class="built_in">ins</span>(st,x,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>  <span class="keyword">if</span>(v&lt;<span class="number">0</span>)<span class="built_in">ins</span>(x,ed,-v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>  n,m,d[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	st=n*n+n+<span class="number">1000</span>+<span class="number">1</span>;ed=st+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span>  x;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">		<span class="keyword">if</span>(!v[x]  &amp;&amp;  m)<span class="built_in">jian</span>(n*n+x,-m*x*x),v[x]=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">jian</span>(n*n+<span class="number">1000</span>+i,-x);</span><br><span class="line">		<span class="built_in">ins</span>(n*n+<span class="number">1000</span>+i,n*n+x,<span class="number">999999999</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  j=i;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d[i][j]);</span><br><span class="line">			<span class="built_in">jian</span>((i<span class="number">-1</span>)*n+j,d[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  j=i;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==j)<span class="built_in">ins</span>((i<span class="number">-1</span>)*n+j,n*n+<span class="number">1000</span>+i,<span class="number">999999999</span>);</span><br><span class="line">			<span class="keyword">else</span>  <span class="built_in">ins</span>((i<span class="number">-1</span>)*n+j,i*n+j,<span class="number">999999999</span>),<span class="built_in">ins</span>((i<span class="number">-1</span>)*n+j,(i<span class="number">-1</span>)*n+j<span class="number">-1</span>,<span class="number">999999999</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">bfs</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		ans-=<span class="built_in">dinic</span>(st,<span class="number">999999999</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1-n^2表示d(i,j)</span></span><br><span class="line"><span class="comment">n^2+1-n^2+1000表示第i个代号。</span></span><br><span class="line"><span class="comment">n^2+1001-n^2+1000+n表示第i个数字，减去其代号 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>如果从感性的角度上理解的话，就是利用最小割处理了一波最小化问题，花最小的代价使得我们选出的闭合图合法。</p>
<p>现在将问题简化，有$n$个点，$d_{i}$为第$i$个点的权值，一个有向图$G=(V,E)$，其中边$(u,v)$表示选了$u$必须选$v$。</p>
<p>我们的模型是：</p>
<p>$c(s,i)=d_{i}(d_i&gt;0)$<br>$c(i,t)=-d_{i}(d_i&lt;0)$<br>$c(i,j)=inf((i,j)∈ E)$</p>
<p>当然，推导的话是直接照搬胡伯涛论文中的内容，因为他写的确实很好。</p>
<p><img src="1.png" alt="在这里插入图片描述"></p>
<p><img src="2.png" alt="在这里插入图片描述"></p>
<p><img src="3.png" alt="在这里插入图片描述"></p>
<h1 id="最大密度子图"><a href="#最大密度子图" class="headerlink" title="最大密度子图"></a>最大密度子图</h1><p><img src="4.png" alt="在这里插入图片描述"></p>
<p><img src="5.png" alt="在这里插入图片描述"></p>
<p><img src="6.png" alt="在这里插入图片描述"></p>
<p><img src="7.png" alt="在这里插入图片描述"></p>
<p>其实感觉点边均带权和不带权的推导式差不多的。</p>
<p>当然，至于不带权的边权图关于其中的精度问题我是有个想法的，因为也说了，精度是在 $\frac{1}{n^2}$ 的，所以其实可以把二分精度设在 $\frac{1}{2n^2}$ ，然后再结束之后 $O(nm)$ 把所有分母的取值枚举一一遍，如果误差在 $\frac{1}{2n^2}$ 以内，则就为这个值。（实际上可以用 $O(n)$ 或者各种优化加速此过程，反正我目前想到的最快的是 $O(n)$ ，暂时想不到更快的了。）</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>洛谷题解</p>
<p>《胡伯涛: 最小割模型在信息学竞赛中的应用》</p>
<h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><p>补充例题。</p>
<p>加深对这个的学习。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>计算几何简单入门学习笔记</title>
    <url>/2025/02/04/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="参照文献"><a href="#参照文献" class="headerlink" title="参照文献"></a>参照文献</h1><p>你谷日报真好用：<a href="https://www.luogu.com.cn/blog/wjyyy/geometry1">https://www.luogu.com.cn/blog/wjyyy/geometry1</a></p>
<p>B站UP主：<a href="https://space.bilibili.com/88461692?spm_id_from=333.788.b_765f7570696e666f.1">https://space.bilibili.com/88461692?spm_id_from=333.788.b_765f7570696e666f.1</a></p>
<p><a href="https://www.cnblogs.com/xiexinxinlove/p/3708147.html">https://www.cnblogs.com/xiexinxinlove/p/3708147.html</a></p>
<h1 id="点、向量"><a href="#点、向量" class="headerlink" title="点、向量"></a>点、向量</h1><h2 id="书写约定"><a href="#书写约定" class="headerlink" title="书写约定"></a>书写约定</h2><p>上了初中就应该学过直角坐标系了，这里不多阐述，本文 $(x,y)$ 表示点的坐标，$A(x,y)$ 中的 $A$ 表示点的编号，特殊的，$O$ 点是坐标系的圆点。</p>
<p>向量呢，是一个有向线段，通常表示为：$\vec{AB}$ 就表示由$A$到$B$的有向线段。</p>
<p>但是呢，许多情况，向量默认起点是在坐标系的原点：$O$，因此向量经常看到的形式都是：$\vec{OA}$，且由于起点固定，所以向量还有种表示方法，就是直接用终点$A$来表示向量，$\begin{bmatrix}x_A\\y_A\end{bmatrix}$ 也是一种表示方法。</p>
<p>下文中一般情况下默认起点不一定在 $O$ 点（很大多数情况都是），但是当看到用终点表示向量时，默认起点是 $O$ 或者是前文规定的某个基准点（表示以这个点建立坐标系），如果一般是 $\vec{AB}$ 这样两个端点给出的向量乘积，那么就以两个向量的共同端点为基准点建立坐标系。（当然还是有特例，一般会有特殊说明<del>可能会忘记写</del>）</p>
<p>向量的模呢，其实就是其的长度，比如向量 $\vec{A}$ 的模写作：$|\vec{A}|$。</p>
<p>向量的幅角呢，其实就是其和 $x$ 正半轴形成的夹角。</p>
<p><img src="1.png" alt="在这里插入图片描述"></p>
<p>一般可以用 $atan2$ 函数进行计算，但是需要注意 $C++$ 用的是弧度制。（其实没啥区别，正负性没有变，值域变了而已。）</p>
<h2 id="向量运算"><a href="#向量运算" class="headerlink" title="向量运算"></a>向量运算</h2><p>实际上，这些运算实际指的是起点在$O$点的运算。</p>
<h3 id="普通运算"><a href="#普通运算" class="headerlink" title="普通运算"></a>普通运算</h3><p>加法运算：$\begin{bmatrix}x_A\\y_A\end{bmatrix}+\begin{bmatrix}x_B\\y_B\end{bmatrix}=\begin{bmatrix}x_A+x_B\\y_A+y_B\end{bmatrix}$</p>
<p>减法运算：$\begin{bmatrix}x_A\\y_A\end{bmatrix}-\begin{bmatrix}x_B\\y_B\end{bmatrix}=\begin{bmatrix}x_A-x_B\\y_A-y_B\end{bmatrix}$</p>
<p>乘常数运算：</p>
<script type="math/tex; mode=display">\begin{bmatrix}x_A\\y_A\end{bmatrix}*w=\begin{bmatrix}x_A*w\\y_A*w\end{bmatrix}</script><p>其余的运算对于信息学计算几何用处不大，因此不再赘述。</p>
<p><del>你放屁，叉积不重要吗。</del></p>
<p><del>我也知道叉积重要</del></p>
<p><del>所以下面开始讲叉积</del></p>
<h3 id="叉积"><a href="#叉积" class="headerlink" title="叉积"></a>叉积</h3><p>叉积的运算法则：</p>
<script type="math/tex; mode=display">\begin{bmatrix}x_B\\y_B\end{bmatrix}\times \begin{bmatrix}x_A\\y_A\end{bmatrix}=x_B*y_A-y_B*x_A</script><p>（考虑到图片标识问题，所以 $AB$ 换个位置。）</p>
<p>你没有看错，就是这么个东西，返回值竟然还是实数，甚至还没有交换律（因此叉积一定要注意前后顺序）。</p>
<p>那么其有什么实际作用呢？</p>
<p><img src="2.png" alt="在这里插入图片描述"></p>
<p>对于向量 $\vec{OB}$ 和 $\vec{OA}$ ，如果 $\vec{OB}$ 绕 $O$ 点逆时针旋转 $0°\sim 180°$ 能够与 $\vec{OA}$ 共线，那么 $\vec{OB}\times \vec{OA}&gt;0$，但是如果不能，代表 $\vec{OA}$ 逆时针旋转 $0°\sim 180°$ 能够与 $B$ 重合，那么 $\vec{OB}\times \vec{OA}<0,\vec{OB}\times \vec{OA}>0$ ，当然，如果一开始就共线，那么为 $0$ 。</p>
<p>至于叉积还有什么作用，也就是求 $▲OAB$ 的面积了。</p>
<p>实际上，这其实是叉积在线性代数中的意义，叉积求的是 $\vec{OB}$ 和 $\vec{OA}$ 为边的平行四边形的面积（除 $2$ 即可），但是为什么会有正负之分呢？额，这个跟线性变换有关，不再赘述，反正意义差不多就这两个。</p>
<p>额，至于证明吗，其实用几何就能证明了，至于线性代数的证明呢？我也不知道。<del>可能根本就没有吧。</del></p>
<p><img src="3.png" alt="在这里插入图片描述"></p>
<p>同机房的CLB奆佬用割补法给出了证明，但是实际上和上面的本质是差不多的，在此不再赘述。</p>
<p>当然，叉积的记忆也很简单。</p>
<p><img src="4.png" alt="在这里插入图片描述"></p>
<p>交叉相乘再相减。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">double</span>  <span class="title">mu</span><span class="params">(dian  x,dian  y,dian  z)</span><span class="comment">//以点z为圆点的叉积</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span>  x1=(x.x-z.x),y1=(x.y-z.y),x2=(y.x-z.x),y2=(y.y-z.y);</span><br><span class="line">	<span class="keyword">return</span>  x1*y2-x2*y1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，叉积有一个性质大家应该也看出来了：$\vec{A}\times \vec{B}=-\vec{B}\times \vec{A}$</p>
<h1 id="多边形的面积"><a href="#多边形的面积" class="headerlink" title="多边形的面积"></a>多边形的面积</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【题意】</span><br><span class="line">在一个平面坐标系上随意画一条有n个点的封闭折线（按画线的顺序给出点的坐标），保证封闭折线的任意两条边都不相交。最后要计算这条路线包围的面积。</span><br><span class="line">（注意，不能相交）</span><br></pre></td></tr></table></figure>
<p><img src="5.jpeg" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【输入格式】</span><br><span class="line">第一行整数 n (3 &lt;= n &lt;= 1000),表示有n个点。</span><br><span class="line">下来n行，每行两个整数x（横坐标）和y（纵坐标），表示点坐标（-10000&lt;x,y&lt;=10000）。</span><br><span class="line">【输出格式】</span><br><span class="line">一行一个实数，即封闭折线所包围的面积（保留4位小数）。</span><br><span class="line">【样例1输入】</span><br><span class="line">4</span><br><span class="line">2 1</span><br><span class="line">5 1</span><br><span class="line">5 5</span><br><span class="line">2 5</span><br><span class="line">【样例1输出】</span><br><span class="line">12.0000</span><br><span class="line"></span><br><span class="line">【样例2输入】</span><br><span class="line">5</span><br><span class="line">2 1</span><br><span class="line">5 1</span><br><span class="line">3 2</span><br><span class="line">5 3</span><br><span class="line">2 3</span><br><span class="line">【样例2输出】</span><br><span class="line">4.0000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>先考虑凸多边形：</p>
<p>只要这样子分就行了</p>
<p><img src="6.png" alt="在这里插入图片描述"></p>
<p>可以看出只要选一个点然后以这个点分割成一堆三角形就行了，而且用叉积都是一个方向。</p>
<p>公式的话，设点的序列是从某个顶点开始，逆时针给出，为$a_1,a_2,a_3,…,a_k$，那么就为$(\vec{a_1a_2}\times \vec{a_1a_3}+\vec{a_1a_3}\times \vec{a_1a_4}+…+\vec{a_1a_{k-1}}\times \vec{a_1a_k})/2$ 。</p>
<p>需要注意的是，由于是逆时针给出，且是正数，所以其中的每一个叉积都是正数，不需要加绝对值，但是如果在不知道是逆时针还是顺时针给出的情况下，最好还是加上绝对值。</p>
<p>那么我们再考虑非凸多边形面积的情况：</p>
<p><img src="7.png" alt="在这里插入图片描述"></p>
<p>如果采用上述的方法：$(\vec{a_1a_2}\times \vec{a_1a_3}+\vec{a_1a_3}\times \vec{a_1a_4}+…+\vec{a_1a_{k-1}}\times \vec{a_1a_k})/2$，我们发现刚好搞好就是多边形的面积，而有些叉积虽然算到多边形外面，后来又消掉。</p>
<p>因此你会发现，如果每次叉积都取绝对值反而会错，因此叉积的正负性真的是一个非常美妙的东西啊。</p>
<p><del>证明完全不会。</del></p>
<p>而在网上寻找证明的时候，我看到一个有意思的东西。<del>还是没找到证明</del></p>
<p>就是说我们上文是默认 $a_1$ 为三角形的公用顶点的，但是如果我们在坐标系中随便选一个点$x$，然后值为：$(\vec{xa_1}\times \vec{xa_2}+…+\vec{xa_k}\times \vec{xa_1})/2$，这样竟然也不会错，用一张别的大佬的博客的图来帮助理解。</p>
<p><img src="8.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  N  1100</span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="type">int</span>  n;</span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">node</span>&#123;<span class="type">double</span>  x,y;&#125;list[N];</span><br><span class="line"><span class="function"><span class="type">double</span>  <span class="title">mu</span><span class="params">(node  x,node  y,node  z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span>  x1=(x.x-z.x),y1=(x.y-z.y),x2=(y.x-z.x),y2=(y.y-z.y);</span><br><span class="line">	<span class="keyword">return</span>  x1*y2-x2*y1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>,&amp;list[i].x,&amp;list[i].y);</span><br><span class="line">	<span class="type">double</span>  ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">3</span>;i&lt;=n;i++)ans+=<span class="built_in">mu</span>(list[i],list[i<span class="number">-1</span>],list[<span class="number">1</span>]);<span class="comment">//直接求 </span></span><br><span class="line">	<span class="keyword">if</span>(ans&lt;<span class="number">0</span>)ans=-ans;<span class="comment">//题目并没有给出顺时针还是逆时针。</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.4lf&quot;</span>,ans/<span class="number">2.0</span><span class="comment">/*三角形面积要除以2*/</span>);</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="线段的相交与直线的交点"><a href="#线段的相交与直线的交点" class="headerlink" title="线段的相交与直线的交点"></a>线段的相交与直线的交点</h1><h2 id="线段的相交判定"><a href="#线段的相交判定" class="headerlink" title="线段的相交判定"></a>线段的相交判定</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">【题意】</span><br><span class="line">有n条线段（编号为<span class="number">1</span>~n），按<span class="number">1</span>~n的顺序放在二维坐标系上（就是先放<span class="number">1</span>号，再放<span class="number">2</span>号……），</span><br><span class="line">要求输出最上面的那些线段的编号（就是没有其他线段压在它上面的那些线段）</span><br><span class="line">【输入格式】</span><br><span class="line">第一行第一个数n（ <span class="number">1</span> &lt;= n &lt;= <span class="number">10000</span>）表示这组数据有n条线段。</span><br><span class="line">下来n行，每行两个坐标，表示第i条线段的两个端点。</span><br><span class="line">【输出格式】</span><br><span class="line">一行。输出最上面的线段的编号（从小到大）。相邻两个编号用空格隔开，最后一个编号没有空格。</span><br><span class="line">【样例<span class="number">1</span>输入】</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">-2.0</span> <span class="number">8</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">8</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">6</span> <span class="number">-2.0</span></span><br><span class="line">【样例<span class="number">1</span>输出】</span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">【样例<span class="number">2</span>输入】</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">0</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line">【样例<span class="number">2</span>输出】</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>线段相交裸题。</p>
<p><del>线段相交不直接列方程打几十行代码暴力判断吗</del></p>
<p>首先看下面这张图：</p>
<p><img src="9.png" alt="在这里插入图片描述"></p>
<p>把向量$AB$化成直线，然后判断另外一个向量是否是$\vec{C’’D’’}$的形式，其余的两种形式肯定都不可能相交。</p>
<p>敏锐的人发现了端点一个在左边，一个在右边（当然，其中一个端点在直线上也可以，两个端点等会讲），更加敏锐的人发现，直线不就是$180°$吗？特别敏锐的人发现，只要两条向量互相都满足这个要求，则一定相交，在不共线的情况下相交，则两条向量互相都满足这个要求。</p>
<p>至于怎么判断是不是长这个样子，即$(\vec{AB}\times \vec{AC’’})*(\vec{AB}\times \vec{AD’’})&lt;0$，然后两个一起判断即可。</p>
<p>代码片段：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">mu</span>(y.x,x.x,x.y)*<span class="built_in">mu</span>(y.y,x.x,x.y)&lt;=<span class="number">0</span>  &amp;&amp;  <span class="built_in">mu</span>(x.x,y.x,y.y)*<span class="built_in">mu</span>(x.y,y.x,y.y)&lt;=<span class="number">0</span>)<span class="keyword">return</span>  <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>注：此代码在后面会稍有魔改，本质是利用叉积：$\vec{A}\times \vec{B}=-\vec{B}\times \vec{A}$的性质，而且$&lt;=0$后面要把等号去掉$0$，因为端点在直线上和共线都是$0$，不能区分。</p>
<p>但是呢，还有一种特别特别恶心的情况，共线。</p>
<p>共线的时候，两个既有可能相交，又有可能不相交，但是由于已经共线，所以我们不妨直接暴力判断即可。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  N  21000</span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">dian</span>&#123;<span class="type">double</span>  x,y;&#125;;</span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">bian</span>&#123;dian  x,y;&#125;list[N];</span><br><span class="line"><span class="type">int</span>  n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">double</span>  <span class="title">mymin</span><span class="params">(<span class="type">double</span>  x,<span class="type">double</span>  y)</span></span>&#123;<span class="keyword">return</span>  x&lt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">double</span>  <span class="title">mymax</span><span class="params">(<span class="type">double</span>  x,<span class="type">double</span>  y)</span></span>&#123;<span class="keyword">return</span>  x&gt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">double</span>  <span class="title">mu</span><span class="params">(dian  x,dian  y,dian  z)</span><span class="comment">//x-&gt;y</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span>  x1=(x.x-z.x),y1=(x.y-z.y),x2=(y.x-z.x),y2=(y.y-z.y);</span><br><span class="line">	<span class="keyword">return</span>  x1*y2-x2*y1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">bool</span>  <span class="title">pd</span><span class="params">(dian  x1,dian  x2,dian  y1)</span></span>&#123;<span class="keyword">return</span>  (<span class="built_in">mymin</span>(x1.x,x2.x)&lt;=y1.x  &amp;&amp;  <span class="built_in">mymax</span>(x1.x,x2.x)&gt;=y1.x  &amp;&amp;  <span class="built_in">mymin</span>(x1.y,x2.y)&lt;=y1.y  &amp;&amp;  <span class="built_in">mymax</span>(x1.y,x2.y)&gt;=y1.y);&#125;<span class="comment">//判断y1点是否在线段x1-x2上</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">bool</span>  <span class="title">check</span><span class="params">(bian  x,bian  y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">mu</span>(y.x,x.x,x.y)*<span class="built_in">mu</span>(x.x,y.y,x.y)&gt;<span class="number">0</span>  &amp;&amp;  <span class="built_in">mu</span>(x.x,y.x,y.y)*<span class="built_in">mu</span>(y.x,x.y,y.y)&gt;<span class="number">0</span>)<span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">//普通情况</span></span><br><span class="line">	<span class="keyword">if</span>((<span class="built_in">mu</span>(x.x,x.y,y.x)==<span class="number">0</span>  &amp;&amp;  <span class="built_in">pd</span>(x.x,x.y,y.x))  ||</span><br><span class="line">	(<span class="built_in">mu</span>(x.x,x.y,y.y)==<span class="number">0</span>  &amp;&amp;  <span class="built_in">pd</span>(x.x,x.y,y.y))  ||</span><br><span class="line">	(<span class="built_in">mu</span>(y.x,y.y,x.x)==<span class="number">0</span>  &amp;&amp;  <span class="built_in">pd</span>(y.x,y.y,x.x))  ||</span><br><span class="line">	(<span class="built_in">mu</span>(y.x,y.y,x.y)==<span class="number">0</span>  &amp;&amp;  <span class="built_in">pd</span>(y.x,y.y,x.y)))<span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">//暴力判断不同的相交情况</span></span><br><span class="line">	<span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span>  bo[N];</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf%lf&quot;</span>,&amp;list[i].x.x,&amp;list[i].x.y,&amp;list[i].y.x,&amp;list[i].y.y);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span>  j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">check</span>(list[i],list[j]))&#123;bo[i]=<span class="literal">true</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//O(n^2)暴力判</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!bo[i])<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="直线交点"><a href="#直线交点" class="headerlink" title="直线交点"></a>直线交点</h2><p>注：本文不考虑共线</p>
<p>一个平面的直线除了平行一定有交点。</p>
<p>平行的情况这里不讲（实际上用截距法算一下斜率判断一下即可），但是这里要将如何在知道两条直线上的各两个点（一条直线上给出的两个点不会相同）的情况下（为什么不能知道斜率啊(#`O′)），判断其交点。</p>
<p>都知道两点确定一条直线，于是可以直接求斜率列方程求交点，但是呢，这样是不是过于麻烦了呢？</p>
<p>于是我们考虑用叉积来求。<del>其实就是想装逼</del></p>
<p>现在，我们不管两个点形成的直线，而是考虑其形成的线段。</p>
<p>先考虑给出的线段$AB$在直线$CD$的两侧（$C,D$点都为直线上任意一点）：<br><img src="10.png" alt="在这里插入图片描述"></p>
<p>注：如果你把给出的线段当成向量，那么$A,D$为起点。</p>
<p>这里先默认$A$在$B$左边，$C$在$D$上面，保证叉积是正的。</p>
<p>此时$AB=AP+BP$。</p>
<p>如果我们能求出$\frac{|AP|}{|BP|}$，那么就可以用下面这条公式算出$P$的坐标：<br>$\vec{OA}+\frac{|AP|}{|AB|}*\vec{AB}=\vec{OP}$，当然，这不就是$P$的坐标吗？</p>
<p>但是关键是怎么求$\frac{|AP|}{|AB|}$呢？</p>
<p>考虑转换成面积，$A、B$向$CD$做一条垂线。<br><img src="11.png" alt="在这里插入图片描述"></p>
<p>不难看出：$▲AEP∽▲BFP$</p>
<p>所以$\frac{AP}{BP}=\frac{AE}{BF}=\frac{S▲ABD}{S▲BCD}$</p>
<p>完美的转换成两个三角形的比值。</p>
<p>因此考虑叉积，以$D$为基准点：</p>
<p>$\frac{AP}{AB}=\frac{\vec{DC}\times \vec{DA}}{\vec{DB}\times \vec{DC}+\vec{DC}\times \vec{DA}}$</p>
<p>当然，上文中$D$在$C$下面，且$A$在$B$左边，所以叉积一直都是正的，当然，如果$C$在$D$的下面，则所有叉积取负，反正求的是比例，也没什么事，如果$A$在$B$的右边，也是如此，只是正负性的变化，但是因为同时变化，所以没有关系。</p>
<p>而且我们发现因为叉积是求逆时针的，所以旋转并不会改变正负性，只有左右翻折会（且是所有叉积的正负性都会改变，因此左右翻折不会改变叉积之间比例），而上文中，$A$与$B$互换位置其实就是翻折，$C$在$D$下面确不是完全的翻折，但是$C$在$D$下面也会导致所求的叉积全部取负，所以也不会改变比例。</p>
<p>当然，这个做法分母不够优秀，因此我们来证明一个定理。</p>
<h3 id="定理1"><a href="#定理1" class="headerlink" title="定理1"></a>定理1</h3><p>$\vec{AB}\times \vec{AC}+\vec{AC}\times \vec{AD}=\vec{AC}\times \vec{BD}$</p>
<p>为什么这两个向量公共端点没有也能乘。</p>
<p>这就是前面叉积讲解中忽略的第三种情况。</p>
<p>对于$\vec{AC}$，我们用$C$的坐标减去$A$的坐标，相当于把$\vec{AC}$移到$\vec{O?}$的位置，把起点设为$O$，然后两个向量都如此操作后得到的叉积值。</p>
<p>或者你也可以理解为通过同样的方式把一个向量的起点移到另外一个向量的起点，以此统一起点。</p>
<p><img src="12.png" alt="在这里插入图片描述"></p>
<p>而在这个直线交点的证明的后半部分，基本都是用这种方式，于是又多了一个性质：</p>
<p>$\vec{AB}\times \vec{CD}=-\vec{BA}\times \vec{CD}$</p>
<p>证明的话，同底等高的三角形面积相同，且由于方向问题，取个符号。</p>
<p>于是不管是叉积的顺序还是向量内部的顺序，都显得十分重要。</p>
<p>回归正题。</p>
<p>证明：</p>
<p>$(x_{B}-x_{A})(y_{C}-y_{A})-(y_{B}-y_{A})(x_{C}-x_{A})+(x_{C}-x_{A})(y_{D}-y_{A})-(y_{C}-y_{A})(x_{D}-x_{A})$</p>
<p>$=(x_{B}-x_{A})(y_{C}-y_{A})-(y_{C}-y_{A})(x_{D}-x_{A})-(y_{B}-y_{A})(x_{C}-x_{A})+(x_{C}-x_{A})(y_{D}-y_{A})$</p>
<p>$=(x_{B}-x_{D})(y_{C}-y_{A})-(y_{B}-y_{D})(x_{C}-x_{A})$</p>
<p>$=(y_{D}-y_{B})(x_{C}-x_{A})-(x_{D}-x_{B})(y_{C}-y_{A})$</p>
<p>$=\vec{AC}\times \vec{BD}$</p>
<p>可视化理解：</p>
<p><img src="13.png" alt="在这里插入图片描述"></p>
<h3 id="运用定理1优化"><a href="#运用定理1优化" class="headerlink" title="运用定理1优化"></a>运用定理1优化</h3><p>$\frac{|AP|}{|AB|}=\frac{\vec{DC}\times \vec{DA}}{\vec{DB}\times \vec{DC}+\vec{DC}\times \vec{DA}}=\frac{\vec{DC}\times \vec{DA}}{\vec{DC}\times \vec{BA}}=\frac{\vec{DC}\times \vec{DA}}{\vec{AB}\times \vec{DC}}$</p>
<h3 id="更加广泛的情况"><a href="#更加广泛的情况" class="headerlink" title="更加广泛的情况"></a>更加广泛的情况</h3><p>当然，还有$A,B$在直线同侧的情况，</p>
<p><img src="14.png" alt="在这里插入图片描述"></p>
<p>同样，先保证 $\vec{DC}\times \vec{DA}$ 是正的，且 $B$ 在 $A$ 右边，$C$ 在 $D$ 上面。</p>
<p>此时 $AB=AP-BP$，一样可以 $\frac{AP}{BP}=\frac{AE}{BF}=\frac{S▲ABD}{S▲BCD}$</p>
<p>但是我们发现 $-BP$ 难搞啊，但是 $\vec{DB}\times \vec{DC}$ 就是负的，完美，这种情况证毕。</p>
<p>于是考虑翻折和旋转，我们只要证明了 $A,B$ 在直线 $C,D$ 的左边的情况是成立的，旋转便可以得到所有的情况。</p>
<p>很明显，$C,D$ 的上下关系改变所有的叉积正负性，比例不变，但是$B$在$A$左边时，我们发现，正负性都没有改变，应该没有影响吧，但是算出来的 $\frac{AP}{AB}$ 变成了负数（但比例绝对值对的）？但是发现 $\vec{AB}$ 与 $\vec{AP}$ 方向反了，负数刚好调过来，完美，因此得证。</p>
<p><del>考场直接记住结论他不香吗。</del></p>
<p>实际上，你从假设给出的两条线段有交点的方向推出的公式，基本上是可以推广到所有情况的，在考场上忘了直接这样推就行了（记住推的思路是最好的），当然不排除推广不了的情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span>  <span class="type">double</span>  <span class="title">muu</span><span class="params">(dian  x1,dian  x2)</span></span>&#123;<span class="keyword">return</span>  x1.x*x2.y-x2.x*x1.y;&#125;<span class="comment">//叉积</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span>  dian  <span class="title">jd</span><span class="params">(line  x,line  y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> w =<span class="built_in">muu</span>((y.y-y.x),(x.x-y.x))/<span class="built_in">muu</span>((x.y-x.x),(y.y-y.x));</span><br><span class="line">    <span class="keyword">return</span> x.x+(x.y-x.x)*w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【题意】</span><br><span class="line">在一个平面坐标系上有n个点，用笔画一个多边形，使得多边形包含这n个点（点在多边形的边上也算包含）。</span><br><span class="line">求多边形的最小周长。</span><br><span class="line">【输入格式】</span><br><span class="line">第一行整数 n (1 &lt;= n &lt;= 1000),表示有n个点。</span><br><span class="line">下来n行，每行两个整数x（横坐标）和y（纵坐标），表示点坐标（-10000&lt;=x,y&lt;=10000)。</span><br><span class="line">【输出格式】</span><br><span class="line">一行一个实数，即多边形的最小周长（保留4位小数）。</span><br><span class="line">【样例1输入】</span><br><span class="line">4</span><br><span class="line">2 1</span><br><span class="line">5 1</span><br><span class="line">5 5</span><br><span class="line">2 5</span><br><span class="line">【样例1输出】</span><br><span class="line">14.0000</span><br><span class="line"></span><br><span class="line">【样例2输入】</span><br><span class="line">5</span><br><span class="line">2 1</span><br><span class="line">5 1</span><br><span class="line">3 2</span><br><span class="line">5 3</span><br><span class="line">2 3</span><br><span class="line">【样例2输出】</span><br><span class="line">10.0000</span><br></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="凸包初步概念"><a href="#凸包初步概念" class="headerlink" title="凸包初步概念"></a>凸包初步概念</h3><p>即找到最小的凸多边形包括我们给出点集 $V$ 。</p>
<h3 id="转换思路"><a href="#转换思路" class="headerlink" title="转换思路"></a>转换思路</h3><p>不难发现凸包就是最小周长：</p>
<p>非凸多边形很明显可以用三角形两边之和小于第三边来证明。</p>
<p><img src="15.png" alt=""></p>
<p>其余的凸多边形，一定比凸包周长要大，感性的理解就是拿个橡皮筋，在一个图上放手，会发现其就是凸包，且是最小周长，但是理性证明，不会。</p>
<h3 id="凸包求法"><a href="#凸包求法" class="headerlink" title="凸包求法"></a>凸包求法</h3><p>Orz wjyyy奆佬手推凸包。</p>
<p>但是这里不讲上下凸包合并。</p>
<p>讲一个算法：graham扫描法。</p>
<h4 id="凸包的性质"><a href="#凸包的性质" class="headerlink" title="凸包的性质"></a>凸包的性质</h4><p>介绍这种算法不妨从凸包的性质讲起。</p>
<ol>
<li>点集的最下角（即 $y$ 最小，$y$ 相同 $x$ 最小）的点一定是凸包的顶点，设这个点为 $x$ ，不难发现对于点集中任意一点$y(y≠x)$，$\vec{xy}$ 的幅角都非负。</li>
<li>从 $x$ 逆时针遍历凸包的顶点，得到$a$顶点序列（ $k$ 个点），其中 $a_1=x,a_{i}=a_{(i-1)\%k+1}$，$\vec{xa_2},\vec{xa_3},…,\vec{xa_k}$ 的幅角严格递增，且都非负。</li>
<li>顶点序列中对于 $(1≤i≤k)$，$∠a_{i}a_{i+1}a_{i+2}<180°$，$\vec{a_{i}a_{i+1}}\times \vec{a_{i}a_{i+2}}>0$（注意这条，如果对于一个多边形满足这条公式，其是凸多边形<del>应该，至少凸包就是用这个判断的。</del>）。</li>
</ol>
<p><del>不要问我证明，我也不会证明，再问就是显然</del></p>
<h4 id="凸包的求法"><a href="#凸包的求法" class="headerlink" title="凸包的求法"></a>凸包的求法</h4><p>根据第一条性质，找到一个点，并且把其放到第一个点，在把剩余的点，按照其和第一个点形成的向量的幅角排序（幅角相同，长度小的优先）。</p>
<p>这样排序有个什么好处呢？这样保证了排序中最后那个点一定在凸包中。</p>
<p>用栈维护目前凸包的点序列，设现在栈中有 $top$ 个点，现在新加入$x$点，如果$top=1$，无条件假如，如果不是，$\vec{a_{top-1}a_{top}}\times \vec{a_{top-1}x}&gt;0$ ，加入，否则 $a_{top}$ 在凸包的边上或者内部，弹出，然后不断判断，知道$x$可以加入为止。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>时间复杂度：$O(nlogn)$。</p>
<p><del>几年前的代码好难看啊。</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span>  std;</span><br><span class="line"><span class="type">int</span>  n;</span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span>  x,y;</span><br><span class="line">&#125;a[<span class="number">2100</span>];<span class="type">double</span>  ans;</span><br><span class="line"><span class="function"><span class="type">double</span>  <span class="title">ins</span><span class="params">(node  x,node  y)</span></span>&#123;<span class="keyword">return</span>  <span class="built_in">sqrt</span>(<span class="built_in">double</span>((x.x-y.x)*(x.x-y.x))+<span class="built_in">double</span>((x.y-y.y)*(x.y-y.y)));&#125;</span><br><span class="line"><span class="function"><span class="type">double</span>  <span class="title">mutle</span><span class="params">(node  x,node  y,node  z<span class="comment">/*基准点*/</span>)</span><span class="comment">//叉积</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span>  x1=x.x-z.x,y1=x.y-z.y,x2=y.x-z.x,y2=y.y-z.y;</span><br><span class="line">    <span class="keyword">return</span>  x1*y2-x2*y1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span>  <span class="title">cmp</span><span class="params">(node  x,node  y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span>  okk=<span class="built_in">mutle</span>(y,x,a[<span class="number">1</span>]);<span class="comment">//反正幅角都是非负的，这样判断也可以。</span></span><br><span class="line">    <span class="keyword">if</span>(okk&gt;<span class="number">0</span>)<span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span>  <span class="keyword">if</span>(okk&lt;<span class="number">0</span>)<span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span>  k1=<span class="built_in">ins</span>(x,a[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">double</span>  k2=<span class="built_in">ins</span>(y,a[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(k1&gt;k2)<span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span>  <span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">node  list[<span class="number">2100</span>];</span><br><span class="line"><span class="type">int</span>  top;</span><br><span class="line"><span class="function">node  <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">2</span>,a+n+<span class="number">1</span>,cmp);</span><br><span class="line">    top=<span class="number">2</span>;list[<span class="number">1</span>]=a[<span class="number">1</span>];list[<span class="number">2</span>]=a[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(top&gt;<span class="number">1</span>  &amp;&amp;  <span class="built_in">mutle</span>(list[top],a[i],list[top<span class="number">-1</span>])&gt;<span class="number">0</span>)top--;</span><br><span class="line">        list[++top]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span>  x,y;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">    a[<span class="number">1</span>].x=x*<span class="number">1.0</span>;a[<span class="number">1</span>].y=y*<span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        a[i].x=x*<span class="number">1.0</span>;a[i].y=y*<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[i].y&lt;a[<span class="number">1</span>].y  ||  (a[i].y==a[<span class="number">1</span>].y  &amp;&amp;  a[i].x&lt;a[<span class="number">1</span>].x))</span><br><span class="line">        &#123;</span><br><span class="line">            node  t=a[i];a[i]=a[<span class="number">1</span>];a[<span class="number">1</span>]=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>  i=<span class="number">2</span>;i&lt;=top;i++)ans+=<span class="built_in">ins</span>(list[i],list[i<span class="number">-1</span>]);</span><br><span class="line">    ans+=<span class="built_in">ins</span>(list[<span class="number">1</span>],list[top]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.4lf\n&quot;</span>,ans);</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="课内可能会用到的数学知识福利"><a href="#课内可能会用到的数学知识福利" class="headerlink" title="课内可能会用到的数学知识福利"></a>课内可能会用到的数学知识福利</h1><h2 id="点到直线的距离"><a href="#点到直线的距离" class="headerlink" title="点到直线的距离"></a>点到直线的距离</h2><p>这里放上一个大佬的另类证法,很强！</p>
<p><a href="https://baijiahao.baidu.com/s?id=1613918613327049797&amp;wfr=spider&amp;for=pc">大佬</a></p>
<p><img src="16.png" alt="在这里插入图片描述"></p>
<p><img src="17.png" alt="在这里插入图片描述"></p>
<p>膜拜大佬。</p>
<h2 id="如何将直线移动1个单位的距离？"><a href="#如何将直线移动1个单位的距离？" class="headerlink" title="如何将直线移动1个单位的距离？"></a>如何将直线移动1个单位的距离？</h2><p>这里指的是垂直距离，那么就不是+1-1的事情了，这里用两点式来进行证明其中的一种情况（其他情况也可以证）</p>
<p>现在有一条直线：$ax+by=0(a<0,b>0)$</p>
<p><img src="18.png" alt="在这里插入图片描述"></p>
<p>$AC⊥A$ 所在的直线</p>
<p>$AC=1$，设 $C$ 点的 $x$ 坐标为 $k$ ，那么我们可以求出 $AC$ 的两点时 $bx-ay=0$ ，那么进而求出 $AD=-\frac{bx}{a}$ ，勾股得出 $AC=\frac{x\sqrt{a^{2}+b^{2}}}{-a}=1$ ，那么 $x=\frac{-a\sqrt{a^{2}+b^{2}}}{a^{2}+b^{2}}$，那么 $C(\frac{-a\sqrt{a^{2}+b^{2}}}{a^{2}+b^{2}},\frac{-b\sqrt{a^{2}+b^{2}}}{a^{2}+b^{2}})$ ，然后我们通过将 $x,y$ 带入 $ax+by+?$ 求出 $?$ 是 $\sqrt{a^{2}+b^{2}}$ ，那么我们就知道移动 $1$ 就是加减 $\sqrt{a^{2}+b^{2}}$ 。</p>
<h1 id="两直线交点看不懂版"><a href="#两直线交点看不懂版" class="headerlink" title="两直线交点看不懂版"></a>两直线交点看不懂版</h1><p>现在我是看不懂我以前写什么了。<del>而且这个证法好像还不严谨</del></p>
<p>但是本着保留思想的心态，我把其保留了下来，可以不看，完全没有看的必要。<del>毕竟我自己写的东西自己也没看看懂</del></p>
<p>难道我们求两线交点就只能列一个二元一次方程？</p>
<p>不，我们可以用叉积！！！</p>
<p>看如下图：</p>
<p><img src="19.png" alt="在这里插入图片描述"></p>
<p>如何求 $\frac{AP}{CP}$？</p>
<p>我们做一条垂线：</p>
<p><img src="20.png" alt="在这里插入图片描述"></p>
<p>我们 $\frac{AE}{BF}=\frac{S▲ABD}{S▲CBD}$，$∠APE=∠CPF，∠AEP=∠CFP$，所以$▲AEP∽▲CFP$，所以 $\frac{AP}{CP}=\frac{AE}{CF}=\frac{S▲ABD}{S▲CBD}$</p>
<p>而这个面积是可以用叉积来求的。</p>
<p>我们设 $t1,t2$ 分别为以 $C$ 为基准点旋到 $A,B$ 的叉积。</p>
<p>两种情况：</p>
<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p><img src="21.png" alt="在这里插入图片描述"></p>
<p>此处 $t1<0,t2>0$</p>
<p>$P$ 点坐标？</p>
<p>列波式子（求 $x$ 坐标，$y$ 坐标一样，在这里推导过程省略原因，多用相似三角形）：</p>
<script type="math/tex; mode=display">\begin{align*}
&x1+\frac{-(x2-x1)*t1}{t2-t1}\\
=&\frac{x1(t2-t1)-(x2-x1)*t1}{t2-t1}\\
=&\frac{x1*t2-x2*t1}{t2-t1}\\
=&\frac{t1*x2-t2*x1}{t1-t2}
\end{align*}</script><p>当然，死记硬背也没问题：$122112$。</p>
<h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p><img src="22.png" alt="在这里插入图片描述"></p>
<p>那么这个的长这样：</p>
<p><img src="23.png" alt="在这里插入图片描述"></p>
<p>在此$t1&lt;0,t2&lt;0$</p>
<script type="math/tex; mode=display">\begin{align*}
&x1+\frac{-(x2-x1)*t1}{t2-t1}\\
=&\frac{x1(t2-t1)-(x2-x1)*t1}{t2-t1}\\
=&\frac{x1*t2-x2*t1}{t2-t1}\\
=&\frac{t1*x2-t2*x1}{t1-t2}
\end{align*}</script><p>等会，这个很眼熟！！！</p>
<p>跟上面一样，所以用这个就行了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span>  dian  <span class="title">jd</span><span class="params">(line  x,line  y)</span><span class="comment">//怎么可能用inline</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">double</span>  t1=<span class="built_in">mu</span>(x.x,y.x,y.y),t2=<span class="built_in">mu</span>(x.y,y.x,y.y);</span><br><span class="line">	<span class="keyword">return</span>  <span class="built_in">dian</span>((t1*x.y.x-t2*x.x.x)/(t1-t2),(t1*x.y.y-t2*x.x.y)/(t1-t2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这还仅仅是入门啊QAQ。</p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>Vizing 定理学习笔记</title>
    <url>/2024/05/28/%E8%BE%B9%E6%9F%93%E8%89%B2%E4%B8%8E-Vizing-%E5%AE%9A%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>本来想一直咕咕咕的，结果没想到最近比赛用到 Vizing 定理了，这下不能咕了。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>简单图：无重边和自环的无向图。（事实上有自环不影响 Vizing 定理的正确性，自环性质太好了，直接染上这个点没有表现的颜色就行了）</p>
<p>一个点的度数为 $d(x)$ ，其中 $\Delta = \max\limits_{x\in V}d(x)$ ，即最大度数。</p>
<p>对于一个边染色 $c$，如果一个点有一条 $c$ 颜色的边，我们称 $c$ 在这个点上表现，一个点的表现颜色数为 $c(x)$ ，边的颜色为 $c(x,y)$ ，称一个边染色合法当且仅当对于每个点：$d(x)=c(x)$ ，即一个颜色不会在一个点重复出现两次，同时称此时的颜色数是合法的。</p>
<p>称一个染色方案 $c^{\prime}$ 为另一个染色方案 $c$ 的优化，当且仅当 ：$\forall c^{\prime}_{x}\ge c_{x}$ ，且存在 $x$ 是 $&gt;$ 号。</p>
<p>一个染色方案称为最优当且仅当其不能被优化，显然一个颜色数合法当且仅当其的其中一个最优染色方案合法。</p>
<p>称：$\chi$ 为最小的合法颜色数，显然有：$\chi\ge \Delta$ 。</p>
<h1 id="Vizing-定理"><a href="#Vizing-定理" class="headerlink" title="Vizing 定理"></a>Vizing 定理</h1><h2 id="简单图上-Vizing-定理的证明"><a href="#简单图上-Vizing-定理的证明" class="headerlink" title="简单图上 Vizing 定理的证明"></a>简单图上 Vizing 定理的证明</h2><p>引理 1 ：对于一个不是奇圈的连通图，存在一种两种颜色边染色（不一定合法）满足 ：$\forall x\in V,d(x)\ge 2 : c(x)\ge 2$ </p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>假设图是一个欧拉图，即所有点度数为偶数，那么如果度数都为 $2$ ，就是一个环，显然必须得是偶环。</p>
<p>否则存在度数 $\ge 4$ 的点 $x$ ，以该点为起点做欧拉回路 ：$x-e_1-x_{1}-e_{2}-…-x$ ，那么每个点都一定在中间出现过一次，所以 $\forall x\in V, c(x)\ge 2$ 。（奇数和偶数的边为不同的颜色）</p>
<p>假设不是欧拉图，此时不可能是奇环，直接新建一个点 $t$ ，把所有奇点连向他，构成一个欧拉图，然后以 $t$ 为起点跑回路，显然这符合要求。</p>
</div></details>
<p>引理 2 ：一个方案最优的必要条件：若 $i_1$ 在 $x$ 处不表现，$i_2$ 表现两次，则 $E_{i_1}\cup E_{i_2}$ 中 $x$ 所在的连通块是个奇环。</p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>显然，不是个奇环就存在两种颜色的染色，根据那种染色重新染上 $i_1,i_2$ ，则一定优化了，证毕。</p>
<p>本来想用增广路证明的，但是发现只能证明从 $x$ 出发的 $i_2-i_1-…$ 的增广路一定是个奇环，离证明连通块是个奇环还有点距离，遂放弃。</p>
</div></details>
<p><strong>Vizing 定理</strong>：对于简单图，$\Delta \le \chi \le \Delta + 1$ </p>
<details class="toggle" ><summary class="toggle-button" style="">证明</summary><div class="toggle-content"><p>反证法，假设 $\chi &gt; \Delta+1$</p>
<p>我们假设一种 $\Delta + 1$ 的最优染色方案。</p>
<p>存在 $u:c(u)&lt;d(u)$ ，那么 $i_{0}$ 在 $x$ 上不表现，$i_{1}$ 表现两次，假设 $c(v_{1},u)=i_1$ ，$i_2$ 不在 $v_{1}$ 上表现，那么一定存在 $v_{2}$ ：$c(v_{2},u)=i_2$ ，否则能优化。</p>
<p>优化：$i_{l+1}$ 不在 $u$ 表示，那么给 $(u,v_{i})$ 染色 $i_{i+1}$ 色就可以优化了。</p>
<p>一直这样下去，直到：$\exist k:i_{k}=i_{l+1}$ （显然 $v$ 序列是不重复的），其中显然 $l\ge 2,k&lt;l$，也就是下面的 $a$ 图。</p>
<p><img src="1.png" alt=""></p>
<p>上面的图片截自参考资料中的视频，来源是 bondy 图论，很老的一个教材。</p>
<p>优化染色，若 $k&gt;1$ ，那么：</p>
<p>给 $\forall 1\le i &lt;k,c^{\prime}(u,v_{i})=i_{i+1}$ ，其余与 $c$ 一样。</p>
<p>和上面的 $b$ 图一样，这样 $E_{i_{0}}\cup E_{i_{k}}$ 中 $u$ 所在的连通块是一个奇环。</p>
<p>然后再基于 $c^{\prime}$ 构造一个新的染色：$\forall k\le i\le l,c^{\prime\prime}(u,v_{i})=i_{l+1}$ ，也就是上面的 $c$ 图，那么此时原来的奇环中，只有 $(u,v_{k})$ 消失了，则剩下的一定不是奇环，相对于 $c^{\prime\prime}$ 可以优化，可以验证，$c^{\prime\prime}$ 不劣于 $c$ ，所以这就构造了一个优化的方案，矛盾。</p>
<p>如果 $k=1$ 那么存在 $v≠v_{1}:c(u,v)=i_{1}$ ，则 $v,v_{1}$ 在奇环中，$\forall 1\le i\le l,c^{\prime}(u,v_{i})=i_{i+1}$ ，那么类似的，奇环断成链，可以优化，矛盾，证毕。</p>
<p>那么重边会导致什么问题呢？可能会导致 $v$ 序列有重复，注意到我们上面重新染色的时候，$c^{\prime}(u,v_{i})=i_{i+1}$ ，这个染色严格不劣的原因是 $i_{i+1}$ 在 $v_{i}$ 上不表现，但是如果 $v$ 序列有重复，就可能把 $v_{i}$ 的两个颜色染成 $i_{i+1}$ ，这样就可能导致更劣的结果，导致我们并没有得到更优的方案，证明不再成立。</p>
<p>一个简单的例子：三角形，但每条边重复两次，手模一下就知道我说的是什么意思了。</p>
</div></details>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>题目链接：<a href="https://uoj.ac/problem/444">https://uoj.ac/problem/444</a></p>
<p>题目大意：给你一个二分图，要求支持加边删边，左右点集和 $k$ 固定，然后问在给边 $k$ 染色后，每个点的每个颜色的最大出现次数 - 最小出现次数的和最小是多少，给出染色方案。</p>
<h2 id="补充结论"><a href="#补充结论" class="headerlink" title="补充结论"></a>补充结论</h2><ol>
<li><p>偶图一定是：$\chi = \Delta$ 。（证明：偶图没有奇环）</p>
</li>
<li><p>非简单图中，设 $u$ 是一条边重复次数的最大值，那么 $\chi\le \Delta + u$ ，我不会证明。</p>
<p>这里放个讲解证明的视频：<a href="https://www.bilibili.com/video/BV1984y1V7Rx/?vd_source=5dd17c0f68b735f1a16d0353c08bcc7a">https://www.bilibili.com/video/BV1984y1V7Rx/?vd_source=5dd17c0f68b735f1a16d0353c08bcc7a</a> 。</p>
<p>再放篇论文：<a href="https://www.doc88.com/p-7488843216853.html?r=1">https://www.doc88.com/p-7488843216853.html?r=1</a> 。</p>
</li>
</ol>
<h2 id="二分图上的构造算法"><a href="#二分图上的构造算法" class="headerlink" title="二分图上的构造算法"></a>二分图上的构造算法</h2><p>类似上面定理的证明方法，考虑增量法，每次加入 $(x,y)$ ，如果 $c_1$ 在 $x$ 上不表现，并且在 $y$ 上不表现，那么就染色，否则找以 $y$ 为起点的增广路，满足 $c_1,c_2$ 交错出现，而且 $c_2$ 在 $y$ 上不表现，由于原来是合法染色，所以增广路一定不会找到环，交换一下颜色然后染色即可。</p>
<p>找增广路的复杂度是 $O(n)$ 的，因为可以每个点记录一下染什么颜色的是什么边。</p>
<p>时空复杂度：$O(nm)$ 。</p>
<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.luogu.com.cn/problem/AT_agc037_d">https://www.luogu.com.cn/problem/AT_agc037_d</a></p>
<p>题目大意：给一个矩形，矩形中的数字都是 $[1,nm]$ 且不同，然后有三次操作，第一次对所有行重排，第二次对所有列重排，第三次对所有行重排，给一种方案使得最后矩形变成 $1,2,3,….$ 的矩形。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>虽然有 Hall 定理的做法，但是 Hall 定理只能做到 $O(n^4)$ 的复杂度，</p>
<p>考虑问题等价于每一行和其有的颜色连边，则行和颜色构成二分图，然后就是给每条边染色的问题，颜色代表列，时间复杂度：$O(n*nm)=O(n^2m)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n, m, a[N][N], b[N][N], c[N][N];</span><br><span class="line"><span class="type">int</span> match[N * <span class="number">2</span>][N];</span><br><span class="line">PII e[N * N], pos[N * N]; <span class="type">int</span> col[N * N];</span><br><span class="line"><span class="type">int</span> sta[N * <span class="number">2</span>], top;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="type">int</span> &amp;x = a[i][j];</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            e[++tmp] = &#123;i, (x - <span class="number">1</span>) / m + <span class="number">1</span> + n&#125;;</span><br><span class="line">            pos[tmp] = &#123;i, j&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * m; i++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> [x, y] = e[i];</span><br><span class="line">        <span class="type">int</span> c1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!match[x][j]) &#123;c1 = j; <span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(match[y][c1])&#123;</span><br><span class="line">            <span class="type">int</span> c2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!match[y][j]) &#123;c2 = j; <span class="keyword">break</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sta[top = <span class="number">1</span>] = y;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(top &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!match[sta[top]][c1]) <span class="keyword">break</span>;</span><br><span class="line">                    sta[top + <span class="number">1</span>] = e[match[sta[top]][c1]].first;</span><br><span class="line">                    col[match[sta[top]][c1]] = c2;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!match[sta[top]][c2]) <span class="keyword">break</span>;</span><br><span class="line">                    sta[top + <span class="number">1</span>] = e[match[sta[top]][c2]].second;</span><br><span class="line">                    col[match[sta[top]][c2]] = c1;</span><br><span class="line">                &#125;</span><br><span class="line">                top++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= top; j++) <span class="built_in">swap</span>(match[sta[j]][c1], match[sta[j]][c2]);</span><br><span class="line">        &#125;</span><br><span class="line">        col[i] = c1;</span><br><span class="line">        match[x][c1] = match[y][c1] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * m; i++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> [x, y] = pos[i];</span><br><span class="line">        b[x][col[i]] = a[x][y];</span><br><span class="line">        c[e[i].second - n][col[i]] = a[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) cout &lt;&lt; b[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) cout &lt;&lt; c[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h2 id="简单图上的构造算法"><a href="#简单图上的构造算法" class="headerlink" title="简单图上的构造算法"></a>简单图上的构造算法</h2><p>有一个 $O(nm)$ 的算法，叫：Misra &amp; Gries edge coloring algorithm</p>
<p>我不会，这里给个连接：<a href="https://en.wikipedia.org/wiki/Vizing%27s_theorem">https://en.wikipedia.org/wiki/Vizing%27s_theorem</a></p>
<p>理论上你会了后，可以直接薄纱这道题目：<a href="https://qoj.ac/contest/329/problem/3979">https://qoj.ac/contest/329/problem/3979</a> ，但疑似感觉有点过于麻烦了。</p>
<h1 id="色多项式"><a href="#色多项式" class="headerlink" title="色多项式"></a>色多项式</h1><p>没看懂，OIwiki 上有，在这里占个坑先，大概率不会用到，先不学了。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.cnblogs.com/CDOI-24374/p/16530126.html">https://www.cnblogs.com/CDOI-24374/p/16530126.html</a></p>
<p><a href="https://www.cnblogs.com/yspm/p/15376796.html">https://www.cnblogs.com/yspm/p/15376796.html</a></p>
<p><a href="http://magic.vicp.io/oi-wiki/graph/color/">http://magic.vicp.io/oi-wiki/graph/color/</a></p>
<p><a href="https://blog.csdn.net/qq_42101694/article/details/120638638">https://blog.csdn.net/qq_42101694/article/details/120638638</a></p>
<p><a href="https://www.bilibili.com/video/BV1oT411j7Q8/?spm_id_from=333.788&amp;vd_source=5dd17c0f68b735f1a16d0353c08bcc7a">https://www.bilibili.com/video/BV1oT411j7Q8/?spm_id_from=333.788&amp;vd_source=5dd17c0f68b735f1a16d0353c08bcc7a</a></p>
<p><a href="https://www.bilibili.com/video/BV1984y1V7Rx/?vd_source=5dd17c0f68b735f1a16d0353c08bcc7a">https://www.bilibili.com/video/BV1984y1V7Rx/?vd_source=5dd17c0f68b735f1a16d0353c08bcc7a</a></p>
<p><a href="https://www.doc88.com/p-7488843216853.html?r=1">https://www.doc88.com/p-7488843216853.html?r=1</a></p>
<p><a href="https://www.luogu.com.cn/problem/solution/AT_agc037_d">https://www.luogu.com.cn/problem/solution/AT_agc037_d</a></p>
<p><a href="https://qoj.ac/download.php?type=attachments&amp;id=329&amp;r=1">https://qoj.ac/download.php?type=attachments&amp;id=329&amp;r=1</a></p>
<p><a href="https://en.wikipedia.org/wiki/Vizing%27s_theorem">https://en.wikipedia.org/wiki/Vizing%27s_theorem</a></p>
<p><a href="https://zh.wikipedia.org/wiki/Vizing%E5%AE%9A%E7%90%86">https://zh.wikipedia.org/wiki/Vizing%E5%AE%9A%E7%90%86</a></p>
]]></content>
      <categories>
        <category>信息学</category>
      </categories>
      <tags>
        <tag>Vizing 定理</tag>
      </tags>
  </entry>
</search>
