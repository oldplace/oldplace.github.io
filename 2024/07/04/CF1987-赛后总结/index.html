<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CF1987 赛后总结 | Oldplace</title><meta name="author" content="player"><meta name="copyright" content="player"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="比赛链接：https:&#x2F;&#x2F;codeforces.com&#x2F;contest&#x2F;1987 A. Upload More RAM题目链接：https:&#x2F;&#x2F;codeforces.com&#x2F;contest&#x2F;1987&#x2F;problem&#x2F;A 题目大意：略。 做法答案是 ：$(n-1)k+1$ 。  B.K-Sort题目链接：https:&#x2F;&#x2F;codeforces.com&#x2F;contest&#x2F;1987&#x2F;problem&#x2F;B 题目">
<meta property="og:type" content="article">
<meta property="og:title" content="CF1987 赛后总结">
<meta property="og:url" content="http://oldplace.github.io/2024/07/04/CF1987-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Oldplace">
<meta property="og:description" content="比赛链接：https:&#x2F;&#x2F;codeforces.com&#x2F;contest&#x2F;1987 A. Upload More RAM题目链接：https:&#x2F;&#x2F;codeforces.com&#x2F;contest&#x2F;1987&#x2F;problem&#x2F;A 题目大意：略。 做法答案是 ：$(n-1)k+1$ 。  B.K-Sort题目链接：https:&#x2F;&#x2F;codeforces.com&#x2F;contest&#x2F;1987&#x2F;problem&#x2F;B 题目">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://oldplace.github.io/img/my%20avatar.jpg">
<meta property="article:published_time" content="2024-07-04T01:38:01.000Z">
<meta property="article:modified_time" content="2024-07-06T12:50:54.517Z">
<meta property="article:author" content="player">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://oldplace.github.io/img/my%20avatar.jpg"><link rel="shortcut icon" href="/img/author16.png"><link rel="canonical" href="http://oldplace.github.io/2024/07/04/CF1987-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CF1987 赛后总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-07-06 20:50:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4233465_4sh0n7ckry.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/my%20avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">159</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">70</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img fixed" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Oldplace"><span class="site-name">Oldplace</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">CF1987 赛后总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-07-04T01:38:01.000Z" title="发表于 2024-07-04 09:38:01">2024-07-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-06T12:50:54.517Z" title="更新于 2024-07-06 20:50:54">2024-07-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BF%A1%E6%81%AF%E5%AD%A6/">信息学</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>38分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CF1987 赛后总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><p>比赛链接：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1987">https://codeforces.com/contest/1987</a></p>
<h1 id="A-Upload-More-RAM"><a href="#A-Upload-More-RAM" class="headerlink" title="A. Upload More RAM"></a>A. Upload More RAM</h1><p>题目链接：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1987/problem/A">https://codeforces.com/contest/1987/problem/A</a></p>
<p>题目大意：略。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>答案是 ：$(n-1)k+1$ 。</p>
</div></details>
<h1 id="B-K-Sort"><a href="#B-K-Sort" class="headerlink" title="B.K-Sort"></a>B.K-Sort</h1><p>题目链接：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1987/problem/B">https://codeforces.com/contest/1987/problem/B</a></p>
<p>题目大意：略。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>显然每个数字最多变到前缀 max 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[N], n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">    LL ans = <span class="number">0ll</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        pre = <span class="built_in">max</span>(pre, a[i]);</span><br><span class="line">        a[i] = pre - a[i];</span><br><span class="line">        ans += a[i];</span><br><span class="line">        val = <span class="built_in">max</span>(val, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ans += val;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="C-Basil’s-Garden"><a href="#C-Basil’s-Garden" class="headerlink" title="C. Basil’s Garden"></a>C. Basil’s Garden</h1><p>题目链接：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1987/problem/C">https://codeforces.com/contest/1987/problem/C</a></p>
<p>题目大意：略。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>倒着做，答案要么是他自己，要么是后面的答案加一。</p>
</div></details>
<h1 id="D-World-is-Mine"><a href="#D-World-is-Mine" class="headerlink" title="D. World is Mine"></a>D. World is Mine</h1><p>题目链接：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1987/problem/D">https://codeforces.com/contest/1987/problem/D</a></p>
<p>题目大意：略。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>首先，基于后手一个不改变答案的选项：不吃。</p>
<p>然后决定好哪些蛋糕是要吃的，且吃了某种蛋糕就一定要全部吃完，显然一定可以按照从左到右的顺序吃（不可以就说明这个方案不优）。</p>
<p>然后可以发现，任意一个前缀，只关心两个值：剩下的蛋糕的种类数，需要吃的蛋糕数，只要任意前缀前者大于等于后者，这个方案就是合法方案。</p>
<p>注意到，现在是三元组：前缀、剩余蛋糕种类数、需要吃的蛋糕数。</p>
<p>因此不妨考虑，在需要吃的蛋糕数相同的情况下，只维护最小的剩余蛋糕种类数。</p>
<p>原因是：假设只有需要吃的蛋糕数不同的情况下，假设 X 方案 &gt; Y 方案的。</p>
<p>假设 X 在后面能到 Z 方案，把 X 方案后面需要吃的 $X-Y$ 种蛋糕全部不吃，并且前面换成 Y 方案，可以发现，这仍然是一个合法方案，而且需要吃的蛋糕数更少，也就是更优，所以 X 所能到的方案严格劣于 Y 能到的方案。</p>
<p>至于严谨证明，可以从前缀开始，每次把一定不可能产生答案的三元组扔掉，答案一定产生于剩下的三元组中，然后前缀从左往右扫就可以证明了。</p>
<p>时间复杂度：$O(n^2)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n, dp[N][N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++) dp[i][j] = -inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="type">int</span> r = l;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; n &amp;&amp; a[r + <span class="number">1</span>] == a[l]) r++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; l; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[l - <span class="number">1</span>][j] == -inf) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> x = dp[l - <span class="number">1</span>][j];</span><br><span class="line">            dp[r][j] = <span class="built_in">max</span>(dp[r][j], x);</span><br><span class="line">            <span class="keyword">if</span>(cnt - (x + <span class="number">1</span>) &gt;= j + r - l + <span class="number">1</span>)&#123;</span><br><span class="line">                dp[r][j + r - l + <span class="number">1</span>] = <span class="built_in">max</span>(dp[r][j + r - l + <span class="number">1</span>], x + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        l = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) ans = <span class="built_in">min</span>(ans, cnt - dp[n][i]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<p>没怎么看官方题解，官方题解也是类似的 $n^2$ dp ，估计区别不大。</p>
<details class="toggle" ><summary class="toggle-button" style="">别的做法</summary><div class="toggle-content"><p>看题解说能 $n\log{n}$ ，先自己想了一个。</p>
<p>首先注意到，我们可以把颜色数记录成一个数组，排序，然后全体 $+1$ 。</p>
<p>这样问题就变成了，你可以选择一些颜色，满足前 $i$ 种颜色选择的数字和 $\le i$ 对于所有的 $i$ 都满足。</p>
<p>那么显然，按数量从小到大考虑每一种颜色是对的，不难证明，不再赘述。</p>
<p>下面是用 $O(n^2)$ 实现的版本，可以用线段树做到 $O(n\log{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[N], n, m, id[N], b[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        m = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; l++)&#123;</span><br><span class="line">            <span class="type">int</span> r = l;</span><br><span class="line">            <span class="keyword">while</span>(r &lt; n &amp;&amp; a[r + <span class="number">1</span>] == a[r]) r++;</span><br><span class="line">            a[++m] = r - l + <span class="number">2</span>;</span><br><span class="line">            l = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) id[i] = i, b[i] = i;</span><br><span class="line">        <span class="built_in">sort</span>(id + <span class="number">1</span>, id + m + <span class="number">1</span>, [](<span class="type">int</span> x, <span class="type">int</span> y)&#123;<span class="keyword">return</span> a[x] &lt; a[y];&#125;);</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="type">int</span> x = id[i];</span><br><span class="line">            <span class="type">bool</span> bk = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = x; j &lt;= m; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(b[j] &lt; a[x]) &#123;bk = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!bk) <span class="keyword">continue</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = x; j &lt;= m; j++) b[j] -= a[x];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; m - cnt &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后一翻 CF 评论区，发现有一种比我这好写的多的单 log 做法。</p>
<p>就是从左到右，直接贪心，每次尝试直接吃完这个颜色，不能吃完就尝试替换之前吃过的颜色。</p>
<p>用一个堆就可以做到 $O(n\log{n})$ ，非常的好写。</p>
<p>这乍一看很对，但是怎么证明呢？</p>
<p>我们需要证明一个引理：</p>
<p>设吃了 $k$ 种颜色的最优方案，则 $k-1$ 种颜色的最优方案就是 $k$ 种颜色最优方案的子集，（证明采用上面那个模型）</p>
<p>考虑 $k$ 种颜色的最优方案和 $k-1$ 种颜色的最优方案，消去相同的选择。</p>
<p>得到：$\{x_1,x_2,x_3,…,x_{m+1}\},\{y_1,y_2,…,y_{m}\}$ （递增排列）</p>
<p>如果存在一个 $L,t$ 满足 $x_{t},y_{t}\le L, x_{t+1},y_{t+1}&gt;L$ 吗，下标不存在认为是 $\infty$ 。</p>
<p>那么这两者一定可以交换且不影响双方的值，因为最优，所以消掉，下面认为不存在这种情况。</p>
<p>则一定有 $y_{1}&gt;x_{2}$ ，考虑对于任意 $i$ ，即 $X$ 集合的贡献为： $\sum\limits_{\forall 2\le j \le m+1,x_j\le i}cnt_{x_j}$ ，同理，$Y$ 集合有：$\sum\limits_{\forall 1\le j \le m,y_j\le i}cnt_{y_j}$ ，根据前面的说法，$X$ 合法的 $j$ 的个数 $\ge$ $Y$ 集合的，而且知道 $X$ 集合的贡献 $\ge$ $Y$ 集合的，否则交换可以使 $Y$ 集合个数不减的同时更优。</p>
<p>综上，最后，我们可以交换 $\{x_{2},…,x_{m+1}\}$ 和 $\{y_1,y_2,…,y_{m}\}$ ，得到不劣的 $X$ ，但又最优，则两者和相等，证毕。（注：上面过程之所以这么繁琐是为了交换完后仍然合法）</p>
<p>因此，我们只需要时时刻刻维护以选择颜色数为第一权重，要吃掉的食物为第二权重的最优方案就行了，也就是上面那个做法。即上面那个做法可以归纳的证明，其每次得到的方案就是方才说的最优方案。</p>
<p>这样正确性就证明完毕了。</p>
<p>这里贴一份别人的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://codeforces.com/contest/1987/submission/268356662</span></span><br><span class="line"><span class="comment">// Problem: D. World is Mine</span></span><br><span class="line"><span class="comment">// Contest: Codeforces - EPIC Institute of Technology Round Summer 2024 (Div. 1 + Div. 2)</span></span><br><span class="line"><span class="comment">// URL: https://codeforces.com/contest/1987/problem/D</span></span><br><span class="line"><span class="comment">// Memory Limit: 256 MB</span></span><br><span class="line"><span class="comment">// Time Limit: 2000 ms</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AC ios::sync_with_stdio(0); cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;Ofast&quot;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//suppose b should eat 2 1 to let a - 2</span></span><br><span class="line"><span class="comment">//but in the gready approach, b will eat 1 first and can&#x27;t eat 2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	AC;</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--) &#123;</span><br><span class="line">		<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">		map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; ma;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="type">int</span> temp; cin &gt;&gt; temp;</span><br><span class="line">			ma[temp]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> skip = <span class="number">0</span>;</span><br><span class="line">		priority_queue&lt;<span class="type">int</span>&gt; pque;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[i, j] : ma) &#123;</span><br><span class="line">			<span class="keyword">if</span> (skip &gt;= j) &#123;</span><br><span class="line">				skip -= j;</span><br><span class="line">				pque.<span class="built_in">push</span>(j);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!pque.<span class="built_in">empty</span>() &amp;&amp; pque.<span class="built_in">top</span>() &gt; j) &#123; <span class="comment">//check if current one costs less skip points</span></span><br><span class="line">				<span class="comment">//if so, reverse the prevoius operation where b stops a</span></span><br><span class="line">				skip += pque.<span class="built_in">top</span>() + <span class="number">1</span>;</span><br><span class="line">				pque.<span class="built_in">pop</span>();</span><br><span class="line">				ans++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (skip &gt;= j) &#123; <span class="comment">//let b stops a in the better scenario, which costs least skip points</span></span><br><span class="line">				skip -= j;</span><br><span class="line">				pque.<span class="built_in">push</span>(j);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ans++;</span><br><span class="line">			skip++;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<h1 id="E-Wonderful-Tree"><a href="#E-Wonderful-Tree" class="headerlink" title="E. Wonderful Tree!"></a>E. Wonderful Tree!</h1><p>题目链接：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1987/problem/E">https://codeforces.com/contest/1987/problem/E</a></p>
<p>题目大意：略。</p>
<details class="toggle" ><summary class="toggle-button" style="">做法</summary><div class="toggle-content"><p>感觉有点简单了，但是有趣。</p>
<p>注意到 $dp[x][i]$ 表示 $x$ 值为 $i$ 的时候的最小代价。</p>
<p>可以发现这是凸性的，而且斜率范围在 $[0,size]$ ，所以直接转移就行了。</p>
<p>当然这也有实际意义，差分一下，表示用代价 $k$ 让 $x$ 增加 $1$ 的操作至多能进行多少次，按照这个思路 dp 转移式就很容易列出来了。（想到这个意义并且证明这是对的还是花了我一定的时间）</p>
<p>时间复杂度：$O(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n, p[N], siz[N], a[N];</span><br><span class="line">LL f[N][N], dp[N], sum[N];</span><br><span class="line"><span class="comment">// vector&lt;int&gt; son[N];</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        siz[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">        <span class="comment">// son[p[i]].push_back(i);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(siz[i] == <span class="number">1</span>) sum[i] = inf;</span><br><span class="line">        LL res = a[i] - sum[i];</span><br><span class="line">        <span class="keyword">if</span>(res &lt; <span class="number">0</span>) f[i][<span class="number">1</span>] = -res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n &amp;&amp; res &gt; <span class="number">0</span>; j++)&#123;</span><br><span class="line">            LL s = <span class="built_in">min</span>(res, f[i][j]);</span><br><span class="line">            res -= s;</span><br><span class="line">            f[i][j] -= s;</span><br><span class="line">            dp[i] += (j - <span class="number">1</span>) * s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        siz[p[i]] += siz[i];</span><br><span class="line">        sum[p[i]] += a[i];</span><br><span class="line">        dp[p[i]] += dp[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++) f[p[i]][j + <span class="number">1</span>] += f[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="comment">// son[i].clear();</span></span><br><span class="line">        dp[i] = sum[i] = <span class="number">0ll</span>;</span><br><span class="line">        <span class="built_in">memset</span>(f[i], <span class="number">0</span>, <span class="built_in">sizeof</span>(f[i]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></details>
<details class="toggle" ><summary class="toggle-button" style="">官方做法</summary><div class="toggle-content"><p>你是真的笨啊，都长成父亲和儿子权值和的比较了，还想不到差分吗？那我只能说你是真 FW 啊。</p>
<p>总之，看了题解后，我觉得我这道题目只是根据见识硬做出来的，其实我根本就没有真正会这道题目。我有个可以过的做法，但是我并未真正触及其本质。</p>
<p>注意到这个不等式可以写成：</p>
<script type="math/tex; mode=display">a_{v}-\sum\limits_{u\in son_{v}}a_{u}\le 0</script><p>其中，如果没有儿子，就认为左式为 $-\infty$ 。</p>
<p>那么这个时候就很显然了，每次操作会把一个点 $+1$ ，父亲 $-1$ 。</p>
<p>要求用最少的步数把所有点变成 $\le 0$ 的。</p>
<p>注意到如果把每次操作，让这个点的父亲向其连一条边，表示父亲的一个 $1$ 流向了这个点，那么操作完后的图一定可以把所有边分成若干条路径，满足不存在一条路径的终点和另外一条路径的起点相同，可以看到，每条路径反映了一个 $1$ 的流向，起点包含了所有正点，终点一定是负点，贡献就是路径长度。</p>
<p>注意到最优方案中，只有正点可能作为起点，且作为起点的次数一定是其的值。（答案一定出在这个集合中）</p>
<p>那么问题可以等价的转化成求这个问题的最优解：每次将一个正点和子树内一个负电匹配，代价是距离，然后把正点 $-1$ ，负电 $+1$ ，直到没有正点为止。</p>
<p>这显然是一个费用流，所以在 CF 评论区和 luogu 都看到了赛时写费用流过题的佬。</p>
<p>当然，因为这个匹配非常简单，显然可以模拟，也不用写费用流。</p>
<p>先回看我上面的做法，实际上是在维护离当前点距离为 $d$ 的负数点能提供多少个匹配，这样就一目了然了。</p>
<p>当然，题解提供了种更好写的做法：每个点 BFS 一遍。</p>
<p>优化一下复杂度，做到 $O(n\log{n})$ 不难，把上面的数组合并写成可并堆的形式就行了。（能不能数组用启发式合并呢？不行，因为还有一个时间复杂度瓶颈是在做单点匹配的时候，需要弹出当前的最小值，数组用遍历的话复杂度仍然是 $O(n^2)$ 的）</p>
<p>能不能再快点？</p>
<p>在原图上，按深度从浅到深遍历每一个负数点，然后并查集维护到祖先的正数点，时间复杂度：$O(n\alpha(n))$ 。</p>
<p>能不能再快点？</p>
<p>可以，长链剖分，每个点用链表维护，合并的时候，两个链表至多弹出短链长度个，所以合并是 $O(n)$ 的，由于链表中的点数至多 $O(n)$ 个，所以弹出最小值也是 $O(n)$ 的。（之所以这样子归并复杂度不是两个数组长度和，是因为我实际上限制了值域范围，而不是限制了弹出个数。归并是两个数组长度和是因为短数组的最大值可能大过长数组的）</p>
<p>综上，时间复杂度为：$O(n)$ 。</p>
<p>最后说个幽默的事情，我在赛后说能启发式合并优化到 $n\log{n}$ ，因为我首先没想到弹出最小值的事情，其次我以为数组长度是和 $size$ 相关，后面问了人才发现，原来是和深度相关的。</p>
<p>很有意思。</p>
</div></details>
<h1 id="F-Interesting-Problem-Hard-Version"><a href="#F-Interesting-Problem-Hard-Version" class="headerlink" title="F. Interesting Problem (Hard Version)"></a>F. Interesting Problem (Hard Version)</h1><p>直接上 Hard Version 吧，我两个一起做的。</p>
<p>题目链接：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1987/problem/F2">https://codeforces.com/contest/1987/problem/F2</a></p>
<p>题目大意：略。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>这里，我采用复盘的形式写出我的做法，因为我觉得看懂最终做法不难，但是明白中间犯了什么错是至关重要的，以及怎么避免犯同样的错误。</p>
<p>首先可以注意到，如果在一开始就规定某些数字是作为 $a[i]=i$ 的位置被删除的，那么可以类似括号匹配一样，找到和其一起被删除的位置。</p>
<p>那么我一开始就想，会不会只要在一个位置前面能被删除的数字个数是 $\frac{i-a[i]}{2}$ ，这个位置就一定能被删除，所有都满足就合法吧。</p>
<p>当时的逻辑是，假设每次都有能删除的数字，每次选择最右边的数字删除，一定不会影响左边，而且还能贡献给右边的数字，让他们也能删除，而且最左边的数字一定能被删除。</p>
<p>然后喜提 WA ，原因：可能删除了两个左括号。</p>
<p>然后我就开始想，也就是说括号嵌套的时候，不能让内层括号的消除时间晚于外层括号，怎么办到呢？</p>
<p>显然从左往右 dp 是办不到的，不可能记录这么多信息，但是发现这是括号序列啊，这不直接区间 dp 。</p>
<p>但“晚于”这个词有点过于模糊不清了，有没有具体点的说法？</p>
<p>当时提出了一种想法，$f[l][r]$ 表示前面需要额外删多少个数字这个区间才可以完整消完（维护最小可能的解，至于为什么，写博客的时候感觉并不是很显然，但是当时很自然的就这么想了，也没质疑，反正都红了。但其实正确性也并不难，只要知道了括号序列合并和嵌套的充要条件，就可以发现维护最小值在任何时候都是最优的，所以直接维护最小值就行了，但前提是充要条件是对的），嵌套的要求一定要求外层的括号所需要删除的数字一定严格大于等于内层的。（但是具体怎么想的也忘了，太红了，但是反正差不多）</p>
<p>就关于 $f$ 的维护我就写了好几种逆天的东西，包括当不限于：找于 l 同奇偶的位置的 a 的最小值、必须要求外层有嵌套等，反正很逆天就是了，感觉就是纯红。</p>
<p>后面发现可以这么维护，区间合并的时候，前一个区间可以对后一个区间产生贡献就行了（至于为什么，也没细想），反正此时终于走上正轨了。</p>
<p>在正确的实现完这个做法后就过了。</p>
<p>时间复杂度：$O(n^3)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">8e2</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((x &amp; <span class="number">1</span>) != (a[x] &amp; <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[x] &gt; x) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">return</span> (x - a[x]) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> v[N][N];</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">20</span>, <span class="built_in">sizeof</span>(v));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) v[i][i - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len += <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l + len - <span class="number">1</span> &lt;= n; l++)&#123;</span><br><span class="line">            <span class="type">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> mid = l; mid &lt; r; mid++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v[l][mid] &gt; n &amp;&amp; v[mid + <span class="number">1</span>][r] &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">                v[l][r] = <span class="built_in">min</span>(<span class="built_in">max</span>(v[l][mid], v[mid + <span class="number">1</span>][r] - (mid - l + <span class="number">1</span>) / <span class="number">2</span>), v[l][r]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> val = <span class="built_in">calc</span>(l);</span><br><span class="line">            <span class="keyword">if</span>(val == <span class="number">-1</span> || v[l + <span class="number">1</span>][r - <span class="number">1</span>] &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(val &gt;= v[l + <span class="number">1</span>][r - <span class="number">1</span>]) v[l][r] = <span class="built_in">min</span>(val, v[l][r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[j + <span class="number">1</span>][i] &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[j] &gt;= v[j + <span class="number">1</span>][i]) dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + (i - j) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">solve</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回忆一下，我当时几乎证明了这个做法是对的，但当时非常的红温，现在来看，确实这个做法是对的，而且证明起来并不困难，但反正当时就是红温，好想只证明了嵌套和合并的条件是当下充要的，并没有考虑后效性什么的，也就是零零散散的给了些部分的证明，并没有串在一起，给一个整体的、完整的证明，当因为在比赛，这也能理解，毕竟 WA 了再想也不迟。虽然但是，我觉得这不是并不证明的借口，我认为比赛时尤其是模拟赛，该证明的东西就应该证明，先不提不会假这种显性收益，不依赖比赛反馈做题的这种习惯是可以带来很多隐形收益的，包括对自己实力的提升和心态的考验。</p>
<p>你要说这场比赛我证明了吗？几乎所有做法我都在写之前给了些零散的证明，但有用吗？没有用，该 WA 还是得 WA ，为什么？首先证明是会假的，但我认为赛时给出正确而不假的证明也是实力的一部分。其次，其实这场比赛很多时候我都知道，我给的证明并不足以称为证明，即很多时候我只给出了局部的正确性，或者是可能能证明的一个方向，我并没有给出具体的，完整的，不容易出现瑕疵的证明，这场的 D,F,G 都是这样，D,G 都可以理解，简单题和时间不够，但是 F 在这一场，就是因为这个问题 WA 了一遍又一遍，但凡我当时多动点脑子，也不至于出现这种情况。将这种碎片化的证明当成证明，等于没有证明，在赛时给出一个正确的证明，我认为这也是比赛考验我们的东西，为了 rating 而舍弃掉证明，靠比赛反馈做题，依赖应试技巧，这和高考有什么区别，抛开这些不谈，我认为过度依赖这种应试技巧，终究会被反噬，所得到的分数，不过也是虚假的分数，不足以反映真正的实力。</p>
<p>但是这又出现了一个问题，为什么队长没证明，却几乎每次都能给出一个不会假的做法。首先队长赛时不证明很久了，因此自然也有规避错误的方法，这个方法是什么呢？我觉得就是想一些极端例子，在这些极端例子下是 well done 的，这相比相信一个不完整的证明，并且没有尝试证伪好多了。简单来说，队长多了个证伪的过程，而且队长证伪能力很强（相应的，他构造水平很高），证伪也是一种能力，至少比纯猜靠反馈要好的多。但你要说这也是种应试技巧，那也算是。但是很多时候极端证伪的过程和证明几乎也没有区别了，所以自然几乎次次都能证伪的话，证明的能力自然也不会差，在比赛时不失为一种策略，虽然我仍然不觉得这是赛时能够考验自己真正实力的习惯。但是队长真正实力也确实很厉害，那我只能认为队长每次的证伪其实和证明已经没有区别了，也就是换个说法的问题。（事实也是每次和他一起打比赛，让他给证明的时候他也能给出证明，队长厉害，无需多言）</p>
<p>所以我认为，比赛时该证明的时候，就要给出一个好的证明，不要过度关注那些排名和 rating 啥的，导致忽略了真正的修行。</p>
<p><strong>回归正题</strong>，怎么证明这个 dp 是充要的呢？</p>
<p>首先明确给出 dp[l][r] 的定义，最小的数 $x$ 满足前面在删除 $2x$ 个数字后，区间 [l,r] 内的数字可以全部删除。</p>
<p>根据前面的说法来看，我们只需要证明采用以下方案可以删除完整个序列就行了。</p>
<p>每次删除最右边的合法括号，这对括号满足：a[i]=i ，内层为空。</p>
<p>这完全等价于什么呢？设任意一个括号序列，对于任意一对括号，其的可删除括号为，所有 () 满足 () 都在其的左括号左边，可删除左括号个数 * 2 $\ge i-a[i]$ 。</p>
<p>用这个性质证明 dp 就显然了。</p>
<p>以下皆是吹水。</p>
<p>你要说我当时知道这么证明纯属狗屁，首先这个性质是在我写博客的时候才想到的，其次我当时只证明了两个括号序列合并，两个括号序列嵌套，那个条件似乎足够充要，但是实际上，为什么要设最小的次数，为什么满足就一定有解呢？当时我是一定没想的。即使现在，我也想不太明白，因为如果纯从局部去证明整体，我很难去说明为什么局部满足这个条件，整体就一定满足，难道归纳吗？拿这又是一个很屎的过程，因为一定会用到优先删右边这个性质，很不巧，这是个整体性质，把整体性质用在局部的归纳法就是一坨屎，就只能说隐隐感觉这样子看非常的正确，但实际书写书写不出来。</p>
<p>一般发生这种情况是因为，我们在想这个问题的时候，默认的使用了某些性质，比如这里就默认使用了能删优先删右边，所以即使左边删多了也不要紧这个性质。但是默认使用的这个性质，在我们并不知情的情况下，是对的吗？用对了没？我们都不知道，所以你要说隐隐感觉对就是对的，我觉得纯放屁，到时候正式赛假了就直接寄了，痛哭流涕。</p>
<p>那如果要从整体去证明，我觉得就不能叫从这个 dp 的角度去证明了，两者的关系大概率是整体证明了一个性质，然后用 dp 维护，这里 dp 就只是维护工具，并不作为证明的载体，但我当时肯定不是这么想的，我是直接想的 dp ，并没有说先找到性质，然后再想办法用 dp 维护这么一个思考过程。</p>
<p>反正我觉得，有些 dp ，先想到一个感觉正确的 dp ，再从这个 dp 去证明做法正确性就是耍流氓。</p>
<p>我个人觉得做大部分 dp ，正确的流程就应该是，我先想到这个题目的一些充要的性质啥的，然后再尝试用 dp 去维护这些充要的性质。</p>
<p>即不是从 dp 本身去证明 dp 的正确性，而是先把 dp 要维护的东西证明了，这样使用 dp 维护就完全正确了。</p>
<p>所以我认为，这道题目正确的、自然的思考过程大体上应该是这样：</p>
<ol>
<li><p>以任意路线发现充要条件：可以采用后面这个方案删除完整个序列：每次删除最右边的合法括号，这对括号满足：a[i]=i ，内层为空。</p>
</li>
<li><p>然后再发现一个等价的充要条件：对于一个括号序列，对于任意一对括号，其的可删除括号为，所有 () 满足 () 都在其的左括号左边，可删除左括号个数 * 2 $\ge i-a[i]$ （或者是等效的可以方便导出 dp 方程的充要条件）。</p>
</li>
<li><p>使用 dp 维护这个过程，取得 AC 。</p>
</li>
</ol>
<p>总之我认为，做一个 dp 题目肯定是先提出充要条件，再维护，而不是先提出 dp ，再证明。</p>
</div></details>
<p>和官方做法没啥区别。</p>
<h1 id="G-Spinning-Round"><a href="#G-Spinning-Round" class="headerlink" title="G. Spinning Round"></a>G. Spinning Round</h1><h2 id="Easy-Version"><a href="#Easy-Version" class="headerlink" title="Easy Version"></a>Easy Version</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1987/problem/G1">https://codeforces.com/contest/1987/problem/G1</a></p>
<p>题目大意：给你一个排列，每个点可以向左边最近的比它大的点连边，或者向右边，问得到的联通图的直径的最大值是多少。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>首先在笛卡尔树上考虑，发现每个点只可能连向自己的祖先，而且根节点一定是自环，可以知道连通的充要条件是除了根节点外的所有点不自环，而且最终一定是一棵树。</p>
<p>所以可以知道求直径等价于求新树中的直径，这样就好求多了。</p>
<p>我们考虑每条路径在这条路径的 LCA 处考虑。</p>
<p>有两种情况：</p>
<ol>
<li>来自不同的儿子。</li>
<li>来自相同的儿子。</li>
</ol>
<p>情况 $1$ 是简单的，重点是情况下，可以发现，他们都一定来自于：</p>
<p>左儿子-右儿子-右儿子-右儿子-右儿子… 这条链，或者反过来。（下面假设就在这条链上处理，反过来同理）</p>
<p>直接在这条链上找就行了，只要一条链能线性处理，则时间复杂度是 ：$O(n)$ 的。</p>
<p>注意到在这条链上选择了一深一浅两个点，浅的点一定会沿着这条链到达 LCA ，然后深的点直接连向 LCA 。（注意，这里浅的点会选择其所在路径与链交集的最深的点，深的点会选择最浅的点，下同）</p>
<p>难点在于发现这个过程可以嵌套，距离来说，如果在链上选择的两个点是相邻的，则下面的路径有可能同时来自于浅的点的子树，导致嵌套。</p>
<p><img src="1.png" alt=""></p>
<p>上面是一个例子，蓝色是新树，当然，这个例子新树的构建不止这一种，这里只是给出上面那种嵌套情况会发生的新树，显然存在以这种情况为唯一最优的树。</p>
<p>用 dp 额外维护就行了，dp[x] 表示现在有两条链，一条连向 $x$ ，一条连向 $x$ 的父亲的长度和。</p>
<p>时间复杂度：$O(n)$ 。</p>
<p>当然，你可能会问，这种讨论题你怎么保证自己能讨论对的，我经常漏情况，要怎么处理？</p>
<p>虽然我主观上认为，讨论的难度反比于你的实力，你的实力越高，你在一开始就越容易找到方便讨论的角度和做法。但是实际上我完全不知道怎么保证自己能讨论对，因为：</p>
<p><img src="2.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(ss) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, sta[N], top, p[N];</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> ss[N];</span><br><span class="line"><span class="type">int</span> d[N], ans;</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y = son[x][t];</span><br><span class="line">    <span class="type">int</span> now = son[x][t], cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> base = d[son[now][t]] + <span class="number">1</span> + cnt;</span><br><span class="line">    <span class="keyword">while</span>(son[now][t ^ <span class="number">1</span>])&#123;</span><br><span class="line">        dp[y] = <span class="built_in">max</span>(dp[y], base + d[son[now][t ^ <span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">        dp[y] = <span class="built_in">max</span>(dp[y], dp[son[now][t ^ <span class="number">1</span>]] + cnt + <span class="number">1</span>);</span><br><span class="line">        now = son[now][t ^ <span class="number">1</span>];</span><br><span class="line">        cnt++;</span><br><span class="line">        base = <span class="built_in">max</span>(base, d[son[now][t]] + <span class="number">1</span> + cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, dp[y] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">0</span>]) <span class="built_in">dfs</span>(son[x][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">1</span>]) <span class="built_in">dfs</span>(son[x][<span class="number">1</span>]);</span><br><span class="line">    d[x] = <span class="built_in">max</span>(d[son[x][<span class="number">0</span>]] + <span class="number">1</span>, d[son[x][<span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, d[son[x][<span class="number">0</span>]] + d[son[x][<span class="number">1</span>]] + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">0</span>]) <span class="built_in">work</span>(x, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">1</span>]) <span class="built_in">work</span>(x, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">        son[i][<span class="number">0</span>] = son[i][<span class="number">1</span>] = d[i] = dp[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">get_char_array</span>(ss);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(top &amp;&amp; p[sta[top]] &lt; p[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre) son[sta[top]][<span class="number">1</span>] = pre;</span><br><span class="line">            pre = sta[top--];</span><br><span class="line">        &#125;</span><br><span class="line">        son[i][<span class="number">0</span>] = pre;</span><br><span class="line">        sta[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = top - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) son[sta[i]][<span class="number">1</span>] = sta[i + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">dfs</span>(sta[<span class="number">1</span>]);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误回顾：</p>
<p> WA 的主要原因：</p>
<ol>
<li>没有发现嵌套的情况。</li>
<li>代码写错了。</li>
</ol>
</div></details>
<h2 id="Hard-Version"><a href="#Hard-Version" class="headerlink" title="Hard Version"></a>Hard Version</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://codeforces.com/contest/1987/problem/G2">https://codeforces.com/contest/1987/problem/G2</a></p>
<p>题目大意：有些点会固定连向左边或者右边。</p>
<details class="toggle" ><summary class="toggle-button" style="">我的做法</summary><div class="toggle-content"><p>书接上回，证明合不合法简单的。</p>
<p>问题在于，当某些点的方向固定后，很多原来可以扔掉的劣的情况，就必须重新考虑了。</p>
<p>首先大的情况还是那么几种（依旧认为是左儿子-右儿子-右儿子-右儿子-右儿子… 这条链）：</p>
<ol>
<li>来自不同子树，不同在于，来自一个子树的最长路不一定来自儿子。</li>
<li><p>来自相同子树。</p>
<p>一样的，我们还是在链上考虑，先假设枚举一深一浅的两个点不相邻，但是有两点不同。</p>
<ol>
<li>浅的点不一定会沿着链到 LCA 。</li>
<li>浅的点所在的路径的下方不一定来自其左儿子。</li>
</ol>
<p><img src="3.png" alt=""></p>
<p>其中 1 好解决，2 不好解决，这需要我们在每个点额外维护一个东西，从这个子树出发向外连边是 L 或者是 R 的最长路径，这样就能维护不相邻的情况。</p>
<p>相邻呢？</p>
<p>还是一样，维护 dp ，而这与上面出现了相同的两个问题，用相同的办法解决就行了。</p>
</li>
</ol>
<p>时间复杂度：$O(n)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_char_array</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> ss[N];</span><br><span class="line">    cin &gt;&gt; ss;</span><br><span class="line">    <span class="built_in">memcpy</span>(s + <span class="number">1</span>, ss, <span class="built_in">sizeof</span>(<span class="type">char</span>) * (<span class="built_in">strlen</span>(ss) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, sta[N], top, p[N];</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> ss[N];</span><br><span class="line"><span class="type">int</span> d[N][<span class="number">2</span>], g[N][<span class="number">2</span>], ans;</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!t) <span class="keyword">return</span> ss[x] == <span class="string">&#x27;?&#x27;</span> || ss[x] == <span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ss[x] == <span class="string">&#x27;?&#x27;</span> || ss[x] == <span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> y = son[x][t];</span><br><span class="line">    d[x][t] = g[y][t];</span><br><span class="line">    g[x][t ^ <span class="number">1</span>] = <span class="built_in">max</span>(g[x][t ^ <span class="number">1</span>], g[y][t ^ <span class="number">1</span>]);</span><br><span class="line">    dp[y] = <span class="built_in">max</span>(d[y][<span class="number">0</span>], d[y][<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> now = y, cnt = <span class="number">0</span>, ncnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*distance between top/or now_top*/</span></span><br><span class="line">    <span class="type">int</span> pre = d[y][t] + <span class="number">1</span>, npre = d[y][t];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">pd</span>(y, t)) cnt = -inf, pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(son[now][t ^ <span class="number">1</span>])&#123;</span><br><span class="line">        now = son[now][t ^ <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> pre1 = g[son[now][t]][t ^ <span class="number">1</span>] + <span class="number">1</span> + cnt;</span><br><span class="line">        <span class="type">int</span> npre1 = g[son[now][t]][t ^ <span class="number">1</span>] + ncnt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pd</span>(now, t))&#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, dp[now] + cnt + <span class="number">2</span>);</span><br><span class="line">            dp[y] = <span class="built_in">max</span>(dp[y], dp[now] + ncnt + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">pd</span>(now, t ^ <span class="number">1</span>)) cnt = <span class="number">0</span>, ncnt = -inf;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">pd</span>(now, t)) cnt ++;</span><br><span class="line">        <span class="keyword">else</span> cnt = <span class="built_in">max</span>(cnt + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        ncnt++;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pd</span>(now, t))&#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">max</span>(d[now][<span class="number">0</span>], d[now][<span class="number">1</span>]) + <span class="number">1</span> + pre);</span><br><span class="line">            dp[y] = <span class="built_in">max</span>(dp[y], <span class="built_in">max</span>(d[now][<span class="number">0</span>], d[now][<span class="number">1</span>]) + <span class="number">1</span> + npre);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = <span class="built_in">max</span>(pre, d[now][t] + <span class="number">1</span> + cnt);</span><br><span class="line">        pre = <span class="built_in">max</span>(pre, pre1);</span><br><span class="line">        npre = <span class="built_in">max</span>(npre, d[now][t] + ncnt);</span><br><span class="line">        npre = <span class="built_in">max</span>(npre, npre1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> state)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(state == <span class="number">1</span> &amp;&amp; !<span class="built_in">pd</span>(x, <span class="number">0</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(state == <span class="number">2</span> &amp;&amp; !<span class="built_in">pd</span>(x, <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">0</span>])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">dfs</span>(son[x][<span class="number">0</span>], state | <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">work</span>(x, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(son[x][<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">dfs</span>(son[x][<span class="number">1</span>], state | <span class="number">2</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">work</span>(x, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pd</span>(x, <span class="number">0</span>)) g[x][<span class="number">0</span>] = <span class="built_in">max</span>(g[x][<span class="number">0</span>], <span class="built_in">max</span>(d[x][<span class="number">0</span>], d[x][<span class="number">1</span>]) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">pd</span>(x, <span class="number">1</span>)) g[x][<span class="number">1</span>] = <span class="built_in">max</span>(g[x][<span class="number">1</span>], <span class="built_in">max</span>(d[x][<span class="number">0</span>], d[x][<span class="number">1</span>]) + <span class="number">1</span>);</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, d[x][<span class="number">0</span>] + d[x][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">        son[i][<span class="number">0</span>] = son[i][<span class="number">1</span>] = d[i][<span class="number">0</span>] = d[i][<span class="number">1</span>] = g[i][<span class="number">0</span>] = g[i][<span class="number">1</span>] = dp[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">get_char_array</span>(ss);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(top &amp;&amp; p[sta[top]] &lt; p[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre) son[sta[top]][<span class="number">1</span>] = pre;</span><br><span class="line">            pre = sta[top--];</span><br><span class="line">        &#125;</span><br><span class="line">        son[i][<span class="number">0</span>] = pre;</span><br><span class="line">        sta[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = top - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) son[sta[i]][<span class="number">1</span>] = sta[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">dfs</span>(sta[<span class="number">1</span>], <span class="number">0</span>)) cout &lt;&lt; <span class="string">&quot;-1\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>犯错记录：</p>
<ol>
<li>代码写错了。</li>
<li>发现忘记浅点的路径可以来自其右儿子的左二子。</li>
<li>发现但是用了错误的方法解决，后面新维护了一个 dp 解决了这个问题，最后 AC 了。</li>
</ol>
<p>感觉这种题目就是很屎，很需要讨论，很看你的讨论功底的题目。</p>
</div></details>
<h2 id="别的做法"><a href="#别的做法" class="headerlink" title="别的做法"></a>别的做法</h2><details class="toggle" ><summary class="toggle-button" style="">在提交中找到的一份做法</summary><div class="toggle-content"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://codeforces.com/contest/1987/submission/268586570</span></span><br><span class="line"><span class="comment">// LUOGU_RID: 163845250</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[<span class="number">400005</span>];</span><br><span class="line"><span class="type">char</span> s[<span class="number">400005</span>];</span><br><span class="line"><span class="type">int</span> st[<span class="number">400005</span>],top;</span><br><span class="line"><span class="type">int</span> ch[<span class="number">400005</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">400005</span>][<span class="number">3</span>],ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ch[x][<span class="number">0</span>])<span class="built_in">dfs</span>(ch[x][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(ch[x][<span class="number">1</span>])<span class="built_in">dfs</span>(ch[x][<span class="number">1</span>]);</span><br><span class="line">    dp[x][<span class="number">0</span>]=dp[ch[x][<span class="number">0</span>]][<span class="number">0</span>];</span><br><span class="line">    dp[x][<span class="number">1</span>]=dp[ch[x][<span class="number">1</span>]][<span class="number">1</span>];</span><br><span class="line">    dp[x][<span class="number">2</span>]=dp[ch[x][<span class="number">0</span>]][<span class="number">0</span>]+dp[ch[x][<span class="number">1</span>]][<span class="number">1</span>];</span><br><span class="line">    ans=<span class="built_in">max</span>(ans,dp[ch[x][<span class="number">0</span>]][<span class="number">1</span>]+dp[ch[x][<span class="number">1</span>]][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span>(s[x]!=<span class="string">&#x27;R&#x27;</span>)&#123;</span><br><span class="line">        dp[x][<span class="number">0</span>]=<span class="built_in">max</span>(&#123;dp[x][<span class="number">0</span>],dp[ch[x][<span class="number">0</span>]][<span class="number">1</span>]+<span class="number">1</span>,dp[ch[x][<span class="number">1</span>]][<span class="number">0</span>]+<span class="number">1</span>&#125;);</span><br><span class="line">        dp[x][<span class="number">2</span>]=<span class="built_in">max</span>(&#123;dp[x][<span class="number">2</span>],dp[ch[x][<span class="number">0</span>]][<span class="number">1</span>]+dp[ch[x][<span class="number">1</span>]][<span class="number">1</span>]+<span class="number">1</span>,dp[ch[x][<span class="number">1</span>]][<span class="number">2</span>]+<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">if</span>(a[x]&lt;n)ans=<span class="built_in">max</span>(&#123;ans,dp[ch[x][<span class="number">0</span>]][<span class="number">0</span>]+dp[ch[x][<span class="number">1</span>]][<span class="number">0</span>]+<span class="number">1</span>,dp[ch[x][<span class="number">0</span>]][<span class="number">2</span>]+<span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s[x]!=<span class="string">&#x27;L&#x27;</span>)&#123;</span><br><span class="line">        dp[x][<span class="number">1</span>]=<span class="built_in">max</span>(&#123;dp[x][<span class="number">1</span>],dp[ch[x][<span class="number">0</span>]][<span class="number">1</span>]+<span class="number">1</span>,dp[ch[x][<span class="number">1</span>]][<span class="number">0</span>]+<span class="number">1</span>&#125;);</span><br><span class="line">        dp[x][<span class="number">2</span>]=<span class="built_in">max</span>(&#123;dp[x][<span class="number">2</span>],dp[ch[x][<span class="number">0</span>]][<span class="number">0</span>]+dp[ch[x][<span class="number">1</span>]][<span class="number">0</span>]+<span class="number">1</span>,dp[ch[x][<span class="number">0</span>]][<span class="number">2</span>]+<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">if</span>(a[x]&lt;n)ans=<span class="built_in">max</span>(&#123;ans,dp[ch[x][<span class="number">0</span>]][<span class="number">1</span>]+dp[ch[x][<span class="number">1</span>]][<span class="number">1</span>]+<span class="number">1</span>,dp[ch[x][<span class="number">1</span>]][<span class="number">2</span>]+<span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,mx=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;mx)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==<span class="string">&#x27;L&#x27;</span>)<span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="built_in">void</span>();</span><br><span class="line">                s[i]=<span class="string">&#x27;R&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mx=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n,mx=<span class="number">0</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;mx)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;n)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==<span class="string">&#x27;R&#x27;</span>)<span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>),<span class="built_in">void</span>();</span><br><span class="line">                s[i]=<span class="string">&#x27;L&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mx=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    top=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)ch[i][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> lst=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(top&amp;&amp;a[st[top]]&lt;a[i])lst=st[top--];</span><br><span class="line">        ch[st[top]][<span class="number">1</span>]=i;</span><br><span class="line">        ch[i][<span class="number">0</span>]=lst;</span><br><span class="line">        st[++top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(ch[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> _;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;_);</span><br><span class="line">    <span class="keyword">while</span>(_--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思考一个事情，我的做法相当于是直接在路径的 LCA 上考虑，这样考虑的好处是：</p>
<ol>
<li>直观，很容易想到这个做法，而且明确知道自己只需要讨论什么东西就足以完成此题。</li>
<li>可实现，在讨论完后所需要维护的东西一般都是可以简单维护的。</li>
</ol>
<p>但是坏处也是显然的：</p>
<p>讨论以后得到的每个部分相对独立，很难整合起来，因此码量比较大。</p>
<p>但是如果我们换个角度看，从下往上考虑，即考虑两条路径什么时候交到一起。</p>
<p>依旧是两种情况：</p>
<ol>
<li>两条路径，一条往左，一条往右，交到一个点上。</li>
<li>两条往同个方向，交到一个点上。</li>
</ol>
<p>注意到这个路径往左往右，也就是这个子树往外的第一条边往左往右，在我的做法中也有类似的定义：$g[x][0/1]$ 表示 $x$ 子树内往外的第一条边是什么方向。</p>
<p>顺着这个思路想，那怎么维护 $2$ 呢？注意到，肯定会有一个时间点，这两条路径一定会从 $x$ 子树的左儿子和右儿子内出来，其中左儿子往左，右儿子往右，所以维护 $g[x][2]$ 表示子树内有两条不相交的路径，一条往左，一条往右的长度。</p>
<p>因此就得到了上面那个做法 ，$g$ 也就是上面的 $dp$ 。</p>
<p>实际上，这个做法所维护的 $g[x][2]$，放到我那个做法中，就是把来自同一子树的两条链在较浅的那个点中产生并一路维护上来，相当于直接在遍历树的过程完成了转移，而不是单独再开一个部分计算答案。同时这个单条链的维护的过程和嵌套转移的过程是一样的，可以直接用一个转移过程，所以就可以少处理很多东西了。</p>
<p>这个思路相较于我的思路，明显的优势就是考虑主体变少了，从一条条链变成了一个个点，自然要好写好想（这里的好想指的是在初始方向正确的情况下，后面的细节都很简单，不是说这个思路好想）。</p>
<p>反思一下，虽然说做法是同构的，但是从这个做法想出那个做法，我感觉要难于直接换个角度考虑。就像很多题目直接考虑考虑不出来，但是换个角度就能考虑出来，做法本质就在那，都是一样的，但是换个角度难度就能大幅减少。</p>
<p>因此，考虑简化做法的时候不要只寄希望于优化当前的做法，因为将其直接优化到更加简洁的做法或许难度很大，有时候可以尝试换个角度观察这个做法，或许能很轻松的得到一个简洁得多的做法。</p>
</div></details>
<p>官方做法没看懂，感觉思考起来不太自然，而且看起来实现也很麻烦，咕了。不过能不在笛卡尔树上完成这道题目确实厉害，我只能说。</p>
<h1 id="比赛小结"><a href="#比赛小结" class="headerlink" title="比赛小结"></a>比赛小结</h1><p>评价一下，打的一坨，还好最后 G1 撞对了，否则坠机了。</p>
<p>比赛小结已经写在了 $F$ 的做法中。</p>
<p>总结下来就一句话 ：</p>
<p><strong>模拟赛</strong>时的题目该证明的就要给出完整的证明，不要搞一些自欺欺人的事情，不要过度的关注排名和 rating 。（当然时间不够的时候猜猜结论也是可以的，猜结论也是能力的一环，但是时间充足的时候或者中期的题目就别猜了，要给出完整的证明）</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://oldplace.github.io">player</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://oldplace.github.io/2024/07/04/CF1987-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/">http://oldplace.github.io/2024/07/04/CF1987-%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://oldplace.github.io" target="_blank">Oldplace</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/my%20avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/my%20avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">player</div><div class="author-info__description">一个蒟蒻在网络上的温馨小窝</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">159</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">70</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/oldplace" target="_blank" title="Github"><i class="fa-brands fa-github" style="color: #hdhfbb;"></i></a><a class="social-icon" href="https://www.luogu.com.cn/user/65602" target="_blank" title="洛谷"><i class="iconfont icon-luogu" style="color: #1461e6;"></i></a><a class="social-icon" href="https://www.codeforces.com/profile/zhangjianjuncd" target="_blank" title="CodeForces"><i class="fa-solid fa-chart-simple" style="color: #fd9d17;"></i></a><a class="social-icon" href="https://atcoder.jp/users/juruozjj" target="_blank" title="AtCoder"><i class="fa-solid fa-a" style="color: #7e0101;"></i></a><a class="social-icon" href="https://loj.ac/u/zhangjianjunab" target="_blank" title="LibreOJ"><i class="fa-solid fa-l" style="color: #9fa4ad;"></i></a><a class="social-icon" href="https://uoj.ac/user/profile/zhangjianjunab" target="_blank" title="Universal Online Judge"><i class="fa-solid fa-u" style="color: #ece509;"></i></a><a class="social-icon" href="https://ac.nowcoder.com/acm/contest/profile/485838814" target="_blank" title="牛客竞赛"><i class="iconfont icon-niu1" style="color: #3c5867;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#A-Upload-More-RAM"><span class="toc-number">1.</span> <span class="toc-text">A. Upload More RAM</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#B-K-Sort"><span class="toc-number">2.</span> <span class="toc-text">B.K-Sort</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-Basil%E2%80%99s-Garden"><span class="toc-number">3.</span> <span class="toc-text">C. Basil’s Garden</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#D-World-is-Mine"><span class="toc-number">4.</span> <span class="toc-text">D. World is Mine</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#E-Wonderful-Tree"><span class="toc-number">5.</span> <span class="toc-text">E. Wonderful Tree!</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#F-Interesting-Problem-Hard-Version"><span class="toc-number">6.</span> <span class="toc-text">F. Interesting Problem (Hard Version)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#G-Spinning-Round"><span class="toc-number">7.</span> <span class="toc-text">G. Spinning Round</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Easy-Version"><span class="toc-number">7.1.</span> <span class="toc-text">Easy Version</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hard-Version"><span class="toc-number">7.2.</span> <span class="toc-text">Hard Version</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%AB%E7%9A%84%E5%81%9A%E6%B3%95"><span class="toc-number">7.3.</span> <span class="toc-text">别的做法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AF%94%E8%B5%9B%E5%B0%8F%E7%BB%93"><span class="toc-number">8.</span> <span class="toc-text">比赛小结</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By player</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>function loadUtterances () {
  let ele = document.createElement('script')
  ele.setAttribute('id', 'utterances_comment')
  ele.setAttribute('src', 'https://utteranc.es/client.js')
  ele.setAttribute('repo', 'oldplace/oldplace.github.io')
  ele.setAttribute('issue-term', 'pathname')
  let nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
  ele.setAttribute('theme', nowTheme)
  ele.setAttribute('crossorigin', 'anonymous')
  ele.setAttribute('async', 'true')
  document.getElementById('utterances-wrap').insertAdjacentElement('afterbegin',ele)
}

function utterancesTheme (theme) {
  const iframe = document.querySelector('.utterances-frame')
  if (iframe) {
    const theme = theme === 'dark' ? 'photon-dark' : 'github-light'
    const message = {
      type: 'set-theme',
      theme: theme
    };
    iframe.contentWindow.postMessage(message, 'https://utteranc.es');
  }
}

btf.addModeChange('utterances', utterancesTheme)

if ('Utterances' === 'Utterances' || !true) {
  if (true) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
  else loadUtterances()
} else {
  function loadOtherComment () {
    loadUtterances()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>